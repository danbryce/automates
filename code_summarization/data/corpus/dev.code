<BoC> <TAB> <BoN> def <EoN> <BoN> parse <EoN> ( <BoN> self <EoN> , <BoN> argument <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> argument <EoN> , <BoN> six <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> type <EoN> ( <BoN> argument <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> argument <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get colspec <EoN> ( <BoN> self <EoN> , <BoN> schema <EoN> = <BoN> None <EoN> , <BoN> table name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> schema <EoN> : <NEWLINE> <TAB> <BoN> schema <EoN> , <BoN> tname <EoN> , <BoN> colname <EoN> = <BoN> self <EoN> . <BoN> column tokens <EoN> <NEWLINE> <BoN> if <EoN> <BoN> table name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> tname <EoN> = <BoN> table name <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <STRING> % ( <BoN> schema <EoN> , <BoN> tname <EoN> , <BoN> colname <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> table name <EoN> : <NEWLINE> <TAB> <BoN> schema <EoN> , <BoN> tname <EoN> , <BoN> colname <EoN> = <BoN> self <EoN> . <BoN> column tokens <EoN> <NEWLINE> <BoN> if <EoN> <BoN> schema <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % ( <BoN> schema <EoN> , <BoN> table name <EoN> , <BoN> colname <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % ( <BoN> table name <EoN> , <BoN> colname <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> table column <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % ( <NEWLINE> <BoN> self <EoN> . <BoN> table column <EoN> . <BoN> table <EoN> . <BoN> fullname <EoN> , <BoN> self <EoN> . <BoN> table column <EoN> . <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> colspec <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is same graph <EoN> ( <BoN> var 1 <EoN> , <BoN> var 2 <EoN> , <BoN> givens <EoN> = <BoN> None <EoN> , <BoN> debug <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> givens <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> givens <EoN> = { } <NEWLINE> <UNTAB> <BoN> global <EoN> <BoN> equal computations <EoN> , <BoN> is same graph with merge <EoN> <NEWLINE> <BoN> if <EoN> <BoN> equal computations <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> opt <EoN> <BoN> import <EoN> <BoN> is same graph with merge <EoN> <NEWLINE> <BoN> from <EoN> <BoN> theano <EoN> . <BoN> scan module <EoN> . <BoN> scan utils <EoN> <BoN> import <EoN> <BoN> equal computations <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> givens <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> givens <EoN> = <BoN> dict <EoN> ( <BoN> givens <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> rval 1 <EoN> = <BoN> is same graph with merge <EoN> ( <BoN> var 1 <EoN> = <BoN> var 1 <EoN> , <BoN> var 2 <EoN> = <BoN> var 2 <EoN> , <BoN> givens <EoN> = <BoN> givens <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> use equal computations <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> if <EoN> <BoN> givens <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> ok <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> in xs <EoN> = [ ] <NEWLINE> <BoN> in ys <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> inputs var <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> inputs <EoN> , ( [ <BoN> var 1 <EoN> ] , [ <BoN> var 2 <EoN> ] ) ) ) <NEWLINE> <BoN> all vars <EoN> = [ <BoN> set <EoN> ( <BoN> variables <EoN> ( <BoN> v i <EoN> , <BoN> v o <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> v i <EoN> , <BoN> v o <EoN> <BoN> in <EoN> ( ( <BoN> inputs var <EoN> [ <NUMBER> ] , [ <BoN> var 1 <EoN> ] ) , <NEWLINE> ( <BoN> inputs var <EoN> [ <NUMBER> ] , [ <BoN> var 2 <EoN> ] ) ) ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> in var <EoN> ( <BoN> x <EoN> , <BoN> k <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> all vars <EoN> [ <BoN> k <EoN> - <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> to replace <EoN> , <BoN> replace by <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> givens <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> inside <EoN> = <BoN> dict <EoN> ( ( <BoN> v <EoN> , [ <BoN> in var <EoN> ( <BoN> v <EoN> , <BoN> k <EoN> ) <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> ( <NUMBER> , <NUMBER> ) ] ) <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> ( <BoN> to replace <EoN> , <BoN> replace by <EoN> ) ) <NEWLINE> <BoN> if <EoN> ( <BoN> inside <EoN> [ <BoN> to replace <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <BoN> not <EoN> <BoN> inside <EoN> [ <BoN> to replace <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <NEWLINE> <BoN> inside <EoN> [ <BoN> replace by <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <BoN> not <EoN> <BoN> inside <EoN> [ <BoN> replace by <EoN> ] [ <NUMBER> ] ) : <NEWLINE> <NEWLINE> <TAB> <BoN> in xs <EoN> . <BoN> append <EoN> ( <BoN> to replace <EoN> ) <NEWLINE> <BoN> in ys <EoN> . <BoN> append <EoN> ( <BoN> replace by <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> inside <EoN> [ <BoN> to replace <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <BoN> not <EoN> <BoN> inside <EoN> [ <BoN> to replace <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <NEWLINE> <BoN> inside <EoN> [ <BoN> replace by <EoN> ] [ <NUMBER> ] <BoN> and <EoN> <BoN> not <EoN> <BoN> inside <EoN> [ <BoN> replace by <EoN> ] [ <NUMBER> ] ) : <NEWLINE> <NEWLINE> <TAB> <BoN> in xs <EoN> . <BoN> append <EoN> ( <BoN> replace by <EoN> ) <NEWLINE> <BoN> in ys <EoN> . <BoN> append <EoN> ( <BoN> to replace <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ok <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> ok <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> debug <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> use equal computations <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> in xs <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> in ys <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> use equal computations <EoN> : <NEWLINE> <TAB> <BoN> rval 2 <EoN> = <BoN> equal computations <EoN> ( <BoN> xs <EoN> = [ <BoN> var 1 <EoN> ] , <BoN> ys <EoN> = [ <BoN> var 2 <EoN> ] , <NEWLINE> <BoN> in xs <EoN> = <BoN> in xs <EoN> , <BoN> in ys <EoN> = <BoN> in ys <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> rval 2 <EoN> == <BoN> rval 1 <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rval 1 <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is math text <EoN> ( <BoN> self <EoN> , <BoN> s <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> dollar count <EoN> = <BoN> s <EoN> . <BoN> count <EoN> ( <STRING> ) - <BoN> s <EoN> . <BoN> count <EoN> ( <STRING> ) <NEWLINE> <BoN> even dollars <EoN> = ( <BoN> dollar count <EoN> > <NUMBER> <BoN> and <EoN> <BoN> dollar count <EoN> % <NUMBER> == <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> rc Params <EoN> [ <STRING> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> s <EoN> , <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> even dollars <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> s <EoN> , <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> s <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) , <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> execute compiled <EoN> ( <BoN> self <EoN> , <BoN> compiled <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> has events <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> engine <EoN> . <BoN> has events <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> fn <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> dispatch <EoN> . <BoN> before execute <EoN> : <NEWLINE> <TAB> <BoN> compiled <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> = <BoN> fn <EoN> ( <BoN> self <EoN> , <BoN> compiled <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> dialect <EoN> = <BoN> self <EoN> . <BoN> dialect <EoN> <NEWLINE> <BoN> parameters <EoN> = <BoN> distill params <EoN> ( <BoN> multiparams <EoN> , <BoN> params <EoN> ) <NEWLINE> <BoN> ret <EoN> = <BoN> self <EoN> . <BoN> execute context <EoN> ( <NEWLINE> <BoN> dialect <EoN> , <NEWLINE> <BoN> dialect <EoN> . <BoN> execution ctx cls <EoN> . <BoN> init compiled <EoN> , <NEWLINE> <BoN> compiled <EoN> , <NEWLINE> <BoN> parameters <EoN> , <NEWLINE> <BoN> compiled <EoN> , <BoN> parameters <EoN> <NEWLINE> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> has events <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> engine <EoN> . <BoN> has events <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> dispatch <EoN> . <BoN> after execute <EoN> ( <BoN> self <EoN> , <NEWLINE> <BoN> compiled <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> , <BoN> ret <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set isolation level <EoN> ( <BoN> self <EoN> , <BoN> dbapi conn <EoN> , <BoN> level <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> invert xaxis <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> set xlim <EoN> ( <BoN> self <EoN> . <BoN> get xlim <EoN> ( ) [ : : - <NUMBER> ] , <BoN> auto <EoN> = <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get func code <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> source file <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> code <EoN> = <BoN> func <EoN> . <BoN> code <EoN> <NEWLINE> <BoN> source file <EoN> = <BoN> code <EoN> . <BoN> co filename <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> source file <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> source code <EoN> = <STRING> . <BoN> join <EoN> ( <BoN> inspect <EoN> . <BoN> getsourcelines <EoN> ( <BoN> func <EoN> ) [ <NUMBER> ] ) <NEWLINE> <BoN> line no <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> source file <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> source file <EoN> , <BoN> line no <EoN> = <BoN> re <EoN> . <BoN> match <EoN> ( <NEWLINE> <STRING> , <BoN> source file <EoN> ) . <BoN> groups <EoN> ( ) <NEWLINE> <BoN> line no <EoN> = <BoN> int <EoN> ( <BoN> line no <EoN> ) <NEWLINE> <BoN> source file <EoN> = <STRING> % <BoN> source file <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> source code <EoN> , <BoN> source file <EoN> , <BoN> line no <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> open py source <EoN> ( <BoN> source file <EoN> ) <BoN> as <EoN> <BoN> source file obj <EoN> : <NEWLINE> <TAB> <BoN> first line <EoN> = <BoN> code <EoN> . <BoN> co firstlineno <EoN> <NEWLINE> <NEWLINE> <BoN> source lines <EoN> = <BoN> list <EoN> ( <BoN> islice <EoN> ( <BoN> source file obj <EoN> , <BoN> first line <EoN> - <NUMBER> , <BoN> None <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <STRING> . <BoN> join <EoN> ( <BoN> inspect <EoN> . <BoN> getblock <EoN> ( <BoN> source lines <EoN> ) ) , <BoN> source file <EoN> , <BoN> first line <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> str <EoN> ( <BoN> func <EoN> . <BoN> code <EoN> . <BoN> hash <EoN> ( ) ) , <BoN> source file <EoN> , - <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> repr <EoN> ( <BoN> func <EoN> ) , <BoN> source file <EoN> , - <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> retry with clean cache <EoN> ( <BoN> openml path <EoN> , <BoN> data home <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> decorator <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> @ <BoN> wraps <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> wrapper <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> data home <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> ( ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> HTTP Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <BoN> Runtime Warning <EoN> ) <NEWLINE> <BoN> local path <EoN> = <BoN> get local path <EoN> ( <BoN> openml path <EoN> , <BoN> data home <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> local path <EoN> ) : <NEWLINE> <TAB> <BoN> os <EoN> . <BoN> unlink <EoN> ( <BoN> local path <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> wrapper <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> decorator <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get control flow context <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> control flow context <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rollback twophase <EoN> ( <BoN> self <EoN> , <BoN> conn <EoN> , <BoN> xid <EoN> , <BoN> is prepared <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fractional max pool grad <EoN> ( <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> out backprop <EoN> , <BoN> row pooling sequence <EoN> , <BoN> col pooling sequence <EoN> , <BoN> overlapping <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <NEWLINE> <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> out backprop <EoN> , <BoN> row pooling sequence <EoN> , <NEWLINE> <BoN> col pooling sequence <EoN> , <STRING> , <BoN> overlapping <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fractional max pool grad eager fallback <EoN> ( <NEWLINE> <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> out backprop <EoN> , <BoN> row pooling sequence <EoN> , <NEWLINE> <BoN> col pooling sequence <EoN> , <BoN> overlapping <EoN> = <BoN> overlapping <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> overlapping <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> overlapping <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> overlapping <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> overlapping <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> orig input <EoN> = <BoN> orig input <EoN> , <NEWLINE> <BoN> orig output <EoN> = <BoN> orig output <EoN> , <NEWLINE> <BoN> out backprop <EoN> = <BoN> out backprop <EoN> , <NEWLINE> <BoN> row pooling sequence <EoN> = <BoN> row pooling sequence <EoN> , <NEWLINE> <BoN> col pooling sequence <EoN> = <BoN> col pooling sequence <EoN> , <NEWLINE> <BoN> overlapping <EoN> = <BoN> overlapping <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> t <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> batch size <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> sample data <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> sample data <EoN> = <BoN> self <EoN> . <BoN> sample data <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = ( <BoN> batch size <EoN> , <BoN> self <EoN> . <BoN> sample size <EoN> ) <NEWLINE> <BoN> sample data <EoN> = <BoN> self <EoN> . <BoN> sampler <EoN> . <BoN> sample <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> samples <EoN> = <BoN> variable <EoN> . <BoN> Variable <EoN> ( <BoN> sample data <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> black out <EoN> . <BoN> black out <EoN> ( <BoN> x <EoN> , <BoN> t <EoN> , <BoN> self <EoN> . <BoN> W <EoN> , <BoN> samples <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> softmax eager fallback <EoN> ( <BoN> logits <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> logits <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> logits <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> logits <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dfs successors <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> = <BoN> None <EoN> , <BoN> depth limit <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> d <EoN> = <BoN> defaultdict <EoN> ( <BoN> list <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> s <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> dfs edges <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> = <BoN> source <EoN> , <BoN> depth limit <EoN> = <BoN> depth limit <EoN> ) : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> s <EoN> ] . <BoN> append <EoN> ( <BoN> t <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dict <EoN> ( <BoN> d <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> from QQ gmpy <EoN> ( <BoN> K 1 <EoN> , <BoN> a <EoN> , <BoN> K 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Python Rational <EoN> ( <BoN> Python Integer <EoN> ( <BoN> a <EoN> . <BoN> numer <EoN> ( ) ) , <NEWLINE> <BoN> Python Integer <EoN> ( <BoN> a <EoN> . <BoN> denom <EoN> ( ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rjust <EoN> ( <BoN> a <EoN> , <BoN> width <EoN> , <BoN> fillchar <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a arr <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> width arr <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> width <EoN> ) <NEWLINE> <BoN> size <EoN> = <BoN> long <EoN> ( <BoN> numpy <EoN> . <BoN> max <EoN> ( <BoN> width arr <EoN> . <BoN> flat <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> numpy <EoN> . <BoN> issubdtype <EoN> ( <BoN> a arr <EoN> . <BoN> dtype <EoN> , <BoN> numpy <EoN> . <BoN> string <EoN> ) : <NEWLINE> <TAB> <BoN> fillchar <EoN> = <BoN> asbytes <EoN> ( <BoN> fillchar <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> vec string <EoN> ( <NEWLINE> <BoN> a arr <EoN> , ( <BoN> a arr <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> size <EoN> ) , <STRING> , ( <BoN> width arr <EoN> , <BoN> fillchar <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> build table schema <EoN> ( <BoN> data <EoN> , <BoN> index <EoN> = <BoN> True <EoN> , <BoN> primary key <EoN> = <BoN> None <EoN> , <BoN> version <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> index <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> set default names <EoN> ( <BoN> data <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> schema <EoN> = { } <NEWLINE> <BoN> fields <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> index <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> data <EoN> . <BoN> index <EoN> . <BoN> nlevels <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> level <EoN> <BoN> in <EoN> <BoN> data <EoN> . <BoN> index <EoN> . <BoN> levels <EoN> : <NEWLINE> <TAB> <BoN> fields <EoN> . <BoN> append <EoN> ( <BoN> convert pandas type to json field <EoN> ( <BoN> level <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fields <EoN> . <BoN> append <EoN> ( <BoN> convert pandas type to json field <EoN> ( <BoN> data <EoN> . <BoN> index <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> data <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> column <EoN> , <BoN> s <EoN> <BoN> in <EoN> <BoN> data <EoN> . <BoN> iteritems <EoN> ( ) : <NEWLINE> <TAB> <BoN> fields <EoN> . <BoN> append <EoN> ( <BoN> convert pandas type to json field <EoN> ( <BoN> s <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fields <EoN> . <BoN> append <EoN> ( <BoN> convert pandas type to json field <EoN> ( <BoN> data <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> schema <EoN> [ <STRING> ] = <BoN> fields <EoN> <NEWLINE> <BoN> if <EoN> <BoN> index <EoN> <BoN> and <EoN> <BoN> data <EoN> . <BoN> index <EoN> . <BoN> is unique <EoN> <BoN> and <EoN> <BoN> primary key <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> data <EoN> . <BoN> index <EoN> . <BoN> nlevels <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> schema <EoN> [ <STRING> ] = [ <BoN> data <EoN> . <BoN> index <EoN> . <BoN> name <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> schema <EoN> [ <STRING> ] = <BoN> data <EoN> . <BoN> index <EoN> . <BoN> names <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> primary key <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> schema <EoN> [ <STRING> ] = <BoN> primary key <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> version <EoN> : <NEWLINE> <TAB> <BoN> schema <EoN> [ <STRING> ] = <STRING> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> schema <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> parse kwargs <EoN> ( <BoN> kwargs <EoN> , * <BoN> keys <EoN> , ** <BoN> keyvalues <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> result <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> keys <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> key <EoN> ] = <BoN> kwargs <EoN> [ <BoN> key <EoN> ] <NEWLINE> <BoN> del <EoN> <BoN> kwargs <EoN> [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> key <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> keyvalues <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> key <EoN> ] = <BoN> kwargs <EoN> [ <BoN> key <EoN> ] <NEWLINE> <BoN> del <EoN> <BoN> kwargs <EoN> [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> key <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> refine <EoN> ( <BoN> self <EoN> , <BoN> assumption <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> assumptions <EoN> <BoN> import <EoN> <BoN> refine <EoN> <NEWLINE> <BoN> return <EoN> <BoN> refine <EoN> ( <BoN> self <EoN> , <BoN> assumption <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gcf <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fig Manager <EoN> = <BoN> pylab helpers <EoN> . <BoN> Gcf <EoN> . <BoN> get active <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> fig Manager <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fig Manager <EoN> . <BoN> canvas <EoN> . <BoN> figure <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> figure <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <BoN> None <EoN> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get timestamped export dir <EoN> ( <BoN> export dir base <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> attempts <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> <BoN> attempts <EoN> < <BoN> MAX DIRECTORY CREATION ATTEMPTS <EoN> : <NEWLINE> <TAB> <BoN> export timestamp <EoN> = <BoN> int <EoN> ( <BoN> time <EoN> . <BoN> time <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> export dir <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <NEWLINE> <BoN> compat <EoN> . <BoN> as bytes <EoN> ( <BoN> export dir base <EoN> ) , <NEWLINE> <BoN> compat <EoN> . <BoN> as bytes <EoN> ( <BoN> str <EoN> ( <BoN> export timestamp <EoN> ) ) ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> gfile <EoN> . <BoN> Exists <EoN> ( <BoN> export dir <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> export dir <EoN> <NEWLINE> <UNTAB> <BoN> time <EoN> . <BoN> sleep <EoN> ( <NUMBER> ) <NEWLINE> <BoN> attempts <EoN> += <NUMBER> <NEWLINE> <BoN> logging <EoN> . <BoN> warn <EoN> ( <STRING> . <NEWLINE> <BoN> format <EoN> ( <BoN> export dir <EoN> , <BoN> attempts <EoN> , <BoN> MAX DIRECTORY CREATION ATTEMPTS <EoN> ) ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> MAX DIRECTORY CREATION ATTEMPTS <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rsub <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> - <BoN> self <EoN> + <BoN> other <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> activation <EoN> <NEWLINE> <BoN> for <EoN> <BoN> l <EoN> <BoN> in <EoN> <BoN> self <EoN> [ : - <NUMBER> ] : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> f <EoN> ( <BoN> l <EoN> ( <BoN> x <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> [ - <NUMBER> ] ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> generate oriented forest <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> P <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( - <NUMBER> , <BoN> n <EoN> ) ) <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> P <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> if <EoN> <BoN> P <EoN> [ <BoN> n <EoN> ] > <NUMBER> : <NEWLINE> <TAB> <BoN> P <EoN> [ <BoN> n <EoN> ] = <BoN> P <EoN> [ <BoN> P <EoN> [ <BoN> n <EoN> ] ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> - <NUMBER> , <NUMBER> , - <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> P <EoN> [ <BoN> p <EoN> ] != <NUMBER> : <NEWLINE> <TAB> <BoN> target <EoN> = <BoN> P <EoN> [ <BoN> p <EoN> ] - <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> q <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> p <EoN> - <NUMBER> , <NUMBER> , - <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> P <EoN> [ <BoN> q <EoN> ] == <BoN> target <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> offset <EoN> = <BoN> p <EoN> - <BoN> q <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> p <EoN> , <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> P <EoN> [ <BoN> i <EoN> ] = <BoN> P <EoN> [ <BoN> i <EoN> - <BoN> offset <EoN> ] <NEWLINE> <UNTAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward event shape tensor <EoN> ( <BoN> self <EoN> , <BoN> input shape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> input shape <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from rational <EoN> ( <BoN> p <EoN> , <BoN> q <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> = <BoN> round fast <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> mpf div <EoN> ( <BoN> from int <EoN> ( <BoN> p <EoN> ) , <BoN> from int <EoN> ( <BoN> q <EoN> ) , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> def linear <EoN> ( <BoN> fun <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> defjvp argnum <EoN> ( <BoN> fun <EoN> , <BoN> lambda <EoN> <BoN> argnum <EoN> , <BoN> g <EoN> , <BoN> ans <EoN> , <BoN> args <EoN> , <BoN> kwargs <EoN> : <NEWLINE> <BoN> fun <EoN> ( * <BoN> subval <EoN> ( <BoN> args <EoN> , <BoN> argnum <EoN> , <BoN> g <EoN> ) , ** <BoN> kwargs <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> munp <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> N <EoN> = <NUMBER> / ( <BoN> m <EoN> / <BoN> beta <EoN> / ( <BoN> m <EoN> - <NUMBER> ) * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) + <BoN> norm pdf C <EoN> * <BoN> norm cdf <EoN> ( <BoN> beta <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> n th moment <EoN> ( <BoN> n <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> A <EoN> = ( <BoN> m <EoN> / <BoN> beta <EoN> ) ** <BoN> m <EoN> * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) <NEWLINE> <BoN> B <EoN> = <BoN> m <EoN> / <BoN> beta <EoN> - <BoN> beta <EoN> <NEWLINE> <BoN> rhs <EoN> = <NUMBER> ** ( ( <BoN> n <EoN> - <NUMBER> ) / <NUMBER> ) * <BoN> sc <EoN> . <BoN> gamma <EoN> ( ( <BoN> n <EoN> + <NUMBER> ) / <NUMBER> ) * ( <NUMBER> + ( - <NUMBER> ) ** <BoN> n <EoN> * <BoN> sc <EoN> . <BoN> gammainc <EoN> ( ( <BoN> n <EoN> + <NUMBER> ) / <NUMBER> , <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) ) <NEWLINE> <BoN> lhs <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> rhs <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> lhs <EoN> += <BoN> sc <EoN> . <BoN> binom <EoN> ( <BoN> n <EoN> , <BoN> k <EoN> ) * <BoN> B <EoN> ** ( <BoN> n <EoN> - <BoN> k <EoN> ) * ( - <NUMBER> ) ** <BoN> k <EoN> / ( <BoN> m <EoN> - <BoN> k <EoN> - <NUMBER> ) * ( <BoN> m <EoN> / <BoN> beta <EoN> ) ** ( - <BoN> m <EoN> + <BoN> k <EoN> + <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> A <EoN> * <BoN> lhs <EoN> + <BoN> rhs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> N <EoN> * <BoN> lazywhere <EoN> ( <BoN> np <EoN> . <BoN> atleast 1 d <EoN> ( <BoN> n <EoN> + <NUMBER> < <BoN> m <EoN> ) , <NEWLINE> ( <BoN> n <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> ) , <NEWLINE> <BoN> np <EoN> . <BoN> vectorize <EoN> ( <BoN> n th moment <EoN> , <BoN> otypes <EoN> = [ <BoN> np <EoN> . <BoN> float <EoN> ] ) , <NEWLINE> <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lt <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> other <EoN> = <BoN> as dimension <EoN> ( <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> other <EoN> . <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> value <EoN> < <BoN> other <EoN> . <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set params <EoN> ( <BoN> self <EoN> , <BoN> arg params <EoN> , <BoN> aux params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> texec <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> execgrp <EoN> . <BoN> train execs <EoN> : <NEWLINE> <TAB> <BoN> texec <EoN> . <BoN> copy params from <EoN> ( <BoN> arg params <EoN> , <BoN> aux params <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> mx op <EoN> . <BoN> register <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> convert transpose <EoN> ( <BoN> node <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> helper <EoN> , <BoN> <EoN> , <BoN> <EoN> = <BoN> import onnx modules <EoN> ( ) <NEWLINE> <BoN> name <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> input idx <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> node <EoN> [ <STRING> ] [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <BoN> proc nodes <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> input node <EoN> = <BoN> proc nodes <EoN> [ <BoN> input idx <EoN> ] . <BoN> name <EoN> <NEWLINE> <BoN> axes <EoN> = <BoN> node <EoN> . <BoN> get <EoN> ( <STRING> , { } ) . <BoN> get <EoN> ( <STRING> , ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> axes <EoN> = <BoN> tuple <EoN> ( <BoN> map <EoN> ( <BoN> int <EoN> , <BoN> re <EoN> . <BoN> findall <EoN> ( <STRING> , <BoN> axes <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> transpose node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <STRING> , <NEWLINE> [ <BoN> input node <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> perm <EoN> = <BoN> axes <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> transpose node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <STRING> , <NEWLINE> [ <BoN> input node <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> [ <BoN> transpose node <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get title <EoN> ( <BoN> self <EoN> , <BoN> loc <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> title <EoN> = { <STRING> : <BoN> self <EoN> . <BoN> left title <EoN> , <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> title <EoN> , <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> right title <EoN> } [ <BoN> loc <EoN> . <BoN> lower <EoN> ( ) ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> loc <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> title <EoN> . <BoN> get text <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save optimizer states <EoN> ( <BoN> self <EoN> , <BoN> fname <EoN> , <BoN> dump optimizer <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> updater <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> , <STRING> <NEWLINE> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> fname <EoN> , <STRING> ) <BoN> as <EoN> <BoN> fout <EoN> : <NEWLINE> <TAB> <BoN> fout <EoN> . <BoN> write <EoN> ( <BoN> self <EoN> . <BoN> updater <EoN> . <BoN> get states <EoN> ( <BoN> dump optimizer <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> onmove <EoN> ( <BoN> self <EoN> , <BoN> event <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> active handle idx <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> idx <EoN> = <BoN> self <EoN> . <BoN> active handle idx <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> xs <EoN> [ <BoN> idx <EoN> ] , <BoN> self <EoN> . <BoN> ys <EoN> [ <BoN> idx <EoN> ] = <BoN> event <EoN> . <BoN> xdata <EoN> , <BoN> event <EoN> . <BoN> ydata <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> idx <EoN> == <NUMBER> <BoN> and <EoN> <BoN> self <EoN> . <BoN> polygon completed <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> xs <EoN> [ - <NUMBER> ] , <BoN> self <EoN> . <BoN> ys <EoN> [ - <NUMBER> ] = <BoN> event <EoN> . <BoN> xdata <EoN> , <BoN> event <EoN> . <BoN> ydata <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> eventpress <EoN> : <NEWLINE> <TAB> <BoN> dx <EoN> = <BoN> event <EoN> . <BoN> xdata <EoN> - <BoN> self <EoN> . <BoN> eventpress <EoN> . <BoN> xdata <EoN> <NEWLINE> <BoN> dy <EoN> = <BoN> event <EoN> . <BoN> ydata <EoN> - <BoN> self <EoN> . <BoN> eventpress <EoN> . <BoN> ydata <EoN> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> xs <EoN> ) ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> xs <EoN> [ <BoN> k <EoN> ] = <BoN> self <EoN> . <BoN> xs at press <EoN> [ <BoN> k <EoN> ] + <BoN> dx <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> ys <EoN> [ <BoN> k <EoN> ] = <BoN> self <EoN> . <BoN> ys at press <EoN> [ <BoN> k <EoN> ] + <BoN> dy <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> ( <BoN> self <EoN> . <BoN> polygon completed <EoN> <NEWLINE> <BoN> or <EoN> <STRING> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> <BoN> or <EoN> <STRING> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> x 0 <EoN> , <BoN> y 0 <EoN> = <BoN> self <EoN> . <BoN> line <EoN> . <BoN> get transform <EoN> ( ) . <BoN> transform <EoN> ( ( <BoN> self <EoN> . <BoN> xs <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> self <EoN> . <BoN> ys <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> v 0 dist <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( ( <BoN> x 0 <EoN> - <BoN> event <EoN> . <BoN> x <EoN> ) ** <NUMBER> + ( <BoN> y 0 <EoN> - <BoN> event <EoN> . <BoN> y <EoN> ) ** <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> xs <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> v 0 dist <EoN> < <BoN> self <EoN> . <BoN> vertex select radius <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> xs <EoN> [ - <NUMBER> ] , <BoN> self <EoN> . <BoN> ys <EoN> [ - <NUMBER> ] = <BoN> self <EoN> . <BoN> xs <EoN> [ <NUMBER> ] , <BoN> self <EoN> . <BoN> ys <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> xs <EoN> [ - <NUMBER> ] , <BoN> self <EoN> . <BoN> ys <EoN> [ - <NUMBER> ] = <BoN> event <EoN> . <BoN> xdata <EoN> , <BoN> event <EoN> . <BoN> ydata <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> draw polygon <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set patchB <EoN> ( <BoN> self <EoN> , <BoN> patch B <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> patch B <EoN> = <BoN> patch B <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is datetimelike v numeric <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> a <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> b <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> b <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> b <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> is numeric <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> is integer dtype <EoN> ( <BoN> x <EoN> ) <BoN> or <EoN> <BoN> is float dtype <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> is datetimelike <EoN> = <BoN> needs i 8 conversion <EoN> <NEWLINE> <BoN> return <EoN> ( ( <BoN> is datetimelike <EoN> ( <BoN> a <EoN> ) <BoN> and <EoN> <BoN> is numeric <EoN> ( <BoN> b <EoN> ) ) <BoN> or <EoN> <NEWLINE> ( <BoN> is datetimelike <EoN> ( <BoN> b <EoN> ) <BoN> and <EoN> <BoN> is numeric <EoN> ( <BoN> a <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get dashes <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dashes <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> key press <EoN> ( <BoN> self <EoN> , <BoN> event <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> rc Params <EoN> [ <STRING> ] != <STRING> : <NEWLINE> <TAB> <BoN> key press handler <EoN> ( <BoN> event <EoN> , <BoN> self <EoN> . <BoN> canvas <EoN> , <BoN> self <EoN> . <BoN> canvas <EoN> . <BoN> toolbar <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> stride repeat <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> not <EoN> <BoN> in <EoN> [ <NUMBER> , <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> x <EoN> ) . <BoN> T <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> shape <EoN> = ( <BoN> n <EoN> , <BoN> x <EoN> . <BoN> size <EoN> ) <NEWLINE> <BoN> strides <EoN> = ( <NUMBER> , <BoN> x <EoN> . <BoN> strides <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = ( <BoN> x <EoN> . <BoN> size <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> strides <EoN> = ( <BoN> x <EoN> . <BoN> strides <EoN> [ <NUMBER> ] , <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> lib <EoN> . <BoN> stride tricks <EoN> . <BoN> as strided <EoN> ( <BoN> x <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> strides <EoN> = <BoN> strides <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> , <BoN> other <EoN> , <BoN> errors <EoN> = <STRING> , <BoN> try cast <EoN> = <BoN> False <EoN> , <BoN> mgr <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> orig other <EoN> = <BoN> other <EoN> <NEWLINE> <BoN> values <EoN> = <BoN> self <EoN> . <BoN> values <EoN> <NEWLINE> <NEWLINE> <BoN> other <EoN> = <BoN> getattr <EoN> ( <BoN> other <EoN> , <STRING> , <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> is transposed <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> other <EoN> , <STRING> ) <BoN> and <EoN> <BoN> hasattr <EoN> ( <BoN> values <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> values <EoN> . <BoN> ndim <EoN> != <BoN> other <EoN> . <BoN> ndim <EoN> : <NEWLINE> <TAB> <BoN> is transposed <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> values <EoN> . <BoN> shape <EoN> == <BoN> other <EoN> . <BoN> shape <EoN> [ : : - <NUMBER> ] : <NEWLINE> <TAB> <BoN> is transposed <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> values <EoN> . <BoN> shape <EoN> [ <NUMBER> ] == <BoN> other <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> is transposed <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> t shape <EoN> = <BoN> values <EoN> . <BoN> T <EoN> . <BoN> shape <EoN> , <BoN> oth shape <EoN> = <BoN> other <EoN> . <BoN> shape <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> transf <EoN> = ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> T <EoN> ) <BoN> if <EoN> <BoN> is transposed <EoN> <BoN> else <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> , <BoN> values mask <EoN> , <BoN> other <EoN> , <BoN> other mask <EoN> = <BoN> self <EoN> . <BoN> try coerce args <EoN> ( <NEWLINE> <BoN> transf <EoN> ( <BoN> values <EoN> ) , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> block <EoN> = <BoN> self <EoN> . <BoN> coerce to target dtype <EoN> ( <BoN> orig other <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> block <EoN> . <BoN> eval <EoN> ( <BoN> func <EoN> , <BoN> orig other <EoN> , <NEWLINE> <BoN> errors <EoN> = <BoN> errors <EoN> , <NEWLINE> <BoN> try cast <EoN> = <BoN> try cast <EoN> , <BoN> mgr <EoN> = <BoN> mgr <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> get result <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> other <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> not <EoN> <BoN> func <EoN> . <BoN> name <EoN> == <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is numeric v string like <EoN> ( <BoN> values <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> func <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is list like <EoN> ( <BoN> other <EoN> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> values <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] != <BoN> other <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> result <EoN> = <BoN> func <EoN> ( <BoN> values <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> func <EoN> ( <BoN> values <EoN> , <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> values mask <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <BoN> and <EoN> <BoN> values mask <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> astype <EoN> ( <STRING> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> result <EoN> [ <BoN> values mask <EoN> ] = <BoN> np <EoN> . <BoN> nan <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> other mask <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> astype <EoN> ( <STRING> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> result <EoN> [ : ] = <BoN> np <EoN> . <BoN> nan <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> other mask <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <BoN> and <EoN> <BoN> other mask <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> astype <EoN> ( <STRING> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> result <EoN> [ <BoN> other mask <EoN> . <BoN> ravel <EoN> ( ) ] = <BoN> np <EoN> . <BoN> nan <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> handle error <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> errors <EoN> == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> other <EoN> = <BoN> other <EoN> , <BoN> detail <EoN> = <BoN> detail <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> values <EoN> . <BoN> shape <EoN> , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <BoN> result <EoN> . <BoN> fill <EoN> ( <BoN> np <EoN> . <BoN> nan <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> all <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> get result <EoN> ( <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> <BoN> as <EoN> <BoN> detail <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> <BoN> as <EoN> <BoN> detail <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> handle error <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> result <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> result <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> values <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <BoN> and <EoN> <BoN> is list like <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> other <EoN> = <BoN> other <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> other <EoN> = <BoN> other <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> result <EoN> = <BoN> transf <EoN> ( <BoN> result <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> try cast <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> try cast result <EoN> ( <BoN> result <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> block shape <EoN> ( <BoN> result <EoN> , <BoN> ndim <EoN> = <BoN> self <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <BoN> return <EoN> [ <BoN> self <EoN> . <BoN> make block <EoN> ( <BoN> result <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write text <EoN> ( <BoN> self <EoN> , <BoN> data <EoN> , <BoN> encoding <EoN> = <BoN> None <EoN> , <BoN> errors <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> data <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <NEWLINE> <BoN> data <EoN> . <BoN> class <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> self <EoN> . <BoN> open <EoN> ( <BoN> mode <EoN> = <STRING> , <BoN> encoding <EoN> = <BoN> encoding <EoN> , <BoN> errors <EoN> = <BoN> errors <EoN> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> write <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rank order <EoN> ( <BoN> image <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> flat image <EoN> = <BoN> image <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> sort order <EoN> = <BoN> flat image <EoN> . <BoN> argsort <EoN> ( ) . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> uint 32 <EoN> ) <NEWLINE> <BoN> flat image <EoN> = <BoN> flat image <EoN> [ <BoN> sort order <EoN> ] <NEWLINE> <BoN> sort rank <EoN> = <BoN> np <EoN> . <BoN> zeros like <EoN> ( <BoN> sort order <EoN> ) <NEWLINE> <BoN> is different <EoN> = <BoN> flat image <EoN> [ : - <NUMBER> ] != <BoN> flat image <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> np <EoN> . <BoN> cumsum <EoN> ( <BoN> is different <EoN> , <BoN> out <EoN> = <BoN> sort rank <EoN> [ <NUMBER> : ] ) <NEWLINE> <BoN> original values <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> sort rank <EoN> [ - <NUMBER> ] + <NUMBER> , ) , <BoN> image <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> original values <EoN> [ <NUMBER> ] = <BoN> flat image <EoN> [ <NUMBER> ] <NEWLINE> <BoN> original values <EoN> [ <NUMBER> : ] = <BoN> flat image <EoN> [ <NUMBER> : ] [ <BoN> is different <EoN> ] <NEWLINE> <BoN> int image <EoN> = <BoN> np <EoN> . <BoN> zeros like <EoN> ( <BoN> sort order <EoN> ) <NEWLINE> <BoN> int image <EoN> [ <BoN> sort order <EoN> ] = <BoN> sort rank <EoN> <NEWLINE> <BoN> return <EoN> ( <BoN> int image <EoN> . <BoN> reshape <EoN> ( <BoN> image <EoN> . <BoN> shape <EoN> ) , <BoN> original values <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add n <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> empty <EoN> ( <BoN> shape <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> stype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> stype <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> stype <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> empty ndarray <EoN> ( <BoN> shape <EoN> , <BoN> ctx <EoN> , <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> empty sparse ndarray <EoN> ( <BoN> stype <EoN> , <BoN> shape <EoN> , <BoN> ctx <EoN> , <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get matching files v 2 <EoN> ( <BoN> pattern <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> errors <EoN> . <BoN> raise exception on not ok status <EoN> ( ) <BoN> as <EoN> <BoN> status <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> pattern <EoN> , <BoN> six <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ <NEWLINE> <NEWLINE> <BoN> compat <EoN> . <BoN> as str any <EoN> ( <BoN> matching filename <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> matching filename <EoN> <BoN> in <EoN> <BoN> pywrap tensorflow <EoN> . <BoN> Get Matching Files <EoN> ( <NEWLINE> <BoN> compat <EoN> . <BoN> as bytes <EoN> ( <BoN> pattern <EoN> ) , <BoN> status <EoN> ) <NEWLINE> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <NEWLINE> <NEWLINE> <BoN> compat <EoN> . <BoN> as str any <EoN> ( <BoN> matching filename <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> single filename <EoN> <BoN> in <EoN> <BoN> pattern <EoN> <NEWLINE> <BoN> for <EoN> <BoN> matching filename <EoN> <BoN> in <EoN> <BoN> pywrap tensorflow <EoN> . <BoN> Get Matching Files <EoN> ( <NEWLINE> <BoN> compat <EoN> . <BoN> as bytes <EoN> ( <BoN> single filename <EoN> ) , <BoN> status <EoN> ) <NEWLINE> ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> public <EoN> <NEWLINE> <BoN> def <EoN> <BoN> cofactors <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , * <BoN> gens <EoN> , ** <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> options <EoN> . <BoN> allowed flags <EoN> ( <BoN> args <EoN> , [ <STRING> ] ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> ( <BoN> F <EoN> , <BoN> G <EoN> ) , <BoN> opt <EoN> = <BoN> parallel poly from expr <EoN> ( ( <BoN> f <EoN> , <BoN> g <EoN> ) , * <BoN> gens <EoN> , ** <BoN> args <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Polification Failed <EoN> <BoN> as <EoN> <BoN> exc <EoN> : <NEWLINE> <TAB> <BoN> domain <EoN> , ( <BoN> a <EoN> , <BoN> b <EoN> ) = <BoN> construct domain <EoN> ( <BoN> exc <EoN> . <BoN> exprs <EoN> ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> h <EoN> , <BoN> cff <EoN> , <BoN> cfg <EoN> = <BoN> domain <EoN> . <BoN> cofactors <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Not Implemented Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Computation Failed <EoN> ( <STRING> , <NUMBER> , <BoN> exc <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> domain <EoN> . <BoN> to sympy <EoN> ( <BoN> h <EoN> ) , <BoN> domain <EoN> . <BoN> to sympy <EoN> ( <BoN> cff <EoN> ) , <BoN> domain <EoN> . <BoN> to sympy <EoN> ( <BoN> cfg <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> h <EoN> , <BoN> cff <EoN> , <BoN> cfg <EoN> = <BoN> F <EoN> . <BoN> cofactors <EoN> ( <BoN> G <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> opt <EoN> . <BoN> polys <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> h <EoN> . <BoN> as expr <EoN> ( ) , <BoN> cff <EoN> . <BoN> as expr <EoN> ( ) , <BoN> cfg <EoN> . <BoN> as expr <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> h <EoN> , <BoN> cff <EoN> , <BoN> cfg <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> applyfunc <EoN> ( <BoN> self <EoN> , <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> callable <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval applyfunc <EoN> ( <BoN> f <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> limit <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> xlim <EoN> , <BoN> dir <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> series <EoN> . <BoN> limits <EoN> <BoN> import <EoN> <BoN> limit <EoN> <NEWLINE> <BoN> return <EoN> <BoN> limit <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> xlim <EoN> , <BoN> dir <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> checksol <EoN> ( <BoN> f <EoN> , <BoN> symbol <EoN> , <BoN> sol <EoN> = <BoN> None <EoN> , ** <BoN> flags <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> physics <EoN> . <BoN> units <EoN> <BoN> import <EoN> <BoN> Unit <EoN> <NEWLINE> <NEWLINE> <BoN> minimal <EoN> = <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sol <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> = { <BoN> symbol <EoN> : <BoN> sol <EoN> } <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> symbol <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> sol <EoN> = <BoN> symbol <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> % ( <BoN> symbol <EoN> , <BoN> sol <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> iterable <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> rv <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> for <EoN> <BoN> fi <EoN> <BoN> in <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> check <EoN> = <BoN> checksol <EoN> ( <BoN> fi <EoN> , <BoN> sol <EoN> , ** <BoN> flags <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> check <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> check <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> rv <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> f <EoN> , <BoN> Poly <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> f <EoN> . <BoN> as expr <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> f <EoN> , ( <BoN> Equality <EoN> , <BoN> Unequality <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> f <EoN> . <BoN> rhs <EoN> <BoN> in <EoN> ( <BoN> S <EoN> . <BoN> true <EoN> , <BoN> S <EoN> . <BoN> false <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> f <EoN> . <BoN> reversed <EoN> <NEWLINE> <UNTAB> <BoN> B <EoN> , <BoN> E <EoN> = <BoN> f <EoN> . <BoN> args <EoN> <NEWLINE> <BoN> if <EoN> <BoN> B <EoN> <BoN> in <EoN> ( <BoN> S <EoN> . <BoN> true <EoN> , <BoN> S <EoN> . <BoN> false <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> sol <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <BoN> S <EoN> . <BoN> true <EoN> , <BoN> S <EoN> . <BoN> false <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> Add <EoN> ( <BoN> f <EoN> . <BoN> lhs <EoN> , - <BoN> f <EoN> . <BoN> rhs <EoN> , <BoN> evaluate <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> f <EoN> , <BoN> Boolean Atom <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> bool <EoN> ( <BoN> f <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> f <EoN> . <BoN> is Relational <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sol <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> f <EoN> . <BoN> free symbols <EoN> & <BoN> set <EoN> ( <BoN> sol <EoN> . <BoN> keys <EoN> ( ) ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> illegal <EoN> = <BoN> set <EoN> ( [ <BoN> S <EoN> . <BoN> Na N <EoN> , <NEWLINE> <BoN> S <EoN> . <BoN> Complex Infinity <EoN> , <NEWLINE> <BoN> S <EoN> . <BoN> Infinity <EoN> , <NEWLINE> <BoN> S <EoN> . <BoN> Negative Infinity <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> sympify <EoN> ( <BoN> v <EoN> ) . <BoN> atoms <EoN> ( ) & <BoN> illegal <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> sol <EoN> . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> was <EoN> = <BoN> f <EoN> <NEWLINE> <BoN> attempt <EoN> = - <NUMBER> <NEWLINE> <BoN> numerical <EoN> = <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <BoN> while <EoN> <NUMBER> : <NEWLINE> <TAB> <BoN> attempt <EoN> += <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> attempt <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> sol <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> val <EoN> , <BoN> Mul <EoN> ) : <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> val <EoN> . <BoN> as independent <EoN> ( <BoN> Unit <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> val <EoN> . <BoN> atoms <EoN> ( ) & <BoN> illegal <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> attempt <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> val <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> val <EoN> . <BoN> is constant <EoN> ( * <BoN> list <EoN> ( <BoN> sol <EoN> . <BoN> keys <EoN> ( ) ) , <BoN> simplify <EoN> = <BoN> not <EoN> <BoN> minimal <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> <EoN> , <BoN> val <EoN> = <BoN> val <EoN> . <BoN> as content primitive <EoN> ( ) <NEWLINE> <BoN> val <EoN> = <BoN> mexpand <EoN> ( <BoN> val <EoN> . <BoN> as numer denom <EoN> ( ) [ <NUMBER> ] , <BoN> recursive <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> attempt <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> minimal <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> sol <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> [ <BoN> k <EoN> ] = <BoN> simplify <EoN> ( <BoN> sol <EoN> [ <BoN> k <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> val <EoN> = <BoN> simplify <EoN> ( <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> sol <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> val <EoN> , <BoN> reps <EoN> = <BoN> posify <EoN> ( <BoN> val <EoN> ) <NEWLINE> <NEWLINE> <BoN> exval <EoN> = <BoN> mexpand <EoN> ( <BoN> val <EoN> , <BoN> recursive <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> exval <EoN> . <BoN> is number <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> exval <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> exval <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> pot <EoN> = <BoN> preorder traversal <EoN> ( <BoN> expand mul <EoN> ( <BoN> val <EoN> ) ) <NEWLINE> <BoN> seen <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> saw pow func <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> pot <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> seen <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> seen <EoN> . <BoN> add <EoN> ( <BoN> p <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> p <EoN> . <BoN> is Pow <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> p <EoN> . <BoN> exp <EoN> . <BoN> is Integer <EoN> : <NEWLINE> <TAB> <BoN> saw pow func <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> p <EoN> . <BoN> is Function <EoN> : <NEWLINE> <TAB> <BoN> saw pow func <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> p <EoN> , <BoN> Undefined Function <EoN> ) : <NEWLINE> <TAB> <BoN> saw pow func <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> saw pow func <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> saw pow func <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> True <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> val <EoN> . <BoN> subs <EoN> ( <BoN> reps <EoN> ) <NEWLINE> <UNTAB> <BoN> nz <EoN> = <BoN> fuzzy not <EoN> ( <BoN> val <EoN> . <BoN> is zero <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> nz <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> val <EoN> . <BoN> is number <EoN> <BoN> and <EoN> <BoN> val <EoN> . <BoN> has <EoN> ( <BoN> Lambert W <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> not <EoN> <BoN> nz <EoN> <NEWLINE> <UNTAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> val <EoN> == <BoN> was <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> val <EoN> . <BoN> is Rational <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> val <EoN> == <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> numerical <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> val <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> val <EoN> <BoN> in <EoN> ( <BoN> S <EoN> . <BoN> true <EoN> , <BoN> S <EoN> . <BoN> false <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> bool <EoN> ( <BoN> val <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> bool <EoN> ( <BoN> abs <EoN> ( <BoN> val <EoN> . <BoN> n <EoN> ( <NUMBER> ) . <BoN> n <EoN> ( <NUMBER> , <BoN> chop <EoN> = <BoN> True <EoN> ) ) < <NUMBER> ) <NEWLINE> <UNTAB> <BoN> was <EoN> = <BoN> val <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> % <BoN> sol <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> unique <EoN> ( <BoN> input <EoN> , <BoN> sorted <EoN> = <BoN> False <EoN> , <BoN> return inverse <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> output <EoN> , <BoN> inverse indices <EoN> = <BoN> torch <EoN> . <BoN> unique <EoN> ( <NEWLINE> <BoN> input <EoN> , <NEWLINE> <BoN> sorted <EoN> = <BoN> sorted <EoN> , <NEWLINE> <BoN> return inverse <EoN> = <BoN> return inverse <EoN> , <NEWLINE> ) <NEWLINE> <BoN> if <EoN> <BoN> return inverse <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> output <EoN> , <BoN> inverse indices <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> output <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> crf unary score <EoN> ( <BoN> tag indices <EoN> , <BoN> sequence lengths <EoN> , <BoN> inputs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> batch size <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> inputs <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> max seq len <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> inputs <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> num tags <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> inputs <EoN> ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> flattened inputs <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> inputs <EoN> , [ - <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> offsets <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> batch size <EoN> ) * <BoN> max seq len <EoN> * <BoN> num tags <EoN> , <NUMBER> ) <NEWLINE> <BoN> offsets <EoN> += <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> max seq len <EoN> ) * <BoN> num tags <EoN> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> tag indices <EoN> . <BoN> dtype <EoN> == <BoN> dtypes <EoN> . <BoN> int 64 <EoN> : <NEWLINE> <TAB> <BoN> offsets <EoN> = <BoN> math ops <EoN> . <BoN> to int 64 <EoN> ( <BoN> offsets <EoN> ) <NEWLINE> <UNTAB> <BoN> flattened tag indices <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> offsets <EoN> + <BoN> tag indices <EoN> , [ - <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> unary scores <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <NEWLINE> <BoN> array ops <EoN> . <BoN> gather <EoN> ( <BoN> flattened inputs <EoN> , <BoN> flattened tag indices <EoN> ) , <NEWLINE> [ <BoN> batch size <EoN> , <BoN> max seq len <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> masks <EoN> = <BoN> array ops <EoN> . <BoN> sequence mask <EoN> ( <BoN> sequence lengths <EoN> , <NEWLINE> <BoN> maxlen <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> tag indices <EoN> ) [ <NUMBER> ] , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <NEWLINE> <BoN> unary scores <EoN> = <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> unary scores <EoN> * <BoN> masks <EoN> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> unary scores <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> infolist <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> filelist <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exquo ground <EoN> ( <BoN> f <EoN> , <BoN> c <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> dmp exquo ground <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> . <BoN> convert <EoN> ( <BoN> c <EoN> ) , <BoN> f <EoN> . <BoN> lev <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> branching weight <EoN> ( <BoN> G <EoN> , <BoN> attr <EoN> = <STRING> , <BoN> default <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <BoN> edge <EoN> [ <NUMBER> ] . <BoN> get <EoN> ( <BoN> attr <EoN> , <BoN> default <EoN> ) <BoN> for <EoN> <BoN> edge <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> edges <EoN> ( <BoN> data <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> polycompanion <EoN> ( <BoN> c <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> [ <BoN> c <EoN> ] = <BoN> pu <EoN> . <BoN> as series <EoN> ( [ <BoN> c <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> c <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> c <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array <EoN> ( [ [ - <BoN> c <EoN> [ <NUMBER> ] / <BoN> c <EoN> [ <NUMBER> ] ] ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> c <EoN> ) - <NUMBER> <NEWLINE> <BoN> mat <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> bot <EoN> = <BoN> mat <EoN> . <BoN> reshape <EoN> ( - <NUMBER> ) [ <BoN> n <EoN> : : <BoN> n <EoN> + <NUMBER> ] <NEWLINE> <BoN> bot <EoN> [ ... ] = <NUMBER> <NEWLINE> <BoN> mat <EoN> [ : , - <NUMBER> ] -= <BoN> c <EoN> [ : - <NUMBER> ] / <BoN> c <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> mat <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> class nodes <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> rval <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> , <BoN> count <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> self <EoN> . <BoN> apply callcount <EoN> ) : <NEWLINE> <TAB> <BoN> typ <EoN> = <BoN> type <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> ) <NEWLINE> <BoN> rval <EoN> . <BoN> setdefault <EoN> ( <BoN> typ <EoN> , <NUMBER> ) <NEWLINE> <BoN> rval <EoN> [ <BoN> typ <EoN> ] += <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rval <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> barh <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> = <BoN> None <EoN> , <BoN> y <EoN> = <BoN> None <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> ( <BoN> kind <EoN> = <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , ** <BoN> kwds <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get dataset names <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> from <EoN> <BoN> bs 4 <EoN> <BoN> import <EoN> <BoN> Beautiful Soup <EoN> <NEWLINE> <BoN> http <EoN> = <BoN> urlopen <EoN> ( <STRING> ) <NEWLINE> <BoN> gh list <EoN> = <BoN> Beautiful Soup <EoN> ( <BoN> http <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> l <EoN> . <BoN> text <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> for <EoN> <BoN> l <EoN> <BoN> in <EoN> <BoN> gh list <EoN> . <BoN> find all <EoN> ( <STRING> , { <STRING> : <STRING> } ) <NEWLINE> <BoN> if <EoN> <BoN> l <EoN> . <BoN> text <EoN> . <BoN> endswith <EoN> ( <STRING> ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create operator <EoN> ( <BoN> matrix <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> linear operator <EoN> = <BoN> collections <EoN> . <BoN> namedtuple <EoN> ( <NEWLINE> <STRING> , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> shape <EoN> = <BoN> matrix <EoN> . <BoN> get shape <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> shape <EoN> . <BoN> is fully defined <EoN> ( ) : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> shape <EoN> . <BoN> as list <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> matrix <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> linear operator <EoN> ( <NEWLINE> <BoN> shape <EoN> = <BoN> shape <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> matrix <EoN> . <BoN> dtype <EoN> , <NEWLINE> <BoN> apply <EoN> = <BoN> lambda <EoN> <BoN> v <EoN> : <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> matrix <EoN> , <BoN> v <EoN> , <BoN> adjoint a <EoN> = <BoN> False <EoN> ) , <NEWLINE> <BoN> apply adjoint <EoN> = <BoN> lambda <EoN> <BoN> v <EoN> : <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> matrix <EoN> , <BoN> v <EoN> , <BoN> adjoint a <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> initialize <EoN> ( <BoN> self <EoN> , <BoN> table <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check table dtypes <EoN> ( <BoN> table <EoN> , <BoN> self <EoN> . <BoN> keys <EoN> . <BoN> dtype <EoN> , <BoN> self <EoN> . <BoN> values <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> , <BoN> values <EoN> = ( <BoN> table <EoN> . <BoN> resource handle <EoN> , <BoN> self <EoN> . <BoN> keys <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> values <EoN> ) ) <BoN> as <EoN> <BoN> scope <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> scope <EoN> += <BoN> str <EoN> ( <BoN> ops <EoN> . <BoN> uid <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fwd compat <EoN> . <BoN> forward compatible <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> init op <EoN> = <BoN> gen lookup ops <EoN> . <BoN> lookup table import v 2 <EoN> ( <NEWLINE> <BoN> table <EoN> . <BoN> resource handle <EoN> , <BoN> self <EoN> . <BoN> keys <EoN> , <BoN> self <EoN> . <BoN> values <EoN> , <BoN> name <EoN> = <BoN> scope <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> init op <EoN> = <BoN> gen lookup ops <EoN> . <BoN> initialize table v 2 <EoN> ( <NEWLINE> <BoN> table <EoN> . <BoN> resource handle <EoN> , <BoN> self <EoN> . <BoN> keys <EoN> , <BoN> self <EoN> . <BoN> values <EoN> , <BoN> name <EoN> = <BoN> scope <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> TABLE INITIALIZERS <EoN> , <BoN> init op <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> init op <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hash categorical <EoN> ( <BoN> c <EoN> , <BoN> encoding <EoN> , <BoN> hash key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> hashed <EoN> = <BoN> hash array <EoN> ( <BoN> c <EoN> . <BoN> categories <EoN> . <BoN> values <EoN> , <BoN> encoding <EoN> , <BoN> hash key <EoN> , <NEWLINE> <BoN> categorize <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> mask <EoN> = <BoN> c <EoN> . <BoN> isna <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> hashed <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> hashed <EoN> . <BoN> take <EoN> ( <BoN> c <EoN> . <BoN> codes <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> len <EoN> ( <BoN> mask <EoN> ) , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mask <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> mask <EoN> ] = <BoN> np <EoN> . <BoN> iinfo <EoN> ( <BoN> np <EoN> . <BoN> uint 64 <EoN> ) . <BoN> max <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> graph atlas g <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> generate graphs <EoN> ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> div eager fallback <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> x <EoN> , <BoN> y <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> ( <BoN> x <EoN> , <BoN> y <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> x <EoN> , <BoN> y <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> memory cached <EoN> ( <BoN> device <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> device <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> device <EoN> = <BoN> current device <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> cuda memoryCached <EoN> ( <BoN> device <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup prs resultant <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> K <EoN> . <BoN> zero <EoN> , [ ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> R <EoN> , <BoN> S <EoN> = <BoN> dup inner subresultants <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dup degree <EoN> ( <BoN> R <EoN> [ - <NUMBER> ] ) > <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> K <EoN> . <BoN> zero <EoN> , <BoN> R <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> S <EoN> [ - <NUMBER> ] , <BoN> R <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> repr <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> str <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> datalim to dt <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dmin <EoN> , <BoN> dmax <EoN> = <BoN> self <EoN> . <BoN> axis <EoN> . <BoN> get data interval <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> dmin <EoN> > <BoN> dmax <EoN> : <NEWLINE> <TAB> <BoN> dmin <EoN> , <BoN> dmax <EoN> = <BoN> dmax <EoN> , <BoN> dmin <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dmin <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> dmin <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> num 2 date <EoN> ( <BoN> dmin <EoN> , <BoN> self <EoN> . <BoN> tz <EoN> ) , <BoN> num 2 date <EoN> ( <BoN> dmax <EoN> , <BoN> self <EoN> . <BoN> tz <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> track checkpointable <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <BoN> Null <EoN> , <BoN> keepdims <EoN> = <BoN> Null <EoN> , <BoN> exclude <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> generate shifts <EoN> ( <BoN> ndim <EoN> , <BoN> multichannel <EoN> , <BoN> max shifts <EoN> , <BoN> shift steps <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mc <EoN> = <BoN> int <EoN> ( <BoN> multichannel <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> isscalar <EoN> ( <BoN> max shifts <EoN> ) : <NEWLINE> <TAB> <BoN> max shifts <EoN> = ( <BoN> max shifts <EoN> , ) * ( <BoN> ndim <EoN> - <BoN> mc <EoN> ) + ( <NUMBER> , ) * <BoN> mc <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> multichannel <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> max shifts <EoN> ) == <BoN> ndim <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> max shifts <EoN> = <BoN> tuple <EoN> ( <BoN> max shifts <EoN> ) + ( <NUMBER> , ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> max shifts <EoN> ) != <BoN> ndim <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> isscalar <EoN> ( <BoN> shift steps <EoN> ) : <NEWLINE> <TAB> <BoN> shift steps <EoN> = ( <BoN> shift steps <EoN> , ) * ( <BoN> ndim <EoN> - <BoN> mc <EoN> ) + ( <NUMBER> , ) * <BoN> mc <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> multichannel <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> shift steps <EoN> ) == <BoN> ndim <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> shift steps <EoN> = <BoN> tuple <EoN> ( <BoN> shift steps <EoN> ) + ( <NUMBER> , ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> shift steps <EoN> ) != <BoN> ndim <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> shift steps <EoN> ) < <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> multichannel <EoN> <BoN> and <EoN> <BoN> max shifts <EoN> [ - <NUMBER> ] != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> product <EoN> ( * [ <BoN> range <EoN> ( <NUMBER> , <BoN> s <EoN> + <NUMBER> , <BoN> t <EoN> ) <BoN> for <EoN> <NEWLINE> <BoN> s <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> max shifts <EoN> , <BoN> shift steps <EoN> ) ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Leaky Re L U <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> gamma <EoN> = <BoN> None <EoN> , <BoN> act type <EoN> = <BoN> Null <EoN> , <BoN> slope <EoN> = <BoN> Null <EoN> , <BoN> lower bound <EoN> = <BoN> Null <EoN> , <BoN> upper bound <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> mx op <EoN> . <BoN> register <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> convert elemwise div <EoN> ( <BoN> node <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> helper <EoN> , <BoN> <EoN> , <BoN> <EoN> = <BoN> import onnx modules <EoN> ( ) <NEWLINE> <BoN> name <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> proc nodes <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> inputs <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> input node a id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <BoN> input node b id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> input node a <EoN> = <BoN> proc nodes <EoN> [ <BoN> input node a id <EoN> ] . <BoN> name <EoN> <NEWLINE> <BoN> input node b <EoN> = <BoN> proc nodes <EoN> [ <BoN> input node b id <EoN> ] . <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> div node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <STRING> , <NEWLINE> [ <BoN> input node a <EoN> , <BoN> input node b <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> div node <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> array wrap <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> , <BoN> context <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> obj <EoN> <BoN> is <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> obj <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> obj <EoN> . <BoN> view <EoN> ( <BoN> type <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <BoN> result <EoN> . <BoN> update from <EoN> ( <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> context <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> mask <EoN> = <BoN> result <EoN> . <BoN> mask <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> func <EoN> , <BoN> args <EoN> , <BoN> out i <EoN> = <BoN> context <EoN> <NEWLINE> <NEWLINE> <BoN> input args <EoN> = <BoN> args <EoN> [ : <BoN> func <EoN> . <BoN> nin <EoN> ] <NEWLINE> <BoN> m <EoN> = <BoN> reduce <EoN> ( <BoN> mask or <EoN> , [ <BoN> getmaskarray <EoN> ( <BoN> arg <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> input args <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> domain <EoN> = <BoN> ufunc domain <EoN> . <BoN> get <EoN> ( <BoN> func <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> domain <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input args <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> divide <EoN> = <STRING> , <BoN> invalid <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> filled <EoN> ( <BoN> reduce <EoN> ( <BoN> domain <EoN> , <BoN> input args <EoN> ) , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> divide <EoN> = <STRING> , <BoN> invalid <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> filled <EoN> ( <BoN> domain <EoN> ( * <BoN> input args <EoN> ) , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> d <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> ufunc fills <EoN> [ <BoN> func <EoN> ] [ - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> ufunc fills <EoN> [ <BoN> func <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> self <EoN> . <BoN> fill value <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> np <EoN> . <BoN> copyto <EoN> ( <BoN> result <EoN> , <BoN> fill value <EoN> , <BoN> where <EoN> = <BoN> d <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> <BoN> is <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> m <EoN> = ( <BoN> m <EoN> | <BoN> d <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> self <EoN> <BoN> and <EoN> <BoN> result <EoN> . <BoN> shape <EoN> == ( ) <BoN> and <EoN> <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> masked <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> mask <EoN> = <BoN> m <EoN> <NEWLINE> <BoN> result <EoN> . <BoN> sharedmask <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exception <EoN> ( <BoN> self <EoN> , <BoN> msg <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> log <EoN> ( <BoN> logging <EoN> . <BoN> ERRO R <EoN> , <BoN> msg <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> softplus <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> add extra attributes <EoN> ( <BoN> attrs <EoN> , { <STRING> : <STRING> } ) <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> new attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> krogh interpolate <EoN> ( <BoN> xi <EoN> , <BoN> yi <EoN> , <BoN> x <EoN> , <BoN> der <EoN> = <NUMBER> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> P <EoN> = <BoN> Krogh Interpolator <EoN> ( <BoN> xi <EoN> , <BoN> yi <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> der <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> P <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isscalar <EoN> ( <BoN> der <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> P <EoN> . <BoN> derivative <EoN> ( <BoN> x <EoN> , <BoN> der <EoN> = <BoN> der <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> P <EoN> . <BoN> derivatives <EoN> ( <BoN> x <EoN> , <BoN> der <EoN> = <BoN> np <EoN> . <BoN> amax <EoN> ( <BoN> der <EoN> ) + <NUMBER> ) [ <BoN> der <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> create op from tf operation <EoN> ( <BoN> self <EoN> , <BoN> c op <EoN> , <BoN> compute device <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> check not finalized <EoN> ( ) <NEWLINE> <BoN> ret <EoN> = <BoN> Operation <EoN> ( <BoN> c op <EoN> , <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> name key <EoN> = <BoN> ret <EoN> . <BoN> name <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> name key <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> names in use <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> names in use <EoN> [ <BoN> name key <EoN> ] = <NUMBER> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> create op helper <EoN> ( <BoN> ret <EoN> , <BoN> compute device <EoN> = <BoN> compute device <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> shortest path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> = <BoN> None <EoN> , <BoN> target <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> method <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> method <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> method <EoN> ) ) <NEWLINE> <UNTAB> <BoN> method <EoN> = <STRING> <BoN> if <EoN> <BoN> weight <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> method <EoN> <NEWLINE> <BoN> if <EoN> <BoN> source <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> target <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> dict <EoN> ( <BoN> nx <EoN> . <BoN> all pairs shortest path <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> dict <EoN> ( <BoN> nx <EoN> . <BoN> all pairs dijkstra path <EoN> ( <BoN> G <EoN> , <BoN> weight <EoN> = <BoN> weight <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> dict <EoN> ( <BoN> nx <EoN> . <BoN> all pairs bellman ford path <EoN> ( <BoN> G <EoN> , <BoN> weight <EoN> = <BoN> weight <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> with <EoN> <BoN> nx <EoN> . <BoN> utils <EoN> . <BoN> reversed <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source shortest path <EoN> ( <BoN> G <EoN> , <BoN> target <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source dijkstra path <EoN> ( <BoN> G <EoN> , <BoN> target <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source bellman ford path <EoN> ( <BoN> G <EoN> , <BoN> target <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> target <EoN> <BoN> in <EoN> <BoN> paths <EoN> : <NEWLINE> <TAB> <BoN> paths <EoN> [ <BoN> target <EoN> ] = <BoN> list <EoN> ( <BoN> reversed <EoN> ( <BoN> paths <EoN> [ <BoN> target <EoN> ] ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> target <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source shortest path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source dijkstra path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> single source bellman ford path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> bidirectional shortest path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> target <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> dijkstra path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> target <EoN> , <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> paths <EoN> = <BoN> nx <EoN> . <BoN> bellman ford path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> target <EoN> , <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> paths <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> greater equal <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> greater equal eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> greater equal <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> greater equal <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getitem <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> indexing dispatch code <EoN> = <BoN> get indexing dispatch code <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> indexing dispatch code <EoN> == <BoN> NDARRAY BASIC INDEXING <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get nd basic indexing <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> indexing dispatch code <EoN> == <BoN> NDARRAY ADVANCED INDEXING <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get nd advanced indexing <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> % ( <BoN> str <EoN> ( <BoN> key <EoN> ) , <BoN> str <EoN> ( <BoN> type <EoN> ( <BoN> key <EoN> ) ) ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set attrs <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> attrs <EoN> . <BoN> encoding <EoN> = <BoN> self <EoN> . <BoN> encoding <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> attrs <EoN> . <BoN> errors <EoN> = <BoN> self <EoN> . <BoN> errors <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> onmove <EoN> ( <BoN> self <EoN> , <BoN> event <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> pressv <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> set span xy <EoN> ( <BoN> event <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> onmove callback <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> vmin <EoN> = <BoN> self <EoN> . <BoN> pressv <EoN> <NEWLINE> <BoN> xdata <EoN> , <BoN> ydata <EoN> = <BoN> self <EoN> . <BoN> get data <EoN> ( <BoN> event <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> direction <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> vmax <EoN> = <BoN> xdata <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> prev <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> vmax <EoN> = <BoN> ydata <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> prev <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> vmin <EoN> > <BoN> vmax <EoN> : <NEWLINE> <TAB> <BoN> vmin <EoN> , <BoN> vmax <EoN> = <BoN> vmax <EoN> , <BoN> vmin <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> onmove callback <EoN> ( <BoN> vmin <EoN> , <BoN> vmax <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> update <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check arg length <EoN> ( <BoN> fname <EoN> , <BoN> args <EoN> , <BoN> max fname arg count <EoN> , <BoN> compat args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> max fname arg count <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) > <BoN> len <EoN> ( <BoN> compat args <EoN> ) : <NEWLINE> <TAB> <BoN> max arg count <EoN> = <BoN> len <EoN> ( <BoN> compat args <EoN> ) + <BoN> max fname arg count <EoN> <NEWLINE> <BoN> actual arg count <EoN> = <BoN> len <EoN> ( <BoN> args <EoN> ) + <BoN> max fname arg count <EoN> <NEWLINE> <BoN> argument <EoN> = <STRING> <BoN> if <EoN> <BoN> max arg count <EoN> == <NUMBER> <BoN> else <EoN> <STRING> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> fname <EoN> = <BoN> fname <EoN> , <BoN> max arg <EoN> = <BoN> max arg count <EoN> , <NEWLINE> <BoN> argument <EoN> = <BoN> argument <EoN> , <BoN> given arg <EoN> = <BoN> actual arg count <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> chain decomposition <EoN> ( <BoN> G <EoN> , <BoN> root <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> dfs cycle forest <EoN> ( <BoN> G <EoN> , <BoN> root <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> H <EoN> = <BoN> nx <EoN> . <BoN> Di Graph <EoN> ( ) <NEWLINE> <BoN> nodes <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> nx <EoN> . <BoN> dfs labeled edges <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> = <BoN> root <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> d <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> u <EoN> == <BoN> v <EoN> : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> add node <EoN> ( <BoN> v <EoN> , <BoN> parent <EoN> = <BoN> None <EoN> ) <NEWLINE> <BoN> nodes <EoN> . <BoN> append <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> add node <EoN> ( <BoN> v <EoN> , <BoN> parent <EoN> = <BoN> u <EoN> ) <NEWLINE> <BoN> H <EoN> . <BoN> add edge <EoN> ( <BoN> v <EoN> , <BoN> u <EoN> , <BoN> nontree <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> nodes <EoN> . <BoN> append <EoN> ( <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> d <EoN> == <STRING> <BoN> and <EoN> <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> H <EoN> [ <BoN> u <EoN> ] : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> add edge <EoN> ( <BoN> v <EoN> , <BoN> u <EoN> , <BoN> nontree <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> H <EoN> , <BoN> nodes <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> build chain <EoN> ( <BoN> G <EoN> , <BoN> u <EoN> , <BoN> v <EoN> , <BoN> visited <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> while <EoN> <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> u <EoN> , <BoN> v <EoN> <NEWLINE> <BoN> visited <EoN> . <BoN> add <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> u <EoN> , <BoN> v <EoN> = <BoN> v <EoN> , <BoN> G <EoN> . <BoN> nodes <EoN> [ <BoN> v <EoN> ] [ <STRING> ] <NEWLINE> <UNTAB> <BoN> yield <EoN> <BoN> u <EoN> , <BoN> v <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> H <EoN> , <BoN> nodes <EoN> = <BoN> dfs cycle forest <EoN> ( <BoN> G <EoN> , <BoN> root <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> visited <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> <BoN> in <EoN> <BoN> nodes <EoN> : <NEWLINE> <TAB> <BoN> visited <EoN> . <BoN> add <EoN> ( <BoN> u <EoN> ) <NEWLINE> <NEWLINE> <BoN> edges <EoN> = ( ( <BoN> u <EoN> , <BoN> v <EoN> ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> H <EoN> . <BoN> out edges <EoN> ( <BoN> u <EoN> , <BoN> data <EoN> = <STRING> ) <BoN> if <EoN> <BoN> d <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> edges <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> chain <EoN> = <BoN> list <EoN> ( <BoN> build chain <EoN> ( <BoN> H <EoN> , <BoN> u <EoN> , <BoN> v <EoN> , <BoN> visited <EoN> ) ) <NEWLINE> <BoN> yield <EoN> <BoN> chain <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval derivative <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> x <EoN> , <BoN> Symbol <EoN> ) <BoN> and <EoN> <BoN> x <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> , <BoN> limits <EoN> = <BoN> self <EoN> . <BoN> function <EoN> , <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> limits <EoN> ) <NEWLINE> <NEWLINE> <BoN> limit <EoN> = <BoN> limits <EoN> . <BoN> pop <EoN> ( - <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> limits <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> f <EoN> , * <BoN> limits <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> limit <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> a <EoN> , <BoN> b <EoN> = <BoN> limit <EoN> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> a <EoN> . <BoN> free symbols <EoN> <BoN> or <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> b <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> df <EoN> = <BoN> Derivative <EoN> ( <BoN> f <EoN> , <BoN> x <EoN> , <BoN> evaluate <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> rv <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> df <EoN> , <BoN> limit <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert ND Array Near <EoN> ( <BoN> self <EoN> , <BoN> ndarray 1 <EoN> , <BoN> ndarray 2 <EoN> , <BoN> err <EoN> , <BoN> msg <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assert True <EoN> ( <BoN> self <EoN> . <BoN> NDArrayNear <EoN> ( <BoN> ndarray 1 <EoN> , <BoN> ndarray 2 <EoN> , <BoN> err <EoN> ) , <BoN> msg <EoN> = <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> svdvals <EoN> ( <BoN> a <EoN> , <BoN> overwrite a <EoN> = <BoN> False <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> asarray validated <EoN> ( <BoN> a <EoN> , <BoN> check finite <EoN> = <BoN> check finite <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> a <EoN> . <BoN> size <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> svd <EoN> ( <BoN> a <EoN> , <BoN> compute uv <EoN> = <NUMBER> , <BoN> overwrite a <EoN> = <BoN> overwrite a <EoN> , <NEWLINE> <BoN> check finite <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> a <EoN> . <BoN> shape <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> numpy <EoN> . <BoN> empty <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assert array equal <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> err msg <EoN> = <STRING> , <BoN> verbose <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tracebackhide <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> assert array compare <EoN> ( <BoN> operator <EoN> . <BoN> eq <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> err msg <EoN> = <BoN> err msg <EoN> , <NEWLINE> <BoN> verbose <EoN> = <BoN> verbose <EoN> , <BoN> header <EoN> = <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is arraylike <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> . <BoN> base <EoN> <BoN> import <EoN> <BoN> is dask collection <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <NEWLINE> <BoN> hasattr <EoN> ( <BoN> x <EoN> , <STRING> ) <BoN> and <EoN> <BoN> x <EoN> . <BoN> shape <EoN> <BoN> and <EoN> <NEWLINE> <BoN> hasattr <EoN> ( <BoN> x <EoN> , <STRING> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> any <EoN> ( <BoN> is dask collection <EoN> ( <BoN> n <EoN> ) <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get custom objects <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> GLOBAL CUSTOM OBJECTS <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> antiderivative inplace <EoN> ( <BoN> self <EoN> , <BoN> nu <EoN> , <BoN> axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> nu <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> derivative inplace <EoN> ( - <BoN> nu <EoN> , <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ndim <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> x <EoN> ) <NEWLINE> <BoN> axis <EoN> = <BoN> axis <EoN> % <BoN> ndim <EoN> <NEWLINE> <NEWLINE> <BoN> perm <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> ndim <EoN> ) ) <NEWLINE> <BoN> perm <EoN> [ <NUMBER> ] , <BoN> perm <EoN> [ <BoN> axis <EoN> ] = <BoN> perm <EoN> [ <BoN> axis <EoN> ] , <BoN> perm <EoN> [ <NUMBER> ] <NEWLINE> <BoN> perm <EoN> = <BoN> perm <EoN> + <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> ndim <EoN> , <BoN> self <EoN> . <BoN> c <EoN> . <BoN> ndim <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> c <EoN> = <BoN> self <EoN> . <BoN> c <EoN> . <BoN> transpose <EoN> ( <BoN> perm <EoN> ) <NEWLINE> <NEWLINE> <BoN> c 2 <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> ] + <BoN> nu <EoN> , ) + <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> : ] , <NEWLINE> <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> c 2 <EoN> [ : - <BoN> nu <EoN> ] = <BoN> c <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> factor <EoN> = <BoN> spec <EoN> . <BoN> poch <EoN> ( <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NUMBER> , - <NUMBER> ) , <BoN> nu <EoN> ) <NEWLINE> <BoN> c 2 <EoN> [ : - <BoN> nu <EoN> ] /= <BoN> factor <EoN> [ ( <BoN> slice <EoN> ( <BoN> None <EoN> ) , ) + ( <BoN> None <EoN> , ) * ( <BoN> c <EoN> . <BoN> ndim <EoN> - <NUMBER> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> perm 2 <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> c 2 <EoN> . <BoN> ndim <EoN> ) ) <NEWLINE> <BoN> perm 2 <EoN> [ <NUMBER> ] , <BoN> perm 2 <EoN> [ <BoN> ndim <EoN> + <BoN> axis <EoN> ] = <BoN> perm 2 <EoN> [ <BoN> ndim <EoN> + <BoN> axis <EoN> ] , <BoN> perm 2 <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> c 2 <EoN> = <BoN> c 2 <EoN> . <BoN> transpose <EoN> ( <BoN> perm 2 <EoN> ) <NEWLINE> <BoN> c 2 <EoN> = <BoN> c 2 <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> ppoly <EoN> . <BoN> fix continuity <EoN> ( <BoN> c 2 <EoN> . <BoN> reshape <EoN> ( <BoN> c 2 <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> c 2 <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , - <NUMBER> ) , <NEWLINE> <BoN> self <EoN> . <BoN> x <EoN> [ <BoN> axis <EoN> ] , <BoN> nu <EoN> - <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> c 2 <EoN> = <BoN> c 2 <EoN> . <BoN> transpose <EoN> ( <BoN> perm 2 <EoN> ) <NEWLINE> <BoN> c 2 <EoN> = <BoN> c 2 <EoN> . <BoN> transpose <EoN> ( <BoN> perm <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> c <EoN> = <BoN> c 2 <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> diag part <EoN> ( <BoN> input <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> input <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> diag part eager fallback <EoN> ( <NEWLINE> <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> diag part <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> diag part <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bfs successors <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> depth limit <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> parent <EoN> = <BoN> source <EoN> <NEWLINE> <BoN> children <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> p <EoN> , <BoN> c <EoN> <BoN> in <EoN> <BoN> bfs edges <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> depth limit <EoN> = <BoN> depth limit <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p <EoN> == <BoN> parent <EoN> : <NEWLINE> <TAB> <BoN> children <EoN> . <BoN> append <EoN> ( <BoN> c <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> yield <EoN> ( <BoN> parent <EoN> , <BoN> children <EoN> ) <NEWLINE> <BoN> children <EoN> = [ <BoN> c <EoN> ] <NEWLINE> <BoN> parent <EoN> = <BoN> p <EoN> <NEWLINE> <UNTAB> <BoN> yield <EoN> ( <BoN> parent <EoN> , <BoN> children <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> empty <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> elements <EoN> ) == <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random exponential <EoN> ( <BoN> lam <EoN> = <BoN> Null <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> ctx <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> XM L <EoN> ( <BoN> text <EoN> , <BoN> parser <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> parser <EoN> : <NEWLINE> <TAB> <BoN> parser <EoN> = <BoN> XML Parser <EoN> ( <BoN> target <EoN> = <BoN> Tree Builder <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> parser <EoN> . <BoN> feed <EoN> ( <BoN> text <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> parser <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ifrt 2 <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> a <EoN> . <BoN> ndim <EoN> != <NUMBER> <BoN> or <EoN> <BoN> a <EoN> . <BoN> shape <EoN> [ <NUMBER> ] != <BoN> a <EoN> . <BoN> shape <EoN> [ <NUMBER> ] + <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ai <EoN> = <BoN> a <EoN> . <BoN> copy <EoN> ( ) [ : - <NUMBER> ] <NEWLINE> <BoN> n <EoN> = <BoN> ai <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> f <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> np <EoN> . <BoN> uint 32 <EoN> ) <NEWLINE> <BoN> f <EoN> [ <NUMBER> ] = <BoN> ai <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> for <EoN> <BoN> m <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> row <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> ai <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> ai <EoN> [ <BoN> row <EoN> ] = <BoN> roll <EoN> ( <BoN> ai <EoN> [ <BoN> row <EoN> ] , <BoN> row <EoN> ) <NEWLINE> <UNTAB> <BoN> f <EoN> [ <BoN> m <EoN> ] = <BoN> ai <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> f <EoN> += <BoN> a <EoN> [ - <NUMBER> ] [ <BoN> newaxis <EoN> ] . <BoN> T <EoN> <NEWLINE> <BoN> f <EoN> = ( <BoN> f <EoN> - <BoN> ai <EoN> [ <NUMBER> ] . <BoN> sum <EoN> ( ) ) / <BoN> n <EoN> <NEWLINE> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> register <EoN> ( <BoN> self <EoN> , <BoN> constraint <EoN> , <BoN> factory <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> factory <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lambda <EoN> <BoN> factory <EoN> : <BoN> self <EoN> . <BoN> register <EoN> ( <BoN> constraint <EoN> , <BoN> factory <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> constraint <EoN> , <BoN> constraints <EoN> . <BoN> Constraint <EoN> ) : <NEWLINE> <TAB> <BoN> constraint <EoN> = <BoN> type <EoN> ( <BoN> constraint <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> constraint <EoN> , <BoN> type <EoN> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> issubclass <EoN> ( <BoN> constraint <EoN> , <BoN> constraints <EoN> . <BoN> Constraint <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> constraint <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> registry <EoN> [ <BoN> constraint <EoN> ] = <BoN> factory <EoN> <NEWLINE> <BoN> return <EoN> <BoN> factory <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set is retired flag func <EoN> ( <BoN> self <EoN> , <BoN> is retired flag func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> dict <EoN> [ <STRING> ] = <BoN> is retired flag func <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> softplus eager fallback <EoN> ( <BoN> features <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> features <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> features <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> features <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> transpose <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> fix attribute names <EoN> ( <BoN> attrs <EoN> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> new attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> run <EoN> ( <BoN> self <EoN> , <BoN> test <EoN> , <BoN> compileflags <EoN> , <BoN> out <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> failures <EoN> = <BoN> tries <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> original optionflags <EoN> = <BoN> self <EoN> . <BoN> optionflags <EoN> <NEWLINE> <NEWLINE> <BoN> SUCCES S <EoN> , <BoN> FAILUR E <EoN> , <BoN> BOO M <EoN> = <BoN> range <EoN> ( <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> check <EoN> = <BoN> self <EoN> . <BoN> checker <EoN> . <BoN> check output <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> examplenum <EoN> , <BoN> example <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> test <EoN> . <BoN> examples <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> quiet <EoN> = ( <BoN> self <EoN> . <BoN> optionflags <EoN> & <BoN> REPORT ONLY FIRST FAILURE <EoN> <BoN> and <EoN> <NEWLINE> <BoN> failures <EoN> > <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> optionflags <EoN> = <BoN> original optionflags <EoN> <NEWLINE> <BoN> if <EoN> <BoN> example <EoN> . <BoN> options <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> ( <BoN> optionflag <EoN> , <BoN> val <EoN> ) <BoN> in <EoN> <BoN> example <EoN> . <BoN> options <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> val <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> optionflags <EoN> |= <BoN> optionflag <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> optionflags <EoN> &= ~ <BoN> optionflag <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> optionflags <EoN> & <BoN> SKI P <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> tries <EoN> += <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> quiet <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> report start <EoN> ( <BoN> out <EoN> , <BoN> test <EoN> , <BoN> example <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> filename <EoN> = <STRING> % ( <BoN> test <EoN> . <BoN> name <EoN> , <BoN> examplenum <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> exec <EoN> ( <BoN> compile <EoN> ( <BoN> example <EoN> . <BoN> source <EoN> , <BoN> filename <EoN> , <STRING> , <NEWLINE> <BoN> compileflags <EoN> , <NUMBER> ) , <BoN> test <EoN> . <BoN> globs <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> debugger <EoN> . <BoN> set continue <EoN> ( ) <NEWLINE> <BoN> exception <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Keyboard Interrupt <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> exception <EoN> = <BoN> sys <EoN> . <BoN> exc info <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> debugger <EoN> . <BoN> set continue <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> got <EoN> = <BoN> self <EoN> . <BoN> fakeout <EoN> . <BoN> getvalue <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> fakeout <EoN> . <BoN> truncate <EoN> ( <NUMBER> ) <NEWLINE> <BoN> outcome <EoN> = <BoN> FAILUR E <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> exception <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> check <EoN> ( <BoN> example <EoN> . <BoN> want <EoN> , <BoN> got <EoN> , <BoN> self <EoN> . <BoN> optionflags <EoN> ) : <NEWLINE> <TAB> <BoN> outcome <EoN> = <BoN> SUCCES S <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> exc msg <EoN> = <BoN> traceback <EoN> . <BoN> format exception only <EoN> ( * <BoN> exception <EoN> [ : <NUMBER> ] ) [ - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> quiet <EoN> : <NEWLINE> <TAB> <BoN> got <EoN> += <BoN> exception traceback <EoN> ( <BoN> exception <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> example <EoN> . <BoN> exc msg <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> outcome <EoN> = <BoN> BOO M <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> check <EoN> ( <BoN> example <EoN> . <BoN> exc msg <EoN> , <BoN> exc msg <EoN> , <BoN> self <EoN> . <BoN> optionflags <EoN> ) : <NEWLINE> <TAB> <BoN> outcome <EoN> = <BoN> SUCCES S <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> optionflags <EoN> & <BoN> IGNORE EXCEPTION DETAIL <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> check <EoN> ( <BoN> strip exception details <EoN> ( <BoN> example <EoN> . <BoN> exc msg <EoN> ) , <NEWLINE> <BoN> strip exception details <EoN> ( <BoN> exc msg <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> optionflags <EoN> ) : <NEWLINE> <TAB> <BoN> outcome <EoN> = <BoN> SUCCES S <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> outcome <EoN> <BoN> is <EoN> <BoN> SUCCES S <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> quiet <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> report success <EoN> ( <BoN> out <EoN> , <BoN> test <EoN> , <BoN> example <EoN> , <BoN> got <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> outcome <EoN> <BoN> is <EoN> <BoN> FAILUR E <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> quiet <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> report failure <EoN> ( <BoN> out <EoN> , <BoN> test <EoN> , <BoN> example <EoN> , <BoN> got <EoN> ) <NEWLINE> <UNTAB> <BoN> failures <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> outcome <EoN> <BoN> is <EoN> <BoN> BOO M <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> quiet <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> report unexpected exception <EoN> ( <BoN> out <EoN> , <BoN> test <EoN> , <BoN> example <EoN> , <NEWLINE> <BoN> exception <EoN> ) <NEWLINE> <UNTAB> <BoN> failures <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> False <EoN> , ( <STRING> , <BoN> outcome <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> failures <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> optionflags <EoN> & <BoN> FAIL FAST <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> optionflags <EoN> = <BoN> original optionflags <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> record outcome <EoN> ( <BoN> test <EoN> , <BoN> failures <EoN> , <BoN> tries <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Test Results <EoN> ( <BoN> failures <EoN> , <BoN> tries <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup diff <EoN> ( <BoN> f <EoN> , <BoN> m <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> dup degree <EoN> ( <BoN> f <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> deriv <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> coeff <EoN> <BoN> in <EoN> <BoN> f <EoN> [ : - <BoN> m <EoN> ] : <NEWLINE> <TAB> <BoN> deriv <EoN> . <BoN> append <EoN> ( <BoN> K <EoN> ( <BoN> n <EoN> ) * <BoN> coeff <EoN> ) <NEWLINE> <BoN> n <EoN> -= <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> coeff <EoN> <BoN> in <EoN> <BoN> f <EoN> [ : - <BoN> m <EoN> ] : <NEWLINE> <TAB> <BoN> k <EoN> = <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> - <NUMBER> , <BoN> n <EoN> - <BoN> m <EoN> , - <NUMBER> ) : <NEWLINE> <TAB> <BoN> k <EoN> *= <BoN> i <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> deriv <EoN> . <BoN> append <EoN> ( <BoN> K <EoN> ( <BoN> k <EoN> ) * <BoN> coeff <EoN> ) <NEWLINE> <BoN> n <EoN> -= <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> dup strip <EoN> ( <BoN> deriv <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> array wrap <EoN> ( <BoN> self <EoN> , <BoN> result <EoN> , <BoN> context <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> context <EoN> , <BoN> tuple <EoN> ) <BoN> and <EoN> <BoN> len <EoN> ( <BoN> context <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> ufunc <EoN> , <BoN> args <EoN> , <BoN> domain <EoN> = <BoN> context <EoN> <NEWLINE> <BoN> args <EoN> = [ <BoN> getattr <EoN> ( <BoN> a <EoN> , <STRING> , <BoN> a <EoN> ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> all <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> ufunc <EoN> ( <BoN> self <EoN> . <BoN> fill value <EoN> , * <BoN> args <EoN> [ <NUMBER> : ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> self <EoN> . <BoN> fill value <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> result <EoN> , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> index <EoN> , <NEWLINE> <BoN> sparse index <EoN> = <BoN> self <EoN> . <BoN> sp index <EoN> , <NEWLINE> <BoN> fill value <EoN> = <BoN> fill value <EoN> , <NEWLINE> <BoN> copy <EoN> = <BoN> False <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reshape like <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> reshape like <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read float 64 <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> float 64 <EoN> ( <BoN> struct <EoN> . <BoN> unpack <EoN> ( <STRING> , <BoN> f <EoN> . <BoN> read <EoN> ( <NUMBER> ) ) [ <NUMBER> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tmin <EoN> ( <BoN> a <EoN> , <BoN> lowerlimit <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> inclusive <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> chk asarray <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> am <EoN> = <BoN> trima <EoN> ( <BoN> a <EoN> , ( <BoN> lowerlimit <EoN> , <BoN> None <EoN> ) , ( <BoN> inclusive <EoN> , <BoN> False <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> ma <EoN> . <BoN> minimum <EoN> . <BoN> reduce <EoN> ( <BoN> am <EoN> , <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> ge <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Symbol <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> internal <EoN> . <BoN> greater equal <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> numeric types <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> internal <EoN> . <BoN> greater equal scalar <EoN> ( <BoN> self <EoN> , <BoN> scalar <EoN> = <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> str <EoN> ( <BoN> type <EoN> ( <BoN> other <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> translate <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> rv <EoN> = <BoN> eye <EoN> ( <NUMBER> ) <NEWLINE> <BoN> rv <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> x <EoN> <NEWLINE> <BoN> rv <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> y <EoN> <NEWLINE> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> truediv <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> check binop other <EoN> ( <BoN> other <EoN> ) <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> State Space <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Not Implemented <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <BoN> and <EoN> <BoN> other <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> mul <EoN> ( <NUMBER> / <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> append <EoN> ( <BoN> self <EoN> , <BoN> parameter <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> register parameter <EoN> ( <BoN> str <EoN> ( <BoN> len <EoN> ( <BoN> self <EoN> ) ) , <BoN> parameter <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Pooling v 1 <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> kernel <EoN> = <BoN> Null <EoN> , <BoN> pool type <EoN> = <BoN> Null <EoN> , <BoN> global pool <EoN> = <BoN> Null <EoN> , <BoN> pooling convention <EoN> = <BoN> Null <EoN> , <BoN> stride <EoN> = <BoN> Null <EoN> , <BoN> pad <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> resolve <EoN> ( <BoN> self <EoN> , <BoN> strict <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> raise closed <EoN> ( ) <NEWLINE> <UNTAB> <BoN> s <EoN> = <BoN> self <EoN> . <BoN> flavour <EoN> . <BoN> resolve <EoN> ( <BoN> self <EoN> , <BoN> strict <EoN> = <BoN> strict <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> stat <EoN> ( ) <NEWLINE> <BoN> s <EoN> = <BoN> str <EoN> ( <BoN> self <EoN> . <BoN> absolute <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> normed <EoN> = <BoN> self <EoN> . <BoN> flavour <EoN> . <BoN> pathmod <EoN> . <BoN> normpath <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> obj <EoN> = <BoN> self <EoN> . <BoN> from parts <EoN> ( ( <BoN> normed <EoN> , ) , <BoN> init <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> obj <EoN> . <BoN> init <EoN> ( <BoN> template <EoN> = <BoN> self <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> obj <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> average name <EoN> ( <BoN> self <EoN> , <BoN> var <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> averages <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> averages <EoN> [ <BoN> var <EoN> ] . <BoN> op <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ops <EoN> . <BoN> get default graph <EoN> ( ) . <BoN> unique name <EoN> ( <NEWLINE> <BoN> var <EoN> . <BoN> op <EoN> . <BoN> name <EoN> + <STRING> + <BoN> self <EoN> . <BoN> name <EoN> , <BoN> mark as used <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create random state <EoN> ( <BoN> random state <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> random state <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> random state <EoN> <BoN> is <EoN> <BoN> np <EoN> . <BoN> random <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> random <EoN> . <BoN> mtrand <EoN> . <BoN> rand <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> random state <EoN> , <BoN> np <EoN> . <BoN> random <EoN> . <BoN> Random State <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> random state <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> random state <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> random <EoN> . <BoN> Random State <EoN> ( <BoN> random state <EoN> ) <NEWLINE> <UNTAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> % <BoN> random state <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> format schema <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> quote <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> quote <EoN> ( <BoN> name <EoN> , <BoN> quote <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gammaln <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> remote fused graph execute <EoN> ( <BoN> inputs <EoN> , <NEWLINE> <BoN> output types <EoN> , <NEWLINE> <BoN> graph def <EoN> , <NEWLINE> <BoN> graph input node names <EoN> , <NEWLINE> <BoN> graph output node names <EoN> , <NEWLINE> <BoN> executor name <EoN> , <NEWLINE> <BoN> serialized executor parameters <EoN> , <NEWLINE> <BoN> default graph input tensor type shapes <EoN> = <BoN> None <EoN> , <NEWLINE> <BoN> default graph output tensor type shapes <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> info proto <EoN> = <BoN> info pb 2 <EoN> . <BoN> Remote Fused Graph Execute Info <EoN> ( ) <NEWLINE> <BoN> info proto <EoN> . <BoN> remote graph <EoN> . <BoN> Copy From <EoN> ( <BoN> graph def <EoN> ) <NEWLINE> <BoN> info proto <EoN> . <BoN> graph input node name <EoN> . <BoN> extend <EoN> ( <BoN> graph input node names <EoN> ) <NEWLINE> <BoN> info proto <EoN> . <BoN> graph output node name <EoN> . <BoN> extend <EoN> ( <BoN> graph output node names <EoN> ) <NEWLINE> <BoN> info proto <EoN> . <BoN> executor name <EoN> = <BoN> executor name <EoN> <NEWLINE> <BoN> info proto <EoN> . <BoN> serialized executor parameters <EoN> = <BoN> serialized executor parameters <EoN> <NEWLINE> <BoN> if <EoN> <BoN> default graph input tensor type shapes <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> type shape <EoN> <BoN> in <EoN> <BoN> default graph input tensor type shapes <EoN> : <NEWLINE> <TAB> <BoN> type shape proto <EoN> = <BoN> info proto <EoN> . <BoN> default graph input tensor shape <EoN> . <BoN> add <EoN> ( ) <NEWLINE> <BoN> type shape proto <EoN> . <BoN> dtype <EoN> = <BoN> int <EoN> ( <BoN> dtypes <EoN> . <BoN> as dtype <EoN> ( <BoN> type shape <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> for <EoN> <BoN> dim <EoN> <BoN> in <EoN> <BoN> type shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> type shape proto <EoN> . <BoN> shape <EoN> . <BoN> dim <EoN> . <BoN> add <EoN> ( ) . <BoN> size <EoN> = <BoN> dim <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> default graph output tensor type shapes <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> type shape <EoN> <BoN> in <EoN> <BoN> default graph output tensor type shapes <EoN> : <NEWLINE> <TAB> <BoN> type shape proto <EoN> = <BoN> info proto <EoN> . <BoN> default graph output tensor shape <EoN> . <BoN> add <EoN> ( ) <NEWLINE> <BoN> type shape proto <EoN> . <BoN> dtype <EoN> = <BoN> int <EoN> ( <BoN> dtypes <EoN> . <BoN> as dtype <EoN> ( <BoN> type shape <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> for <EoN> <BoN> dim <EoN> <BoN> in <EoN> <BoN> type shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> type shape proto <EoN> . <BoN> shape <EoN> . <BoN> dim <EoN> . <BoN> add <EoN> ( ) . <BoN> size <EoN> = <BoN> dim <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> serialized info <EoN> = <BoN> info proto <EoN> . <BoN> Serialize To String <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> gen remote fused graph ops <EoN> . <BoN> remote fused graph execute <EoN> ( <NEWLINE> <BoN> inputs <EoN> , <BoN> output types <EoN> , <BoN> serialized info <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> kill <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> . <BoN> remove internal <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> g <EoN> . <BoN> clear <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> initial seed <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> default generator <EoN> . <BoN> initial seed <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> degrees <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> samples <EoN> ( <BoN> sound <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> numpysnd <EoN> . <BoN> samples <EoN> ( <BoN> sound <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> canberra distance <EoN> ( <BoN> self <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> s <EoN> , <BoN> p <EoN> = <BoN> Point <EoN> . <BoN> normalize dimension <EoN> ( <BoN> self <EoN> , <BoN> Point <EoN> ( <BoN> p <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is zero <EoN> <BoN> and <EoN> <BoN> p <EoN> . <BoN> is zero <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Add <EoN> ( * ( ( <BoN> abs <EoN> ( <BoN> a <EoN> - <BoN> b <EoN> ) / ( <BoN> abs <EoN> ( <BoN> a <EoN> ) + <BoN> abs <EoN> ( <BoN> b <EoN> ) ) ) <BoN> for <EoN> <BoN> a <EoN> , <BoN> b <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> s <EoN> , <BoN> p <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> issparse <EoN> ( <BoN> X <EoN> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> metric <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> X <EoN> = <BoN> check array <EoN> ( <BoN> X <EoN> , <BoN> accept sparse <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> neigh dist <EoN> , <BoN> neigh ind <EoN> = <BoN> self <EoN> . <BoN> kneighbors <EoN> ( <BoN> X <EoN> ) <NEWLINE> <NEWLINE> <BoN> weights <EoN> = <BoN> get weights <EoN> ( <BoN> neigh dist <EoN> , <BoN> self <EoN> . <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <BoN> y <EoN> = <BoN> self <EoN> . <BoN> y <EoN> <NEWLINE> <BoN> if <EoN> <BoN> y <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> y <EoN> . <BoN> reshape <EoN> ( ( - <NUMBER> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> weights <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> y pred <EoN> = <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> y <EoN> [ <BoN> neigh ind <EoN> ] , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> y pred <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> denom <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> weights <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> num <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> y <EoN> [ <BoN> neigh ind <EoN> , <BoN> j <EoN> ] * <BoN> weights <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> y pred <EoN> [ : , <BoN> j <EoN> ] = <BoN> num <EoN> / <BoN> denom <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> y <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> y pred <EoN> = <BoN> y pred <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> y pred <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assert valid refcount <EoN> ( <BoN> op <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> HAS REFCOUNT <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <NEWLINE> <BoN> b <EoN> = <BoN> np <EoN> . <BoN> arange <EoN> ( <NUMBER> * <NUMBER> ) . <BoN> reshape <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> c <EoN> = <BoN> b <EoN> <NEWLINE> <BoN> i <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> rc <EoN> = <BoN> sys <EoN> . <BoN> getrefcount <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> ) : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> op <EoN> ( <BoN> b <EoN> , <BoN> c <EoN> ) <NEWLINE> <UNTAB> <BoN> assert <EoN> ( <BoN> sys <EoN> . <BoN> getrefcount <EoN> ( <BoN> i <EoN> ) >= <BoN> rc <EoN> ) <NEWLINE> <BoN> del <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> contextlib <EoN> . <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> name scope <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> values <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> self <EoN> . <BoN> name <EoN> ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <NEWLINE> <BoN> name <EoN> , <BoN> values <EoN> = ( <BoN> values <EoN> <BoN> or <EoN> [ ] ) + <BoN> self <EoN> . <BoN> graph parents <EoN> ) <BoN> as <EoN> <BoN> scope <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> scope <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shape array <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> shape array <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sqrt <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> zero <EoN> = <BoN> to tensor <EoN> ( <NUMBER> , <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> inf <EoN> = <BoN> to tensor <EoN> ( <BoN> np <EoN> . <BoN> inf <EoN> , <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> clip ops <EoN> . <BoN> clip by value <EoN> ( <BoN> x <EoN> , <BoN> zero <EoN> , <BoN> inf <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> sqrt <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> iter <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> iter <EoN> ( <BoN> self <EoN> . <BoN> tolist <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> warn external <EoN> ( <BoN> message <EoN> , <BoN> category <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> frame <EoN> = <BoN> sys <EoN> . <BoN> getframe <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> stacklevel <EoN> <BoN> in <EoN> <BoN> itertools <EoN> . <BoN> count <EoN> ( <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> frame <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> re <EoN> . <BoN> match <EoN> ( <STRING> , <NEWLINE> <BoN> frame <EoN> . <BoN> f globals <EoN> [ <STRING> ] ) : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> frame <EoN> = <BoN> frame <EoN> . <BoN> f back <EoN> <NEWLINE> <UNTAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> message <EoN> , <BoN> category <EoN> , <BoN> stacklevel <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on detach <EoN> ( <BoN> self <EoN> , <BoN> fgraph <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> del <EoN> <BoN> fgraph <EoN> . <BoN> validate <EoN> <NEWLINE> <BoN> del <EoN> <BoN> fgraph <EoN> . <BoN> consistent <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> self group <EoN> ( <BoN> self <EoN> , <BoN> against <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> against <EoN> , <BoN> Compound Select <EoN> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> needs parens for grouping <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> From Grouping <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get row slice <EoN> ( <BoN> self <EoN> , <BoN> i <EoN> , <BoN> cslice <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> M <EoN> , <BoN> N <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> i <EoN> += <BoN> M <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> i <EoN> < <NUMBER> <BoN> or <EoN> <BoN> i <EoN> >= <BoN> M <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <STRING> % <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> stride <EoN> = <BoN> cslice <EoN> . <BoN> indices <EoN> ( <BoN> N <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stride <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> row indptr <EoN> , <BoN> row indices <EoN> , <BoN> row data <EoN> = <BoN> get csr submatrix <EoN> ( <NEWLINE> <BoN> M <EoN> , <BoN> N <EoN> , <BoN> self <EoN> . <BoN> indptr <EoN> , <BoN> self <EoN> . <BoN> indices <EoN> , <BoN> self <EoN> . <BoN> data <EoN> , <BoN> i <EoN> , <BoN> i <EoN> + <NUMBER> , <NEWLINE> <BoN> start <EoN> , <BoN> stop <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> row indices <EoN> = <BoN> self <EoN> . <BoN> indices <EoN> [ <BoN> self <EoN> . <BoN> indptr <EoN> [ <BoN> i <EoN> ] : <BoN> self <EoN> . <BoN> indptr <EoN> [ <BoN> i <EoN> + <NUMBER> ] ] <NEWLINE> <BoN> row data <EoN> = <BoN> self <EoN> . <BoN> data <EoN> [ <BoN> self <EoN> . <BoN> indptr <EoN> [ <BoN> i <EoN> ] : <BoN> self <EoN> . <BoN> indptr <EoN> [ <BoN> i <EoN> + <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stride <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> ind <EoN> = ( <BoN> row indices <EoN> >= <BoN> start <EoN> ) & ( <BoN> row indices <EoN> < <BoN> stop <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ind <EoN> = ( <BoN> row indices <EoN> <= <BoN> start <EoN> ) & ( <BoN> row indices <EoN> > <BoN> stop <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> stride <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> ind <EoN> &= ( <BoN> row indices <EoN> - <BoN> start <EoN> ) % <BoN> stride <EoN> == <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> row indices <EoN> = ( <BoN> row indices <EoN> [ <BoN> ind <EoN> ] - <BoN> start <EoN> ) // <BoN> stride <EoN> <NEWLINE> <BoN> row data <EoN> = <BoN> row data <EoN> [ <BoN> ind <EoN> ] <NEWLINE> <BoN> row indptr <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <NUMBER> , <BoN> len <EoN> ( <BoN> row indices <EoN> ) ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stride <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> row data <EoN> = <BoN> row data <EoN> [ : : - <NUMBER> ] <NEWLINE> <BoN> row indices <EoN> = <BoN> abs <EoN> ( <BoN> row indices <EoN> [ : : - <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> shape <EoN> = ( <NUMBER> , <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> ceil <EoN> ( <BoN> float <EoN> ( <BoN> stop <EoN> - <BoN> start <EoN> ) / <BoN> stride <EoN> ) ) ) <NEWLINE> <BoN> return <EoN> <BoN> csr matrix <EoN> ( ( <BoN> row data <EoN> , <BoN> row indices <EoN> , <BoN> row indptr <EoN> ) , <BoN> shape <EoN> = <BoN> shape <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> binary method <EoN> ( <BoN> ufunc <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> func <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> disables array ufunc <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Not Implemented <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ufunc <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> func <EoN> . <BoN> name <EoN> = <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> func <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> threshold niblack <EoN> ( <BoN> image <EoN> , <BoN> window size <EoN> = <NUMBER> , <BoN> k <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> m <EoN> , <BoN> s <EoN> = <BoN> mean std <EoN> ( <BoN> image <EoN> , <BoN> window size <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> m <EoN> - <BoN> k <EoN> * <BoN> s <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> non slot devices <EoN> ( <BoN> self <EoN> , <BoN> var list <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set sample static shape <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> sample shape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> sample shape <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( <NEWLINE> <BoN> tensor util <EoN> . <BoN> constant value <EoN> ( <BoN> sample shape <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> ndims <EoN> = <BoN> x <EoN> . <BoN> get shape <EoN> ( ) . <BoN> ndims <EoN> <NEWLINE> <BoN> sample ndims <EoN> = <BoN> sample shape <EoN> . <BoN> ndims <EoN> <NEWLINE> <BoN> batch ndims <EoN> = <BoN> self <EoN> . <BoN> batch shape <EoN> . <BoN> ndims <EoN> <NEWLINE> <BoN> event ndims <EoN> = <BoN> self <EoN> . <BoN> event shape <EoN> . <BoN> ndims <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> ndims <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> sample ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> batch ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> ndims <EoN> = <BoN> sample ndims <EoN> + <BoN> batch ndims <EoN> + <BoN> event ndims <EoN> <NEWLINE> <BoN> x <EoN> . <BoN> set shape <EoN> ( [ <BoN> None <EoN> ] * <BoN> ndims <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> sample ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> sample shape <EoN> . <BoN> concatenate <EoN> ( [ <BoN> None <EoN> ] * ( <BoN> ndims <EoN> - <BoN> sample ndims <EoN> ) ) <NEWLINE> <BoN> x <EoN> . <BoN> set shape <EoN> ( <BoN> x <EoN> . <BoN> get shape <EoN> ( ) . <BoN> merge with <EoN> ( <BoN> shape <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( <NEWLINE> [ <BoN> None <EoN> ] * ( <BoN> ndims <EoN> - <BoN> event ndims <EoN> ) ) . <BoN> concatenate <EoN> ( <BoN> self <EoN> . <BoN> event shape <EoN> ) <NEWLINE> <BoN> x <EoN> . <BoN> set shape <EoN> ( <BoN> x <EoN> . <BoN> get shape <EoN> ( ) . <BoN> merge with <EoN> ( <BoN> shape <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> batch ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> sample ndims <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sample ndims <EoN> = <BoN> ndims <EoN> - <BoN> batch ndims <EoN> - <BoN> event ndims <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> sample ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> event ndims <EoN> = <BoN> ndims <EoN> - <BoN> batch ndims <EoN> - <BoN> sample ndims <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> sample ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( [ <BoN> None <EoN> ] * <BoN> sample ndims <EoN> ) . <BoN> concatenate <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> batch shape <EoN> ) . <BoN> concatenate <EoN> ( [ <BoN> None <EoN> ] * <BoN> event ndims <EoN> ) <NEWLINE> <BoN> x <EoN> . <BoN> set shape <EoN> ( <BoN> x <EoN> . <BoN> get shape <EoN> ( ) . <BoN> merge with <EoN> ( <BoN> shape <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get iterator <EoN> ( <BoN> self <EoN> , <BoN> data <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> data <EoN> , <BoN> ND Frame <EoN> ) : <NEWLINE> <TAB> <BoN> slicer <EoN> = <BoN> lambda <EoN> <BoN> start <EoN> , <BoN> edge <EoN> : <BoN> data <EoN> . <BoN> slice <EoN> ( <NEWLINE> <BoN> slice <EoN> ( <BoN> start <EoN> , <BoN> edge <EoN> ) , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> length <EoN> = <BoN> len <EoN> ( <BoN> data <EoN> . <BoN> axes <EoN> [ <BoN> axis <EoN> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> slicer <EoN> = <BoN> lambda <EoN> <BoN> start <EoN> , <BoN> edge <EoN> : <BoN> data <EoN> [ <BoN> slice <EoN> ( <BoN> start <EoN> , <BoN> edge <EoN> ) ] <NEWLINE> <BoN> length <EoN> = <BoN> len <EoN> ( <BoN> data <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> start <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> edge <EoN> , <BoN> label <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> bins <EoN> , <BoN> self <EoN> . <BoN> binlabels <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> Na T <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> label <EoN> , <BoN> slicer <EoN> ( <BoN> start <EoN> , <BoN> edge <EoN> ) <NEWLINE> <UNTAB> <BoN> start <EoN> = <BoN> edge <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> start <EoN> < <BoN> length <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> self <EoN> . <BoN> binlabels <EoN> [ - <NUMBER> ] , <BoN> slicer <EoN> ( <BoN> start <EoN> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> traverse <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> cloned traverse <EoN> ( <NEWLINE> <BoN> obj <EoN> , <BoN> self <EoN> . <BoN> traverse options <EoN> , <BoN> self <EoN> . <BoN> visitor dict <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tril <EoN> ( <BoN> m <EoN> , <BoN> k <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> m <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> m <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> tri <EoN> ( <BoN> m <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> m <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> k <EoN> = <BoN> k <EoN> , <BoN> dtype <EoN> = <BoN> m <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> ) * <BoN> m <EoN> <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform <EoN> ( <BoN> self <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check is fitted <EoN> ( <BoN> self <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <BoN> class to index <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> classes <EoN> , <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> classes <EoN> ) ) ) ) <NEWLINE> <BoN> yt <EoN> = <BoN> self <EoN> . <BoN> transform <EoN> ( <BoN> y <EoN> , <BoN> class to index <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> sparse output <EoN> : <NEWLINE> <TAB> <BoN> yt <EoN> = <BoN> yt <EoN> . <BoN> toarray <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> yt <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from numpy matrix <EoN> ( <BoN> A <EoN> , <BoN> parallel edges <EoN> = <BoN> False <EoN> , <BoN> create using <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <BoN> kind to python type <EoN> = { <STRING> : <BoN> float <EoN> , <NEWLINE> <STRING> : <BoN> int <EoN> , <NEWLINE> <STRING> : <BoN> int <EoN> , <NEWLINE> <STRING> : <BoN> bool <EoN> , <NEWLINE> <STRING> : <BoN> complex <EoN> , <NEWLINE> <STRING> : <BoN> str <EoN> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> blurb <EoN> = <BoN> chr <EoN> ( <NUMBER> ) <NEWLINE> <BoN> kind to python type <EoN> [ <STRING> ] = <BoN> str <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> kind to python type <EoN> [ <STRING> ] = <BoN> unicode <EoN> <NEWLINE> <UNTAB> <BoN> G <EoN> = <BoN> nx <EoN> . <BoN> empty graph <EoN> ( <NUMBER> , <BoN> create using <EoN> ) <NEWLINE> <BoN> n <EoN> , <BoN> m <EoN> = <BoN> A <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> != <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <STRING> , <NEWLINE> <STRING> % ( <BoN> A <EoN> . <BoN> shape <EoN> , ) ) <NEWLINE> <UNTAB> <BoN> dt <EoN> = <BoN> A <EoN> . <BoN> dtype <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> python type <EoN> = <BoN> kind to python type <EoN> [ <BoN> dt <EoN> . <BoN> kind <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> dt <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> G <EoN> . <BoN> add nodes from <EoN> ( <BoN> range <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> edges <EoN> = <BoN> map <EoN> ( <BoN> lambda <EoN> <BoN> e <EoN> : ( <BoN> int <EoN> ( <BoN> e <EoN> [ <NUMBER> ] ) , <BoN> int <EoN> ( <BoN> e <EoN> [ <NUMBER> ] ) ) , <NEWLINE> <BoN> zip <EoN> ( * ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> A <EoN> ) . <BoN> nonzero <EoN> ( ) ) ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> python type <EoN> <BoN> is <EoN> <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> fields <EoN> = <BoN> sorted <EoN> ( ( <BoN> offset <EoN> , <BoN> dtype <EoN> , <BoN> name <EoN> ) <BoN> for <EoN> <BoN> name <EoN> , ( <BoN> dtype <EoN> , <BoN> offset <EoN> ) <BoN> in <EoN> <NEWLINE> <BoN> A <EoN> . <BoN> dtype <EoN> . <BoN> fields <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <BoN> triples <EoN> = ( ( <BoN> u <EoN> , <BoN> v <EoN> , { <BoN> name <EoN> : <BoN> kind to python type <EoN> [ <BoN> dtype <EoN> . <BoN> kind <EoN> ] ( <BoN> val <EoN> ) <NEWLINE> <BoN> for <EoN> ( <BoN> <EoN> , <BoN> dtype <EoN> , <BoN> name <EoN> ) , <BoN> val <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> fields <EoN> , <BoN> A <EoN> [ <BoN> u <EoN> , <BoN> v <EoN> ] ) } ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> edges <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> python type <EoN> <BoN> is <EoN> <BoN> int <EoN> <BoN> and <EoN> <BoN> G <EoN> . <BoN> is multigraph <EoN> ( ) <BoN> and <EoN> <BoN> parallel edges <EoN> : <NEWLINE> <TAB> <BoN> chain <EoN> = <BoN> itertools <EoN> . <BoN> chain <EoN> . <BoN> from iterable <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> triples <EoN> = <BoN> chain <EoN> ( ( ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> dict <EoN> ( <BoN> weight <EoN> = <NUMBER> ) ) <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> A <EoN> [ <BoN> u <EoN> , <BoN> v <EoN> ] ) ) <NEWLINE> <BoN> for <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <BoN> in <EoN> <BoN> edges <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> triples <EoN> = ( ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> dict <EoN> ( <BoN> weight <EoN> = <BoN> python type <EoN> ( <BoN> A <EoN> [ <BoN> u <EoN> , <BoN> v <EoN> ] ) ) ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> edges <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> G <EoN> . <BoN> is multigraph <EoN> ( ) <BoN> and <EoN> <BoN> not <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) : <NEWLINE> <TAB> <BoN> triples <EoN> = ( ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> d <EoN> ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> triples <EoN> <BoN> if <EoN> <BoN> u <EoN> <= <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> G <EoN> . <BoN> add edges from <EoN> ( <BoN> triples <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> control dependencies <EoN> ( <BoN> self <EoN> , <BoN> control inputs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> control inputs <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> ControlDependenciesController <EoN> ( <BoN> self <EoN> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> control ops <EoN> = [ ] <NEWLINE> <BoN> current <EoN> = <BoN> self <EoN> . <BoN> current control dependencies <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> control inputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> c <EoN> , <BoN> Indexed Slices <EoN> ) : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> c <EoN> . <BoN> op <EoN> <NEWLINE> <UNTAB> <BoN> c <EoN> = <BoN> self <EoN> . <BoN> as graph element <EoN> ( <BoN> c <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> c <EoN> , <BoN> Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> c <EoN> . <BoN> op <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> c <EoN> , <BoN> Operation <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> c <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> c <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> current <EoN> : <NEWLINE> <TAB> <BoN> control ops <EoN> . <BoN> append <EoN> ( <BoN> c <EoN> ) <NEWLINE> <BoN> current <EoN> . <BoN> add <EoN> ( <BoN> c <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> ControlDependenciesController <EoN> ( <BoN> self <EoN> , <BoN> control ops <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get custom preamble <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> . <BoN> join <EoN> ( <BoN> rc Params <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rs nth root <EoN> ( <BoN> p <EoN> , <BoN> n <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p 0 <EoN> = <BoN> p <EoN> <NEWLINE> <BoN> n 0 <EoN> = <BoN> n <EoN> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> p <EoN> . <BoN> ring <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rs trunc <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> R <EoN> = <BoN> p <EoN> . <BoN> ring <EoN> <NEWLINE> <BoN> zm <EoN> = <BoN> R <EoN> . <BoN> zero monom <EoN> <NEWLINE> <BoN> index <EoN> = <BoN> R <EoN> . <BoN> gens <EoN> . <BoN> index <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> m <EoN> = <BoN> min <EoN> ( <BoN> p <EoN> , <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> k <EoN> : <BoN> k <EoN> [ <BoN> index <EoN> ] ) [ <BoN> index <EoN> ] <NEWLINE> <BoN> p <EoN> = <BoN> mul xin <EoN> ( <BoN> p <EoN> , <BoN> index <EoN> , - <BoN> m <EoN> ) <NEWLINE> <BoN> prec <EoN> -= <BoN> m <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> has constant term <EoN> ( <BoN> p <EoN> - <NUMBER> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> zm <EoN> = <BoN> R <EoN> . <BoN> zero monom <EoN> <NEWLINE> <BoN> c <EoN> = <BoN> p <EoN> [ <BoN> zm <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> R <EoN> . <BoN> domain <EoN> <BoN> is <EoN> <BoN> E X <EoN> : <NEWLINE> <TAB> <BoN> c expr <EoN> = <BoN> c <EoN> . <BoN> as expr <EoN> ( ) <NEWLINE> <BoN> const <EoN> = <BoN> c expr <EoN> ** <BoN> Q Q <EoN> ( <NUMBER> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> c <EoN> , <BoN> Poly Element <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> c expr <EoN> = <BoN> c <EoN> . <BoN> as expr <EoN> ( ) <NEWLINE> <BoN> const <EoN> = <BoN> R <EoN> ( <BoN> c expr <EoN> ** ( <BoN> Q Q <EoN> ( <NUMBER> , <BoN> n <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Domain Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> const <EoN> = <BoN> R <EoN> ( <BoN> c <EoN> ** <BoN> Rational <EoN> ( <NUMBER> , <BoN> n <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Domain Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> res <EoN> = <BoN> rs nth root <EoN> ( <BoN> p <EoN> / <BoN> c <EoN> , <BoN> n <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) * <BoN> const <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> nth root 1 <EoN> ( <BoN> p <EoN> , <BoN> n <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> Q Q <EoN> ( <BoN> m <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> res <EoN> = <BoN> mul xin <EoN> ( <BoN> res <EoN> , <BoN> index <EoN> , <BoN> m <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sparse softmax <EoN> ( <BoN> sp input <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , <NEWLINE> [ <BoN> sp input <EoN> . <BoN> indices <EoN> , <BoN> sp input <EoN> . <BoN> values <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> out vals <EoN> = <BoN> gen sparse ops <EoN> . <BoN> sparse softmax <EoN> ( <BoN> sp input <EoN> . <BoN> indices <EoN> , <BoN> sp input <EoN> . <BoN> values <EoN> , <NEWLINE> <BoN> sp input <EoN> . <BoN> dense shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> sparse tensor <EoN> . <BoN> Sparse Tensor <EoN> ( <BoN> sp input <EoN> . <BoN> indices <EoN> , <BoN> out vals <EoN> , <NEWLINE> <BoN> sp input <EoN> . <BoN> dense shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> skewtest <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> chk asarray <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> a <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> b 2 <EoN> = <BoN> skew <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> a <EoN> . <BoN> count <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> min <EoN> ( <BoN> n <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> np <EoN> . <BoN> min <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> b 2 <EoN> * <BoN> ma <EoN> . <BoN> sqrt <EoN> ( ( ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) ) / ( <NUMBER> * ( <BoN> n <EoN> - <NUMBER> ) ) ) <NEWLINE> <BoN> beta 2 <EoN> = ( <NUMBER> * ( <BoN> n <EoN> * <BoN> n <EoN> + <NUMBER> * <BoN> n <EoN> - <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) ) / ( ( <BoN> n <EoN> - <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) ) <NEWLINE> <BoN> W 2 <EoN> = - <NUMBER> + <BoN> ma <EoN> . <BoN> sqrt <EoN> ( <NUMBER> * ( <BoN> beta 2 <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> delta <EoN> = <NUMBER> / <BoN> ma <EoN> . <BoN> sqrt <EoN> ( <NUMBER> * <BoN> ma <EoN> . <BoN> log <EoN> ( <BoN> W 2 <EoN> ) ) <NEWLINE> <BoN> alpha <EoN> = <BoN> ma <EoN> . <BoN> sqrt <EoN> ( <NUMBER> / ( <BoN> W 2 <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> y <EoN> = <BoN> ma <EoN> . <BoN> where <EoN> ( <BoN> y <EoN> == <NUMBER> , <NUMBER> , <BoN> y <EoN> ) <NEWLINE> <BoN> Z <EoN> = <BoN> delta <EoN> * <BoN> ma <EoN> . <BoN> log <EoN> ( <BoN> y <EoN> / <BoN> alpha <EoN> + <BoN> ma <EoN> . <BoN> sqrt <EoN> ( ( <BoN> y <EoN> / <BoN> alpha <EoN> ) ** <NUMBER> + <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Skewtest Result <EoN> ( <BoN> Z <EoN> , <NUMBER> * <BoN> distributions <EoN> . <BoN> norm <EoN> . <BoN> sf <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> Z <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> disjoint union <EoN> ( <BoN> G <EoN> , <BoN> H <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> R 1 <EoN> = <BoN> nx <EoN> . <BoN> convert node labels to integers <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> R 2 <EoN> = <BoN> nx <EoN> . <BoN> convert node labels to integers <EoN> ( <BoN> H <EoN> , <BoN> first label <EoN> = <BoN> len <EoN> ( <BoN> R 1 <EoN> ) ) <NEWLINE> <BoN> R <EoN> = <BoN> union <EoN> ( <BoN> R 1 <EoN> , <BoN> R 2 <EoN> ) <NEWLINE> <BoN> R <EoN> . <BoN> graph <EoN> . <BoN> update <EoN> ( <BoN> G <EoN> . <BoN> graph <EoN> ) <NEWLINE> <BoN> R <EoN> . <BoN> graph <EoN> . <BoN> update <EoN> ( <BoN> H <EoN> . <BoN> graph <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> R <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> validate fillna kwargs <EoN> ( <BoN> value <EoN> , <BoN> method <EoN> , <BoN> validate scalar dict value <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> missing <EoN> <BoN> import <EoN> <BoN> clean fill method <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> method <EoN> = <BoN> clean fill method <EoN> ( <BoN> method <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> validate scalar dict value <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> type <EoN> ( <BoN> value <EoN> ) . <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> value <EoN> , <BoN> method <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> convolution ntt <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> prime <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> p <EoN> = <BoN> a <EoN> [ : ] , <BoN> b <EoN> [ : ] , <BoN> as int <EoN> ( <BoN> prime <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> m <EoN> = <BoN> len <EoN> ( <BoN> a <EoN> ) + <BoN> len <EoN> ( <BoN> b <EoN> ) - <NUMBER> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> > <NUMBER> <BoN> and <EoN> <BoN> n <EoN> & ( <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <NUMBER> ** <BoN> n <EoN> . <BoN> bit length <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> += [ <NUMBER> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <BoN> b <EoN> += [ <NUMBER> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> ntt <EoN> ( <BoN> a <EoN> , <BoN> p <EoN> ) , <BoN> ntt <EoN> ( <BoN> b <EoN> , <BoN> p <EoN> ) <NEWLINE> <BoN> a <EoN> = [ <BoN> x <EoN> * <BoN> y <EoN> % <BoN> p <EoN> <BoN> for <EoN> <BoN> x <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) ] <NEWLINE> <BoN> a <EoN> = <BoN> intt <EoN> ( <BoN> a <EoN> , <BoN> p <EoN> ) [ : <BoN> m <EoN> ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> traverse <EoN> ( <BoN> out <EoN> , <BoN> x <EoN> , <BoN> x copy <EoN> , <BoN> d <EoN> , <BoN> visited <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> visited <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> visited <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> out <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> visited <EoN> . <BoN> add <EoN> ( <BoN> out <EoN> ) <NEWLINE> <BoN> from <EoN> <BoN> theano <EoN> . <BoN> gpuarray <EoN> . <BoN> basic ops <EoN> <BoN> import <EoN> <BoN> Gpu From Host <EoN> , <BoN> host from gpu <EoN> <NEWLINE> <BoN> from <EoN> <BoN> theano <EoN> . <BoN> gpuarray <EoN> <BoN> import <EoN> <BoN> pygpu activated <EoN> <NEWLINE> <BoN> from <EoN> <BoN> theano <EoN> . <BoN> gpuarray <EoN> . <BoN> type <EoN> <BoN> import <EoN> <BoN> Gpu Array Type <EoN> <NEWLINE> <BoN> if <EoN> <BoN> out <EoN> == <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> isinstance <EoN> ( <BoN> x <EoN> . <BoN> type <EoN> , <BoN> Gpu Array Type <EoN> ) <NEWLINE> <BoN> d <EoN> [ <BoN> out <EoN> ] = <BoN> Gpu From Host <EoN> ( <BoN> x <EoN> . <BoN> type <EoN> . <BoN> context name <EoN> ) ( <BoN> x copy <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> out <EoN> . <BoN> owner <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> pygpu activated <EoN> <BoN> and <EoN> <NEWLINE> <BoN> out <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> host from gpu <EoN> <BoN> and <EoN> <NEWLINE> <BoN> out <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> == [ <BoN> x <EoN> ] ) : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> out <EoN> ] = <BoN> tensor <EoN> . <BoN> as tensor variable <EoN> ( <BoN> x copy <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> inp <EoN> <BoN> in <EoN> <BoN> out <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> traverse <EoN> ( <BoN> inp <EoN> , <BoN> x <EoN> , <BoN> x copy <EoN> , <BoN> d <EoN> , <BoN> visited <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get temp view names <EoN> ( <BoN> self <EoN> , <BoN> connection <EoN> , <BoN> schema <EoN> = <BoN> None <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> cross <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cross eager fallback <EoN> ( <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> cross <EoN> , <BoN> a <EoN> = <BoN> a <EoN> , <BoN> b <EoN> = <BoN> b <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> a <EoN> = <BoN> a <EoN> , <BoN> b <EoN> = <BoN> b <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> cross <EoN> , <BoN> a <EoN> = <BoN> a <EoN> , <BoN> b <EoN> = <BoN> b <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> adjust lighting <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> alpha <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> binopt <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> op <EoN> , <BoN> in shape <EoN> = <BoN> None <EoN> , <BoN> out shape <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> other <EoN> = <BoN> self <EoN> . <BoN> class <EoN> ( <BoN> other <EoN> , <BoN> blocksize <EoN> = <BoN> self <EoN> . <BoN> blocksize <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> fn <EoN> = <BoN> getattr <EoN> ( <BoN> sparsetools <EoN> , <BoN> self <EoN> . <BoN> format <EoN> + <BoN> op <EoN> + <BoN> self <EoN> . <BoN> format <EoN> ) <NEWLINE> <NEWLINE> <BoN> R <EoN> , <BoN> C <EoN> = <BoN> self <EoN> . <BoN> blocksize <EoN> <NEWLINE> <NEWLINE> <BoN> max bnnz <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> data <EoN> ) + <BoN> len <EoN> ( <BoN> other <EoN> . <BoN> data <EoN> ) <NEWLINE> <BoN> idx dtype <EoN> = <BoN> get index dtype <EoN> ( ( <BoN> self <EoN> . <BoN> indptr <EoN> , <BoN> self <EoN> . <BoN> indices <EoN> , <NEWLINE> <BoN> other <EoN> . <BoN> indptr <EoN> , <BoN> other <EoN> . <BoN> indices <EoN> ) , <NEWLINE> <BoN> maxval <EoN> = <BoN> max bnnz <EoN> ) <NEWLINE> <BoN> indptr <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> self <EoN> . <BoN> indptr <EoN> . <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> idx dtype <EoN> ) <NEWLINE> <BoN> indices <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> max bnnz <EoN> , <BoN> dtype <EoN> = <BoN> idx dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> bool ops <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> op <EoN> <BoN> in <EoN> <BoN> bool ops <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> R <EoN> * <BoN> C <EoN> * <BoN> max bnnz <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> bool <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> R <EoN> * <BoN> C <EoN> * <BoN> max bnnz <EoN> , <BoN> dtype <EoN> = <BoN> upcast <EoN> ( <BoN> self <EoN> . <BoN> dtype <EoN> , <BoN> other <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> fn <EoN> ( <BoN> self <EoN> . <BoN> shape <EoN> [ <NUMBER> ] // <BoN> R <EoN> , <BoN> self <EoN> . <BoN> shape <EoN> [ <NUMBER> ] // <BoN> C <EoN> , <BoN> R <EoN> , <BoN> C <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> indptr <EoN> . <BoN> astype <EoN> ( <BoN> idx dtype <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> indices <EoN> . <BoN> astype <EoN> ( <BoN> idx dtype <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> data <EoN> , <NEWLINE> <BoN> other <EoN> . <BoN> indptr <EoN> . <BoN> astype <EoN> ( <BoN> idx dtype <EoN> ) , <NEWLINE> <BoN> other <EoN> . <BoN> indices <EoN> . <BoN> astype <EoN> ( <BoN> idx dtype <EoN> ) , <NEWLINE> <BoN> np <EoN> . <BoN> ravel <EoN> ( <BoN> other <EoN> . <BoN> data <EoN> ) , <NEWLINE> <BoN> indptr <EoN> , <NEWLINE> <BoN> indices <EoN> , <NEWLINE> <BoN> data <EoN> ) <NEWLINE> <NEWLINE> <BoN> actual bnnz <EoN> = <BoN> indptr <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> indices <EoN> = <BoN> indices <EoN> [ : <BoN> actual bnnz <EoN> ] <NEWLINE> <BoN> data <EoN> = <BoN> data <EoN> [ : <BoN> R <EoN> * <BoN> C <EoN> * <BoN> actual bnnz <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> actual bnnz <EoN> < <BoN> max bnnz <EoN> / <NUMBER> : <NEWLINE> <TAB> <BoN> indices <EoN> = <BoN> indices <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> data <EoN> = <BoN> data <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> data <EoN> = <BoN> data <EoN> . <BoN> reshape <EoN> ( - <NUMBER> , <BoN> R <EoN> , <BoN> C <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> class <EoN> ( ( <BoN> data <EoN> , <BoN> indices <EoN> , <BoN> indptr <EoN> ) , <BoN> shape <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> arccos <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> arccos <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> unary method <EoN> ( <BoN> ufunc <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> func <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ufunc <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> func <EoN> . <BoN> name <EoN> = <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> func <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ttf Font Property <EoN> ( <BoN> font <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> name <EoN> = <BoN> font <EoN> . <BoN> family name <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sfnt <EoN> = <BoN> font <EoN> . <BoN> get sfnt <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sfnt 2 <EoN> = <BoN> sfnt <EoN> . <BoN> get <EoN> ( ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) , <STRING> ) . <BoN> decode <EoN> ( <STRING> ) . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> sfnt 4 <EoN> = <BoN> sfnt <EoN> . <BoN> get <EoN> ( ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) , <STRING> ) . <BoN> decode <EoN> ( <STRING> ) . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> : <NEWLINE> <TAB> <BoN> style <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> : <NEWLINE> <TAB> <BoN> style <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> sfnt 2 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> : <NEWLINE> <TAB> <BoN> style <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> font <EoN> . <BoN> style flags <EoN> & <BoN> ft 2 font <EoN> . <BoN> ITALI C <EoN> : <NEWLINE> <TAB> <BoN> style <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> style <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> name <EoN> . <BoN> lower <EoN> ( ) <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> variant <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> variant <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> weight <EoN> = <BoN> next <EoN> ( ( <BoN> w <EoN> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> weight dict <EoN> <BoN> if <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <BoN> w <EoN> ) >= <NUMBER> ) , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> weight <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> font <EoN> . <BoN> style flags <EoN> & <BoN> ft 2 font <EoN> . <BoN> BOL D <EoN> : <NEWLINE> <TAB> <BoN> weight <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> weight <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> ( <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> <BoN> or <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> <BoN> or <EoN> <NEWLINE> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> ) : <NEWLINE> <TAB> <BoN> stretch <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> : <NEWLINE> <TAB> <BoN> stretch <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> <BoN> or <EoN> <BoN> sfnt 4 <EoN> . <BoN> find <EoN> ( <STRING> ) >= <NUMBER> : <NEWLINE> <TAB> <BoN> stretch <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> stretch <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> font <EoN> . <BoN> scalable <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> size <EoN> = <STRING> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Font Entry <EoN> ( <BoN> font <EoN> . <BoN> fname <EoN> , <BoN> name <EoN> , <BoN> style <EoN> , <BoN> variant <EoN> , <BoN> weight <EoN> , <BoN> stretch <EoN> , <BoN> size <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform sgv <EoN> ( <BoN> self <EoN> , <BoN> info <EoN> , <BoN> sgv <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ops <EoN> = [ <BoN> op <EoN> <BoN> for <EoN> <BoN> <EoN> , <BoN> op <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> info <EoN> . <BoN> transformed ops <EoN> ) ] <NEWLINE> <BoN> sgv <EoN> = <BoN> subgraph <EoN> . <BoN> Sub Graph View <EoN> ( <BoN> ops <EoN> ) <NEWLINE> <BoN> sgv inputs <EoN> = <BoN> sgv <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> sgv outputs <EoN> = <BoN> sgv <EoN> . <BoN> outputs <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> input map <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> input t <EoN> <BoN> in <EoN> <BoN> sgv <EoN> . <BoN> inputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> input t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> info <EoN> . <BoN> transformed ts <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> input t <EoN> = <BoN> info <EoN> . <BoN> transformed ts <EoN> [ <BoN> input t <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> input t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> sgv inputs <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> input t index <EoN> = <BoN> sgv <EoN> . <BoN> input index <EoN> ( <BoN> input t <EoN> ) <NEWLINE> <BoN> input map <EoN> . <BoN> append <EoN> ( <BoN> input t index <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> output map <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> output t <EoN> <BoN> in <EoN> <BoN> sgv <EoN> . <BoN> outputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> output t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> info <EoN> . <BoN> transformed ts <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> output t <EoN> = <BoN> info <EoN> . <BoN> transformed ts <EoN> [ <BoN> output t <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> output t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> sgv outputs <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> output t index <EoN> = <BoN> sgv <EoN> . <BoN> output index <EoN> ( <BoN> output t <EoN> ) <NEWLINE> <BoN> output map <EoN> . <BoN> append <EoN> ( <BoN> output t index <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sgv <EoN> . <BoN> remap <EoN> ( <BoN> input map <EoN> , <BoN> output map <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> synchronize <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check error <EoN> ( <BoN> cudart <EoN> ( ) . <BoN> cuda Event Synchronize <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> init default <EoN> ( <BoN> cls <EoN> , <BoN> dialect <EoN> , <BoN> connection <EoN> , <BoN> dbapi connection <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> = <BoN> cls <EoN> . <BoN> new <EoN> ( <BoN> cls <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> root connection <EoN> = <BoN> connection <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dbapi connection <EoN> = <BoN> dbapi connection <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dialect <EoN> = <BoN> connection <EoN> . <BoN> dialect <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> execution options <EoN> = <BoN> connection <EoN> . <BoN> execution options <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> cursor <EoN> = <BoN> self <EoN> . <BoN> create cursor <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get name value <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> name <EoN> , <BoN> value <EoN> = <BoN> self <EoN> . <BoN> get <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> name <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = [ <BoN> name <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> value <EoN> = [ <BoN> value <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> name <EoN> , <BoN> value <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> backward <EoN> ( <BoN> self <EoN> , <BoN> out grads <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> binded <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> params initialized <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> curr module <EoN> . <BoN> backward <EoN> ( <BoN> out grads <EoN> = <BoN> out grads <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> geterrcall <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> umath <EoN> . <BoN> geterrobj <EoN> ( ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> inverse permutation <EoN> ( <BoN> perm <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> permute row elements <EoN> ( <NEWLINE> <BoN> arange <EoN> ( <BoN> perm <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] , <BoN> dtype <EoN> = <BoN> perm <EoN> . <BoN> dtype <EoN> ) , <NEWLINE> <BoN> perm <EoN> , <NEWLINE> <BoN> inverse <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> anderson ksamp right <EoN> ( <BoN> samples <EoN> , <BoN> Z <EoN> , <BoN> Zstar <EoN> , <BoN> k <EoN> , <BoN> n <EoN> , <BoN> N <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> A 2 k N <EoN> = <NUMBER> <NEWLINE> <BoN> lj <EoN> = <BoN> Z <EoN> . <BoN> searchsorted <EoN> ( <BoN> Zstar <EoN> [ : - <NUMBER> ] , <STRING> ) - <BoN> Z <EoN> . <BoN> searchsorted <EoN> ( <BoN> Zstar <EoN> [ : - <NUMBER> ] , <NEWLINE> <STRING> ) <NEWLINE> <BoN> Bj <EoN> = <BoN> lj <EoN> . <BoN> cumsum <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <NUMBER> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> np <EoN> . <BoN> sort <EoN> ( <BoN> samples <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <BoN> Mij <EoN> = <BoN> s <EoN> . <BoN> searchsorted <EoN> ( <BoN> Zstar <EoN> [ : - <NUMBER> ] , <BoN> side <EoN> = <STRING> ) <NEWLINE> <BoN> inner <EoN> = <BoN> lj <EoN> / <BoN> float <EoN> ( <BoN> N <EoN> ) * ( <BoN> N <EoN> * <BoN> Mij <EoN> - <BoN> Bj <EoN> * <BoN> n <EoN> [ <BoN> i <EoN> ] ) ** <NUMBER> / ( <BoN> Bj <EoN> * ( <BoN> N <EoN> - <BoN> Bj <EoN> ) ) <NEWLINE> <BoN> A 2 k N <EoN> += <BoN> inner <EoN> . <BoN> sum <EoN> ( ) / <BoN> n <EoN> [ <BoN> i <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> A 2 k N <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lagint <EoN> ( <BoN> c <EoN> , <BoN> m <EoN> = <NUMBER> , <BoN> k <EoN> = [ ] , <BoN> lbnd <EoN> = <NUMBER> , <BoN> scl <EoN> = <NUMBER> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> c <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> c <EoN> , <BoN> ndmin <EoN> = <NUMBER> , <BoN> copy <EoN> = <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> <BoN> in <EoN> <STRING> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> c <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> double <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> iterable <EoN> ( <BoN> k <EoN> ) : <NEWLINE> <TAB> <BoN> k <EoN> = [ <BoN> k <EoN> ] <NEWLINE> <UNTAB> <BoN> cnt <EoN> , <BoN> iaxis <EoN> = [ <BoN> int <EoN> ( <BoN> t <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> [ <BoN> m <EoN> , <BoN> axis <EoN> ] ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> cnt <EoN> != <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> cnt <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> k <EoN> ) > <BoN> cnt <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> ndim <EoN> ( <BoN> lbnd <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> ndim <EoN> ( <BoN> scl <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> iaxis <EoN> != <BoN> axis <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> iaxis <EoN> = <BoN> normalize axis index <EoN> ( <BoN> iaxis <EoN> , <BoN> c <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> cnt <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> c <EoN> = <BoN> np <EoN> . <BoN> moveaxis <EoN> ( <BoN> c <EoN> , <BoN> iaxis <EoN> , <NUMBER> ) <NEWLINE> <BoN> k <EoN> = <BoN> list <EoN> ( <BoN> k <EoN> ) + [ <NUMBER> ] * ( <BoN> cnt <EoN> - <BoN> len <EoN> ( <BoN> k <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> cnt <EoN> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> c <EoN> ) <NEWLINE> <BoN> c <EoN> *= <BoN> scl <EoN> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> <BoN> and <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> c <EoN> [ <NUMBER> ] == <NUMBER> ) : <NEWLINE> <TAB> <BoN> c <EoN> [ <NUMBER> ] += <BoN> k <EoN> [ <BoN> i <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> tmp <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> n <EoN> + <NUMBER> , ) + <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> : ] , <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> tmp <EoN> [ <NUMBER> ] = <BoN> c <EoN> [ <NUMBER> ] <NEWLINE> <BoN> tmp <EoN> [ <NUMBER> ] = - <BoN> c <EoN> [ <NUMBER> ] <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> tmp <EoN> [ <BoN> j <EoN> ] += <BoN> c <EoN> [ <BoN> j <EoN> ] <NEWLINE> <BoN> tmp <EoN> [ <BoN> j <EoN> + <NUMBER> ] = - <BoN> c <EoN> [ <BoN> j <EoN> ] <NEWLINE> <UNTAB> <BoN> tmp <EoN> [ <NUMBER> ] += <BoN> k <EoN> [ <BoN> i <EoN> ] - <BoN> lagval <EoN> ( <BoN> lbnd <EoN> , <BoN> tmp <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> tmp <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> c <EoN> = <BoN> np <EoN> . <BoN> moveaxis <EoN> ( <BoN> c <EoN> , <NUMBER> , <BoN> iaxis <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> can pan <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> show <EoN> ( <BoN> self <EoN> , <BoN> file <EoN> = <BoN> sys <EoN> . <BoN> stdout <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> keys <EoN> = <BoN> sorted <EoN> ( <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> global <EoN> . <BoN> dict <EoN> ) | <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> local <EoN> . <BoN> dict <EoN> ) ) <NEWLINE> <BoN> print attrs <EoN> ( <BoN> self <EoN> , <BoN> keys <EoN> , <BoN> file <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> variables <EoN> ( <BoN> i <EoN> , <BoN> o <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> variables and orphans <EoN> ( <BoN> i <EoN> , <BoN> o <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> convert for op <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> has same tz <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> to m 8 <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> common type <EoN> ( * <BoN> arrays <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> is complex <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> precision <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> arrays <EoN> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> a <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> <NEWLINE> <BoN> if <EoN> <BoN> iscomplexobj <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <BoN> is complex <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> issubclass <EoN> ( <BoN> t <EoN> , <BoN> nx <EoN> . <BoN> integer <EoN> ) : <NEWLINE> <TAB> <BoN> p <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> = <BoN> array precision <EoN> . <BoN> get <EoN> ( <BoN> t <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> p <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> precision <EoN> = <BoN> max <EoN> ( <BoN> precision <EoN> , <BoN> p <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> is complex <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array type <EoN> [ <NUMBER> ] [ <BoN> precision <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array type <EoN> [ <NUMBER> ] [ <BoN> precision <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load <EoN> ( <BoN> file <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> file <EoN> , <BoN> type <EoN> ( <STRING> ) ) : <NEWLINE> <TAB> <BoN> file <EoN> = <BoN> open <EoN> ( <BoN> file <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> pickle <EoN> . <BoN> load <EoN> ( <BoN> file <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> icdf <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> value <EoN> = <BoN> self <EoN> . <BoN> monotonize cdf <EoN> ( <BoN> value <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> validate args <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> base dist <EoN> . <BoN> validate sample <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> value <EoN> = <BoN> self <EoN> . <BoN> base dist <EoN> . <BoN> icdf <EoN> ( <BoN> value <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> transform <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> transforms <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> transform <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> harmonic function <EoN> ( <BoN> G <EoN> , <BoN> max iter <EoN> = <NUMBER> , <BoN> label name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> scipy <EoN> <BoN> import <EoN> <BoN> sparse <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> build propagation matrix <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> degrees <EoN> = <BoN> X <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) . <BoN> A <EoN> [ <NUMBER> ] <NEWLINE> <BoN> degrees <EoN> [ <BoN> degrees <EoN> == <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> D <EoN> = <BoN> sparse <EoN> . <BoN> diags <EoN> ( ( <NUMBER> / <BoN> degrees <EoN> ) , <BoN> offsets <EoN> = <NUMBER> ) <NEWLINE> <BoN> P <EoN> = <BoN> D <EoN> . <BoN> dot <EoN> ( <BoN> X <EoN> ) . <BoN> tolil <EoN> ( ) <NEWLINE> <BoN> P <EoN> [ <BoN> labels <EoN> [ : , <NUMBER> ] ] = <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> P <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> build base matrix <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> , <BoN> n classes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n samples <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> B <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> n samples <EoN> , <BoN> n classes <EoN> ) ) <NEWLINE> <BoN> B <EoN> [ <BoN> labels <EoN> [ : , <NUMBER> ] , <BoN> labels <EoN> [ : , <NUMBER> ] ] = <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> B <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> X <EoN> = <BoN> nx <EoN> . <BoN> to scipy sparse matrix <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> labels <EoN> , <BoN> label dict <EoN> = <BoN> get label info <EoN> ( <BoN> G <EoN> , <BoN> label name <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> labels <EoN> . <BoN> shape <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <NEWLINE> <STRING> + <BoN> label name <EoN> + <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n samples <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> n classes <EoN> = <BoN> label dict <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> F <EoN> = <BoN> init label matrix <EoN> ( <BoN> n samples <EoN> , <BoN> n classes <EoN> ) <NEWLINE> <NEWLINE> <BoN> P <EoN> = <BoN> build propagation matrix <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> ) <NEWLINE> <BoN> B <EoN> = <BoN> build base matrix <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> , <BoN> n classes <EoN> ) <NEWLINE> <NEWLINE> <BoN> remaining iter <EoN> = <BoN> max iter <EoN> <NEWLINE> <BoN> while <EoN> <BoN> remaining iter <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> F <EoN> = <BoN> propagate <EoN> ( <BoN> P <EoN> , <BoN> F <EoN> , <BoN> B <EoN> ) <NEWLINE> <BoN> remaining iter <EoN> -= <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> predicted <EoN> = <BoN> predict <EoN> ( <BoN> F <EoN> , <BoN> label dict <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> predicted <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> bessel i 0 e <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> bessel i 0 e eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> bessel i 0 e <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> bessel i 0 e <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> mean <EoN> ( <BoN> self <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dim <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> = <BoN> self <EoN> . <BoN> process parameters <EoN> ( <BoN> df <EoN> , <BoN> scale <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> self <EoN> . <BoN> mean <EoN> ( <BoN> dim <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> squeeze output <EoN> ( <BoN> out <EoN> ) <BoN> if <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> min distance point <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> p <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> minkowski distance <EoN> ( <NUMBER> , <BoN> np <EoN> . <BoN> maximum <EoN> ( <NUMBER> , <BoN> np <EoN> . <BoN> maximum <EoN> ( <BoN> self <EoN> . <BoN> mins <EoN> - <BoN> x <EoN> , <BoN> x <EoN> - <BoN> self <EoN> . <BoN> maxes <EoN> ) ) , <BoN> p <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is any int dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> arr or dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> tipo <EoN> = <BoN> get dtype type <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , <BoN> np <EoN> . <BoN> integer <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> to offset <EoN> ( <BoN> freq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> freq <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> freq <EoN> , <BoN> Date Offset <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> freq <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> freq <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> freq <EoN> [ <NUMBER> ] <NEWLINE> <BoN> stride <EoN> = <BoN> freq <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> stride <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> , <BoN> stride <EoN> = <BoN> stride <EoN> , <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> name <EoN> , <BoN> <EoN> = <BoN> libfreqs <EoN> . <BoN> base and stride <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> delta <EoN> = <BoN> get offset <EoN> ( <BoN> name <EoN> ) * <BoN> stride <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> freq <EoN> , <BoN> timedelta <EoN> ) : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> freq <EoN> = <BoN> Timedelta <EoN> ( <BoN> freq <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> freq <EoN> . <BoN> components <EoN> . <BoN> fields <EoN> : <NEWLINE> <TAB> <BoN> offset <EoN> = <BoN> name to offset map <EoN> [ <BoN> name <EoN> ] <NEWLINE> <BoN> stride <EoN> = <BoN> getattr <EoN> ( <BoN> freq <EoN> . <BoN> components <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> stride <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> offset <EoN> = <BoN> stride <EoN> * <BoN> offset <EoN> <NEWLINE> <BoN> if <EoN> <BoN> delta <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> offset <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> delta <EoN> + <BoN> offset <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> libfreqs <EoN> . <BoN> INVALID FREQ ERROR <EoN> . <BoN> format <EoN> ( <BoN> freq <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> stride sign <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> splitted <EoN> = <BoN> re <EoN> . <BoN> split <EoN> ( <BoN> libfreqs <EoN> . <BoN> opattern <EoN> , <BoN> freq <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> splitted <EoN> [ - <NUMBER> ] != <STRING> <BoN> and <EoN> <BoN> not <EoN> <BoN> splitted <EoN> [ - <NUMBER> ] . <BoN> isspace <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> sep <EoN> , <BoN> stride <EoN> , <BoN> name <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> splitted <EoN> [ <NUMBER> : : <NUMBER> ] , <BoN> splitted <EoN> [ <NUMBER> : : <NUMBER> ] , <NEWLINE> <BoN> splitted <EoN> [ <NUMBER> : : <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> sep <EoN> != <STRING> <BoN> and <EoN> <BoN> not <EoN> <BoN> sep <EoN> . <BoN> isspace <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> prefix <EoN> = <BoN> libfreqs <EoN> . <BoN> lite rule alias <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> ) <BoN> or <EoN> <BoN> name <EoN> <NEWLINE> <BoN> if <EoN> <BoN> stride sign <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> stride sign <EoN> = - <NUMBER> <BoN> if <EoN> <BoN> stride <EoN> . <BoN> startswith <EoN> ( <STRING> ) <BoN> else <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> stride <EoN> : <NEWLINE> <TAB> <BoN> stride <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> prefix <EoN> <BoN> in <EoN> <BoN> Resolution <EoN> . <BoN> reso str bump map <EoN> . <BoN> keys <EoN> ( ) : <NEWLINE> <TAB> <BoN> stride <EoN> , <BoN> name <EoN> = <BoN> Resolution <EoN> . <BoN> get stride from decimal <EoN> ( <NEWLINE> <BoN> float <EoN> ( <BoN> stride <EoN> ) , <BoN> prefix <EoN> <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> stride <EoN> = <BoN> int <EoN> ( <BoN> stride <EoN> ) <NEWLINE> <BoN> offset <EoN> = <BoN> get offset <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> offset <EoN> = <BoN> offset <EoN> * <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> fabs <EoN> ( <BoN> stride <EoN> ) * <BoN> stride sign <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> delta <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> offset <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> delta <EoN> + <BoN> offset <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> libfreqs <EoN> . <BoN> INVALID FREQ ERROR <EoN> . <BoN> format <EoN> ( <BoN> freq <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> delta <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> libfreqs <EoN> . <BoN> INVALID FREQ ERROR <EoN> . <BoN> format <EoN> ( <BoN> freq <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> delta <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> iter test indices <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> = <BoN> None <EoN> , <BoN> y <EoN> = <BoN> None <EoN> , <BoN> groups <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> execute <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> select <EoN> ( ) . <BoN> execute <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> import <EoN> ( <BoN> self <EoN> , <BoN> apply node <EoN> , <BoN> check <EoN> = <BoN> True <EoN> , <BoN> reason <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> node <EoN> = <BoN> apply node <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new nodes <EoN> = <BoN> graph <EoN> . <BoN> io toposort <EoN> ( <BoN> self <EoN> . <BoN> variables <EoN> , <BoN> apply node <EoN> . <BoN> outputs <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> check <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> new nodes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> node <EoN> , <STRING> ) <BoN> and <EoN> <BoN> node <EoN> . <BoN> fgraph <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <STRING> % <BoN> node <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> r <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> inputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> r <EoN> , <STRING> ) <BoN> and <EoN> <BoN> r <EoN> . <BoN> fgraph <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <STRING> % <BoN> r <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> r <EoN> . <BoN> owner <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> r <EoN> , <BoN> graph <EoN> . <BoN> Constant <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> r <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inputs <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> error msg <EoN> = ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> node <EoN> . <BoN> inputs <EoN> . <BoN> index <EoN> ( <BoN> r <EoN> ) , <BoN> str <EoN> ( <BoN> node <EoN> ) ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Missing Input Error <EoN> ( <BoN> error msg <EoN> , <BoN> variable <EoN> = <BoN> r <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> new nodes <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> node <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> apply nodes <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> setup node <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> apply nodes <EoN> . <BoN> add <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> node <EoN> . <BoN> tag <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> node <EoN> . <BoN> tag <EoN> . <BoN> imported by <EoN> = [ ] <NEWLINE> <UNTAB> <BoN> node <EoN> . <BoN> tag <EoN> . <BoN> imported by <EoN> . <BoN> append <EoN> ( <BoN> str <EoN> ( <BoN> reason <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> output <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> outputs <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> setup r <EoN> ( <BoN> output <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> variables <EoN> . <BoN> add <EoN> ( <BoN> output <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> input <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> node <EoN> . <BoN> inputs <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> input <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> variables <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> setup r <EoN> ( <BoN> input <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> variables <EoN> . <BoN> add <EoN> ( <BoN> input <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> add client <EoN> ( <BoN> input <EoN> , ( <BoN> node <EoN> , <BoN> i <EoN> ) ) <NEWLINE> <UNTAB> <BoN> assert <EoN> <BoN> node <EoN> . <BoN> fgraph <EoN> <BoN> is <EoN> <BoN> self <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> execute callbacks <EoN> ( <STRING> , <BoN> node <EoN> , <BoN> reason <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> choose <EoN> ( <BoN> a <EoN> , <BoN> choices <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> mode <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> assert <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Choose <EoN> ( <BoN> mode <EoN> ) ( <BoN> a <EoN> , <BoN> choices <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> items <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> parameters <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> flush <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> mode <EoN> <BoN> in <EoN> <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> write <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> codes to ints <EoN> ( <BoN> self <EoN> , <BoN> codes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> codes <EoN> <<= <BoN> self <EoN> . <BoN> offsets <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> codes <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> bitwise or <EoN> . <BoN> reduce <EoN> ( <BoN> codes <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> bitwise or <EoN> . <BoN> reduce <EoN> ( <BoN> codes <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> clf <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y type <EoN> = <BoN> type of target <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> y pred <EoN> = <BoN> clf <EoN> . <BoN> predict proba <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> y type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> y pred <EoN> . <BoN> shape <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> y pred <EoN> = <BoN> y pred <EoN> [ : , <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> y pred <EoN> . <BoN> shape <EoN> , <BoN> self <EoN> . <BoN> score func <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> sign <EoN> * <BoN> self <EoN> . <BoN> score func <EoN> ( <BoN> y <EoN> , <BoN> y pred <EoN> , <NEWLINE> <BoN> sample weight <EoN> = <BoN> sample weight <EoN> , <NEWLINE> ** <BoN> self <EoN> . <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> sign <EoN> * <BoN> self <EoN> . <BoN> score func <EoN> ( <BoN> y <EoN> , <BoN> y pred <EoN> , ** <BoN> self <EoN> . <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get offset position <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> offset position <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> close <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> parent <EoN> . <BoN> is active <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> parent <EoN> <BoN> is <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> rollback <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read value <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict proba <EoN> ( <BoN> self <EoN> , <BoN> input fn <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> key <EoN> = <BoN> prediction key <EoN> . <BoN> Prediction Key <EoN> . <BoN> PROBABILITIE S <EoN> <NEWLINE> <BoN> predictions <EoN> = <BoN> super <EoN> ( <BoN> Kernel Linear Classifier <EoN> , <BoN> self <EoN> ) . <BoN> predict <EoN> ( <NEWLINE> <BoN> input fn <EoN> = <BoN> input fn <EoN> , <BoN> outputs <EoN> = [ <BoN> key <EoN> ] ) <NEWLINE> <BoN> return <EoN> ( <BoN> pred <EoN> [ <BoN> key <EoN> ] <BoN> for <EoN> <BoN> pred <EoN> <BoN> in <EoN> <BoN> predictions <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> create <EoN> ( <BoN> self <EoN> , <BoN> bind <EoN> = <BoN> None <EoN> , <BoN> checkfirst <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> bind <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bind <EoN> = <BoN> bind or error <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> bind <EoN> . <BoN> run visitor <EoN> ( <BoN> ddl <EoN> . <BoN> Schema Generator <EoN> , <NEWLINE> <BoN> self <EoN> , <NEWLINE> <BoN> checkfirst <EoN> = <BoN> checkfirst <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> do return conn <EoN> ( <BoN> self <EoN> , <BoN> conn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to algebraic integer <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> Poly <EoN> <NEWLINE> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> minpoly <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> . <BoN> L C <EoN> ( ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> coeff <EoN> = <BoN> f <EoN> . <BoN> L C <EoN> ( ) ** ( <BoN> f <EoN> . <BoN> degree <EoN> ( ) - <NUMBER> ) <NEWLINE> <BoN> poly <EoN> = <BoN> f <EoN> . <BoN> compose <EoN> ( <BoN> Poly <EoN> ( <BoN> f <EoN> . <BoN> gen <EoN> / <BoN> f <EoN> . <BoN> L C <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <BoN> minpoly <EoN> = <BoN> poly <EoN> * <BoN> coeff <EoN> <NEWLINE> <BoN> root <EoN> = <BoN> f <EoN> . <BoN> L C <EoN> ( ) * <BoN> self <EoN> . <BoN> root <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Algebraic Number <EoN> ( ( <BoN> minpoly <EoN> , <BoN> root <EoN> ) , <BoN> self <EoN> . <BoN> coeffs <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast add <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> assert safe casting <EoN> ( <BoN> cls <EoN> , <BoN> data <EoN> , <BoN> subarr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get saver <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> saver <EoN> = <BoN> get first op from collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> saver <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> variables <EoN> . <BoN> global variables <EoN> ( ) : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> tf saver <EoN> . <BoN> Saver <EoN> ( ) <NEWLINE> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> , <BoN> saver <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> saver <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> box iou <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> format <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> find closest point on path <EoN> ( <BoN> lc <EoN> , <BoN> point <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ds <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( ( <BoN> lc <EoN> - <BoN> point <EoN> [ <BoN> None <EoN> , : ] ) ** <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> imin <EoN> = <BoN> np <EoN> . <BoN> argmin <EoN> ( <BoN> ds <EoN> ) <NEWLINE> <NEWLINE> <BoN> dmin <EoN> = <BoN> np <EoN> . <BoN> inf <EoN> <NEWLINE> <BoN> xcmin <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> legmin <EoN> = ( <BoN> None <EoN> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> closed <EoN> = <BoN> is closed polygon <EoN> ( <BoN> lc <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> legs <EoN> = [ ] <NEWLINE> <BoN> if <EoN> <BoN> imin <EoN> > <NUMBER> <BoN> or <EoN> <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> legs <EoN> . <BoN> append <EoN> ( ( ( <BoN> imin <EoN> - <NUMBER> ) % <BoN> len <EoN> ( <BoN> lc <EoN> ) , <BoN> imin <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> imin <EoN> < <BoN> len <EoN> ( <BoN> lc <EoN> ) - <NUMBER> <BoN> or <EoN> <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> legs <EoN> . <BoN> append <EoN> ( ( <BoN> imin <EoN> , ( <BoN> imin <EoN> + <NUMBER> ) % <BoN> len <EoN> ( <BoN> lc <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> leg <EoN> <BoN> in <EoN> <BoN> legs <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> , <BoN> xc <EoN> = <BoN> find closest point on leg <EoN> ( <BoN> lc <EoN> [ <BoN> leg <EoN> [ <NUMBER> ] ] , <BoN> lc <EoN> [ <BoN> leg <EoN> [ <NUMBER> ] ] , <BoN> point <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> d <EoN> < <BoN> dmin <EoN> : <NEWLINE> <TAB> <BoN> dmin <EoN> = <BoN> d <EoN> <NEWLINE> <BoN> xcmin <EoN> = <BoN> xc <EoN> <NEWLINE> <BoN> legmin <EoN> = <BoN> leg <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> ( <BoN> dmin <EoN> , <BoN> xcmin <EoN> , <BoN> legmin <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> YT complex <EoN> ( <BoN> ker pole <EoN> , <BoN> Q <EoN> , <BoN> transfer matrix <EoN> , <BoN> i <EoN> , <BoN> j <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> ur <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) * <BoN> Q <EoN> [ : , - <NUMBER> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> ui <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) * <BoN> Q <EoN> [ : , - <NUMBER> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> u <EoN> = <BoN> ur <EoN> + <NUMBER> * <BoN> ui <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ker pole ij <EoN> = <BoN> ker pole <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> m <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> np <EoN> . <BoN> conj <EoN> ( <BoN> ker pole ij <EoN> . <BoN> T <EoN> ) , <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> u <EoN> , <BoN> np <EoN> . <BoN> conj <EoN> ( <BoN> u <EoN> ) . <BoN> T <EoN> ) - <NEWLINE> <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> np <EoN> . <BoN> conj <EoN> ( <BoN> u <EoN> ) , <BoN> u <EoN> . <BoN> T <EoN> ) ) , <BoN> ker pole ij <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> e val <EoN> , <BoN> e vec <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> eig <EoN> ( <BoN> m <EoN> ) <NEWLINE> <NEWLINE> <BoN> e val idx <EoN> = <BoN> np <EoN> . <BoN> argsort <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> e val <EoN> ) ) <NEWLINE> <BoN> mu 1 <EoN> = <BoN> e vec <EoN> [ : , <BoN> e val idx <EoN> [ - <NUMBER> ] , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> mu 2 <EoN> = <BoN> e vec <EoN> [ : , <BoN> e val idx <EoN> [ - <NUMBER> ] , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> transfer matrix j mo transfer matrix j <EoN> = ( <NEWLINE> <BoN> transfer matrix <EoN> [ : , <BoN> i <EoN> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] + <NEWLINE> <NUMBER> * <BoN> transfer matrix <EoN> [ : , <BoN> j <EoN> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> e val <EoN> [ <BoN> e val idx <EoN> [ - <NUMBER> ] ] ) , <NEWLINE> <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> e val <EoN> [ <BoN> e val idx <EoN> [ - <NUMBER> ] ] ) ) : <NEWLINE> <TAB> <BoN> ker pole mu <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> ker pole ij <EoN> , <BoN> mu 1 <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> mu 1 mu 2 matrix <EoN> = <BoN> np <EoN> . <BoN> hstack <EoN> ( ( <BoN> mu 1 <EoN> , <BoN> mu 2 <EoN> ) ) <NEWLINE> <BoN> ker pole mu <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> ker pole ij <EoN> , <BoN> mu 1 mu 2 matrix <EoN> ) <NEWLINE> <UNTAB> <BoN> transfer matrix i j <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> ker pole mu <EoN> , <BoN> np <EoN> . <BoN> conj <EoN> ( <BoN> ker pole mu <EoN> . <BoN> T <EoN> ) ) , <NEWLINE> <BoN> transfer matrix j mo transfer matrix j <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> transfer matrix i j <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> transfer matrix i j <EoN> = ( <BoN> transfer matrix i j <EoN> / <NEWLINE> <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> transfer matrix i j <EoN> ) ) <NEWLINE> <BoN> transfer matrix <EoN> [ : , <BoN> i <EoN> ] = <BoN> np <EoN> . <BoN> real <EoN> ( <BoN> transfer matrix i j <EoN> [ : , <NUMBER> ] ) <NEWLINE> <BoN> transfer matrix <EoN> [ : , <BoN> j <EoN> ] = <BoN> np <EoN> . <BoN> imag <EoN> ( <BoN> transfer matrix i j <EoN> [ : , <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> transfer matrix <EoN> [ : , <BoN> i <EoN> ] = <BoN> np <EoN> . <BoN> real <EoN> ( <BoN> ker pole mu <EoN> [ : , <NUMBER> ] ) <NEWLINE> <BoN> transfer matrix <EoN> [ : , <BoN> j <EoN> ] = <BoN> np <EoN> . <BoN> imag <EoN> ( <BoN> ker pole mu <EoN> [ : , <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random flip top bottom <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> l 2 loss eager fallback <EoN> ( <BoN> t <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> t <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> t <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> t <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get table comment <EoN> ( <BoN> self <EoN> , <BoN> table name <EoN> , <BoN> schema <EoN> = <BoN> None <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dialect <EoN> . <BoN> get table comment <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> bind <EoN> , <BoN> table name <EoN> , <BoN> schema <EoN> , <BoN> info cache <EoN> = <BoN> self <EoN> . <BoN> info cache <EoN> , <NEWLINE> ** <BoN> kw <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> flip left right <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> has node <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> node <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check for x over absX <EoN> ( <BoN> numerators <EoN> , <BoN> denominators <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> den <EoN> <BoN> in <EoN> <BoN> list <EoN> ( <BoN> denominators <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> den <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> den <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> T <EoN> . <BoN> abs <EoN> <BoN> and <EoN> <NEWLINE> <BoN> den <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <BoN> in <EoN> <BoN> numerators <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> den <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] . <BoN> type <EoN> . <BoN> dtype <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> denominators <EoN> . <BoN> remove <EoN> ( <BoN> den <EoN> ) <NEWLINE> <BoN> numerators <EoN> . <BoN> remove <EoN> ( <BoN> den <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> numerators <EoN> . <BoN> append <EoN> ( <BoN> T <EoN> . <BoN> sgn <EoN> ( <BoN> den <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> numerators <EoN> , <BoN> denominators <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rcm estimate <EoN> ( <BoN> G <EoN> , <BoN> nodelist <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> = <BoN> G <EoN> . <BoN> subgraph <EoN> ( <BoN> nodelist <EoN> ) <NEWLINE> <BoN> order <EoN> = <BoN> reverse cuthill mckee ordering <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> nodelist <EoN> ) <NEWLINE> <BoN> index <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> nodelist <EoN> , <BoN> range <EoN> ( <BoN> n <EoN> ) ) ) <NEWLINE> <BoN> x <EoN> = <BoN> ndarray <EoN> ( <BoN> n <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> u <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> order <EoN> ) : <NEWLINE> <TAB> <BoN> x <EoN> [ <BoN> index <EoN> [ <BoN> u <EoN> ] ] = <BoN> i <EoN> <NEWLINE> <UNTAB> <BoN> x <EoN> -= ( <BoN> n <EoN> - <NUMBER> ) / <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate tensor info <EoN> ( <BoN> self <EoN> , <BoN> tensor info <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> tensor info <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tensor info <EoN> . <BoN> Which Oneof <EoN> ( <STRING> ) <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % <BoN> tensor info <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tensor info <EoN> . <BoN> dtype <EoN> <BoN> is <EoN> <BoN> types pb 2 <EoN> . <BoN> DT INVALID <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> tensor info <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add legend data <EoN> ( <BoN> self <EoN> , <BoN> ax <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> hue names <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> rgb <EoN> , <BoN> label <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> colors <EoN> , <BoN> self <EoN> . <BoN> hue names <EoN> ) : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> scatter <EoN> ( [ ] , [ ] , <NEWLINE> <BoN> color <EoN> = <BoN> mpl <EoN> . <BoN> colors <EoN> . <BoN> rgb 2 hex <EoN> ( <BoN> rgb <EoN> ) , <NEWLINE> <BoN> label <EoN> = <BoN> label <EoN> , <NEWLINE> <BoN> s <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> defun <EoN> <NEWLINE> <BoN> def <EoN> <BoN> nsum <EoN> ( <BoN> ctx <EoN> , <BoN> f <EoN> , * <BoN> intervals <EoN> , ** <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> infinite <EoN> , <BoN> g <EoN> = <BoN> standardize <EoN> ( <BoN> ctx <EoN> , <BoN> f <EoN> , <BoN> intervals <EoN> , <BoN> options <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> infinite <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> + <BoN> g <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> update <EoN> ( <BoN> partial sums <EoN> , <BoN> indices <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> partial sums <EoN> : <NEWLINE> <TAB> <BoN> psum <EoN> = <BoN> partial sums <EoN> [ - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> psum <EoN> = <BoN> ctx <EoN> . <BoN> zero <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> indices <EoN> : <NEWLINE> <TAB> <BoN> psum <EoN> = <BoN> psum <EoN> + <BoN> g <EoN> ( <BoN> ctx <EoN> . <BoN> mpf <EoN> ( <BoN> k <EoN> ) ) <NEWLINE> <BoN> partial sums <EoN> . <BoN> append <EoN> ( <BoN> psum <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> prec <EoN> = <BoN> ctx <EoN> . <BoN> prec <EoN> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> emfun <EoN> ( <BoN> point <EoN> , <BoN> tol <EoN> ) : <NEWLINE> <TAB> <BoN> workprec <EoN> = <BoN> ctx <EoN> . <BoN> prec <EoN> <NEWLINE> <BoN> ctx <EoN> . <BoN> prec <EoN> = <BoN> prec <EoN> + <NUMBER> <NEWLINE> <BoN> v <EoN> = <BoN> ctx <EoN> . <BoN> sumem <EoN> ( <BoN> g <EoN> , [ <BoN> point <EoN> , <BoN> ctx <EoN> . <BoN> inf <EoN> ] , <BoN> tol <EoN> , <BoN> error <EoN> = <NUMBER> ) <NEWLINE> <BoN> ctx <EoN> . <BoN> prec <EoN> = <BoN> workprec <EoN> <NEWLINE> <BoN> return <EoN> <BoN> v <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> + <BoN> ctx <EoN> . <BoN> adaptive extrapolation <EoN> ( <BoN> update <EoN> , <BoN> emfun <EoN> , <BoN> options <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is signed integer dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> arr or dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> tipo <EoN> = <BoN> get dtype type <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , <BoN> np <EoN> . <BoN> signedinteger <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , ( <BoN> np <EoN> . <BoN> datetime 64 <EoN> , <BoN> np <EoN> . <BoN> timedelta 64 <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> copy <EoN> ( <BoN> a <EoN> , <BoN> order <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> array <EoN> ( <BoN> a <EoN> , <BoN> order <EoN> = <BoN> order <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp negative p <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> K <EoN> . <BoN> is negative <EoN> ( <BoN> dmp ground LC <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arcsin <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> repr data resource <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> config <EoN> . <BoN> get option <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> self <EoN> . <BoN> head <EoN> ( <BoN> config <EoN> . <BoN> get option <EoN> ( <STRING> ) ) <NEWLINE> <BoN> payload <EoN> = <BoN> json <EoN> . <BoN> loads <EoN> ( <BoN> data <EoN> . <BoN> to json <EoN> ( <BoN> orient <EoN> = <STRING> ) , <NEWLINE> <BoN> object pairs hook <EoN> = <BoN> collections <EoN> . <BoN> Ordered Dict <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> payload <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set initial value <EoN> ( <BoN> self <EoN> , <BoN> y <EoN> , <BoN> t <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y <EoN> = <BoN> asarray <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> tmp <EoN> = <BoN> zeros <EoN> ( <BoN> y <EoN> . <BoN> size <EoN> * <NUMBER> , <STRING> ) <NEWLINE> <BoN> self <EoN> . <BoN> tmp <EoN> [ : : <NUMBER> ] = <BoN> real <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> tmp <EoN> [ <NUMBER> : : <NUMBER> ] = <BoN> imag <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ode <EoN> . <BoN> set initial value <EoN> ( <BoN> self <EoN> , <BoN> self <EoN> . <BoN> tmp <EoN> , <BoN> t <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get value <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> . <BoN> eval <EoN> ( <BoN> session <EoN> = <BoN> get session <EoN> ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y <EoN> = <BoN> super <EoN> ( <BoN> Base SV C <EoN> , <BoN> self <EoN> ) . <BoN> predict <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> classes <EoN> . <BoN> take <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> y <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> intp <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> are coplanar <EoN> ( <BoN> cls <EoN> , * <BoN> points <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> points <EoN> ) <= <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> points <EoN> = <BoN> cls <EoN> . <BoN> normalize dimension <EoN> ( * [ <BoN> Point <EoN> ( <BoN> i <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> points <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> points <EoN> [ <NUMBER> ] . <BoN> ambient dimension <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> points <EoN> = <BoN> list <EoN> ( <BoN> uniq <EoN> ( <BoN> points <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> Point <EoN> . <BoN> affine rank <EoN> ( * <BoN> points <EoN> ) <= <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> report <EoN> ( <BoN> values <EoN> , <BoN> observer <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> reporters <EoN> : <NEWLINE> <TAB> <BoN> current <EoN> = <BoN> reporters <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> current <EoN> . <BoN> report <EoN> ( <BoN> values <EoN> , <BoN> observer <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> command <EoN> ( <BoN> engine <EoN> , <BoN> format <EoN> , <BoN> filepath <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> engine <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> ENGINE S <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> engine <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> format <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> FORMAT S <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> format <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> args <EoN> , <BoN> rendered <EoN> = [ <BoN> engine <EoN> , <STRING> % <BoN> format <EoN> ] , <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> filepath <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> args <EoN> . <BoN> extend <EoN> ( [ <STRING> , <BoN> filepath <EoN> ] ) <NEWLINE> <BoN> rendered <EoN> = <STRING> % ( <BoN> filepath <EoN> , <BoN> format <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> args <EoN> , <BoN> rendered <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> digits <EoN> ( <BoN> n <EoN> , <BoN> b <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> b <EoN> = <BoN> as int <EoN> ( <BoN> b <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> as int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> b <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> y <EoN> = <BoN> abs <EoN> ( <BoN> n <EoN> ) , [ ] <NEWLINE> <BoN> while <EoN> <BoN> x <EoN> >= <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> r <EoN> = <BoN> divmod <EoN> ( <BoN> x <EoN> , <BoN> b <EoN> ) <NEWLINE> <BoN> y <EoN> . <BoN> append <EoN> ( <BoN> r <EoN> ) <NEWLINE> <UNTAB> <BoN> y <EoN> . <BoN> append <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> y <EoN> . <BoN> append <EoN> ( - <BoN> b <EoN> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> <BoN> else <EoN> <BoN> b <EoN> ) <NEWLINE> <BoN> y <EoN> . <BoN> reverse <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create temp <EoN> ( <BoN> node <EoN> , <BoN> namer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , <BoN> gast <EoN> . <BoN> Name <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> node <EoN> . <BoN> id <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , ( <BoN> gast <EoN> . <BoN> Attribute <EoN> , <BoN> gast <EoN> . <BoN> Subscript <EoN> ) ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> node <EoN> . <BoN> value <EoN> . <BoN> id <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> <NEWLINE> <UNTAB> <BoN> temp node <EoN> = <BoN> gast <EoN> . <BoN> Name <EoN> ( <BoN> id <EoN> = <BoN> namer <EoN> . <BoN> temp <EoN> ( <BoN> name <EoN> ) , <BoN> annotation <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) <NEWLINE> <BoN> anno <EoN> . <BoN> setanno <EoN> ( <BoN> temp node <EoN> , <STRING> , <BoN> node <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> temp node <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get select precolumns <EoN> ( <BoN> self <EoN> , <BoN> select <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> select <EoN> . <BoN> distinct <EoN> <BoN> and <EoN> <STRING> <BoN> or <EoN> <STRING> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reshape <EoN> ( <BoN> a <EoN> , <BoN> new shape <EoN> , <BoN> order <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> a <EoN> . <BoN> reshape <EoN> ( <BoN> new shape <EoN> , <BoN> order <EoN> = <BoN> order <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> tmp <EoN> = <BoN> narray <EoN> ( <BoN> a <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) . <BoN> reshape <EoN> ( <BoN> new shape <EoN> , <BoN> order <EoN> = <BoN> order <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> tmp <EoN> . <BoN> view <EoN> ( <BoN> Masked Array <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get graph from inputs <EoN> ( <BoN> op input list <EoN> , <BoN> graph <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> ops <EoN> . <BoN> get graph from inputs <EoN> ( <BoN> op input list <EoN> , <BoN> graph <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load op library <EoN> ( <BoN> path <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> os <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> path <EoN> ) : <NEWLINE> <TAB> <BoN> path <EoN> = <BoN> re <EoN> . <BoN> sub <EoN> ( <STRING> , <STRING> , <BoN> path <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> path <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> path <EoN> = <BoN> resource loader <EoN> . <BoN> get path to datafile <EoN> ( <BoN> path <EoN> ) <NEWLINE> <BoN> ret <EoN> = <BoN> load library <EoN> . <BoN> load op library <EoN> ( <BoN> path <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> ret <EoN> , <STRING> % <BoN> path <EoN> <NEWLINE> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> imag <EoN> ( <BoN> val <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> val <EoN> . <BoN> imag <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> asanyarray <EoN> ( <BoN> val <EoN> ) . <BoN> imag <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cumprod <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> cumprod <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> zeros <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> floatx <EoN> ( ) <NEWLINE> <UNTAB> <BoN> tf dtype <EoN> = <BoN> tf <EoN> . <BoN> as dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> tf <EoN> . <BoN> zeros <EoN> ( <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> tf dtype <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> py all <EoN> ( <BoN> v <EoN> . <BoN> get shape <EoN> ( ) . <BoN> as list <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> variable <EoN> ( <BoN> v <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> v <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Not Found Error <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> , <BoN> NOT FOUND <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max pool with argmax eager fallback <EoN> ( <BoN> input <EoN> , <BoN> ksize <EoN> , <BoN> strides <EoN> , <BoN> padding <EoN> , <BoN> Targmax <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> ksize <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> ksize <EoN> ) <NEWLINE> <UNTAB> <BoN> ksize <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> ksize <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> strides <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> strides <EoN> ) <NEWLINE> <UNTAB> <BoN> strides <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> strides <EoN> ] <NEWLINE> <BoN> padding <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> padding <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> Targmax <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> Targmax <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> <NEWLINE> <UNTAB> <BoN> Targmax <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> Targmax <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> input <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> ksize <EoN> , <STRING> , <BoN> strides <EoN> , <STRING> , <BoN> Targmax <EoN> , <STRING> , <NEWLINE> <BoN> padding <EoN> , <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> MaxPoolWithArgmaxOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get patch transform <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> transforms <EoN> . <BoN> Identity Transform <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> capitalize <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a arr <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> vec string <EoN> ( <BoN> a arr <EoN> , <BoN> a arr <EoN> . <BoN> dtype <EoN> , <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> raw fft <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> axis <EoN> , <BoN> direction <EoN> , <BoN> overwrite x <EoN> , <BoN> work function <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> n <EoN> != <BoN> x <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> copy made <EoN> = <BoN> fix shape <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> overwrite x <EoN> = <BoN> overwrite x <EoN> <BoN> or <EoN> <BoN> copy made <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> == - <NUMBER> <BoN> or <EoN> <BoN> axis <EoN> == <BoN> len <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> ) - <NUMBER> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> work function <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> direction <EoN> , <BoN> overwrite x <EoN> = <BoN> overwrite x <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> swapaxes <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> , - <NUMBER> ) <NEWLINE> <BoN> r <EoN> = <BoN> work function <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> direction <EoN> , <BoN> overwrite x <EoN> = <BoN> overwrite x <EoN> ) <NEWLINE> <BoN> r <EoN> = <BoN> swapaxes <EoN> ( <BoN> r <EoN> , <BoN> axis <EoN> , - <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reshape nd <EoN> ( <BoN> image <EoN> , <BoN> ndim <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> image <EoN> . <BoN> ndim <EoN> >= <BoN> ndim <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> image <EoN> <NEWLINE> <UNTAB> <BoN> image <EoN> = <BoN> image <EoN> . <BoN> reshape <EoN> ( ( <NUMBER> , ) * ( <BoN> ndim <EoN> - <BoN> image <EoN> . <BoN> ndim <EoN> ) + <BoN> image <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> image <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Dws <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Cs <EoN> ( <BoN> n <EoN> , [ <NUMBER> , <NUMBER> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> find <EoN> ( <BoN> A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> A <EoN> = <BoN> coo matrix <EoN> ( <BoN> A <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> A <EoN> . <BoN> sum duplicates <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> nz mask <EoN> = <BoN> A <EoN> . <BoN> data <EoN> != <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> A <EoN> . <BoN> row <EoN> [ <BoN> nz mask <EoN> ] , <BoN> A <EoN> . <BoN> col <EoN> [ <BoN> nz mask <EoN> ] , <BoN> A <EoN> . <BoN> data <EoN> [ <BoN> nz mask <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> clarkson woodruff transform <EoN> ( <BoN> input matrix <EoN> , <BoN> sketch size <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> S <EoN> = <BoN> cwt matrix <EoN> ( <BoN> sketch size <EoN> , <BoN> input matrix <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> seed <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> S <EoN> , <BoN> input matrix <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> linear 2 eq order 2 type 9 <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> t <EoN> , <BoN> r <EoN> , <BoN> eq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> C 1 <EoN> , <BoN> C 2 <EoN> , <BoN> C 3 <EoN> , <BoN> C 4 <EoN> = <BoN> get numbered constants <EoN> ( <BoN> eq <EoN> , <BoN> num <EoN> = <NUMBER> ) <NEWLINE> <BoN> k <EoN> = <BoN> Symbol <EoN> ( <STRING> ) <NEWLINE> <BoN> a 1 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ; <BoN> a 2 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> <NEWLINE> <BoN> b 1 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ; <BoN> b 2 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> <NEWLINE> <BoN> c 1 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ** <NUMBER> ; <BoN> c 2 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ** <NUMBER> <NEWLINE> <BoN> d 1 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ** <NUMBER> ; <BoN> d 2 <EoN> = - <BoN> r <EoN> [ <STRING> ] * <BoN> t <EoN> ** <NUMBER> <NEWLINE> <BoN> eq <EoN> = ( <BoN> k <EoN> ** <NUMBER> + ( <BoN> a 1 <EoN> - <NUMBER> ) * <BoN> k <EoN> + <BoN> c 1 <EoN> ) * ( <BoN> k <EoN> ** <NUMBER> + ( <BoN> b 2 <EoN> - <NUMBER> ) * <BoN> k <EoN> + <BoN> d 2 <EoN> ) - ( <BoN> b 1 <EoN> * <BoN> k <EoN> + <BoN> d 1 <EoN> ) * ( <BoN> a 2 <EoN> * <BoN> k <EoN> + <BoN> c 2 <EoN> ) <NEWLINE> [ <BoN> k 1 <EoN> , <BoN> k 2 <EoN> , <BoN> k 3 <EoN> , <BoN> k 4 <EoN> ] = <BoN> roots quartic <EoN> ( <BoN> Poly <EoN> ( <BoN> eq <EoN> ) ) <NEWLINE> <BoN> sol 1 <EoN> = - <BoN> C 1 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 1 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 1 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) - <BoN> C 2 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 2 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 2 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) - <BoN> C 3 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 3 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 3 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) - <BoN> C 4 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 4 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 4 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> a 1 <EoN> = ( <BoN> a 1 <EoN> - <NUMBER> ) <NEWLINE> <BoN> sol 2 <EoN> = <BoN> C 1 <EoN> * ( <BoN> k 1 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 1 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 1 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) + <BoN> C 2 <EoN> * ( <BoN> k 2 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 2 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 2 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) + <BoN> C 3 <EoN> * ( <BoN> k 3 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 3 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 3 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) + <BoN> C 4 <EoN> * ( <BoN> k 4 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 4 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 4 <EoN> * <BoN> log <EoN> ( <BoN> t <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> Eq <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> sol 1 <EoN> ) , <BoN> Eq <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> sol 2 <EoN> ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> bitwise and <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> bitwise and eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> bitwise and <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> bitwise and <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> squeeze <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> squeeze <EoN> ( <BoN> x <EoN> , [ <BoN> axis <EoN> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> convert dtypes <EoN> ( <BoN> dtype template <EoN> , <BoN> order code <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dtypes <EoN> = <BoN> dtype template <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> dtypes <EoN> : <NEWLINE> <TAB> <BoN> dtypes <EoN> [ <BoN> k <EoN> ] = <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> dtypes <EoN> [ <BoN> k <EoN> ] ) . <BoN> newbyteorder <EoN> ( <BoN> order code <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dtypes <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nbytes full <EoN> ( <BoN> fmt <EoN> , <BoN> nlines <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <BoN> fmt <EoN> . <BoN> repeat <EoN> * <BoN> fmt <EoN> . <BoN> width <EoN> + <NUMBER> ) * ( <BoN> nlines <EoN> - <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> checkpointable <EoN> . <BoN> no automatic dependency tracking <EoN> <NEWLINE> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> self <EoN> , <BoN> layer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> layer <EoN> , <BoN> base layer <EoN> . <BoN> Layer <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> layer <EoN> ) ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> built <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> set inputs <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> layers <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> layer <EoN> , <BoN> Input Layer <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> layer <EoN> . <BoN> inbound nodes <EoN> [ - <NUMBER> ] . <BoN> output tensors <EoN> ) == <NUMBER> <NEWLINE> <BoN> set inputs <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> batch shape <EoN> , <BoN> dtype <EoN> = <BoN> training utils <EoN> . <BoN> get input shape and dtype <EoN> ( <BoN> layer <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> batch shape <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> Input <EoN> ( <NEWLINE> <BoN> batch shape <EoN> = <BoN> batch shape <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtype <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> layer <EoN> . <BoN> name <EoN> + <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> layer <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> set inputs <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> set inputs <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> layer <EoN> . <BoN> inbound nodes <EoN> [ - <NUMBER> ] . <BoN> output tensors <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> outputs <EoN> = [ <BoN> layer <EoN> . <BoN> inbound nodes <EoN> [ - <NUMBER> ] . <BoN> output tensors <EoN> [ <NUMBER> ] ] <NEWLINE> <BoN> self <EoN> . <BoN> inputs <EoN> = <BoN> layer utils <EoN> . <BoN> get source inputs <EoN> ( <BoN> self <EoN> . <BoN> outputs <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> outputs <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> output tensor <EoN> = <BoN> layer <EoN> ( <BoN> self <EoN> . <BoN> outputs <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> output tensor <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> outputs <EoN> = [ <BoN> output tensor <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> set inputs <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> is graph network <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> init graph network <EoN> ( <BoN> self <EoN> . <BoN> inputs <EoN> , <BoN> self <EoN> . <BoN> outputs <EoN> , <BoN> name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> built <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> layers <EoN> . <BoN> append <EoN> ( <BoN> layer <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> layers <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> track layers <EoN> ( <BoN> self <EoN> . <BoN> layers <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assoc recurrence memo <EoN> ( <BoN> base seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> cache <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> decorator <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> @ <BoN> wraps <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> g <EoN> ( <BoN> n <EoN> , <BoN> m <EoN> ) : <NEWLINE> <TAB> <BoN> L <EoN> = <BoN> len <EoN> ( <BoN> cache <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <BoN> L <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cache <EoN> [ <BoN> n <EoN> ] [ <BoN> m <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> L <EoN> , <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> F i 0 <EoN> = <BoN> base seq <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> F i cache <EoN> = [ <BoN> F i 0 <EoN> ] <NEWLINE> <BoN> cache <EoN> . <BoN> append <EoN> ( <BoN> F i cache <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> i <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> F ij <EoN> = <BoN> f <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> , <BoN> cache <EoN> ) <NEWLINE> <BoN> F i cache <EoN> . <BoN> append <EoN> ( <BoN> F ij <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> cache <EoN> [ <BoN> n <EoN> ] [ <BoN> m <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> g <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> decorator <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get snap <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> rc Params <EoN> [ <STRING> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> snap <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> r <EoN> = <BoN> false <EoN> <NEWLINE> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> elements <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> Eq <EoN> ( <BoN> e <EoN> , <BoN> other <EoN> , <BoN> evaluate <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> t <EoN> <BoN> is <EoN> <BoN> true <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> t <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> t <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> false <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> to rgb <EoN> ( <BoN> arg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> to rgb <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is unsigned integer dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> arr or dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> tipo <EoN> = <BoN> get dtype type <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , <BoN> np <EoN> . <BoN> unsignedinteger <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , ( <BoN> np <EoN> . <BoN> datetime 64 <EoN> , <BoN> np <EoN> . <BoN> timedelta 64 <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> threshold yen <EoN> ( <BoN> image <EoN> , <BoN> nbins <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> hist <EoN> , <BoN> bin centers <EoN> = <BoN> histogram <EoN> ( <BoN> image <EoN> . <BoN> ravel <EoN> ( ) , <BoN> nbins <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> bin centers <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> bin centers <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> pmf <EoN> = <BoN> hist <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 32 <EoN> ) / <BoN> hist <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> P 1 <EoN> = <BoN> np <EoN> . <BoN> cumsum <EoN> ( <BoN> pmf <EoN> ) <NEWLINE> <BoN> P 1 sq <EoN> = <BoN> np <EoN> . <BoN> cumsum <EoN> ( <BoN> pmf <EoN> ** <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> P 2 sq <EoN> = <BoN> np <EoN> . <BoN> cumsum <EoN> ( <BoN> pmf <EoN> [ : : - <NUMBER> ] ** <NUMBER> ) [ : : - <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> crit <EoN> = <BoN> np <EoN> . <BoN> log <EoN> ( ( ( <BoN> P 1 sq <EoN> [ : - <NUMBER> ] * <BoN> P 2 sq <EoN> [ <NUMBER> : ] ) ** - <NUMBER> ) * <NEWLINE> ( <BoN> P 1 <EoN> [ : - <NUMBER> ] * ( <NUMBER> - <BoN> P 1 <EoN> [ : - <NUMBER> ] ) ) ** <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> bin centers <EoN> [ <BoN> crit <EoN> . <BoN> argmax <EoN> ( ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast to <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> cast to floatx <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> x <EoN> , <BoN> dtype <EoN> = <BoN> FLOATX <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mask cmp op <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> op <EoN> , <BoN> allowed types <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> xrav <EoN> = <BoN> x <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> x <EoN> . <BoN> size <EoN> , <BoN> dtype <EoN> = <BoN> bool <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> y <EoN> , <BoN> allowed types <EoN> ) : <NEWLINE> <TAB> <BoN> yrav <EoN> = <BoN> y <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> mask <EoN> = <BoN> notna <EoN> ( <BoN> xrav <EoN> ) & <BoN> notna <EoN> ( <BoN> yrav <EoN> ) <NEWLINE> <BoN> result <EoN> [ <BoN> mask <EoN> ] = <BoN> op <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> list <EoN> ( <BoN> xrav <EoN> [ <BoN> mask <EoN> ] ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> list <EoN> ( <BoN> yrav <EoN> [ <BoN> mask <EoN> ] ) ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> mask <EoN> = <BoN> notna <EoN> ( <BoN> xrav <EoN> ) <NEWLINE> <BoN> result <EoN> [ <BoN> mask <EoN> ] = <BoN> op <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> list <EoN> ( <BoN> xrav <EoN> [ <BoN> mask <EoN> ] ) ) , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> op <EoN> == <BoN> operator <EoN> . <BoN> ne <EoN> : <NEWLINE> <TAB> <BoN> np <EoN> . <BoN> putmask <EoN> ( <BoN> result <EoN> , ~ <BoN> mask <EoN> , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> np <EoN> . <BoN> putmask <EoN> ( <BoN> result <EoN> , ~ <BoN> mask <EoN> , <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> handle deferred dependencies <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> checkpointable <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> maybe initialize checkpointable <EoN> ( ) <NEWLINE> <BoN> checkpointable <EoN> . <BoN> maybe initialize checkpointable <EoN> ( ) <NEWLINE> <BoN> deferred dependencies list <EoN> = <BoN> self <EoN> . <BoN> deferred dependencies <EoN> . <BoN> pop <EoN> ( <BoN> name <EoN> , ( ) ) <NEWLINE> <BoN> for <EoN> <BoN> checkpoint position <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <NEWLINE> <BoN> deferred dependencies list <EoN> , <NEWLINE> <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> restore <EoN> : <BoN> restore <EoN> . <BoN> checkpoint <EoN> . <BoN> restore uid <EoN> , <NEWLINE> <BoN> reverse <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> checkpoint position <EoN> . <BoN> restore <EoN> ( <BoN> checkpointable <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> name based restore <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> name based restores <EoN> , <NEWLINE> <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> checkpoint <EoN> : <BoN> checkpoint <EoN> . <BoN> restore uid <EoN> , <NEWLINE> <BoN> reverse <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> checkpointable <EoN> . <BoN> name based attribute restore <EoN> ( <BoN> name based restore <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lcm <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> . <BoN> lcm <EoN> ( <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> adjacency graph <EoN> ( <BoN> data <EoN> , <BoN> directed <EoN> = <BoN> False <EoN> , <BoN> multigraph <EoN> = <BoN> True <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> multigraph <EoN> = <BoN> data <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> multigraph <EoN> ) <NEWLINE> <BoN> directed <EoN> = <BoN> data <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> directed <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> multigraph <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> = <BoN> nx <EoN> . <BoN> Multi Graph <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> = <BoN> nx <EoN> . <BoN> Graph <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> directed <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> = <BoN> graph <EoN> . <BoN> to directed <EoN> ( ) <NEWLINE> <UNTAB> <BoN> id <EoN> = <BoN> attrs <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> key <EoN> = <BoN> None <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> multigraph <EoN> <BoN> else <EoN> <BoN> attrs <EoN> [ <STRING> ] <NEWLINE> <BoN> graph <EoN> . <BoN> graph <EoN> = <BoN> dict <EoN> ( <BoN> data <EoN> . <BoN> get <EoN> ( <STRING> , [ ] ) ) <NEWLINE> <BoN> mapping <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> data <EoN> [ <STRING> ] : <NEWLINE> <TAB> <BoN> node data <EoN> = <BoN> d <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> node <EoN> = <BoN> node data <EoN> . <BoN> pop <EoN> ( <BoN> id <EoN> ) <NEWLINE> <BoN> mapping <EoN> . <BoN> append <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> graph <EoN> . <BoN> add node <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> graph <EoN> . <BoN> nodes <EoN> [ <BoN> node <EoN> ] . <BoN> update <EoN> ( <BoN> node data <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> data <EoN> [ <STRING> ] ) : <NEWLINE> <TAB> <BoN> source <EoN> = <BoN> mapping <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> tdata <EoN> <BoN> in <EoN> <BoN> d <EoN> : <NEWLINE> <TAB> <BoN> target data <EoN> = <BoN> tdata <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> target <EoN> = <BoN> target data <EoN> . <BoN> pop <EoN> ( <BoN> id <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> multigraph <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> . <BoN> add edge <EoN> ( <BoN> source <EoN> , <BoN> target <EoN> ) <NEWLINE> <BoN> graph <EoN> [ <BoN> source <EoN> ] [ <BoN> target <EoN> ] . <BoN> update <EoN> ( <BoN> tdata <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ky <EoN> = <BoN> target data <EoN> . <BoN> pop <EoN> ( <BoN> key <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> graph <EoN> . <BoN> add edge <EoN> ( <BoN> source <EoN> , <BoN> target <EoN> , <BoN> key <EoN> = <BoN> ky <EoN> ) <NEWLINE> <BoN> graph <EoN> [ <BoN> source <EoN> ] [ <BoN> target <EoN> ] [ <BoN> ky <EoN> ] . <BoN> update <EoN> ( <BoN> tdata <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> graph <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> graph action deprecation <EoN> <NEWLINE> <BoN> def <EoN> <BoN> run n <EoN> ( <BoN> output dict <EoN> , <BoN> feed dict <EoN> = <BoN> None <EoN> , <BoN> restore checkpoint path <EoN> = <BoN> None <EoN> , <BoN> n <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> run feeds <EoN> ( <NEWLINE> <BoN> output dict <EoN> = <BoN> output dict <EoN> , <NEWLINE> <BoN> feed dicts <EoN> = <BoN> itertools <EoN> . <BoN> repeat <EoN> ( <BoN> feed dict <EoN> , <BoN> n <EoN> ) , <NEWLINE> <BoN> restore checkpoint path <EoN> = <BoN> restore checkpoint path <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> RealGetContents <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fp <EoN> = <BoN> self <EoN> . <BoN> fp <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> endrec <EoN> = <BoN> EndRecData <EoN> ( <BoN> fp <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Bad Zip File <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> endrec <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Bad Zip File <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> debug <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> print <EoN> ( <BoN> endrec <EoN> ) <NEWLINE> <UNTAB> <BoN> size cd <EoN> = <BoN> endrec <EoN> [ <BoN> ECD SIZE <EoN> ] <NEWLINE> <BoN> offset cd <EoN> = <BoN> endrec <EoN> [ <BoN> ECD OFFSET <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> comment <EoN> = <BoN> endrec <EoN> [ <BoN> ECD COMMENT <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> concat <EoN> = <BoN> endrec <EoN> [ <BoN> ECD LOCATION <EoN> ] - <BoN> size cd <EoN> - <BoN> offset cd <EoN> <NEWLINE> <BoN> if <EoN> <BoN> endrec <EoN> [ <BoN> ECD SIGNATURE <EoN> ] == <BoN> string End Archive 64 <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> concat <EoN> -= ( <BoN> size End Cent Dir 64 <EoN> + <BoN> size End Cent Dir 64 Locator <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> debug <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> inferred <EoN> = <BoN> concat <EoN> + <BoN> offset cd <EoN> <NEWLINE> <BoN> print <EoN> ( <STRING> , <BoN> offset cd <EoN> , <BoN> inferred <EoN> , <BoN> concat <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> start dir <EoN> = <BoN> offset cd <EoN> + <BoN> concat <EoN> <NEWLINE> <BoN> fp <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> start dir <EoN> , <NUMBER> ) <NEWLINE> <BoN> data <EoN> = <BoN> fp <EoN> . <BoN> read <EoN> ( <BoN> size cd <EoN> ) <NEWLINE> <BoN> fp <EoN> = <BoN> io <EoN> . <BoN> Bytes I O <EoN> ( <BoN> data <EoN> ) <NEWLINE> <BoN> total <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> <BoN> total <EoN> < <BoN> size cd <EoN> : <NEWLINE> <TAB> <BoN> centdir <EoN> = <BoN> fp <EoN> . <BoN> read <EoN> ( <BoN> size Central Dir <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> centdir <EoN> ) != <BoN> size Central Dir <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Bad Zip File <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> centdir <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> struct Central Dir <EoN> , <BoN> centdir <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> centdir <EoN> [ <BoN> CD SIGNATURE <EoN> ] != <BoN> string Central Dir <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Bad Zip File <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> debug <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> print <EoN> ( <BoN> centdir <EoN> ) <NEWLINE> <UNTAB> <BoN> filename <EoN> = <BoN> fp <EoN> . <BoN> read <EoN> ( <BoN> centdir <EoN> [ <BoN> CD FILENAME LENGTH <EoN> ] ) <NEWLINE> <BoN> flags <EoN> = <BoN> centdir <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> flags <EoN> & <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> filename <EoN> . <BoN> decode <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> filename <EoN> . <BoN> decode <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> Zip Info <EoN> ( <BoN> filename <EoN> ) <NEWLINE> <BoN> x <EoN> . <BoN> extra <EoN> = <BoN> fp <EoN> . <BoN> read <EoN> ( <BoN> centdir <EoN> [ <BoN> CD EXTRA FIELD LENGTH <EoN> ] ) <NEWLINE> <BoN> x <EoN> . <BoN> comment <EoN> = <BoN> fp <EoN> . <BoN> read <EoN> ( <BoN> centdir <EoN> [ <BoN> CD COMMENT LENGTH <EoN> ] ) <NEWLINE> <BoN> x <EoN> . <BoN> header offset <EoN> = <BoN> centdir <EoN> [ <BoN> CD LOCAL HEADER OFFSET <EoN> ] <NEWLINE> ( <BoN> x <EoN> . <BoN> create version <EoN> , <BoN> x <EoN> . <BoN> create system <EoN> , <BoN> x <EoN> . <BoN> extract version <EoN> , <BoN> x <EoN> . <BoN> reserved <EoN> , <NEWLINE> <BoN> x <EoN> . <BoN> flag bits <EoN> , <BoN> x <EoN> . <BoN> compress type <EoN> , <BoN> t <EoN> , <BoN> d <EoN> , <NEWLINE> <BoN> x <EoN> . <BoN> CR C <EoN> , <BoN> x <EoN> . <BoN> compress size <EoN> , <BoN> x <EoN> . <BoN> file size <EoN> ) = <BoN> centdir <EoN> [ <NUMBER> : <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> . <BoN> extract version <EoN> > <BoN> MAX EXTRACT VERSION <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> % <NEWLINE> ( <BoN> x <EoN> . <BoN> extract version <EoN> / <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> x <EoN> . <BoN> volume <EoN> , <BoN> x <EoN> . <BoN> internal attr <EoN> , <BoN> x <EoN> . <BoN> external attr <EoN> = <BoN> centdir <EoN> [ <NUMBER> : <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> x <EoN> . <BoN> raw time <EoN> = <BoN> t <EoN> <NEWLINE> <BoN> x <EoN> . <BoN> date time <EoN> = ( ( <BoN> d <EoN> >> <NUMBER> ) + <NUMBER> , ( <BoN> d <EoN> >> <NUMBER> ) & <NUMBER> , <BoN> d <EoN> & <NUMBER> , <NEWLINE> <BoN> t <EoN> >> <NUMBER> , ( <BoN> t <EoN> >> <NUMBER> ) & <NUMBER> , ( <BoN> t <EoN> & <NUMBER> ) * <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> x <EoN> . <BoN> decodeExtra <EoN> ( ) <NEWLINE> <BoN> x <EoN> . <BoN> header offset <EoN> = <BoN> x <EoN> . <BoN> header offset <EoN> + <BoN> concat <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> filelist <EoN> . <BoN> append <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> Name To Info <EoN> [ <BoN> x <EoN> . <BoN> filename <EoN> ] = <BoN> x <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> total <EoN> = ( <BoN> total <EoN> + <BoN> size Central Dir <EoN> + <BoN> centdir <EoN> [ <BoN> CD FILENAME LENGTH <EoN> ] <NEWLINE> + <BoN> centdir <EoN> [ <BoN> CD EXTRA FIELD LENGTH <EoN> ] <NEWLINE> + <BoN> centdir <EoN> [ <BoN> CD COMMENT LENGTH <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> debug <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> print <EoN> ( <STRING> , <BoN> total <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ROI Pooling <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> rois <EoN> = <BoN> None <EoN> , <BoN> pooled size <EoN> = <BoN> Null <EoN> , <BoN> spatial scale <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> dag longest path length <EoN> ( <BoN> G <EoN> , <BoN> weight <EoN> = <STRING> , <BoN> default weight <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> path <EoN> = <BoN> nx <EoN> . <BoN> dag longest path <EoN> ( <BoN> G <EoN> , <BoN> weight <EoN> , <BoN> default weight <EoN> ) <NEWLINE> <BoN> path length <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <BoN> in <EoN> <BoN> pairwise <EoN> ( <BoN> path <EoN> ) : <NEWLINE> <TAB> <BoN> path length <EoN> += <BoN> G <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] . <BoN> get <EoN> ( <BoN> weight <EoN> , <BoN> default weight <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> path length <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> conv 3 d weight <EoN> ( <BoN> input <EoN> , <BoN> weight size <EoN> , <BoN> grad output <EoN> , <BoN> stride <EoN> = <NUMBER> , <BoN> padding <EoN> = <NUMBER> , <BoN> dilation <EoN> = <NUMBER> , <BoN> groups <EoN> = <NUMBER> , <BoN> bias <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> stride <EoN> = <BoN> triple <EoN> ( <BoN> stride <EoN> ) <NEWLINE> <BoN> padding <EoN> = <BoN> triple <EoN> ( <BoN> padding <EoN> ) <NEWLINE> <BoN> dilation <EoN> = <BoN> triple <EoN> ( <BoN> dilation <EoN> ) <NEWLINE> <BoN> in channels <EoN> = <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> out channels <EoN> = <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> min batch <EoN> = <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> grad output <EoN> = <BoN> grad output <EoN> . <BoN> repeat <EoN> ( <NUMBER> , <BoN> in channels <EoN> // <BoN> groups <EoN> , <NUMBER> , <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> grad output <EoN> = <BoN> grad output <EoN> . <BoN> contiguous <EoN> ( ) . <BoN> view <EoN> ( <NEWLINE> <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] * <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NUMBER> , <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> grad output <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> input <EoN> = <BoN> input <EoN> . <BoN> contiguous <EoN> ( ) . <BoN> view <EoN> ( <NUMBER> , <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] * <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> input <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> grad weight <EoN> = <BoN> torch <EoN> . <BoN> conv 3 d <EoN> ( <BoN> input <EoN> , <BoN> grad output <EoN> , <BoN> bias <EoN> , <BoN> dilation <EoN> , <BoN> padding <EoN> , <NEWLINE> <BoN> stride <EoN> , <BoN> in channels <EoN> * <BoN> min batch <EoN> ) <NEWLINE> <NEWLINE> <BoN> grad weight <EoN> = <BoN> grad weight <EoN> . <BoN> contiguous <EoN> ( ) . <BoN> view <EoN> ( <NEWLINE> <BoN> min batch <EoN> , <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] // <BoN> min batch <EoN> , <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> grad weight <EoN> . <BoN> sum <EoN> ( <BoN> dim <EoN> = <NUMBER> ) . <BoN> view <EoN> ( <NEWLINE> <BoN> in channels <EoN> // <BoN> groups <EoN> , <BoN> out channels <EoN> , <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> grad weight <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> ) . <BoN> narrow <EoN> ( <NEWLINE> <NUMBER> , <NUMBER> , <BoN> weight size <EoN> [ <NUMBER> ] ) . <BoN> narrow <EoN> ( <NUMBER> , <NUMBER> , <BoN> weight size <EoN> [ <NUMBER> ] ) . <BoN> narrow <EoN> ( <NEWLINE> <NUMBER> , <NUMBER> , <BoN> weight size <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> normalize theta set <EoN> ( <BoN> theta <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> functions <EoN> . <BoN> elementary <EoN> . <BoN> trigonometric <EoN> <BoN> import <EoN> <BoN> pi coeff <EoN> <BoN> as <EoN> <BoN> coeff <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> theta <EoN> . <BoN> is Interval <EoN> : <NEWLINE> <TAB> <BoN> interval len <EoN> = <BoN> theta <EoN> . <BoN> measure <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> interval len <EoN> >= <NUMBER> * <BoN> S <EoN> . <BoN> Pi <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> interval len <EoN> == <NUMBER> * <BoN> S <EoN> . <BoN> Pi <EoN> <BoN> and <EoN> <BoN> theta <EoN> . <BoN> left open <EoN> <BoN> and <EoN> <BoN> theta <EoN> . <BoN> right open <EoN> : <NEWLINE> <TAB> <BoN> k <EoN> = <BoN> coeff <EoN> ( <BoN> theta <EoN> . <BoN> start <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Union <EoN> ( <BoN> Interval <EoN> ( <NUMBER> , <BoN> k <EoN> * <BoN> S <EoN> . <BoN> Pi <EoN> , <BoN> False <EoN> , <BoN> True <EoN> ) , <NEWLINE> <BoN> Interval <EoN> ( <BoN> k <EoN> * <BoN> S <EoN> . <BoN> Pi <EoN> , <NUMBER> * <BoN> S <EoN> . <BoN> Pi <EoN> , <BoN> True <EoN> , <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Interval <EoN> ( <NUMBER> , <NUMBER> * <BoN> S <EoN> . <BoN> Pi <EoN> , <BoN> False <EoN> , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> k start <EoN> , <BoN> k end <EoN> = <BoN> coeff <EoN> ( <BoN> theta <EoN> . <BoN> start <EoN> ) , <BoN> coeff <EoN> ( <BoN> theta <EoN> . <BoN> end <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k start <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> k end <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> new start <EoN> = <BoN> k start <EoN> * <BoN> S <EoN> . <BoN> Pi <EoN> <NEWLINE> <BoN> new end <EoN> = <BoN> k end <EoN> * <BoN> S <EoN> . <BoN> Pi <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> new start <EoN> > <BoN> new end <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Union <EoN> ( <BoN> Interval <EoN> ( <BoN> S <EoN> . <BoN> Zero <EoN> , <BoN> new end <EoN> , <BoN> False <EoN> , <BoN> theta <EoN> . <BoN> right open <EoN> ) , <NEWLINE> <BoN> Interval <EoN> ( <BoN> new start <EoN> , <NUMBER> * <BoN> S <EoN> . <BoN> Pi <EoN> , <BoN> theta <EoN> . <BoN> left open <EoN> , <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Interval <EoN> ( <BoN> new start <EoN> , <BoN> new end <EoN> , <BoN> theta <EoN> . <BoN> left open <EoN> , <BoN> theta <EoN> . <BoN> right open <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> theta <EoN> . <BoN> is FiniteSet <EoN> : <NEWLINE> <TAB> <BoN> new theta <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> element <EoN> <BoN> in <EoN> <BoN> theta <EoN> : <NEWLINE> <TAB> <BoN> k <EoN> = <BoN> coeff <EoN> ( <BoN> element <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new theta <EoN> . <BoN> append <EoN> ( <BoN> k <EoN> * <BoN> S <EoN> . <BoN> Pi <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> Finite Set <EoN> ( * <BoN> new theta <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> theta <EoN> . <BoN> is Union <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Union <EoN> ( * [ <BoN> normalize theta set <EoN> ( <BoN> interval <EoN> ) <BoN> for <EoN> <BoN> interval <EoN> <BoN> in <EoN> <BoN> theta <EoN> . <BoN> args <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> theta <EoN> . <BoN> is subset <EoN> ( <BoN> S <EoN> . <BoN> Reals <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> theta <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <BoN> theta <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> needs reindex multi <EoN> ( <BoN> self <EoN> , <BoN> axes <EoN> , <BoN> method <EoN> , <BoN> level <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> partition <EoN> ( <BoN> n <EoN> , <BoN> seq <EoN> , <BoN> pad <EoN> = <BoN> no pad <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> args <EoN> = [ <BoN> iter <EoN> ( <BoN> seq <EoN> ) ] * <BoN> n <EoN> <NEWLINE> <BoN> if <EoN> <BoN> pad <EoN> <BoN> is <EoN> <BoN> no pad <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> zip <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> zip longest <EoN> ( * <BoN> args <EoN> , <BoN> fillvalue <EoN> = <BoN> pad <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add half edge cw <EoN> ( <BoN> self <EoN> , <BoN> start node <EoN> , <BoN> end node <EoN> , <BoN> reference neighbor <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> add edge <EoN> ( <BoN> start node <EoN> , <BoN> end node <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> reference neighbor <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> end node <EoN> ] [ <STRING> ] = <BoN> end node <EoN> <NEWLINE> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> end node <EoN> ] [ <STRING> ] = <BoN> end node <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> nodes <EoN> [ <BoN> start node <EoN> ] [ <STRING> ] = <BoN> end node <EoN> <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> reference neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> [ <BoN> start node <EoN> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Exception <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> cw reference <EoN> = <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> reference neighbor <EoN> ] [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> reference neighbor <EoN> ] [ <STRING> ] = <BoN> end node <EoN> <NEWLINE> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> end node <EoN> ] [ <STRING> ] = <BoN> cw reference <EoN> <NEWLINE> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> cw reference <EoN> ] [ <STRING> ] = <BoN> end node <EoN> <NEWLINE> <BoN> self <EoN> [ <BoN> start node <EoN> ] [ <BoN> end node <EoN> ] [ <STRING> ] = <BoN> reference neighbor <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get metrics <EoN> ( <BoN> self <EoN> , <BoN> font <EoN> , <BoN> font class <EoN> , <BoN> sym <EoN> , <BoN> fontsize <EoN> , <BoN> dpi <EoN> , <BoN> math <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> info <EoN> = <BoN> self <EoN> . <BoN> get info <EoN> ( <BoN> font <EoN> , <BoN> font class <EoN> , <BoN> sym <EoN> , <BoN> fontsize <EoN> , <BoN> dpi <EoN> , <BoN> math <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> info <EoN> . <BoN> metrics <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get fullname <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> name <EoN> = <BoN> self <EoN> . <BoN> header <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> self <EoN> . <BoN> header <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> name <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to excel <EoN> ( <BoN> self <EoN> , <BoN> path <EoN> , <BoN> na rep <EoN> = <STRING> , <BoN> engine <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> io <EoN> . <BoN> excel <EoN> <BoN> import <EoN> <BoN> Excel Writer <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> path <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> writer <EoN> = <BoN> Excel Writer <EoN> ( <BoN> path <EoN> , <BoN> engine <EoN> = <BoN> engine <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> writer <EoN> = <BoN> path <EoN> <NEWLINE> <UNTAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> na rep <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> item <EoN> , <BoN> df <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> iteritems <EoN> ( ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> str <EoN> ( <BoN> item <EoN> ) <NEWLINE> <BoN> df <EoN> . <BoN> to excel <EoN> ( <BoN> writer <EoN> , <BoN> name <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> writer <EoN> . <BoN> save <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reorder categories <EoN> ( <BoN> self <EoN> , <BoN> new categories <EoN> , <BoN> ordered <EoN> = <BoN> None <EoN> , <BoN> inplace <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> inplace <EoN> = <BoN> validate bool kwarg <EoN> ( <BoN> inplace <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> dtype <EoN> . <BoN> categories <EoN> ) != <BoN> set <EoN> ( <BoN> new categories <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> set categories <EoN> ( <BoN> new categories <EoN> , <BoN> ordered <EoN> = <BoN> ordered <EoN> , <NEWLINE> <BoN> inplace <EoN> = <BoN> inplace <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> iterable not string <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> collections <EoN> . <BoN> Iterable <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> string types <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> baseurl <EoN> , <BoN> destpath <EoN> = <BoN> os <EoN> . <BoN> curdir <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> Data Source <EoN> . <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> destpath <EoN> = <BoN> destpath <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> baseurl <EoN> = <BoN> baseurl <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get slice axis <EoN> ( <BoN> self <EoN> , <BoN> slice obj <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> axis <EoN> <BoN> or <EoN> <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> obj <EoN> = <BoN> self <EoN> . <BoN> obj <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> need slice <EoN> ( <BoN> slice obj <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> obj <EoN> . <BoN> copy <EoN> ( <BoN> deep <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> labels <EoN> = <BoN> obj <EoN> . <BoN> get axis <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> indexer <EoN> = <BoN> labels <EoN> . <BoN> slice indexer <EoN> ( <BoN> slice obj <EoN> . <BoN> start <EoN> , <BoN> slice obj <EoN> . <BoN> stop <EoN> , <NEWLINE> <BoN> slice obj <EoN> . <BoN> step <EoN> , <BoN> kind <EoN> = <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> indexer <EoN> , <BoN> slice <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> slice <EoN> ( <BoN> indexer <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> kind <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> obj <EoN> . <BoN> take <EoN> ( <BoN> indexer <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> factorial <EoN> ( <BoN> n <EoN> , <BoN> exact <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> exact <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> ndim <EoN> ( <BoN> n <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> <BoN> else <EoN> <BoN> math <EoN> . <BoN> factorial <EoN> ( <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> asarray <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> un <EoN> = <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> n <EoN> ) . <BoN> astype <EoN> ( <BoN> object <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> un <EoN> [ - <NUMBER> ] > <NUMBER> : <NEWLINE> <TAB> <BoN> dt <EoN> = <BoN> object <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> un <EoN> [ - <NUMBER> ] > <NUMBER> : <NEWLINE> <TAB> <BoN> dt <EoN> = <BoN> np <EoN> . <BoN> int 64 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dt <EoN> = <BoN> np <EoN> . <BoN> int <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> empty like <EoN> ( <BoN> n <EoN> , <BoN> dtype <EoN> = <BoN> dt <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> un <EoN> = <BoN> un <EoN> [ <BoN> un <EoN> > <NUMBER> ] <NEWLINE> <BoN> out <EoN> [ <BoN> n <EoN> < <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> out <EoN> [ <BoN> n <EoN> < <NUMBER> ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> un <EoN> . <BoN> size <EoN> : <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> math <EoN> . <BoN> factorial <EoN> ( <BoN> un <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> out <EoN> [ <BoN> n <EoN> == <BoN> un <EoN> [ <NUMBER> ] ] = <BoN> val <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> len <EoN> ( <BoN> un <EoN> ) - <NUMBER> ) : <NEWLINE> <TAB> <BoN> prev <EoN> = <BoN> un <EoN> [ <BoN> i <EoN> ] + <NUMBER> <NEWLINE> <BoN> current <EoN> = <BoN> un <EoN> [ <BoN> i <EoN> + <NUMBER> ] <NEWLINE> <BoN> val <EoN> *= <BoN> range prod <EoN> ( <BoN> prev <EoN> , <BoN> current <EoN> ) <NEWLINE> <BoN> out <EoN> [ <BoN> n <EoN> == <BoN> current <EoN> ] = <BoN> val <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> asarray <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> vals <EoN> = <BoN> gamma <EoN> ( <BoN> n <EoN> + <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> where <EoN> ( <BoN> n <EoN> >= <NUMBER> , <BoN> vals <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> label <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Label <EoN> ( <BoN> name <EoN> , <BoN> self <EoN> , <BoN> self <EoN> . <BoN> type <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reshape <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> reshape <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hard sigmoid <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Hard Sigmoid <EoN> ( ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> remove <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> ax <EoN> . <BoN> figure <EoN> . <BoN> callbacks <EoN> . <BoN> disconnect <EoN> ( <BoN> self <EoN> . <BoN> cid <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> cid <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> mcollections <EoN> . <BoN> Poly Collection <EoN> . <BoN> remove <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> array wrap <EoN> ( <BoN> self <EoN> , <BoN> result <EoN> , <BoN> context <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> result <EoN> , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> index <EoN> , <NEWLINE> <BoN> copy <EoN> = <BoN> False <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> mark Inputline <EoN> ( <BoN> self <EoN> , <BoN> marker String <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> line str <EoN> = <BoN> self <EoN> . <BoN> line <EoN> <NEWLINE> <BoN> line column <EoN> = <BoN> self <EoN> . <BoN> column <EoN> - <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> marker String <EoN> : <NEWLINE> <TAB> <BoN> line str <EoN> = <STRING> . <BoN> join <EoN> ( ( <BoN> line str <EoN> [ : <BoN> line column <EoN> ] , <NEWLINE> <BoN> marker String <EoN> , <BoN> line str <EoN> [ <BoN> line column <EoN> : ] ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> line str <EoN> . <BoN> strip <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> diric <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> , <BoN> n <EoN> = <BoN> asarray <EoN> ( <BoN> x <EoN> ) , <BoN> asarray <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> asarray <EoN> ( <BoN> n <EoN> + ( <BoN> x <EoN> - <BoN> x <EoN> ) ) <NEWLINE> <BoN> x <EoN> = <BoN> asarray <EoN> ( <BoN> x <EoN> + ( <BoN> n <EoN> - <BoN> n <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> issubdtype <EoN> ( <BoN> x <EoN> . <BoN> dtype <EoN> , <BoN> inexact <EoN> ) : <NEWLINE> <TAB> <BoN> ytype <EoN> = <BoN> x <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ytype <EoN> = <BoN> float <EoN> <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> zeros <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> , <BoN> ytype <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> finfo <EoN> ( <BoN> ytype <EoN> ) . <BoN> eps <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> minval <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> np <EoN> . <BoN> finfo <EoN> ( <BoN> ytype <EoN> ) . <BoN> eps <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> minval <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> minval <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> mask 1 <EoN> = ( <BoN> n <EoN> <= <NUMBER> ) | ( <BoN> n <EoN> != <BoN> floor <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <BoN> place <EoN> ( <BoN> y <EoN> , <BoN> mask 1 <EoN> , <BoN> nan <EoN> ) <NEWLINE> <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> / <NUMBER> <NEWLINE> <BoN> denom <EoN> = <BoN> sin <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> mask 2 <EoN> = ( <NUMBER> - <BoN> mask 1 <EoN> ) & ( <BoN> abs <EoN> ( <BoN> denom <EoN> ) < <BoN> minval <EoN> ) <NEWLINE> <BoN> xsub <EoN> = <BoN> extract <EoN> ( <BoN> mask 2 <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> nsub <EoN> = <BoN> extract <EoN> ( <BoN> mask 2 <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> zsub <EoN> = <BoN> xsub <EoN> / <BoN> pi <EoN> <NEWLINE> <BoN> place <EoN> ( <BoN> y <EoN> , <BoN> mask 2 <EoN> , <BoN> pow <EoN> ( - <NUMBER> , <BoN> np <EoN> . <BoN> round <EoN> ( <BoN> zsub <EoN> ) * ( <BoN> nsub <EoN> - <NUMBER> ) ) ) <NEWLINE> <NEWLINE> <BoN> mask <EoN> = ( <NUMBER> - <BoN> mask 1 <EoN> ) & ( <NUMBER> - <BoN> mask 2 <EoN> ) <NEWLINE> <BoN> xsub <EoN> = <BoN> extract <EoN> ( <BoN> mask <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> nsub <EoN> = <BoN> extract <EoN> ( <BoN> mask <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> dsub <EoN> = <BoN> extract <EoN> ( <BoN> mask <EoN> , <BoN> denom <EoN> ) <NEWLINE> <BoN> place <EoN> ( <BoN> y <EoN> , <BoN> mask <EoN> , <BoN> sin <EoN> ( <BoN> nsub <EoN> * <BoN> xsub <EoN> ) / ( <BoN> nsub <EoN> * <BoN> dsub <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> serialize <EoN> ( <BoN> self <EoN> , <BoN> serializer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> t <EoN> = <BoN> serializer <EoN> ( <STRING> , <BoN> self <EoN> . <BoN> t <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> state <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> serializer <EoN> , <BoN> serializer module <EoN> . <BoN> Deserializer <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> state <EoN> = { } <NEWLINE> <BoN> self copy <EoN> = <BoN> copy <EoN> . <BoN> copy <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> arr <EoN> = <BoN> numpy <EoN> . <BoN> empty <EoN> ( <NUMBER> , <BoN> dtype <EoN> = <BoN> numpy <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> self copy <EoN> . <BoN> init state <EoN> ( <BoN> variable <EoN> . <BoN> Variable <EoN> ( <BoN> arr <EoN> , <BoN> grad <EoN> = <BoN> arr <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> serializer <EoN> ( <BoN> key <EoN> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> enabled <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> value <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> state <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> state <EoN> [ <BoN> key <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> state <EoN> [ <BoN> key <EoN> ] = <BoN> serializer <EoN> ( <BoN> key <EoN> , <BoN> self <EoN> . <BoN> state <EoN> [ <BoN> key <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max pool 3 d grad grad eager fallback <EoN> ( <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> , <BoN> ksize <EoN> , <BoN> strides <EoN> , <BoN> padding <EoN> , <BoN> data format <EoN> = <STRING> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> ksize <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> ksize <EoN> ) <NEWLINE> <UNTAB> <BoN> ksize <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> ksize <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> strides <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> strides <EoN> ) <NEWLINE> <UNTAB> <BoN> strides <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> strides <EoN> ] <NEWLINE> <BoN> padding <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> padding <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> data format <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data format <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> data format <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> data format <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> ( <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> ksize <EoN> , <STRING> , <BoN> strides <EoN> , <STRING> , <BoN> padding <EoN> , <NEWLINE> <STRING> , <BoN> data format <EoN> , <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> full rary tree <EoN> ( <BoN> r <EoN> , <BoN> n <EoN> , <BoN> create using <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> = <BoN> empty graph <EoN> ( <BoN> n <EoN> , <BoN> create using <EoN> ) <NEWLINE> <BoN> G <EoN> . <BoN> add edges from <EoN> ( <BoN> tree edges <EoN> ( <BoN> n <EoN> , <BoN> r <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> as strided <EoN> ( <BoN> x <EoN> , <BoN> shape <EoN> = <BoN> None <EoN> , <BoN> strides <EoN> = <BoN> None <EoN> , <BoN> subok <EoN> = <BoN> False <EoN> , <BoN> writeable <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> x <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> , <BoN> subok <EoN> = <BoN> subok <EoN> ) <NEWLINE> <BoN> interface <EoN> = <BoN> dict <EoN> ( <BoN> x <EoN> . <BoN> array interface <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> shape <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> interface <EoN> [ <STRING> ] = <BoN> tuple <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> strides <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> interface <EoN> [ <STRING> ] = <BoN> tuple <EoN> ( <BoN> strides <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> array <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> Dummy Array <EoN> ( <BoN> interface <EoN> , <BoN> base <EoN> = <BoN> x <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> array <EoN> . <BoN> dtype <EoN> = <BoN> x <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> view <EoN> = <BoN> maybe view as subclass <EoN> ( <BoN> x <EoN> , <BoN> array <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> view <EoN> . <BoN> flags <EoN> . <BoN> writeable <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> writeable <EoN> : <NEWLINE> <TAB> <BoN> view <EoN> . <BoN> flags <EoN> . <BoN> writeable <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> view <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> len <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> codes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> could be isomorphic <EoN> ( <BoN> G 1 <EoN> , <BoN> G 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> G 1 <EoN> . <BoN> order <EoN> ( ) != <BoN> G 2 <EoN> . <BoN> order <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> d 1 <EoN> = <BoN> G 1 <EoN> . <BoN> degree <EoN> ( ) <NEWLINE> <BoN> t 1 <EoN> = <BoN> nx <EoN> . <BoN> triangles <EoN> ( <BoN> G 1 <EoN> ) <NEWLINE> <BoN> c 1 <EoN> = <BoN> nx <EoN> . <BoN> number of cliques <EoN> ( <BoN> G 1 <EoN> ) <NEWLINE> <BoN> props 1 <EoN> = [ [ <BoN> d <EoN> , <BoN> t 1 <EoN> [ <BoN> v <EoN> ] , <BoN> c 1 <EoN> [ <BoN> v <EoN> ] ] <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> d 1 <EoN> ] <NEWLINE> <BoN> props 1 <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> d 2 <EoN> = <BoN> G 2 <EoN> . <BoN> degree <EoN> ( ) <NEWLINE> <BoN> t 2 <EoN> = <BoN> nx <EoN> . <BoN> triangles <EoN> ( <BoN> G 2 <EoN> ) <NEWLINE> <BoN> c 2 <EoN> = <BoN> nx <EoN> . <BoN> number of cliques <EoN> ( <BoN> G 2 <EoN> ) <NEWLINE> <BoN> props 2 <EoN> = [ [ <BoN> d <EoN> , <BoN> t 2 <EoN> [ <BoN> v <EoN> ] , <BoN> c 2 <EoN> [ <BoN> v <EoN> ] ] <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> d 2 <EoN> ] <NEWLINE> <BoN> props 2 <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> props 1 <EoN> != <BoN> props 2 <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reset defaults <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mpl <EoN> . <BoN> rc Params <EoN> . <BoN> update <EoN> ( <BoN> mpl <EoN> . <BoN> rc Params Default <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> prewitt <EoN> ( <BoN> image <EoN> , <BoN> mask <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert nD <EoN> ( <BoN> image <EoN> , <NUMBER> ) <NEWLINE> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> prewitt h <EoN> ( <BoN> image <EoN> , <BoN> mask <EoN> ) ** <NUMBER> + <BoN> prewitt v <EoN> ( <BoN> image <EoN> , <BoN> mask <EoN> ) ** <NUMBER> ) <NEWLINE> <BoN> out <EoN> /= <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> convert <EoN> ( <BoN> a <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Coercion Failed <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shift <EoN> ( <BoN> self <EoN> , <BoN> periods <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> mgr <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new values <EoN> , <BoN> fill value <EoN> = <BoN> maybe upcast <EoN> ( <BoN> self <EoN> . <BoN> values <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> f ordered <EoN> = <BoN> new values <EoN> . <BoN> flags <EoN> . <BoN> f contiguous <EoN> <NEWLINE> <BoN> if <EoN> <BoN> f ordered <EoN> : <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> new values <EoN> . <BoN> T <EoN> <NEWLINE> <BoN> axis <EoN> = <BoN> new values <EoN> . <BoN> ndim <EoN> - <BoN> axis <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> new values <EoN> . <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> np <EoN> . <BoN> roll <EoN> ( <BoN> new values <EoN> , <BoN> ensure platform int <EoN> ( <BoN> periods <EoN> ) , <NEWLINE> <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> axis indexer <EoN> = [ <BoN> slice <EoN> ( <BoN> None <EoN> ) ] * <BoN> self <EoN> . <BoN> ndim <EoN> <NEWLINE> <BoN> if <EoN> <BoN> periods <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> axis indexer <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <BoN> None <EoN> , <BoN> periods <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axis indexer <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <BoN> periods <EoN> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> new values <EoN> [ <BoN> tuple <EoN> ( <BoN> axis indexer <EoN> ) ] = <BoN> fill value <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> f ordered <EoN> : <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> new values <EoN> . <BoN> T <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> [ <BoN> self <EoN> . <BoN> make block <EoN> ( <BoN> new values <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> construct doc <EoN> ( <BoN> self <EoN> , <BoN> docdict <EoN> , <BoN> shapes vals <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tempdict <EoN> = <BoN> docdict <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> tempdict <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> name <EoN> <BoN> or <EoN> <STRING> <NEWLINE> <BoN> tempdict <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> shapes <EoN> <BoN> or <EoN> <STRING> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> shapes vals <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shapes vals <EoN> = ( ) <NEWLINE> <UNTAB> <BoN> vals <EoN> = <STRING> . <BoN> join <EoN> ( <STRING> % <BoN> val <EoN> <BoN> for <EoN> <BoN> val <EoN> <BoN> in <EoN> <BoN> shapes vals <EoN> ) <NEWLINE> <BoN> tempdict <EoN> [ <STRING> ] = <BoN> vals <EoN> <NEWLINE> <NEWLINE> <BoN> tempdict <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> shapes <EoN> <BoN> or <EoN> <STRING> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shapes <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> numargs <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> tempdict <EoN> [ <STRING> ] += <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shapes <EoN> : <NEWLINE> <TAB> <BoN> tempdict <EoN> [ <STRING> ] = <STRING> % ( <BoN> self <EoN> . <BoN> shapes <EoN> , <BoN> vals <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> tempdict <EoN> [ <STRING> ] = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shapes <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> item <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> tempdict <EoN> [ <BoN> item <EoN> ] = <BoN> tempdict <EoN> [ <BoN> item <EoN> ] . <BoN> replace <EoN> ( <NEWLINE> <STRING> , <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shapes <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> doc <EoN> = <BoN> self <EoN> . <BoN> doc <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> doc <EoN> = <BoN> doccer <EoN> . <BoN> docformat <EoN> ( <BoN> self <EoN> . <BoN> doc <EoN> , <BoN> tempdict <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> doc <EoN> = <BoN> self <EoN> . <BoN> doc <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Unimplemented Error <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> , <NEWLINE> <BoN> UNIMPLEMENTE D <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> constructor <EoN> <NEWLINE> <BoN> def <EoN> <BoN> zeros like <EoN> ( <BoN> model <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> opt <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> model <EoN> . <BoN> type <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <BoN> ret <EoN> = <BoN> constant <EoN> ( <NUMBER> , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> opt <EoN> <BoN> and <EoN> <BoN> ret <EoN> . <BoN> type <EoN> == <BoN> model <EoN> . <BoN> type <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> fill <EoN> ( <BoN> model <EoN> , <BoN> ret <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf sub ground <EoN> ( <BoN> f <EoN> , <BoN> a <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = - <BoN> a <EoN> % <BoN> p <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = ( <BoN> f <EoN> [ - <NUMBER> ] - <BoN> a <EoN> ) % <BoN> p <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> f <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> [ : - <NUMBER> ] + [ <BoN> a <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> a <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> a <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> generative <EoN> <NEWLINE> <BoN> def <EoN> <BoN> having <EoN> ( <BoN> self <EoN> , <BoN> having <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> append having <EoN> ( <BoN> having <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> model fn from saved model <EoN> ( <BoN> self <EoN> , <BoN> features <EoN> , <BoN> labels <EoN> , <BoN> mode <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> validate mode <EoN> ( <BoN> mode <EoN> ) <NEWLINE> <NEWLINE> <BoN> g <EoN> = <BoN> ops <EoN> . <BoN> get default graph <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> training util <EoN> . <BoN> get global step <EoN> ( <BoN> g <EoN> ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> signature def <EoN> = <BoN> self <EoN> . <BoN> get signature def for mode <EoN> ( <BoN> mode <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> input map <EoN> = <BoN> generate input map <EoN> ( <BoN> signature def <EoN> , <BoN> features <EoN> , <BoN> labels <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> output tensor names <EoN> = [ <NEWLINE> <BoN> value <EoN> . <BoN> name <EoN> <BoN> for <EoN> <BoN> value <EoN> <BoN> in <EoN> <BoN> six <EoN> . <BoN> itervalues <EoN> ( <BoN> signature def <EoN> . <BoN> outputs <EoN> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> tags <EoN> = <BoN> model fn lib <EoN> . <BoN> EXPORT TAG MAP <EoN> [ <BoN> mode <EoN> ] <NEWLINE> <BoN> <EoN> , <BoN> output tensors <EoN> = <BoN> self <EoN> . <BoN> saved model loader <EoN> . <BoN> load graph <EoN> ( <NEWLINE> <BoN> g <EoN> , <BoN> tags <EoN> , <BoN> input map <EoN> = <BoN> input map <EoN> , <BoN> return elements <EoN> = <BoN> output tensor names <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> scaffold <EoN> = <BoN> monitored session <EoN> . <BoN> Scaffold <EoN> ( <NEWLINE> <BoN> local init op <EoN> = <BoN> loader impl <EoN> . <BoN> get main op tensor <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> get meta graph def for mode <EoN> ( <BoN> mode <EoN> ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> global step tensor <EoN> = <BoN> training util <EoN> . <BoN> get global step <EoN> ( <BoN> g <EoN> ) <NEWLINE> <BoN> training util <EoN> . <BoN> assert global step <EoN> ( <BoN> global step tensor <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> output map <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> output tensor names <EoN> , <BoN> output tensors <EoN> ) ) <NEWLINE> <BoN> outputs <EoN> = { <BoN> key <EoN> : <BoN> output map <EoN> [ <BoN> value <EoN> . <BoN> name <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> six <EoN> . <BoN> iteritems <EoN> ( <BoN> signature def <EoN> . <BoN> outputs <EoN> ) } <NEWLINE> <NEWLINE> <BoN> loss <EoN> , <BoN> predictions <EoN> , <BoN> metrics <EoN> = <BoN> validate and extract outputs <EoN> ( <NEWLINE> <BoN> mode <EoN> , <BoN> outputs <EoN> , <BoN> signature def <EoN> . <BoN> method name <EoN> ) <NEWLINE> <NEWLINE> <BoN> train op <EoN> = <BoN> ops <EoN> . <BoN> get collection <EoN> ( <BoN> constants <EoN> . <BoN> TRAIN OP KEY <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> train op <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> train op <EoN> = <BoN> None <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> train op <EoN> <BoN> else <EoN> <BoN> train op <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> clear saved model collections <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> model fn lib <EoN> . <BoN> Estimator Spec <EoN> ( <NEWLINE> <BoN> scaffold <EoN> = <BoN> scaffold <EoN> , <NEWLINE> <BoN> mode <EoN> = <BoN> mode <EoN> , <NEWLINE> <BoN> loss <EoN> = <BoN> loss <EoN> , <NEWLINE> <BoN> train op <EoN> = <BoN> train op <EoN> , <NEWLINE> <BoN> predictions <EoN> = <BoN> predictions <EoN> , <NEWLINE> <BoN> eval metric ops <EoN> = <BoN> metrics <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save <EoN> ( <BoN> self <EoN> , <BoN> filepath <EoN> , <BoN> overwrite <EoN> = <BoN> True <EoN> , <BoN> include optimizer <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is graph network <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> from <EoN> <BoN> tensorflow <EoN> . <BoN> python <EoN> . <BoN> keras <EoN> . <BoN> models <EoN> <BoN> import <EoN> <BoN> save model <EoN> <NEWLINE> <BoN> save model <EoN> ( <BoN> self <EoN> , <BoN> filepath <EoN> , <BoN> overwrite <EoN> , <BoN> include optimizer <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp convert <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K 0 <EoN> , <BoN> K 1 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> u <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dup convert <EoN> ( <BoN> f <EoN> , <BoN> K 0 <EoN> , <BoN> K 1 <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> K 0 <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> K 0 <EoN> == <BoN> K 1 <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> v <EoN> = <BoN> u <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dmp strip <EoN> ( [ <BoN> dmp convert <EoN> ( <BoN> c <EoN> , <BoN> v <EoN> , <BoN> K 0 <EoN> , <BoN> K 1 <EoN> ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> f <EoN> ] , <BoN> u <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> row del <EoN> ( <BoN> self <EoN> , <BoN> row <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> row <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> row <EoN> += <BoN> self <EoN> . <BoN> rows <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <NUMBER> <= <BoN> row <EoN> < <BoN> self <EoN> . <BoN> rows <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> row <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval row del <EoN> ( <BoN> row <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tan <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> tan <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> remove redundancy dense <EoN> ( <BoN> A <EoN> , <BoN> rhs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tolapiv <EoN> = <NUMBER> <NEWLINE> <BoN> tolprimal <EoN> = <NUMBER> <NEWLINE> <BoN> status <EoN> = <NUMBER> <NEWLINE> <BoN> message <EoN> = <STRING> <NEWLINE> <BoN> inconsistent <EoN> = ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> A <EoN> , <BoN> rhs <EoN> , <BoN> status <EoN> , <BoN> message <EoN> = <BoN> remove zero rows <EoN> ( <BoN> A <EoN> , <BoN> rhs <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> status <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> A <EoN> , <BoN> rhs <EoN> , <BoN> status <EoN> , <BoN> message <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> m <EoN> , <BoN> n <EoN> = <BoN> A <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> v <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> m <EoN> ) ) <NEWLINE> <BoN> b <EoN> = <BoN> list <EoN> ( <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> k <EoN> = <BoN> set <EoN> ( <BoN> range <EoN> ( <BoN> m <EoN> , <BoN> m <EoN> + <BoN> n <EoN> ) ) <NEWLINE> <BoN> d <EoN> = [ ] <NEWLINE> <BoN> lu <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> perm r <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> A orig <EoN> = <BoN> A <EoN> <NEWLINE> <BoN> A <EoN> = <BoN> np <EoN> . <BoN> hstack <EoN> ( ( <BoN> np <EoN> . <BoN> eye <EoN> ( <BoN> m <EoN> ) , <BoN> A <EoN> ) ) <NEWLINE> <BoN> e <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> m <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> B <EoN> = <BoN> A <EoN> [ : , <BoN> b <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> v <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> e <EoN> [ <BoN> i <EoN> ] = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> e <EoN> [ <BoN> i <EoN> - <NUMBER> ] = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> j <EoN> = <BoN> b <EoN> [ <BoN> i <EoN> - <NUMBER> ] <NEWLINE> <BoN> lu <EoN> = <BoN> bg update dense <EoN> ( <BoN> lu <EoN> , <BoN> perm r <EoN> , <BoN> A <EoN> [ : , <BoN> j <EoN> ] , <BoN> i <EoN> - <NUMBER> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> lu <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> lu factor <EoN> ( <BoN> B <EoN> ) <NEWLINE> <BoN> L U <EoN> , <BoN> p <EoN> = <BoN> lu <EoN> <NEWLINE> <BoN> perm r <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> m <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i 1 <EoN> , <BoN> i 2 <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> p <EoN> ) : <NEWLINE> <TAB> <BoN> perm r <EoN> [ <BoN> i 1 <EoN> ] , <BoN> perm r <EoN> [ <BoN> i 2 <EoN> ] = <BoN> perm r <EoN> [ <BoN> i 2 <EoN> ] , <BoN> perm r <EoN> [ <BoN> i 1 <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> pi <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> lu solve <EoN> ( <BoN> lu <EoN> , <BoN> e <EoN> , <BoN> trans <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> js <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> list <EoN> ( <BoN> k <EoN> - <BoN> set <EoN> ( <BoN> b <EoN> ) ) ) <NEWLINE> <BoN> batch <EoN> = <NUMBER> <NEWLINE> <BoN> dependent <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> j index <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> len <EoN> ( <BoN> js <EoN> ) , <BoN> batch <EoN> ) : <NEWLINE> <TAB> <BoN> j indices <EoN> = <BoN> js <EoN> [ <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> j index <EoN> , <BoN> min <EoN> ( <BoN> j index <EoN> + <BoN> batch <EoN> , <BoN> len <EoN> ( <BoN> js <EoN> ) ) ) ] <NEWLINE> <NEWLINE> <BoN> c <EoN> = <BoN> abs <EoN> ( <BoN> A <EoN> [ : , <BoN> j indices <EoN> ] . <BoN> transpose <EoN> ( ) . <BoN> dot <EoN> ( <BoN> pi <EoN> ) ) <NEWLINE> <BoN> if <EoN> ( <BoN> c <EoN> > <BoN> tolapiv <EoN> ) . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> j <EoN> = <BoN> js <EoN> [ <BoN> j index <EoN> + <BoN> np <EoN> . <BoN> argmax <EoN> ( <BoN> c <EoN> ) ] <NEWLINE> <BoN> B <EoN> [ : , <BoN> i <EoN> ] = <BoN> A <EoN> [ : , <BoN> j <EoN> ] <NEWLINE> <BoN> b <EoN> [ <BoN> i <EoN> ] = <BoN> j <EoN> <NEWLINE> <BoN> dependent <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> dependent <EoN> : <NEWLINE> <TAB> <BoN> bibar <EoN> = <BoN> pi <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> rhs <EoN> . <BoN> reshape <EoN> ( - <NUMBER> , <NUMBER> ) ) <NEWLINE> <BoN> bnorm <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> rhs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> bibar <EoN> ) / ( <NUMBER> + <BoN> bnorm <EoN> ) > <BoN> tolprimal <EoN> : <NEWLINE> <TAB> <BoN> status <EoN> = <NUMBER> <NEWLINE> <BoN> message <EoN> = <BoN> inconsistent <EoN> <NEWLINE> <BoN> return <EoN> <BoN> A orig <EoN> , <BoN> rhs <EoN> , <BoN> status <EoN> , <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> keep <EoN> = <BoN> set <EoN> ( <BoN> range <EoN> ( <BoN> m <EoN> ) ) <NEWLINE> <BoN> keep <EoN> = <BoN> list <EoN> ( <BoN> keep <EoN> - <BoN> set <EoN> ( <BoN> d <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> A orig <EoN> [ <BoN> keep <EoN> , : ] , <BoN> rhs <EoN> [ <BoN> keep <EoN> ] , <BoN> status <EoN> , <BoN> message <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set text position <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> bbox <EoN> = <BoN> self <EoN> . <BoN> get window extent <EoN> ( <BoN> renderer <EoN> ) <NEWLINE> <BoN> l <EoN> , <BoN> b <EoN> , <BoN> w <EoN> , <BoN> h <EoN> = <BoN> bbox <EoN> . <BoN> bounds <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> text <EoN> . <BoN> set verticalalignment <EoN> ( <STRING> ) <NEWLINE> <BoN> y <EoN> = <BoN> b <EoN> + ( <BoN> h <EoN> / <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> loc <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> text <EoN> . <BoN> set horizontalalignment <EoN> ( <STRING> ) <NEWLINE> <BoN> x <EoN> = <BoN> l <EoN> + ( <BoN> w <EoN> / <NUMBER> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> loc <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> text <EoN> . <BoN> set horizontalalignment <EoN> ( <STRING> ) <NEWLINE> <BoN> x <EoN> = <BoN> l <EoN> + ( <BoN> w <EoN> * <BoN> self <EoN> . <BoN> PA D <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> text <EoN> . <BoN> set horizontalalignment <EoN> ( <STRING> ) <NEWLINE> <BoN> x <EoN> = <BoN> l <EoN> + ( <BoN> w <EoN> * ( <NUMBER> - <BoN> self <EoN> . <BoN> PA D <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> text <EoN> . <BoN> set position <EoN> ( ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> make node <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> splits <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> as tensor variable <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> axis <EoN> = <BoN> as tensor variable <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> splits <EoN> = <BoN> as tensor variable <EoN> ( <BoN> splits <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> splits <EoN> . <BoN> type <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> int vector types <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> , <NEWLINE> <BoN> splits <EoN> . <BoN> type <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> . <BoN> type <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> int types <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> , <BoN> axis <EoN> . <BoN> type <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> inputs <EoN> = [ <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> splits <EoN> ] <NEWLINE> <BoN> outputs <EoN> = [ <BoN> x <EoN> . <BoN> type <EoN> ( ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> self <EoN> . <BoN> len splits <EoN> ) ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Apply <EoN> ( <BoN> self <EoN> , <BoN> inputs <EoN> , <BoN> outputs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> unicode <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> object <EoN> . <BoN> repr <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call and shelve <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> <EoN> , <BoN> args id <EoN> , <BoN> metadata <EoN> = <BoN> self <EoN> . <BoN> cached call <EoN> ( <BoN> args <EoN> , <BoN> kwargs <EoN> , <BoN> shelving <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Memorized Result <EoN> ( <BoN> self <EoN> . <BoN> store backend <EoN> , <BoN> self <EoN> . <BoN> func <EoN> , <BoN> args id <EoN> , <NEWLINE> <BoN> metadata <EoN> = <BoN> metadata <EoN> , <BoN> verbose <EoN> = <BoN> self <EoN> . <BoN> verbose <EoN> - <NUMBER> , <NEWLINE> <BoN> timestamp <EoN> = <BoN> self <EoN> . <BoN> timestamp <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> views <EoN> [ <BoN> self <EoN> . <BoN> figure <EoN> ] . <BoN> forward <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> positions <EoN> [ <BoN> self <EoN> . <BoN> figure <EoN> ] . <BoN> forward <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> negative <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> two hop succ <EoN> ( <BoN> self <EoN> , <BoN> Gx <EoN> , <BoN> Gx node <EoN> , <BoN> core x <EoN> , <BoN> succ <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> all <EoN> ( <BoN> self <EoN> . <BoN> one hop <EoN> ( <BoN> Gx <EoN> , <BoN> s <EoN> , <BoN> core x <EoN> , <BoN> self <EoN> . <BoN> preds <EoN> ( <BoN> Gx <EoN> , <BoN> core x <EoN> , <BoN> s <EoN> , <BoN> Gx node <EoN> ) , <BoN> self <EoN> . <BoN> succs <EoN> ( <BoN> Gx <EoN> , <BoN> core x <EoN> , <BoN> s <EoN> ) ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> succ <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> format exitcodes <EoN> ( <BoN> exitcodes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> str exitcodes <EoN> = [ <STRING> . <BoN> format <EoN> ( <BoN> get exitcode name <EoN> ( <BoN> e <EoN> ) , <BoN> e <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> exitcodes <EoN> <BoN> if <EoN> <BoN> e <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> return <EoN> <STRING> + <STRING> . <BoN> join <EoN> ( <BoN> str exitcodes <EoN> ) + <STRING> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Affine 2 D Base <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> mtx <EoN> = <BoN> other <EoN> . <BoN> get matrix <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> invalidate <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set label position <EoN> ( <BoN> self <EoN> , <BoN> position <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> position <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> label <EoN> . <BoN> set verticalalignment <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> position <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> label <EoN> . <BoN> set verticalalignment <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> label position <EoN> = <BoN> position <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tick params <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> = <STRING> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> xkw <EoN> = <BoN> dict <EoN> ( <BoN> kwargs <EoN> ) <NEWLINE> <BoN> xkw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> xkw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> xkw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> xkw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> xaxis <EoN> . <BoN> set tick params <EoN> ( ** <BoN> xkw <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> ykw <EoN> = <BoN> dict <EoN> ( <BoN> kwargs <EoN> ) <NEWLINE> <BoN> ykw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> ykw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> ykw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> ykw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> yaxis <EoN> . <BoN> set tick params <EoN> ( ** <BoN> ykw <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> multinomial loss <EoN> ( <BoN> w <EoN> , <BoN> X <EoN> , <BoN> Y <EoN> , <BoN> alpha <EoN> , <BoN> sample weight <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n classes <EoN> = <BoN> Y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> n features <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> fit intercept <EoN> = <BoN> w <EoN> . <BoN> size <EoN> == ( <BoN> n classes <EoN> * ( <BoN> n features <EoN> + <NUMBER> ) ) <NEWLINE> <BoN> w <EoN> = <BoN> w <EoN> . <BoN> reshape <EoN> ( <BoN> n classes <EoN> , - <NUMBER> ) <NEWLINE> <BoN> sample weight <EoN> = <BoN> sample weight <EoN> [ : , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> fit intercept <EoN> : <NEWLINE> <TAB> <BoN> intercept <EoN> = <BoN> w <EoN> [ : , - <NUMBER> ] <NEWLINE> <BoN> w <EoN> = <BoN> w <EoN> [ : , : - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> intercept <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> safe sparse dot <EoN> ( <BoN> X <EoN> , <BoN> w <EoN> . <BoN> T <EoN> ) <NEWLINE> <BoN> p <EoN> += <BoN> intercept <EoN> <NEWLINE> <BoN> p <EoN> -= <BoN> logsumexp <EoN> ( <BoN> p <EoN> , <BoN> axis <EoN> = <NUMBER> ) [ : , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> loss <EoN> = - ( <BoN> sample weight <EoN> * <BoN> Y <EoN> * <BoN> p <EoN> ) . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> loss <EoN> += <NUMBER> * <BoN> alpha <EoN> * <BoN> squared norm <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> p <EoN> = <BoN> np <EoN> . <BoN> exp <EoN> ( <BoN> p <EoN> , <BoN> p <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> loss <EoN> , <BoN> p <EoN> , <BoN> w <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as default <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> ops <EoN> . <BoN> default session <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get xaxis transform <EoN> ( <BoN> self <EoN> , <BoN> which <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> xaxis transform <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> spines <EoN> [ <STRING> ] . <BoN> get spine transform <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> spines <EoN> [ <STRING> ] . <BoN> get spine transform <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> = - <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> preread check <EoN> ( ) <NEWLINE> <BoN> with <EoN> <BoN> errors <EoN> . <BoN> raise exception on not ok status <EoN> ( ) <BoN> as <EoN> <BoN> status <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n <EoN> == - <NUMBER> : <NEWLINE> <TAB> <BoN> length <EoN> = <BoN> self <EoN> . <BoN> size <EoN> ( ) - <BoN> self <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> length <EoN> = <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> prepare value <EoN> ( <NEWLINE> <BoN> pywrap tensorflow <EoN> . <BoN> Read From Stream <EoN> ( <BoN> self <EoN> . <BoN> read buf <EoN> , <BoN> length <EoN> , <BoN> status <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample gamma <EoN> ( <BoN> alpha <EoN> = <BoN> None <EoN> , <BoN> beta <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> radius neighbors <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> radius <EoN> = <BoN> None <EoN> , <BoN> return distance <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> radius <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> radius <EoN> = <BoN> self <EoN> . <BoN> radius <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> X <EoN> = <BoN> check array <EoN> ( <BoN> X <EoN> , <BoN> accept sparse <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> neighbors <EoN> , <BoN> distances <EoN> = [ ] , [ ] <NEWLINE> <BoN> bin queries <EoN> , <BoN> max depth <EoN> = <BoN> self <EoN> . <BoN> query <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) : <NEWLINE> <NEWLINE> <TAB> <BoN> neighs <EoN> , <BoN> dists <EoN> = <BoN> self <EoN> . <BoN> get radius neighbors <EoN> ( <BoN> X <EoN> [ [ <BoN> i <EoN> ] ] , <BoN> max depth <EoN> [ <BoN> i <EoN> ] , <NEWLINE> <BoN> bin queries <EoN> [ <BoN> i <EoN> ] , <BoN> radius <EoN> ) <NEWLINE> <BoN> neighbors <EoN> . <BoN> append <EoN> ( <BoN> neighs <EoN> ) <NEWLINE> <BoN> distances <EoN> . <BoN> append <EoN> ( <BoN> dists <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> return distance <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array of arrays <EoN> ( <BoN> distances <EoN> ) , <BoN> array of arrays <EoN> ( <BoN> neighbors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array of arrays <EoN> ( <BoN> neighbors <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> context <EoN> ( ) . <BoN> executing eagerly <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> v measure score <EoN> ( <BoN> labels true <EoN> , <BoN> labels pred <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> homogeneity completeness v measure <EoN> ( <BoN> labels true <EoN> , <BoN> labels pred <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> atexit print fn <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> config <EoN> . <BoN> profile <EoN> : <NEWLINE> <TAB> <BoN> to sum <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> destination <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> destination file <EoN> = <BoN> sys <EoN> . <BoN> stderr <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> destination <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> destination file <EoN> = <BoN> sys <EoN> . <BoN> stdout <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> destination file <EoN> = <BoN> open <EoN> ( <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> destination <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> ps <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> atexit print list <EoN> , <NEWLINE> <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> a <EoN> : <BoN> a <EoN> . <BoN> compile time <EoN> + <BoN> a <EoN> . <BoN> fct call time <EoN> ) [ : : - <NUMBER> ] : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> ps <EoN> . <BoN> fct callcount <EoN> >= <NUMBER> <BoN> or <EoN> <BoN> ps <EoN> . <BoN> compile time <EoN> > <NUMBER> <BoN> or <EoN> <NEWLINE> <BoN> getattr <EoN> ( <BoN> ps <EoN> , <STRING> , <NUMBER> ) > <NUMBER> ) : <NEWLINE> <TAB> <BoN> ps <EoN> . <BoN> summary <EoN> ( <BoN> file <EoN> = <BoN> destination file <EoN> , <NEWLINE> <BoN> n ops to print <EoN> = <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> n ops <EoN> , <NEWLINE> <BoN> n apply to print <EoN> = <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> n apply <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> ps <EoN> , <BoN> Scan Profile Stats <EoN> ) : <NEWLINE> <TAB> <BoN> to sum <EoN> . <BoN> append <EoN> ( <BoN> ps <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> print <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> to sum <EoN> ) > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> cum <EoN> = <BoN> copy <EoN> . <BoN> copy <EoN> ( <BoN> to sum <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> % <BoN> len <EoN> ( <BoN> to sum <EoN> ) ) <NEWLINE> <BoN> cum <EoN> . <BoN> message <EoN> = <BoN> msg <EoN> <NEWLINE> <BoN> for <EoN> <BoN> ps <EoN> <BoN> in <EoN> <BoN> to sum <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> attr <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> cum <EoN> , <BoN> attr <EoN> , <BoN> getattr <EoN> ( <BoN> cum <EoN> , <BoN> attr <EoN> ) + <BoN> getattr <EoN> ( <BoN> ps <EoN> , <BoN> attr <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> attr <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] : <NEWLINE> <TAB> <BoN> cum attr <EoN> = <BoN> getattr <EoN> ( <BoN> cum <EoN> , <BoN> attr <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> val <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> getattr <EoN> ( <BoN> ps <EoN> , <BoN> attr <EoN> ) ) : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> key <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> cum attr <EoN> , ( <BoN> key <EoN> , <BoN> cum attr <EoN> ) <NEWLINE> <BoN> cum attr <EoN> [ <BoN> key <EoN> ] = <BoN> val <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> cum <EoN> . <BoN> optimizer profile <EoN> <BoN> and <EoN> <BoN> ps <EoN> . <BoN> optimizer profile <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> merge <EoN> = <BoN> cum <EoN> . <BoN> optimizer profile <EoN> [ <NUMBER> ] . <BoN> merge profile <EoN> ( <NEWLINE> <BoN> cum <EoN> . <BoN> optimizer profile <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> ps <EoN> . <BoN> optimizer profile <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> merge <EoN> ) == <BoN> len <EoN> ( <BoN> cum <EoN> . <BoN> optimizer profile <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> cum <EoN> . <BoN> optimizer profile <EoN> = ( <BoN> cum <EoN> . <BoN> optimizer profile <EoN> [ <NUMBER> ] , <BoN> merge <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> print <EoN> ( <BoN> e <EoN> ) <NEWLINE> <BoN> cum <EoN> . <BoN> optimizer profile <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cum <EoN> . <BoN> optimizer profile <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> cum <EoN> . <BoN> summary <EoN> ( <BoN> file <EoN> = <BoN> destination file <EoN> , <NEWLINE> <BoN> n ops to print <EoN> = <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> n ops <EoN> , <NEWLINE> <BoN> n apply to print <EoN> = <BoN> config <EoN> . <BoN> profiling <EoN> . <BoN> n apply <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> config <EoN> . <BoN> print global stats <EoN> : <NEWLINE> <TAB> <BoN> print global stats <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Linear Regression Output <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> label <EoN> = <BoN> None <EoN> , <BoN> grad scale <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set figwidth <EoN> ( <BoN> self <EoN> , <BoN> val <EoN> , <BoN> forward <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> set size inches <EoN> ( <BoN> val <EoN> , <BoN> self <EoN> . <BoN> get figheight <EoN> ( ) , <BoN> forward <EoN> = <BoN> forward <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> notilike <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> escape <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> operate <EoN> ( <BoN> notilike op <EoN> , <BoN> other <EoN> , <BoN> escape <EoN> = <BoN> escape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> added <EoN> ( <BoN> self <EoN> , <BoN> function <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> init python printing <EoN> ( <BoN> stringify func <EoN> , ** <BoN> settings <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> sys <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> compatibility <EoN> <BoN> import <EoN> <BoN> builtins <EoN> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> displayhook <EoN> ( <BoN> arg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> arg <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> builtins <EoN> . <BoN> <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> print <EoN> ( <BoN> stringify func <EoN> ( <BoN> arg <EoN> , ** <BoN> settings <EoN> ) ) <NEWLINE> <BoN> builtins <EoN> . <BoN> <EoN> = <BoN> arg <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> sys <EoN> . <BoN> displayhook <EoN> = <BoN> displayhook <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> add numeric methods unary <EoN> ( <BoN> cls <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> make evaluate unary <EoN> ( <BoN> op <EoN> , <BoN> opstr <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> def <EoN> <BoN> evaluate numeric unary <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> validate for numeric unaryop <EoN> ( <BoN> op <EoN> , <BoN> opstr <EoN> ) <NEWLINE> <BoN> attrs <EoN> = <BoN> self <EoN> . <BoN> get attributes dict <EoN> ( ) <NEWLINE> <BoN> attrs <EoN> = <BoN> self <EoN> . <BoN> maybe update attributes <EoN> ( <BoN> attrs <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Index <EoN> ( <BoN> op <EoN> ( <BoN> self <EoN> . <BoN> values <EoN> ) , ** <BoN> attrs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> evaluate numeric unary <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> cls <EoN> . <BoN> neg <EoN> = <BoN> make evaluate unary <EoN> ( <BoN> operator <EoN> . <BoN> neg <EoN> , <STRING> ) <NEWLINE> <BoN> cls <EoN> . <BoN> pos <EoN> = <BoN> make evaluate unary <EoN> ( <BoN> operator <EoN> . <BoN> pos <EoN> , <STRING> ) <NEWLINE> <BoN> cls <EoN> . <BoN> abs <EoN> = <BoN> make evaluate unary <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> , <STRING> ) <NEWLINE> <BoN> cls <EoN> . <BoN> inv <EoN> = <BoN> make evaluate unary <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : - <BoN> x <EoN> , <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> no regularizer <EoN> ( <BoN> <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> multi lgamma <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> p <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> self <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <BoN> values <EoN> = [ <BoN> a <EoN> , <BoN> p <EoN> ] ) : <NEWLINE> <TAB> <BoN> seq <EoN> = <BoN> self <EoN> . <BoN> multi gamma sequence <EoN> ( <BoN> a <EoN> , <BoN> p <EoN> ) <NEWLINE> <BoN> return <EoN> ( <NUMBER> * <BoN> p <EoN> * ( <BoN> p <EoN> - <NUMBER> ) * <BoN> math <EoN> . <BoN> log <EoN> ( <BoN> math <EoN> . <BoN> pi <EoN> ) + <NEWLINE> <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> math ops <EoN> . <BoN> lgamma <EoN> ( <BoN> seq <EoN> ) , <NEWLINE> <BoN> axis <EoN> = [ - <NUMBER> ] ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pad bytes <EoN> ( <BoN> name <EoN> , <BoN> length <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> name <EoN> + <STRING> * ( <BoN> length <EoN> - <BoN> len <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> assert integer <EoN> ( <BoN> x <EoN> , <BoN> message <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> message <EoN> = <BoN> message <EoN> <BoN> or <EoN> <STRING> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> x <EoN> ] ) : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> is integer <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> x <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> err msg <EoN> = ( <NEWLINE> <STRING> <NEWLINE> % ( <BoN> message <EoN> , <BoN> name <EoN> , <BoN> x <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <BoN> err msg <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> no op <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval aseries <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> , <BoN> args 0 <EoN> , <BoN> x <EoN> , <BoN> logx <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> utilities <EoN> . <BoN> misc <EoN> <BoN> import <EoN> <BoN> filldedent <EoN> <NEWLINE> <BoN> raise <EoN> <BoN> Pole Error <EoN> ( <BoN> filldedent <EoN> ( <STRING> % ( <BoN> type <EoN> ( <BoN> self <EoN> ) , <BoN> args 0 <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init params <EoN> ( <BoN> self <EoN> , <BoN> initializer <EoN> = <BoN> Uniform <EoN> ( <NUMBER> ) , <BoN> arg params <EoN> = <BoN> None <EoN> , <BoN> aux params <EoN> = <BoN> None <EoN> , <NEWLINE> <BoN> allow missing <EoN> = <BoN> False <EoN> , <BoN> force init <EoN> = <BoN> False <EoN> , <BoN> allow extra <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> params initialized <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> force init <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> binded <EoN> , <STRING> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> impl <EoN> ( <BoN> name <EoN> , <BoN> arr <EoN> , <BoN> cache <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> cache <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> cache <EoN> : <NEWLINE> <TAB> <BoN> cache arr <EoN> = <BoN> cache <EoN> [ <BoN> name <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> cache arr <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> arr <EoN> : <NEWLINE> <TAB> <BoN> cache arr <EoN> . <BoN> copyto <EoN> ( <BoN> arr <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> allow missing <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> % <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> initializer <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> initializer <EoN> ( <BoN> name <EoN> , <BoN> arr <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> initializer <EoN> ( <BoN> name <EoN> , <BoN> arr <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> attrs <EoN> = <BoN> self <EoN> . <BoN> symbol <EoN> . <BoN> attr dict <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> name <EoN> , <BoN> arr <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> self <EoN> . <BoN> arg params <EoN> . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> desc <EoN> = <BoN> Init Desc <EoN> ( <BoN> name <EoN> , <BoN> attrs <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> , <BoN> None <EoN> ) ) <NEWLINE> <BoN> impl <EoN> ( <BoN> desc <EoN> , <BoN> arr <EoN> , <BoN> arg params <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> name <EoN> , <BoN> arr <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> self <EoN> . <BoN> aux params <EoN> . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> desc <EoN> = <BoN> Init Desc <EoN> ( <BoN> name <EoN> , <BoN> attrs <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> , <BoN> None <EoN> ) ) <NEWLINE> <BoN> impl <EoN> ( <BoN> desc <EoN> , <BoN> arr <EoN> , <BoN> aux params <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> params initialized <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> params dirty <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> exec group <EoN> . <BoN> set params <EoN> ( <BoN> self <EoN> . <BoN> arg params <EoN> , <BoN> self <EoN> . <BoN> aux params <EoN> , <NEWLINE> <BoN> allow extra <EoN> = <BoN> allow extra <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> register flag by module <EoN> ( <BoN> self <EoN> , <BoN> module name <EoN> , <BoN> flag <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> flags by module <EoN> = <BoN> self <EoN> . <BoN> flags by module dict <EoN> ( ) <NEWLINE> <BoN> flags by module <EoN> . <BoN> setdefault <EoN> ( <BoN> module name <EoN> , [ ] ) . <BoN> append <EoN> ( <BoN> flag <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> from ZZ gmpy <EoN> ( <BoN> K 1 <EoN> , <BoN> a <EoN> , <BoN> K 0 <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> K 1 <EoN> . <BoN> dtype <EoN> ( <BoN> K 1 <EoN> . <BoN> dom <EoN> . <BoN> from ZZ gmpy <EoN> ( <BoN> a <EoN> , <BoN> K 0 <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> construct axes dict <EoN> ( <BoN> self <EoN> , <BoN> axes <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> d <EoN> = { <BoN> a <EoN> : <BoN> self <EoN> . <BoN> get axis <EoN> ( <BoN> a <EoN> ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> ( <BoN> axes <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> AXIS ORDERS <EoN> ) } <NEWLINE> <BoN> d <EoN> . <BoN> update <EoN> ( <BoN> kwargs <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> prepare gramian <EoN> ( <BoN> self <EoN> , <BoN> factors <EoN> , <BoN> gramian <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> partial gramians <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> factors <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> colocate with <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <BoN> partial gramians <EoN> . <BoN> append <EoN> ( <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> f <EoN> , <BoN> f <EoN> , <BoN> transpose a <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> colocate with <EoN> ( <BoN> gramian <EoN> ) : <NEWLINE> <TAB> <BoN> prep gramian <EoN> = <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> gramian <EoN> , <NEWLINE> <BoN> math ops <EoN> . <BoN> add n <EoN> ( <BoN> partial gramians <EoN> ) ) . <BoN> op <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> prep gramian <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reset <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> curr idx <EoN> = <NUMBER> <NEWLINE> <BoN> random <EoN> . <BoN> shuffle <EoN> ( <BoN> self <EoN> . <BoN> idx <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> buck <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> data <EoN> : <NEWLINE> <TAB> <BoN> np <EoN> . <BoN> random <EoN> . <BoN> shuffle <EoN> ( <BoN> buck <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> nddata <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> ndlabel <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> buck <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> data <EoN> : <NEWLINE> <TAB> <BoN> label <EoN> = <BoN> np <EoN> . <BoN> empty like <EoN> ( <BoN> buck <EoN> ) <NEWLINE> <BoN> label <EoN> [ : , : - <NUMBER> ] = <BoN> buck <EoN> [ : , <NUMBER> : ] <NEWLINE> <BoN> label <EoN> [ : , - <NUMBER> ] = <BoN> self <EoN> . <BoN> invalid label <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> nddata <EoN> . <BoN> append <EoN> ( <BoN> ndarray <EoN> . <BoN> array <EoN> ( <BoN> buck <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> ndlabel <EoN> . <BoN> append <EoN> ( <BoN> ndarray <EoN> . <BoN> array <EoN> ( <BoN> label <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> src <EoN> , <BoN> label <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> random <EoN> . <BoN> random <EoN> ( ) < <BoN> self <EoN> . <BoN> skip prob <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> src <EoN> , <BoN> label <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> random <EoN> . <BoN> shuffle <EoN> ( <BoN> self <EoN> . <BoN> aug list <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> aug list <EoN> [ <NUMBER> ] ( <BoN> src <EoN> , <BoN> label <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ode lie group <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> match <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> heuristics <EoN> = <BoN> lie heuristics <EoN> <NEWLINE> <BoN> inf <EoN> = { } <NEWLINE> <BoN> f <EoN> = <BoN> func <EoN> . <BoN> func <EoN> <NEWLINE> <BoN> x <EoN> = <BoN> func <EoN> . <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> df <EoN> = <BoN> func <EoN> . <BoN> diff <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> xi <EoN> = <BoN> Function <EoN> ( <STRING> ) <NEWLINE> <BoN> eta <EoN> = <BoN> Function <EoN> ( <STRING> ) <NEWLINE> <BoN> a <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> df <EoN> ] ) <NEWLINE> <BoN> b <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> df <EoN> ] ) <NEWLINE> <BoN> xis <EoN> = <BoN> match <EoN> . <BoN> pop <EoN> ( <STRING> ) <NEWLINE> <BoN> etas <EoN> = <BoN> match <EoN> . <BoN> pop <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> match <EoN> : <NEWLINE> <TAB> <BoN> h <EoN> = - <BoN> simplify <EoN> ( <BoN> match <EoN> [ <BoN> match <EoN> [ <STRING> ] ] / <BoN> match <EoN> [ <BoN> match <EoN> [ <STRING> ] ] ) <NEWLINE> <BoN> y <EoN> = <BoN> match <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> = <BoN> solve <EoN> ( <BoN> eq <EoN> , <BoN> df <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Not Implemented Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> eq <EoN> ) + <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> h <EoN> = <BoN> sol <EoN> [ <NUMBER> ] . <BoN> subs <EoN> ( <BoN> func <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> xis <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> etas <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> inf <EoN> = [ { <BoN> xi <EoN> ( <BoN> x <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> ) ) : <BoN> S <EoN> ( <BoN> xis <EoN> ) , <BoN> eta <EoN> ( <BoN> x <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> ) ) : <BoN> S <EoN> ( <BoN> etas <EoN> ) } ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> checkinfsol <EoN> ( <BoN> eq <EoN> , <BoN> inf <EoN> , <BoN> func <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> order <EoN> = <NUMBER> ) [ <NUMBER> ] [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> heuristics <EoN> = [ <STRING> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> match <EoN> = { <STRING> : <BoN> h <EoN> , <STRING> : <BoN> y <EoN> } <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> tempsol <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> heuristic <EoN> <BoN> in <EoN> <BoN> heuristics <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> inf <EoN> : <NEWLINE> <TAB> <BoN> inf <EoN> = <BoN> infinitesimals <EoN> ( <BoN> eq <EoN> , <BoN> hint <EoN> = <BoN> heuristic <EoN> , <BoN> func <EoN> = <BoN> func <EoN> , <BoN> order <EoN> = <NUMBER> , <BoN> match <EoN> = <BoN> match <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> infsim <EoN> <BoN> in <EoN> <BoN> inf <EoN> : <NEWLINE> <TAB> <BoN> xiinf <EoN> = ( <BoN> infsim <EoN> [ <BoN> xi <EoN> ( <BoN> x <EoN> , <BoN> func <EoN> ) ] ) . <BoN> subs <EoN> ( <BoN> func <EoN> , <BoN> y <EoN> ) <NEWLINE> <BoN> etainf <EoN> = ( <BoN> infsim <EoN> [ <BoN> eta <EoN> ( <BoN> x <EoN> , <BoN> func <EoN> ) ] ) . <BoN> subs <EoN> ( <BoN> func <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> simplify <EoN> ( <BoN> etainf <EoN> / <BoN> xiinf <EoN> ) == <BoN> h <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> rpde <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( <BoN> x <EoN> ) * <BoN> xiinf <EoN> + <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( <BoN> y <EoN> ) * <BoN> etainf <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> pdsolve <EoN> ( <BoN> rpde <EoN> , <BoN> func <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) . <BoN> rhs <EoN> <NEWLINE> <BoN> s <EoN> = <BoN> pdsolve <EoN> ( <BoN> rpde <EoN> - <NUMBER> , <BoN> func <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) . <BoN> rhs <EoN> <NEWLINE> <BoN> newcoord <EoN> = [ <BoN> lie group remove <EoN> ( <BoN> coord <EoN> ) <BoN> for <EoN> <BoN> coord <EoN> <BoN> in <EoN> [ <BoN> r <EoN> , <BoN> s <EoN> ] ] <NEWLINE> <BoN> r <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> s <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> C 1 <EoN> = <BoN> Symbol <EoN> ( <STRING> ) <NEWLINE> <BoN> rcoord <EoN> = <BoN> newcoord <EoN> [ <NUMBER> ] <NEWLINE> <BoN> scoord <EoN> = <BoN> newcoord <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> = <BoN> solve <EoN> ( [ <BoN> r <EoN> - <BoN> rcoord <EoN> , <BoN> s <EoN> - <BoN> scoord <EoN> ] , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> dict <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Not Implemented Error <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> = <BoN> sol <EoN> [ <NUMBER> ] <NEWLINE> <BoN> xsub <EoN> = <BoN> sol <EoN> [ <BoN> x <EoN> ] <NEWLINE> <BoN> ysub <EoN> = <BoN> sol <EoN> [ <BoN> y <EoN> ] <NEWLINE> <BoN> num <EoN> = <BoN> simplify <EoN> ( <BoN> scoord <EoN> . <BoN> diff <EoN> ( <BoN> x <EoN> ) + <BoN> scoord <EoN> . <BoN> diff <EoN> ( <BoN> y <EoN> ) * <BoN> h <EoN> ) <NEWLINE> <BoN> denom <EoN> = <BoN> simplify <EoN> ( <BoN> rcoord <EoN> . <BoN> diff <EoN> ( <BoN> x <EoN> ) + <BoN> rcoord <EoN> . <BoN> diff <EoN> ( <BoN> y <EoN> ) * <BoN> h <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> num <EoN> <BoN> and <EoN> <BoN> denom <EoN> : <NEWLINE> <TAB> <BoN> diffeq <EoN> = <BoN> simplify <EoN> ( ( <BoN> num <EoN> / <BoN> denom <EoN> ) . <BoN> subs <EoN> ( [ ( <BoN> x <EoN> , <BoN> xsub <EoN> ) , ( <BoN> y <EoN> , <BoN> ysub <EoN> ) ] ) ) <NEWLINE> <BoN> sep <EoN> = <BoN> separatevars <EoN> ( <BoN> diffeq <EoN> , <BoN> symbols <EoN> = [ <BoN> r <EoN> , <BoN> s <EoN> ] , <BoN> dict <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> sep <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> deq <EoN> = <BoN> integrate <EoN> ( ( <NUMBER> / <BoN> sep <EoN> [ <BoN> s <EoN> ] ) , <BoN> s <EoN> ) + <BoN> C 1 <EoN> - <BoN> integrate <EoN> ( <BoN> sep <EoN> [ <STRING> ] * <BoN> sep <EoN> [ <BoN> r <EoN> ] , <BoN> r <EoN> ) <NEWLINE> <NEWLINE> <BoN> deq <EoN> = <BoN> deq <EoN> . <BoN> subs <EoN> ( [ ( <BoN> r <EoN> , <BoN> rcoord <EoN> ) , ( <BoN> s <EoN> , <BoN> scoord <EoN> ) ] ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> sdeq <EoN> = <BoN> solve <EoN> ( <BoN> deq <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Not Implemented Error <EoN> : <NEWLINE> <TAB> <BoN> tempsol <EoN> . <BoN> append <EoN> ( <BoN> deq <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> sdeq <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Eq <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> sdeq <EoN> . <BoN> pop <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> Eq <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> sol <EoN> ) <BoN> for <EoN> <BoN> sol <EoN> <BoN> in <EoN> <BoN> sdeq <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> denom <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Eq <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> solve <EoN> ( <BoN> scoord <EoN> - <BoN> C 1 <EoN> , <BoN> y <EoN> ) [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> num <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Eq <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> solve <EoN> ( <BoN> rcoord <EoN> - <BoN> C 1 <EoN> , <BoN> y <EoN> ) [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> tempsol <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tempsol <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Eq <EoN> ( <BoN> tempsol <EoN> . <BoN> pop <EoN> ( ) . <BoN> subs <EoN> ( <BoN> y <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> ) ) , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> Eq <EoN> ( <BoN> sol <EoN> . <BoN> subs <EoN> ( <BoN> y <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> ) ) , <NUMBER> ) <BoN> for <EoN> <BoN> sol <EoN> <BoN> in <EoN> <BoN> tempsol <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> + <BoN> str <EoN> ( <BoN> eq <EoN> ) + <STRING> <NEWLINE> + <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> bench <EoN> ( <BoN> self <EoN> , <BoN> label <EoN> = <STRING> , <BoN> verbose <EoN> = <NUMBER> , <BoN> extra argv <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> print <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> package name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> show system info <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> argv <EoN> = <BoN> self <EoN> . <BoN> test argv <EoN> ( <BoN> label <EoN> , <BoN> verbose <EoN> , <BoN> extra argv <EoN> ) <NEWLINE> <BoN> argv <EoN> += [ <STRING> , <STRING> % <BoN> os <EoN> . <BoN> sep <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> nose <EoN> = <BoN> import nose <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> from <EoN> . <BoN> noseclasses <EoN> <BoN> import <EoN> <BoN> Unplugger <EoN> <NEWLINE> <BoN> add plugins <EoN> = [ <BoN> Unplugger <EoN> ( <STRING> ) ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> nose <EoN> . <BoN> run <EoN> ( <BoN> argv <EoN> = <BoN> argv <EoN> , <BoN> addplugins <EoN> = <BoN> add plugins <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nancumsum <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> mask <EoN> = <BoN> replace nan <EoN> ( <BoN> a <EoN> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> cumsum <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> out <EoN> = <BoN> out <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> decompose <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> . <BoN> lev <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> f <EoN> . <BoN> per <EoN> , <BoN> dup decompose <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> copy <EoN> ( <BoN> self <EoN> , <BoN> mode <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ret <EoN> = <BoN> super <EoN> ( <BoN> Chain List <EoN> , <BoN> self <EoN> ) . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> ret <EoN> . <BoN> children <EoN> = <BoN> list <EoN> ( <BoN> ret <EoN> . <BoN> children <EoN> ) <NEWLINE> <BoN> children <EoN> = <BoN> ret <EoN> . <BoN> children <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> child <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> children <EoN> ) : <NEWLINE> <TAB> <BoN> child <EoN> = <BoN> child <EoN> . <BoN> copy <EoN> ( <BoN> mode <EoN> ) <NEWLINE> <BoN> child <EoN> . <BoN> name <EoN> = <BoN> str <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> children <EoN> [ <BoN> i <EoN> ] = <BoN> child <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check rows is arange len labels <EoN> ( <BoN> rows <EoN> , <BoN> labels <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> labels <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> hasattr <EoN> ( <BoN> labels <EoN> . <BoN> owner <EoN> . <BoN> fgraph <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> shape of <EoN> = <BoN> labels <EoN> . <BoN> owner <EoN> . <BoN> fgraph <EoN> . <BoN> shape feature <EoN> . <BoN> shape of <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> shape of <EoN> [ <BoN> labels <EoN> ] ) == <NUMBER> <BoN> and <EoN> <BoN> is const <EoN> ( <BoN> shape of <EoN> [ <BoN> labels <EoN> ] [ <NUMBER> ] , <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> is const <EoN> ( <BoN> rows <EoN> , <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> rows <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> rows <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> , <BoN> tensor <EoN> . <BoN> A Range <EoN> ) : <NEWLINE> <TAB> <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> step <EoN> = <BoN> rows <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> if <EoN> <BoN> getattr <EoN> ( <BoN> start <EoN> , <STRING> , <BoN> None <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> getattr <EoN> ( <BoN> step <EoN> , <STRING> , <BoN> None <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> stop <EoN> . <BoN> owner <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> stop <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> , <BoN> subtensor <EoN> . <BoN> Subtensor <EoN> ) : <NEWLINE> <TAB> <BoN> shape subtensor <EoN> = <BoN> stop <EoN> . <BoN> owner <EoN> <NEWLINE> <BoN> if <EoN> <BoN> shape subtensor <EoN> . <BoN> op <EoN> . <BoN> get constant idx <EoN> ( <BoN> shape subtensor <EoN> . <BoN> inputs <EoN> , <NEWLINE> <BoN> allow partial <EoN> = <BoN> True <EoN> ) == [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> shape var <EoN> = <BoN> shape subtensor <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> shape var <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> shape var <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> tensor <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> shape var <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <BoN> is <EoN> <BoN> labels <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> shape of <EoN> = <BoN> stop <EoN> . <BoN> owner <EoN> . <BoN> fgraph <EoN> . <BoN> shape feature <EoN> . <BoN> shape of <EoN> <NEWLINE> <BoN> return <EoN> <BoN> shape of <EoN> [ <BoN> labels <EoN> ] [ <NUMBER> ] <BoN> is <EoN> <BoN> stop <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> poisson <EoN> ( <BoN> lam <EoN> = <NUMBER> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> random helper <EoN> ( <BoN> internal <EoN> . <BoN> random poisson <EoN> , <BoN> internal <EoN> . <BoN> sample poisson <EoN> , <NEWLINE> [ <BoN> lam <EoN> ] , <BoN> shape <EoN> , <BoN> dtype <EoN> , <BoN> ctx <EoN> , <BoN> out <EoN> , <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is extension array dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> arrays <EoN> <BoN> import <EoN> <BoN> Extension Array <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , ( <BoN> ABC Index Class <EoN> , <BoN> ABC Series <EoN> ) ) : <NEWLINE> <TAB> <BoN> arr or dtype <EoN> = <BoN> arr or dtype <EoN> . <BoN> values <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , ( <BoN> Extension Dtype <EoN> , <BoN> Extension Array <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sub ground <EoN> ( <BoN> f <EoN> , <BoN> coeff <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> sub ground <EoN> ( <BoN> coeff <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Operation Not Supported <EoN> ( <BoN> f <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf compose mod <EoN> ( <BoN> g <EoN> , <BoN> h <EoN> , <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> comp <EoN> = [ <BoN> g <EoN> [ <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> g <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> comp <EoN> = <BoN> gf mul <EoN> ( <BoN> comp <EoN> , <BoN> h <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> comp <EoN> = <BoN> gf add ground <EoN> ( <BoN> comp <EoN> , <BoN> a <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> comp <EoN> = <BoN> gf rem <EoN> ( <BoN> comp <EoN> , <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> comp <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> step <EoN> ( <BoN> self <EoN> , <BoN> closure <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> loss <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> closure <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> loss <EoN> = <BoN> closure <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> group <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> param groups <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> group <EoN> [ <STRING> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p <EoN> . <BoN> grad <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> grad <EoN> = <BoN> p <EoN> . <BoN> grad <EoN> . <BoN> data <EoN> <NEWLINE> <BoN> if <EoN> <BoN> grad <EoN> . <BoN> is sparse <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> state <EoN> = <BoN> self <EoN> . <BoN> state <EoN> [ <BoN> p <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> state <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> state <EoN> [ <STRING> ] = <NUMBER> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> torch <EoN> . <BoN> zeros like <EoN> ( <BoN> p <EoN> . <BoN> data <EoN> ) <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> grad <EoN> . <BoN> new <EoN> ( ) . <BoN> resize as <EoN> ( <BoN> grad <EoN> ) . <BoN> fill <EoN> ( <BoN> group <EoN> [ <STRING> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> etaminus <EoN> , <BoN> etaplus <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> step size min <EoN> , <BoN> step size max <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> step size <EoN> = <BoN> state <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> state <EoN> [ <STRING> ] += <NUMBER> <NEWLINE> <NEWLINE> <BoN> sign <EoN> = <BoN> grad <EoN> . <BoN> mul <EoN> ( <BoN> state <EoN> [ <STRING> ] ) . <BoN> sign <EoN> ( ) <NEWLINE> <BoN> sign <EoN> [ <BoN> sign <EoN> . <BoN> gt <EoN> ( <NUMBER> ) ] = <BoN> etaplus <EoN> <NEWLINE> <BoN> sign <EoN> [ <BoN> sign <EoN> . <BoN> lt <EoN> ( <NUMBER> ) ] = <BoN> etaminus <EoN> <NEWLINE> <BoN> sign <EoN> [ <BoN> sign <EoN> . <BoN> eq <EoN> ( <NUMBER> ) ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> step size <EoN> . <BoN> mul <EoN> ( <BoN> sign <EoN> ) . <BoN> clamp <EoN> ( <BoN> step size min <EoN> , <BoN> step size max <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> grad <EoN> = <BoN> grad <EoN> . <BoN> clone <EoN> ( ) <NEWLINE> <BoN> grad <EoN> [ <BoN> sign <EoN> . <BoN> eq <EoN> ( <BoN> etaminus <EoN> ) ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> p <EoN> . <BoN> data <EoN> . <BoN> addcmul <EoN> ( - <NUMBER> , <BoN> grad <EoN> . <BoN> sign <EoN> ( ) , <BoN> step size <EoN> ) <NEWLINE> <NEWLINE> <BoN> state <EoN> [ <STRING> ] . <BoN> copy <EoN> ( <BoN> grad <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> loss <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compare nrmse <EoN> ( <BoN> im true <EoN> , <BoN> im test <EoN> , <BoN> norm type <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert compatible <EoN> ( <BoN> im true <EoN> , <BoN> im test <EoN> ) <NEWLINE> <BoN> im true <EoN> , <BoN> im test <EoN> = <BoN> as floats <EoN> ( <BoN> im true <EoN> , <BoN> im test <EoN> ) <NEWLINE> <NEWLINE> <BoN> norm type <EoN> = <BoN> norm type <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> norm type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> denom <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> np <EoN> . <BoN> mean <EoN> ( ( <BoN> im true <EoN> * <BoN> im true <EoN> ) , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> norm type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> denom <EoN> = <BoN> im true <EoN> . <BoN> max <EoN> ( ) - <BoN> im true <EoN> . <BoN> min <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> norm type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> denom <EoN> = <BoN> im true <EoN> . <BoN> mean <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> compare mse <EoN> ( <BoN> im true <EoN> , <BoN> im test <EoN> ) ) / <BoN> denom <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit transform <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> unused y <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> fit <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> transform <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> wait <EoN> ( <BoN> self <EoN> , <BoN> stream <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> stream <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> stream <EoN> = <BoN> torch <EoN> . <BoN> cuda <EoN> . <BoN> current stream <EoN> ( ) <NEWLINE> <UNTAB> <BoN> stream <EoN> . <BoN> wait event <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> local vars update <EoN> ( <BoN> self <EoN> , <BoN> var list <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> var list <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> update ops <EoN> = [ ] <NEWLINE> <BoN> global center vars <EoN> = [ <BoN> self <EoN> . <BoN> local 2 global <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> var list <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> lvar <EoN> , <BoN> gvar <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> var list <EoN> , <BoN> global center vars <EoN> ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> device <EoN> ( <BoN> lvar <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> lvar <EoN> , <BoN> gvar <EoN> . <BoN> read value <EoN> ( ) ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * ( <BoN> update ops <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trima <EoN> ( <BoN> a <EoN> , <BoN> limits <EoN> = <BoN> None <EoN> , <BoN> inclusive <EoN> = ( <BoN> True <EoN> , <BoN> True <EoN> ) ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> ma <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> a <EoN> . <BoN> unshare mask <EoN> ( ) <NEWLINE> <BoN> if <EoN> ( <BoN> limits <EoN> <BoN> is <EoN> <BoN> None <EoN> ) <BoN> or <EoN> ( <BoN> limits <EoN> == ( <BoN> None <EoN> , <BoN> None <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <NEWLINE> <UNTAB> ( <BoN> lower lim <EoN> , <BoN> upper lim <EoN> ) = <BoN> limits <EoN> <NEWLINE> ( <BoN> lower in <EoN> , <BoN> upper in <EoN> ) = <BoN> inclusive <EoN> <NEWLINE> <BoN> condition <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> lower lim <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> lower in <EoN> : <NEWLINE> <TAB> <BoN> condition <EoN> |= ( <BoN> a <EoN> < <BoN> lower lim <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> condition <EoN> |= ( <BoN> a <EoN> <= <BoN> lower lim <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> upper lim <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> upper in <EoN> : <NEWLINE> <TAB> <BoN> condition <EoN> |= ( <BoN> a <EoN> > <BoN> upper lim <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> condition <EoN> |= ( <BoN> a <EoN> >= <BoN> upper lim <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> a <EoN> [ <BoN> condition <EoN> . <BoN> filled <EoN> ( <BoN> True <EoN> ) ] = <BoN> masked <EoN> <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set item <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> ensure valid index <EoN> ( <BoN> value <EoN> ) <NEWLINE> <BoN> value <EoN> = <BoN> self <EoN> . <BoN> sanitize column <EoN> ( <BoN> key <EoN> , <BoN> value <EoN> ) <NEWLINE> <BoN> ND Frame <EoN> . <BoN> set item <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> check setitem copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> topk <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> topk <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gen fill zeros <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> . <BoN> strip <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> name <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> np <EoN> . <BoN> inf <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> name <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> np <EoN> . <BoN> nan <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> fill value <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> dispersionset <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> polys <EoN> . <BoN> dispersion <EoN> <BoN> import <EoN> <BoN> dispersionset <EoN> <NEWLINE> <BoN> return <EoN> <BoN> dispersionset <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mpf cosh sinh <EoN> ( <BoN> x <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> = <BoN> round fast <EoN> , <BoN> tanh <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sign <EoN> , <BoN> man <EoN> , <BoN> exp <EoN> , <BoN> bc <EoN> = <BoN> x <EoN> <NEWLINE> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> man <EoN> ) <BoN> and <EoN> <BoN> exp <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> tanh <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> == <BoN> finf <EoN> : <BoN> return <EoN> <BoN> fone <EoN> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> == <BoN> fninf <EoN> : <BoN> return <EoN> <BoN> fnone <EoN> <NEWLINE> <BoN> return <EoN> <BoN> fnan <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> == <BoN> finf <EoN> : <BoN> return <EoN> ( <BoN> finf <EoN> , <BoN> finf <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> == <BoN> fninf <EoN> : <BoN> return <EoN> ( <BoN> finf <EoN> , <BoN> fninf <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> fnan <EoN> , <BoN> fnan <EoN> <NEWLINE> <UNTAB> <BoN> mag <EoN> = <BoN> exp <EoN> + <BoN> bc <EoN> <NEWLINE> <BoN> wp <EoN> = <BoN> prec <EoN> + <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> mag <EoN> < - <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> mag <EoN> < - <BoN> wp <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> tanh <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mpf perturb <EoN> ( <BoN> x <EoN> , <NUMBER> - <BoN> sign <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <BoN> cosh <EoN> = <BoN> mpf perturb <EoN> ( <BoN> fone <EoN> , <NUMBER> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <BoN> sinh <EoN> = <BoN> mpf perturb <EoN> ( <BoN> x <EoN> , <BoN> sign <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> cosh <EoN> , <BoN> sinh <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> wp <EoN> += ( - <BoN> mag <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mag <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <NUMBER> * ( <NUMBER> << ( <BoN> mag <EoN> - <NUMBER> ) ) > <BoN> wp <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> tanh <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mpf perturb <EoN> ( [ <BoN> fone <EoN> , <BoN> fnone <EoN> ] [ <BoN> sign <EoN> ] , <NUMBER> - <BoN> sign <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <BoN> c <EoN> = <BoN> s <EoN> = <BoN> mpf shift <EoN> ( <BoN> mpf exp <EoN> ( <BoN> mpf abs <EoN> ( <BoN> x <EoN> ) , <BoN> prec <EoN> , <BoN> rnd <EoN> ) , - <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> sign <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> mpf neg <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> c <EoN> , <BoN> s <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> mag <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> wpmod <EoN> = <BoN> wp <EoN> + <BoN> mag <EoN> <NEWLINE> <BoN> offset <EoN> = <BoN> exp <EoN> + <BoN> wpmod <EoN> <NEWLINE> <BoN> if <EoN> <BoN> offset <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> man <EoN> << <BoN> offset <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> man <EoN> >> ( - <BoN> offset <EoN> ) <NEWLINE> <UNTAB> <BoN> lg 2 <EoN> = <BoN> ln 2 fixed <EoN> ( <BoN> wpmod <EoN> ) <NEWLINE> <BoN> n <EoN> , <BoN> t <EoN> = <BoN> divmod <EoN> ( <BoN> t <EoN> , <BoN> lg 2 <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> t <EoN> >>= <BoN> mag <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> offset <EoN> = <BoN> exp <EoN> + <BoN> wp <EoN> <NEWLINE> <BoN> if <EoN> <BoN> offset <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> man <EoN> << <BoN> offset <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> man <EoN> >> ( - <BoN> offset <EoN> ) <NEWLINE> <UNTAB> <BoN> n <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> exp expneg basecase <EoN> ( <BoN> t <EoN> , <BoN> wp <EoN> ) <NEWLINE> <NEWLINE> <BoN> cosh <EoN> = <BoN> a <EoN> + ( <BoN> b <EoN> >> ( <NUMBER> * <BoN> n <EoN> ) ) <NEWLINE> <BoN> sinh <EoN> = <BoN> a <EoN> - ( <BoN> b <EoN> >> ( <NUMBER> * <BoN> n <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> sign <EoN> : <NEWLINE> <TAB> <BoN> sinh <EoN> = - <BoN> sinh <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tanh <EoN> : <NEWLINE> <TAB> <BoN> man <EoN> = ( <BoN> sinh <EoN> << <BoN> wp <EoN> ) // <BoN> cosh <EoN> <NEWLINE> <BoN> return <EoN> <BoN> from man exp <EoN> ( <BoN> man <EoN> , - <BoN> wp <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cosh <EoN> = <BoN> from man exp <EoN> ( <BoN> cosh <EoN> , <BoN> n <EoN> - <BoN> wp <EoN> - <NUMBER> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <BoN> sinh <EoN> = <BoN> from man exp <EoN> ( <BoN> sinh <EoN> , <BoN> n <EoN> - <BoN> wp <EoN> - <NUMBER> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> cosh <EoN> , <BoN> sinh <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tree query parallel helper <EoN> ( <BoN> tree <EoN> , <BoN> data <EoN> , <BoN> n neighbors <EoN> , <BoN> return distance <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tree <EoN> . <BoN> query <EoN> ( <BoN> data <EoN> , <BoN> n neighbors <EoN> , <BoN> return distance <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample uniform <EoN> ( <BoN> low <EoN> = <BoN> None <EoN> , <BoN> high <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> integer basis <EoN> ( <BoN> poly <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> monoms <EoN> , <BoN> coeffs <EoN> = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> poly <EoN> . <BoN> terms <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <BoN> monoms <EoN> , = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> monoms <EoN> ) ) <NEWLINE> <BoN> coeffs <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> abs <EoN> , <BoN> coeffs <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> coeffs <EoN> [ <NUMBER> ] < <BoN> coeffs <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> coeffs <EoN> = <BoN> list <EoN> ( <BoN> reversed <EoN> ( <BoN> coeffs <EoN> ) ) <NEWLINE> <BoN> n <EoN> = <BoN> monoms <EoN> [ <NUMBER> ] <NEWLINE> <BoN> monoms <EoN> = [ <BoN> n <EoN> - <BoN> i <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> reversed <EoN> ( <BoN> monoms <EoN> ) ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> monoms <EoN> = <BoN> monoms <EoN> [ : - <NUMBER> ] <NEWLINE> <BoN> coeffs <EoN> = <BoN> coeffs <EoN> [ : - <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> divs <EoN> = <BoN> reversed <EoN> ( <BoN> divisors <EoN> ( <BoN> gcd list <EoN> ( <BoN> coeffs <EoN> ) ) [ <NUMBER> : ] ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> div <EoN> = <BoN> next <EoN> ( <BoN> divs <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> monom <EoN> , <BoN> coeff <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> monoms <EoN> , <BoN> coeffs <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> coeff <EoN> % <BoN> div <EoN> ** <BoN> monom <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> div <EoN> = <BoN> next <EoN> ( <BoN> divs <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> div <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> clip <EoN> ( <BoN> x <EoN> , <BoN> x min <EoN> , <BoN> x max <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Clip <EoN> ( <BoN> x min <EoN> , <BoN> x max <EoN> ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compare and bitpack eager fallback <EoN> ( <BoN> input <EoN> , <BoN> threshold <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> , <BoN> threshold <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> ( <BoN> input <EoN> , <BoN> threshold <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> , <BoN> threshold <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> local efficiency <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> efficiency list <EoN> = ( <BoN> global efficiency <EoN> ( <BoN> G <EoN> . <BoN> subgraph <EoN> ( <BoN> G <EoN> [ <BoN> v <EoN> ] ) ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <BoN> efficiency list <EoN> ) / <BoN> len <EoN> ( <BoN> G <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to embed <EoN> ( <BoN> self <EoN> , <BoN> keep tz <EoN> = <BoN> False <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> astype <EoN> ( <BoN> dtype <EoN> ) . <BoN> to embed <EoN> ( <BoN> keep tz <EoN> = <BoN> keep tz <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> count <EoN> ( <BoN> seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> seq <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> seq <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sum <EoN> ( <NUMBER> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> seq <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> block <EoN> ( <BoN> arrays <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> bottom index <EoN> , <BoN> arr ndim <EoN> = <BoN> block check depths match <EoN> ( <BoN> arrays <EoN> ) <NEWLINE> <BoN> list ndim <EoN> = <BoN> len <EoN> ( <BoN> bottom index <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> block <EoN> ( <BoN> arrays <EoN> , <BoN> list ndim <EoN> , <BoN> max <EoN> ( <BoN> arr ndim <EoN> , <BoN> list ndim <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is color like <EoN> ( <BoN> c <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is nth color <EoN> ( <BoN> c <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> to rgba <EoN> ( <BoN> c <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> neg <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> neg eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> neg <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> neg <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> outer <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> x <EoN> . <BoN> flatten <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> y <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> y <EoN> . <BoN> flatten <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dot <EoN> ( <NEWLINE> <BoN> x <EoN> . <BoN> dimshuffle <EoN> ( <NUMBER> , <STRING> ) , <NEWLINE> <BoN> y <EoN> . <BoN> dimshuffle <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call model fn <EoN> ( <BoN> self <EoN> , <BoN> features <EoN> , <BoN> labels <EoN> , <BoN> mode <EoN> , <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> model fn args <EoN> = <BoN> function utils <EoN> . <BoN> fn args <EoN> ( <BoN> self <EoN> . <BoN> model fn <EoN> ) <NEWLINE> <BoN> kwargs <EoN> = { } <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> model fn args <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> labels <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> labels <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> model fn args <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> mode <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> model fn args <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> params <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> verify estimator spec <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> model fn <EoN> ( <BoN> features <EoN> = <BoN> features <EoN> , ** <BoN> kwargs <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> columns to tensors <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> columns to tensors <EoN> [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> key <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> FeatureColumn <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> key <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> key <EoN> . <BoN> insert transformed feature <EoN> ( <BoN> self <EoN> . <BoN> columns to tensors <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> columns to tensors <EoN> [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check label shapes <EoN> ( <BoN> labels <EoN> , <BoN> preds <EoN> , <BoN> wrap <EoN> = <BoN> False <EoN> , <BoN> shape <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> label shape <EoN> , <BoN> pred shape <EoN> = <BoN> len <EoN> ( <BoN> labels <EoN> ) , <BoN> len <EoN> ( <BoN> preds <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> label shape <EoN> , <BoN> pred shape <EoN> = <BoN> labels <EoN> . <BoN> shape <EoN> , <BoN> preds <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> label shape <EoN> != <BoN> pred shape <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> label shape <EoN> , <BoN> pred shape <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> wrap <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> labels <EoN> , <BoN> ndarray <EoN> . <BoN> ndarray <EoN> . <BoN> ND Array <EoN> ) : <NEWLINE> <TAB> <BoN> labels <EoN> = [ <BoN> labels <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> preds <EoN> , <BoN> ndarray <EoN> . <BoN> ndarray <EoN> . <BoN> ND Array <EoN> ) : <NEWLINE> <TAB> <BoN> preds <EoN> = [ <BoN> preds <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> labels <EoN> , <BoN> preds <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get vecs by tokens <EoN> ( <BoN> self <EoN> , <BoN> tokens <EoN> , <BoN> lower case backup <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> to reduce <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> tokens <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> tokens <EoN> = [ <BoN> tokens <EoN> ] <NEWLINE> <BoN> to reduce <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> lower case backup <EoN> : <NEWLINE> <TAB> <BoN> indices <EoN> = [ <BoN> self <EoN> . <BoN> token to idx <EoN> . <BoN> get <EoN> ( <BoN> token <EoN> , <BoN> C <EoN> . <BoN> UNKNOWN IDX <EoN> ) <BoN> for <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> tokens <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> indices <EoN> = [ <BoN> self <EoN> . <BoN> token to idx <EoN> [ <BoN> token <EoN> ] <BoN> if <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> token to idx <EoN> <NEWLINE> <BoN> else <EoN> <BoN> self <EoN> . <BoN> token to idx <EoN> . <BoN> get <EoN> ( <BoN> token <EoN> . <BoN> lower <EoN> ( ) , <BoN> C <EoN> . <BoN> UNKNOWN IDX <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> tokens <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> vecs <EoN> = <BoN> nd <EoN> . <BoN> Embedding <EoN> ( <BoN> nd <EoN> . <BoN> array <EoN> ( <BoN> indices <EoN> ) , <BoN> self <EoN> . <BoN> idx to vec <EoN> , <BoN> self <EoN> . <BoN> idx to vec <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> self <EoN> . <BoN> idx to vec <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> vecs <EoN> [ <NUMBER> ] <BoN> if <EoN> <BoN> to reduce <EoN> <BoN> else <EoN> <BoN> vecs <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read record <EoN> ( <BoN> self <EoN> , * <BoN> dtypes <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dtype <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> tuple <EoN> ( <BoN> kwargs <EoN> . <BoN> keys <EoN> ( ) ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtypes <EoN> = <BoN> dtypes <EoN> + ( <BoN> dtype <EoN> , ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> dtypes <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> first size <EoN> = <BoN> self <EoN> . <BoN> read size <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> dtypes <EoN> = <BoN> tuple <EoN> ( <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> dtype <EoN> ) <BoN> for <EoN> <BoN> dtype <EoN> <BoN> in <EoN> <BoN> dtypes <EoN> ) <NEWLINE> <BoN> block size <EoN> = <BoN> sum <EoN> ( <BoN> dtype <EoN> . <BoN> itemsize <EoN> <BoN> for <EoN> <BoN> dtype <EoN> <BoN> in <EoN> <BoN> dtypes <EoN> ) <NEWLINE> <NEWLINE> <BoN> num blocks <EoN> , <BoN> remainder <EoN> = <BoN> divmod <EoN> ( <BoN> first size <EoN> , <BoN> block size <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> remainder <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> first size <EoN> , <BoN> block size <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> dtypes <EoN> ) != <NUMBER> <BoN> and <EoN> <BoN> first size <EoN> != <BoN> block size <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> first size <EoN> , <BoN> block size <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> data <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> dtype <EoN> <BoN> in <EoN> <BoN> dtypes <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> np <EoN> . <BoN> fromfile <EoN> ( <BoN> self <EoN> . <BoN> fp <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> count <EoN> = <BoN> num blocks <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> shape <EoN> != ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> num blocks <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> r <EoN> . <BoN> shape <EoN> == ( <NUMBER> , ) + <BoN> dtype <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> r <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> data <EoN> . <BoN> append <EoN> ( <BoN> r <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> second size <EoN> = <BoN> self <EoN> . <BoN> read size <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> first size <EoN> != <BoN> second size <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> IO Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> dtypes <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> data <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> metrics <EoN> ( <BoN> self <EoN> , <BoN> eval loss <EoN> , <BoN> predictions <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> , <BoN> values <EoN> = ( <NEWLINE> [ <BoN> eval loss <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> ] + <BoN> list <EoN> ( <BoN> six <EoN> . <BoN> itervalues <EoN> ( <BoN> predictions <EoN> ) ) ) ) : <NEWLINE> <TAB> <BoN> classes <EoN> = <BoN> predictions <EoN> [ <BoN> prediction key <EoN> . <BoN> Prediction Key <EoN> . <BoN> CLASSE S <EoN> ] <NEWLINE> <BoN> probabilities <EoN> = <BoN> predictions <EoN> [ <BoN> prediction key <EoN> . <BoN> Prediction Key <EoN> . <BoN> PROBABILITIE S <EoN> ] <NEWLINE> <BoN> logits <EoN> = <BoN> predictions <EoN> [ <BoN> prediction key <EoN> . <BoN> Prediction Key <EoN> . <BoN> LOGIT S <EoN> ] <NEWLINE> <NEWLINE> <BoN> metrics <EoN> = { <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> LOS S <EoN> ) : <NEWLINE> <BoN> metrics lib <EoN> . <BoN> mean <EoN> ( <BoN> eval loss <EoN> ) } <NEWLINE> <NEWLINE> <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> ACCURAC Y <EoN> ) ] = ( <NEWLINE> <BoN> metrics lib <EoN> . <BoN> accuracy <EoN> ( <BoN> labels <EoN> , <BoN> classes <EoN> , <BoN> weights <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> AU C <EoN> ) ] = <BoN> streaming auc <EoN> ( <NEWLINE> <BoN> probabilities <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> AUC PR <EoN> ) ] = <BoN> streaming auc <EoN> ( <NEWLINE> <BoN> probabilities <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> , <BoN> curve <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> class id <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> metric class ids <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS PREDICTION MEAN <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> predictions streaming mean <EoN> ( <BoN> classes <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS LABEL MEAN <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> indicator labels streaming mean <EoN> ( <BoN> labels <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS PROBABILITY MEAN <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> predictions streaming mean <EoN> ( <BoN> probabilities <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS LOGITS MEAN <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> predictions streaming mean <EoN> ( <BoN> logits <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS AUC <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> streaming auc <EoN> ( <BoN> probabilities <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> ) ) <NEWLINE> <BoN> metrics <EoN> [ <BoN> summary key <EoN> ( <BoN> self <EoN> . <BoN> head name <EoN> , <BoN> mkey <EoN> . <BoN> CLASS AUC PR <EoN> % <BoN> class id <EoN> ) ] = ( <NEWLINE> <BoN> streaming auc <EoN> ( <BoN> probabilities <EoN> , <BoN> labels <EoN> , <BoN> weights <EoN> , <BoN> class id <EoN> , <NEWLINE> <BoN> curve <EoN> = <STRING> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> metrics <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exec once <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> exec once <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> self <EoN> . <BoN> exec once mutex <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> exec once <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> ( * <BoN> args <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> exec once <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> registry <EoN> [ <BoN> self <EoN> . <BoN> scopefunc <EoN> ( ) ] = <BoN> obj <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from items <EoN> ( <BoN> cls <EoN> , <BoN> items <EoN> , <BoN> columns <EoN> = <BoN> None <EoN> , <BoN> orient <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <NEWLINE> <BoN> Future Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> keys <EoN> , <BoN> values <EoN> = <BoN> lzip <EoN> ( * <BoN> items <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> orient <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> columns <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> columns <EoN> = <BoN> ensure index <EoN> ( <BoN> columns <EoN> ) <NEWLINE> <NEWLINE> <BoN> idict <EoN> = <BoN> dict <EoN> ( <BoN> items <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> idict <EoN> ) < <BoN> len <EoN> ( <BoN> items <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> columns <EoN> . <BoN> equals <EoN> ( <BoN> ensure index <EoN> ( <BoN> keys <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> arrays <EoN> = <BoN> values <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> arrays <EoN> = [ <BoN> idict <EoN> [ <BoN> k <EoN> ] <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> columns <EoN> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> idict <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> columns <EoN> = <BoN> ensure index <EoN> ( <BoN> keys <EoN> ) <NEWLINE> <BoN> arrays <EoN> = <BoN> values <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> . <BoN> from arrays <EoN> ( <BoN> arrays <EoN> , <BoN> columns <EoN> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> is nested list like <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> orient <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> columns <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> keys <EoN> = <BoN> ensure index <EoN> ( <BoN> keys <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> arr <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> values <EoN> , <BoN> dtype <EoN> = <BoN> object <EoN> ) . <BoN> T <EoN> <NEWLINE> <BoN> data <EoN> = [ <BoN> lib <EoN> . <BoN> maybe convert objects <EoN> ( <BoN> v <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> arr <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> cls <EoN> . <BoN> from arrays <EoN> ( <BoN> data <EoN> , <BoN> columns <EoN> , <BoN> keys <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> is nested list like <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> decorate <EoN> ( <BoN> func <EoN> , <BoN> caller <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> evaldict <EoN> = <BoN> func <EoN> . <BoN> globals <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> evaldict <EoN> [ <STRING> ] = <BoN> caller <EoN> <NEWLINE> <BoN> evaldict <EoN> [ <STRING> ] = <BoN> func <EoN> <NEWLINE> <BoN> fun <EoN> = <BoN> Function Maker <EoN> . <BoN> create <EoN> ( <NEWLINE> <BoN> func <EoN> , <STRING> , <NEWLINE> <BoN> evaldict <EoN> , <BoN> wrapped <EoN> = <BoN> func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> fun <EoN> . <BoN> qualname <EoN> = <BoN> func <EoN> . <BoN> qualname <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> fun <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> info <EoN> ( <BoN> self <EoN> , <BoN> series <EoN> = <BoN> None <EoN> , <BoN> pages <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> series <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> series <EoN> = <BoN> self <EoN> . <BoN> series <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> series <EoN> = [ <BoN> self <EoN> . <BoN> series <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> sequence <EoN> ( <BoN> series <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> result <EoN> = [ <BoN> str <EoN> ( <BoN> self <EoN> ) ] <NEWLINE> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> series <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> str <EoN> ( <BoN> s <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> pages <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> . <BoN> pages <EoN> [ <NUMBER> ] . <BoN> info <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> pages <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> pages <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> pages <EoN> = <BoN> self <EoN> . <BoN> pages <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pages <EoN> = [ <BoN> self <EoN> . <BoN> pages <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> sequence <EoN> ( <BoN> pages <EoN> ) ] <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> pages <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> p <EoN> . <BoN> info <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <STRING> . <BoN> join <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cofactors <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> gcd <EoN> = <BoN> self <EoN> . <BoN> gcd <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <BoN> cfa <EoN> = <BoN> self <EoN> . <BoN> quo <EoN> ( <BoN> a <EoN> , <BoN> gcd <EoN> ) <NEWLINE> <BoN> cfb <EoN> = <BoN> self <EoN> . <BoN> quo <EoN> ( <BoN> b <EoN> , <BoN> gcd <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> gcd <EoN> , <BoN> cfa <EoN> , <BoN> cfb <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rosen hess <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> atleast 1 d <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> H <EoN> = <BoN> numpy <EoN> . <BoN> diag <EoN> ( - <NUMBER> * <BoN> x <EoN> [ : - <NUMBER> ] , <NUMBER> ) - <BoN> numpy <EoN> . <BoN> diag <EoN> ( <NUMBER> * <BoN> x <EoN> [ : - <NUMBER> ] , - <NUMBER> ) <NEWLINE> <BoN> diagonal <EoN> = <BoN> numpy <EoN> . <BoN> zeros <EoN> ( <BoN> len <EoN> ( <BoN> x <EoN> ) , <BoN> dtype <EoN> = <BoN> x <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> diagonal <EoN> [ <NUMBER> ] = <NUMBER> * <BoN> x <EoN> [ <NUMBER> ] ** <NUMBER> - <NUMBER> * <BoN> x <EoN> [ <NUMBER> ] + <NUMBER> <NEWLINE> <BoN> diagonal <EoN> [ - <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> diagonal <EoN> [ <NUMBER> : - <NUMBER> ] = <NUMBER> + <NUMBER> * <BoN> x <EoN> [ <NUMBER> : - <NUMBER> ] ** <NUMBER> - <NUMBER> * <BoN> x <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> H <EoN> = <BoN> H <EoN> + <BoN> numpy <EoN> . <BoN> diag <EoN> ( <BoN> diagonal <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> H <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> anf <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> AN F <EoN> ( ) . <BoN> visit <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> node <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get args in value order <EoN> ( <BoN> self <EoN> , <BoN> argset <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> self <EoN> . <BoN> value number to value <EoN> [ <BoN> argn <EoN> ] <BoN> for <EoN> <BoN> argn <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> argset <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to ast <EoN> ( <BoN> self <EoN> , <BoN> namespace <EoN> , <BoN> internal convert user code <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> template <EoN> = <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> as qualified name <EoN> ( <BoN> o <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> inspect utils <EoN> . <BoN> getqualifiedname <EoN> ( <BoN> namespace <EoN> , <BoN> o <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> o <EoN> , <BoN> namespace <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> name <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> list of names <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <STRING> . <BoN> format <EoN> ( <STRING> . <BoN> join <EoN> ( <NEWLINE> <BoN> tuple <EoN> ( <BoN> as qualified name <EoN> ( <BoN> v <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> values <EoN> ) ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> list of features <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <STRING> . <BoN> format <EoN> ( <STRING> . <BoN> join <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> Feature <EoN> . <BoN> members <EoN> <NEWLINE> <BoN> if <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> values <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> internal convert user code <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> internal convert user code <EoN> = <BoN> self <EoN> . <BoN> internal convert user code <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> expr ast <EoN> = <BoN> templates <EoN> . <BoN> replace <EoN> ( <NEWLINE> <BoN> template <EoN> , <NEWLINE> <BoN> constructor name <EoN> = <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <NEWLINE> <BoN> as qualified name <EoN> ( <BoN> Conversion Options <EoN> ) ) , <NEWLINE> <BoN> recursive val <EoN> = <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <BoN> str <EoN> ( <BoN> self <EoN> . <BoN> recursive <EoN> ) ) , <NEWLINE> <BoN> verbose val <EoN> = <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <BoN> str <EoN> ( <BoN> int <EoN> ( <BoN> self <EoN> . <BoN> verbose <EoN> ) ) ) , <NEWLINE> <BoN> strip decorators val <EoN> = <BoN> list of names <EoN> ( <BoN> self <EoN> . <BoN> strip decorators <EoN> ) , <NEWLINE> <BoN> force conversion val <EoN> = <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <NEWLINE> <BoN> str <EoN> ( <BoN> self <EoN> . <BoN> force conversion <EoN> ) ) , <NEWLINE> <BoN> internal convert user code val <EoN> = <BoN> parser <EoN> . <BoN> parse expression <EoN> ( <NEWLINE> <BoN> str <EoN> ( <BoN> internal convert user code <EoN> ) ) , <NEWLINE> <BoN> optional features val <EoN> = <BoN> list of features <EoN> ( <BoN> self <EoN> . <BoN> optional features <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> expr ast <EoN> [ <NUMBER> ] . <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cholesky solve <EoN> ( <BoN> self <EoN> , <BoN> rhs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is hermitian <EoN> : <NEWLINE> <TAB> <BoN> L <EoN> = <BoN> self <EoN> . <BoN> cholesky <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> rows <EoN> >= <BoN> self <EoN> . <BoN> cols <EoN> : <NEWLINE> <TAB> <BoN> L <EoN> = ( <BoN> self <EoN> . <BoN> H <EoN> * <BoN> self <EoN> ) . <BoN> cholesky <EoN> ( ) <NEWLINE> <BoN> rhs <EoN> = <BoN> self <EoN> . <BoN> H <EoN> * <BoN> rhs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> Y <EoN> = <BoN> L <EoN> . <BoN> lower triangular solve <EoN> ( <BoN> rhs <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> L <EoN> . <BoN> H <EoN> ) . <BoN> upper triangular solve <EoN> ( <BoN> Y <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> davies bouldin score <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> X <EoN> , <BoN> labels <EoN> = <BoN> check X y <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> ) <NEWLINE> <BoN> le <EoN> = <BoN> Label Encoder <EoN> ( ) <NEWLINE> <BoN> labels <EoN> = <BoN> le <EoN> . <BoN> fit transform <EoN> ( <BoN> labels <EoN> ) <NEWLINE> <BoN> n samples <EoN> , <BoN> <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> n labels <EoN> = <BoN> len <EoN> ( <BoN> le <EoN> . <BoN> classes <EoN> ) <NEWLINE> <BoN> check number of labels <EoN> ( <BoN> n labels <EoN> , <BoN> n samples <EoN> ) <NEWLINE> <NEWLINE> <BoN> intra dists <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> n labels <EoN> ) <NEWLINE> <BoN> centroids <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> n labels <EoN> , <BoN> len <EoN> ( <BoN> X <EoN> [ <NUMBER> ] ) ) , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n labels <EoN> ) : <NEWLINE> <TAB> <BoN> cluster k <EoN> = <BoN> safe indexing <EoN> ( <BoN> X <EoN> , <BoN> labels <EoN> == <BoN> k <EoN> ) <NEWLINE> <BoN> centroid <EoN> = <BoN> cluster k <EoN> . <BoN> mean <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> centroids <EoN> [ <BoN> k <EoN> ] = <BoN> centroid <EoN> <NEWLINE> <BoN> intra dists <EoN> [ <BoN> k <EoN> ] = <BoN> np <EoN> . <BoN> average <EoN> ( <BoN> pairwise distances <EoN> ( <NEWLINE> <BoN> cluster k <EoN> , [ <BoN> centroid <EoN> ] ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> centroid distances <EoN> = <BoN> pairwise distances <EoN> ( <BoN> centroids <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> intra dists <EoN> , <NUMBER> ) <BoN> or <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> centroid distances <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> score <EoN> = ( <BoN> intra dists <EoN> [ : , <BoN> None <EoN> ] + <BoN> intra dists <EoN> ) / <BoN> centroid distances <EoN> <NEWLINE> <BoN> score <EoN> [ <BoN> score <EoN> == <BoN> np <EoN> . <BoN> inf <EoN> ] = <BoN> np <EoN> . <BoN> nan <EoN> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> np <EoN> . <BoN> nanmax <EoN> ( <BoN> score <EoN> , <BoN> axis <EoN> = <NUMBER> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get params <EoN> ( <BoN> self <EoN> , ** <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> res <EoN> = <BoN> copy <EoN> . <BoN> deepcopy <EoN> ( <BoN> self <EoN> . <BoN> sk params <EoN> ) <NEWLINE> <BoN> res <EoN> . <BoN> update <EoN> ( { <STRING> : <BoN> self <EoN> . <BoN> build fn <EoN> } ) <NEWLINE> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> distribute <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> distribute rl <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> arg <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> expr <EoN> . <BoN> args <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> arg <EoN> , <BoN> B <EoN> ) : <NEWLINE> <TAB> <BoN> first <EoN> , <BoN> b <EoN> , <BoN> tail <EoN> = <BoN> expr <EoN> . <BoN> args <EoN> [ : <BoN> i <EoN> ] , <BoN> expr <EoN> . <BoN> args <EoN> [ <BoN> i <EoN> ] , <BoN> expr <EoN> . <BoN> args <EoN> [ <BoN> i <EoN> + <NUMBER> : ] <NEWLINE> <BoN> return <EoN> <BoN> B <EoN> ( * [ <BoN> A <EoN> ( * ( <BoN> first <EoN> + ( <BoN> arg <EoN> , ) + <BoN> tail <EoN> ) ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> b <EoN> . <BoN> args <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> distribute rl <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sincos to sum <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> expr <EoN> . <BoN> has <EoN> ( <BoN> cos <EoN> , <BoN> sin <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> T R 8 <EoN> ( <BoN> expand mul <EoN> ( <BoN> T Rpower <EoN> ( <BoN> expr <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> findtext <EoN> ( <BoN> self <EoN> , <BoN> path <EoN> , <BoN> default <EoN> = <BoN> None <EoN> , <BoN> namespaces <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> path <EoN> [ : <NUMBER> ] == <STRING> : <NEWLINE> <TAB> <BoN> path <EoN> = <STRING> + <BoN> path <EoN> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> path <EoN> , <NEWLINE> <BoN> Future Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> findtext <EoN> ( <BoN> path <EoN> , <BoN> default <EoN> , <BoN> namespaces <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> intersecting product <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> a <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> a <EoN> [ : ] , <BoN> b <EoN> [ : ] <NEWLINE> <BoN> n <EoN> = <BoN> max <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) , <BoN> len <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> & ( <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <NUMBER> ** <BoN> n <EoN> . <BoN> bit length <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> += [ <BoN> S <EoN> . <BoN> Zero <EoN> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <BoN> b <EoN> += [ <BoN> S <EoN> . <BoN> Zero <EoN> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> mobius transform <EoN> ( <BoN> a <EoN> , <BoN> subset <EoN> = <BoN> False <EoN> ) , <BoN> mobius transform <EoN> ( <BoN> b <EoN> , <BoN> subset <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> a <EoN> = [ <BoN> expand mul <EoN> ( <BoN> x <EoN> * <BoN> y <EoN> ) <BoN> for <EoN> <BoN> x <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) ] <NEWLINE> <BoN> a <EoN> = <BoN> inverse mobius transform <EoN> ( <BoN> a <EoN> , <BoN> subset <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> translate train sizes <EoN> ( <BoN> train sizes <EoN> , <BoN> n max training samples <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> train sizes abs <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> train sizes <EoN> ) <NEWLINE> <BoN> n ticks <EoN> = <BoN> train sizes abs <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> n min required samples <EoN> = <BoN> np <EoN> . <BoN> min <EoN> ( <BoN> train sizes abs <EoN> ) <NEWLINE> <BoN> n max required samples <EoN> = <BoN> np <EoN> . <BoN> max <EoN> ( <BoN> train sizes abs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> issubdtype <EoN> ( <BoN> train sizes abs <EoN> . <BoN> dtype <EoN> , <BoN> np <EoN> . <BoN> floating <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n min required samples <EoN> <= <NUMBER> <BoN> or <EoN> <BoN> n max required samples <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> n min required samples <EoN> , <NEWLINE> <BoN> n max required samples <EoN> ) ) <NEWLINE> <UNTAB> <BoN> train sizes abs <EoN> = ( <BoN> train sizes abs <EoN> * <BoN> n max training samples <EoN> ) . <BoN> astype <EoN> ( <NEWLINE> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> train sizes abs <EoN> = <BoN> np <EoN> . <BoN> clip <EoN> ( <BoN> train sizes abs <EoN> , <NUMBER> , <NEWLINE> <BoN> n max training samples <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> n min required samples <EoN> <= <NUMBER> <BoN> or <EoN> <NEWLINE> <BoN> n max required samples <EoN> > <BoN> n max training samples <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> n max training samples <EoN> , <NEWLINE> <BoN> n min required samples <EoN> , <NEWLINE> <BoN> n max required samples <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> train sizes abs <EoN> = <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> train sizes abs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n ticks <EoN> > <BoN> train sizes abs <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> train sizes abs <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> n ticks <EoN> ) , <BoN> Runtime Warning <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> train sizes abs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set clip path <EoN> ( <BoN> self <EoN> , <BoN> path <EoN> , <BoN> transform <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( ) . <BoN> set clip path <EoN> ( <BoN> path <EoN> , <BoN> transform <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> update clip properties <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assert array almost equal nulp <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> nulp <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tracebackhide <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <BoN> ax <EoN> = <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> ay <EoN> = <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> ref <EoN> = <BoN> nulp <EoN> * <BoN> np <EoN> . <BoN> spacing <EoN> ( <BoN> np <EoN> . <BoN> where <EoN> ( <BoN> ax <EoN> > <BoN> ay <EoN> , <BoN> ax <EoN> , <BoN> ay <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> x <EoN> - <BoN> y <EoN> ) <= <BoN> ref <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> x <EoN> ) <BoN> or <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> y <EoN> ) : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> % <BoN> nulp <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> max nulp <EoN> = <BoN> np <EoN> . <BoN> max <EoN> ( <BoN> nulp diff <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <BoN> msg <EoN> = <STRING> % ( <BoN> nulp <EoN> , <BoN> max nulp <EoN> ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> construct <EoN> ( <BoN> Edge Component Aux Graph <EoN> , <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> not implemented for <EoN> ( <STRING> ) ( <BoN> lambda <EoN> <BoN> G <EoN> : <BoN> G <EoN> ) ( <BoN> G <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> recursive build <EoN> ( <BoN> H <EoN> , <BoN> A <EoN> , <BoN> source <EoN> , <BoN> avail <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> { <BoN> source <EoN> } == <BoN> avail <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sink <EoN> = <BoN> arbitrary element <EoN> ( <BoN> avail <EoN> - { <BoN> source <EoN> } ) <NEWLINE> <NEWLINE> <BoN> value <EoN> , ( <BoN> S <EoN> , <BoN> T <EoN> ) = <BoN> nx <EoN> . <BoN> minimum cut <EoN> ( <BoN> H <EoN> , <BoN> source <EoN> , <BoN> sink <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> H <EoN> . <BoN> is directed <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> value <EoN> , ( <BoN> T <EoN> , <BoN> S <EoN> ) = <BoN> nx <EoN> . <BoN> minimum cut <EoN> ( <BoN> H <EoN> , <BoN> sink <EoN> , <BoN> source <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> value <EoN> < <BoN> value <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> , <BoN> S <EoN> , <BoN> T <EoN> = <BoN> value <EoN> , <BoN> S <EoN> , <BoN> T <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> A <EoN> . <BoN> add edge <EoN> ( <BoN> source <EoN> , <BoN> sink <EoN> , <BoN> weight <EoN> = <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <BoN> recursive build <EoN> ( <BoN> H <EoN> , <BoN> A <EoN> , <BoN> source <EoN> , <BoN> avail <EoN> . <BoN> intersection <EoN> ( <BoN> S <EoN> ) ) <NEWLINE> <BoN> recursive build <EoN> ( <BoN> H <EoN> , <BoN> A <EoN> , <BoN> sink <EoN> , <BoN> avail <EoN> . <BoN> intersection <EoN> ( <BoN> T <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> H <EoN> = <BoN> G <EoN> . <BoN> class <EoN> ( ) <NEWLINE> <BoN> H <EoN> . <BoN> add nodes from <EoN> ( <BoN> G <EoN> . <BoN> nodes <EoN> ( ) ) <NEWLINE> <BoN> H <EoN> . <BoN> add edges from <EoN> ( <BoN> G <EoN> . <BoN> edges <EoN> ( ) , <BoN> capacity <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> A <EoN> = <BoN> nx <EoN> . <BoN> Graph <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> H <EoN> . <BoN> number of nodes <EoN> ( ) > <NUMBER> : <NEWLINE> <TAB> <BoN> source <EoN> = <BoN> arbitrary element <EoN> ( <BoN> H <EoN> . <BoN> nodes <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> avail <EoN> = <BoN> set <EoN> ( <BoN> H <EoN> . <BoN> nodes <EoN> ( ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> recursive build <EoN> ( <BoN> H <EoN> , <BoN> A <EoN> , <BoN> source <EoN> , <BoN> avail <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> = <BoN> Edge Component Aux Graph <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> A <EoN> = <BoN> A <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> H <EoN> = <BoN> H <EoN> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fliplr <EoN> ( <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> m <EoN> = <BoN> asanyarray <EoN> ( <BoN> m <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> . <BoN> ndim <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> m <EoN> [ : , : : - <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get indices Mul <EoN> ( <BoN> expr <EoN> , <BoN> return dummies <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> inds <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> get indices <EoN> , <BoN> expr <EoN> . <BoN> args <EoN> ) ) <NEWLINE> <BoN> inds <EoN> , <BoN> syms <EoN> = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> inds <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> inds <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> list <EoN> , <BoN> inds <EoN> ) ) <NEWLINE> <BoN> inds <EoN> = <BoN> list <EoN> ( <BoN> reduce <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> , <BoN> y <EoN> : <BoN> x <EoN> + <BoN> y <EoN> , <BoN> inds <EoN> ) ) <NEWLINE> <BoN> inds <EoN> , <BoN> dummies <EoN> = <BoN> remove repeated <EoN> ( <BoN> inds <EoN> ) <NEWLINE> <NEWLINE> <BoN> symmetry <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> syms <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> pair <EoN> <BoN> in <EoN> <BoN> s <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> pair <EoN> <BoN> in <EoN> <BoN> symmetry <EoN> : <NEWLINE> <TAB> <BoN> symmetry <EoN> [ <BoN> pair <EoN> ] *= <BoN> s <EoN> [ <BoN> pair <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> symmetry <EoN> [ <BoN> pair <EoN> ] = <BoN> s <EoN> [ <BoN> pair <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> return dummies <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> inds <EoN> , <BoN> symmetry <EoN> , <BoN> dummies <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> inds <EoN> , <BoN> symmetry <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Random Dataset V 2 <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> seed <EoN> , <BoN> self <EoN> . <BoN> seed 2 <EoN> = <BoN> random seed <EoN> . <BoN> get seed <EoN> ( <BoN> seed <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> invert <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> harmonize columns <EoN> ( <BoN> self <EoN> , <BoN> parse dates <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> parse dates <EoN> <BoN> is <EoN> <BoN> True <EoN> <BoN> or <EoN> <BoN> parse dates <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> parse dates <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> parse dates <EoN> = [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> parse dates <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> parse dates <EoN> = [ <BoN> parse dates <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> sql col <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> table <EoN> . <BoN> columns <EoN> : <NEWLINE> <TAB> <BoN> col name <EoN> = <BoN> sql col <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> df col <EoN> = <BoN> self <EoN> . <BoN> frame <EoN> [ <BoN> col name <EoN> ] <NEWLINE> <NEWLINE> <BoN> col type <EoN> = <BoN> self <EoN> . <BoN> get dtype <EoN> ( <BoN> sql col <EoN> . <BoN> type <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> col type <EoN> <BoN> is <EoN> <BoN> datetime <EoN> <BoN> or <EoN> <BoN> col type <EoN> <BoN> is <EoN> <BoN> date <EoN> <BoN> or <EoN> <NEWLINE> <BoN> col type <EoN> <BoN> is <EoN> <BoN> Datetime TZ Dtype <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> utc <EoN> = <BoN> col type <EoN> <BoN> is <EoN> <BoN> Datetime TZ Dtype <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> frame <EoN> [ <BoN> col name <EoN> ] = <BoN> handle date column <EoN> ( <BoN> df col <EoN> , <BoN> utc <EoN> = <BoN> utc <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> col type <EoN> <BoN> is <EoN> <BoN> float <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> frame <EoN> [ <BoN> col name <EoN> ] = <BoN> df col <EoN> . <BoN> astype <EoN> ( <BoN> col type <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> df col <EoN> ) == <BoN> df col <EoN> . <BoN> count <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> col type <EoN> <BoN> is <EoN> <BoN> np <EoN> . <BoN> dtype <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> col type <EoN> <BoN> is <EoN> <BoN> bool <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> frame <EoN> [ <BoN> col name <EoN> ] = <BoN> df col <EoN> . <BoN> astype <EoN> ( <NEWLINE> <BoN> col type <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> col name <EoN> <BoN> in <EoN> <BoN> parse dates <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> fmt <EoN> = <BoN> parse dates <EoN> [ <BoN> col name <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> fmt <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> frame <EoN> [ <BoN> col name <EoN> ] = <BoN> handle date column <EoN> ( <NEWLINE> <BoN> df col <EoN> , <BoN> format <EoN> = <BoN> fmt <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> upgrade to float no complex <EoN> ( * <BoN> types <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> type <EoN> <BoN> in <EoN> <BoN> types <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> type <EoN> <BoN> in <EoN> <BoN> complex types <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> upgrade to float <EoN> ( * <BoN> types <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set array <EoN> ( <BoN> self <EoN> , <BoN> A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> A <EoN> = <BoN> A <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> update dict <EoN> [ <STRING> ] = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> trainer <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> reporter <EoN> = <BoN> reporter module <EoN> . <BoN> Reporter <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prefix <EoN> = <BoN> self <EoN> . <BoN> name <EoN> + <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> prefix <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> name <EoN> , <BoN> target <EoN> <BoN> in <EoN> <BoN> six <EoN> . <BoN> iteritems <EoN> ( <BoN> self <EoN> . <BoN> targets <EoN> ) : <NEWLINE> <TAB> <BoN> reporter <EoN> . <BoN> add observer <EoN> ( <BoN> prefix <EoN> + <BoN> name <EoN> , <BoN> target <EoN> ) <NEWLINE> <BoN> reporter <EoN> . <BoN> add observers <EoN> ( <BoN> prefix <EoN> + <BoN> name <EoN> , <NEWLINE> <BoN> target <EoN> . <BoN> namedlinks <EoN> ( <BoN> skipself <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> reporter <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> configuration <EoN> . <BoN> using config <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> evaluate <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> reporter module <EoN> . <BoN> report <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> spherical kn <EoN> ( <BoN> n <EoN> , <BoN> z <EoN> , <BoN> derivative <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> derivative <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> spherical kn d <EoN> ( <BoN> n <EoN> , <BoN> z <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> spherical kn <EoN> ( <BoN> n <EoN> , <BoN> z <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> convert to protection <EoN> ( <BoN> cls <EoN> , <BoN> protection dict <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> from <EoN> <BoN> openpyxl <EoN> . <BoN> styles <EoN> <BoN> import <EoN> <BoN> Protection <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Protection <EoN> ( ** <BoN> protection dict <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get parents <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check array length consistency <EoN> ( <BoN> inputs <EoN> , <BoN> targets <EoN> , <BoN> weights <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> set of lengths <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> { <NUMBER> } <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> set <EoN> ( [ <NUMBER> <BoN> if <EoN> <BoN> y <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> int <EoN> ( <BoN> y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <BoN> for <EoN> <BoN> y <EoN> <BoN> in <EoN> <BoN> x <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> set x <EoN> = <BoN> set of lengths <EoN> ( <BoN> inputs <EoN> ) <NEWLINE> <BoN> set y <EoN> = <BoN> set of lengths <EoN> ( <BoN> targets <EoN> ) <NEWLINE> <BoN> set w <EoN> = <BoN> set of lengths <EoN> ( <BoN> weights <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> set x <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( [ <BoN> x <EoN> . <BoN> shape <EoN> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> inputs <EoN> ] ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> set y <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( [ <BoN> y <EoN> . <BoN> shape <EoN> <BoN> for <EoN> <BoN> y <EoN> <BoN> in <EoN> <BoN> targets <EoN> ] ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> set x <EoN> <BoN> and <EoN> <BoN> set y <EoN> <BoN> and <EoN> <BoN> list <EoN> ( <BoN> set x <EoN> ) [ <NUMBER> ] != <BoN> list <EoN> ( <BoN> set y <EoN> ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> list <EoN> ( <BoN> set x <EoN> ) [ <NUMBER> ] ) + <STRING> <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> list <EoN> ( <BoN> set y <EoN> ) [ <NUMBER> ] ) + <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> set w <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( [ <BoN> w <EoN> . <BoN> shape <EoN> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> weights <EoN> ] ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> set y <EoN> <BoN> and <EoN> <BoN> set w <EoN> <BoN> and <EoN> <BoN> list <EoN> ( <BoN> set y <EoN> ) [ <NUMBER> ] != <BoN> list <EoN> ( <BoN> set w <EoN> ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> list <EoN> ( <BoN> set y <EoN> ) [ <NUMBER> ] ) + <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> list <EoN> ( <BoN> set w <EoN> ) [ <NUMBER> ] ) + <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> vals <EoN> , <BoN> rows <EoN> , <BoN> cols <EoN> , <BoN> shape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> n <EoN> , <BoN> self <EoN> . <BoN> m <EoN> = <BoN> shape <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> vals <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> vals <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> rows <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> rows <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> cols <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> cols <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rsqrt <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> rsqrt <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logsumexp <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> keepdims <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> reduce logsumexp <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> keepdims <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> stack <EoN> ( <BoN> frame <EoN> , <BoN> level <EoN> = - <NUMBER> , <BoN> dropna <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> factorize <EoN> ( <BoN> index <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> index <EoN> . <BoN> is unique <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> index <EoN> , <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> len <EoN> ( <BoN> index <EoN> ) ) <NEWLINE> <UNTAB> <BoN> codes <EoN> , <BoN> categories <EoN> = <BoN> factorize from iterable <EoN> ( <BoN> index <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> categories <EoN> , <BoN> codes <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> N <EoN> , <BoN> K <EoN> = <BoN> frame <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> frame <EoN> . <BoN> columns <EoN> , <BoN> Multi Index <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> frame <EoN> . <BoN> columns <EoN> . <BoN> reference duplicate name <EoN> ( <BoN> level <EoN> ) : <NEWLINE> <TAB> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> level <EoN> = <BoN> level <EoN> ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> level num <EoN> = <BoN> frame <EoN> . <BoN> columns <EoN> . <BoN> get level number <EoN> ( <BoN> level <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> frame <EoN> . <BoN> columns <EoN> , <BoN> Multi Index <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> stack multi columns <EoN> ( <BoN> frame <EoN> , <BoN> level num <EoN> = <BoN> level num <EoN> , <BoN> dropna <EoN> = <BoN> dropna <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> frame <EoN> . <BoN> index <EoN> , <BoN> Multi Index <EoN> ) : <NEWLINE> <TAB> <BoN> new levels <EoN> = <BoN> list <EoN> ( <BoN> frame <EoN> . <BoN> index <EoN> . <BoN> levels <EoN> ) <NEWLINE> <BoN> new labels <EoN> = [ <BoN> lab <EoN> . <BoN> repeat <EoN> ( <BoN> K <EoN> ) <BoN> for <EoN> <BoN> lab <EoN> <BoN> in <EoN> <BoN> frame <EoN> . <BoN> index <EoN> . <BoN> labels <EoN> ] <NEWLINE> <NEWLINE> <BoN> clev <EoN> , <BoN> clab <EoN> = <BoN> factorize <EoN> ( <BoN> frame <EoN> . <BoN> columns <EoN> ) <NEWLINE> <BoN> new levels <EoN> . <BoN> append <EoN> ( <BoN> clev <EoN> ) <NEWLINE> <BoN> new labels <EoN> . <BoN> append <EoN> ( <BoN> np <EoN> . <BoN> tile <EoN> ( <BoN> clab <EoN> , <BoN> N <EoN> ) . <BoN> ravel <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> new names <EoN> = <BoN> list <EoN> ( <BoN> frame <EoN> . <BoN> index <EoN> . <BoN> names <EoN> ) <NEWLINE> <BoN> new names <EoN> . <BoN> append <EoN> ( <BoN> frame <EoN> . <BoN> columns <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> new index <EoN> = <BoN> Multi Index <EoN> ( <BoN> levels <EoN> = <BoN> new levels <EoN> , <BoN> labels <EoN> = <BoN> new labels <EoN> , <NEWLINE> <BoN> names <EoN> = <BoN> new names <EoN> , <BoN> verify integrity <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> levels <EoN> , ( <BoN> ilab <EoN> , <BoN> clab <EoN> ) = <BoN> zip <EoN> ( * <BoN> map <EoN> ( <BoN> factorize <EoN> , ( <BoN> frame <EoN> . <BoN> index <EoN> , <NEWLINE> <BoN> frame <EoN> . <BoN> columns <EoN> ) ) ) <NEWLINE> <BoN> labels <EoN> = <BoN> ilab <EoN> . <BoN> repeat <EoN> ( <BoN> K <EoN> ) , <BoN> np <EoN> . <BoN> tile <EoN> ( <BoN> clab <EoN> , <BoN> N <EoN> ) . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> new index <EoN> = <BoN> Multi Index <EoN> ( <BoN> levels <EoN> = <BoN> levels <EoN> , <BoN> labels <EoN> = <BoN> labels <EoN> , <NEWLINE> <BoN> names <EoN> = [ <BoN> frame <EoN> . <BoN> index <EoN> . <BoN> name <EoN> , <BoN> frame <EoN> . <BoN> columns <EoN> . <BoN> name <EoN> ] , <NEWLINE> <BoN> verify integrity <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> new values <EoN> = <BoN> frame <EoN> . <BoN> values <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> dropna <EoN> : <NEWLINE> <TAB> <BoN> mask <EoN> = <BoN> notna <EoN> ( <BoN> new values <EoN> ) <NEWLINE> <BoN> new values <EoN> = <BoN> new values <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <BoN> new index <EoN> = <BoN> new index <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> frame <EoN> . <BoN> constructor sliced <EoN> ( <BoN> new values <EoN> , <BoN> index <EoN> = <BoN> new index <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> general cosine <EoN> ( <BoN> M <EoN> , <BoN> a <EoN> , <BoN> sym <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len guards <EoN> ( <BoN> M <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> ones <EoN> ( <BoN> M <EoN> ) <NEWLINE> <UNTAB> <BoN> M <EoN> , <BoN> needs trunc <EoN> = <BoN> extend <EoN> ( <BoN> M <EoN> , <BoN> sym <EoN> ) <NEWLINE> <NEWLINE> <BoN> fac <EoN> = <BoN> np <EoN> . <BoN> linspace <EoN> ( - <BoN> np <EoN> . <BoN> pi <EoN> , <BoN> np <EoN> . <BoN> pi <EoN> , <BoN> M <EoN> ) <NEWLINE> <BoN> w <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> M <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) ) : <NEWLINE> <TAB> <BoN> w <EoN> += <BoN> a <EoN> [ <BoN> k <EoN> ] * <BoN> np <EoN> . <BoN> cos <EoN> ( <BoN> k <EoN> * <BoN> fac <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> truncate <EoN> ( <BoN> w <EoN> , <BoN> needs trunc <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bilinear kernel 1 D <EoN> ( <BoN> ratio <EoN> , <BoN> normalize <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> T <EoN> = <BoN> theano <EoN> . <BoN> tensor <EoN> <NEWLINE> <BoN> half kern <EoN> = <BoN> T <EoN> . <BoN> arange <EoN> ( <NUMBER> , <BoN> ratio <EoN> + <NUMBER> , <BoN> dtype <EoN> = <BoN> theano <EoN> . <BoN> config <EoN> . <BoN> float X <EoN> ) <NEWLINE> <BoN> kern <EoN> = <BoN> T <EoN> . <BoN> concatenate <EoN> ( [ <BoN> half kern <EoN> , <BoN> half kern <EoN> [ - <NUMBER> : : - <NUMBER> ] ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> normalize <EoN> : <NEWLINE> <TAB> <BoN> kern <EoN> /= <BoN> ratio <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> kern <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> @ <BoN> cacheit <EoN> <NEWLINE> <BoN> def <EoN> <BoN> taylor term <EoN> ( <BoN> n <EoN> , <BoN> x <EoN> , * <BoN> previous terms <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> bernoulli <EoN> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> / <BoN> sympify <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> n <EoN> < <NUMBER> <BoN> or <EoN> <BoN> n <EoN> % <NUMBER> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> sympify <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> B <EoN> = <BoN> bernoulli <EoN> ( <BoN> n <EoN> + <NUMBER> ) <NEWLINE> <BoN> F <EoN> = <BoN> factorial <EoN> ( <BoN> n <EoN> + <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <NUMBER> * ( <NUMBER> - <NUMBER> ** <BoN> n <EoN> ) * <BoN> B <EoN> / <BoN> F <EoN> * <BoN> x <EoN> ** <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> figaspect <EoN> ( <BoN> arg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> isarray <EoN> = <BoN> hasattr <EoN> ( <BoN> arg <EoN> , <STRING> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> isscalar <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> figsize min <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <BoN> figsize max <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isarray <EoN> : <NEWLINE> <TAB> <BoN> nr <EoN> , <BoN> nc <EoN> = <BoN> arg <EoN> . <BoN> shape <EoN> [ : <NUMBER> ] <NEWLINE> <BoN> arr ratio <EoN> = <BoN> nr <EoN> / <BoN> nc <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> arr ratio <EoN> = <BoN> arg <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> fig height <EoN> = <BoN> rc Params <EoN> [ <STRING> ] [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> newsize <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( ( <BoN> fig height <EoN> / <BoN> arr ratio <EoN> , <BoN> fig height <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> newsize <EoN> /= <BoN> min <EoN> ( <NUMBER> , * ( <BoN> newsize <EoN> / <BoN> figsize min <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> newsize <EoN> /= <BoN> max <EoN> ( <NUMBER> , * ( <BoN> newsize <EoN> / <BoN> figsize max <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> newsize <EoN> = <BoN> np <EoN> . <BoN> clip <EoN> ( <BoN> newsize <EoN> , <BoN> figsize min <EoN> , <BoN> figsize max <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> newsize <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> share memory <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> storage <EoN> ( ) . <BoN> share memory <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hsv 2 rgb <EoN> ( <BoN> hsv <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> arr <EoN> = <BoN> prepare colorarray <EoN> ( <BoN> hsv <EoN> ) <NEWLINE> <NEWLINE> <BoN> hi <EoN> = <BoN> np <EoN> . <BoN> floor <EoN> ( <BoN> arr <EoN> [ : , : , <NUMBER> ] * <NUMBER> ) <NEWLINE> <BoN> f <EoN> = <BoN> arr <EoN> [ : , : , <NUMBER> ] * <NUMBER> - <BoN> hi <EoN> <NEWLINE> <BoN> p <EoN> = <BoN> arr <EoN> [ : , : , <NUMBER> ] * ( <NUMBER> - <BoN> arr <EoN> [ : , : , <NUMBER> ] ) <NEWLINE> <BoN> q <EoN> = <BoN> arr <EoN> [ : , : , <NUMBER> ] * ( <NUMBER> - <BoN> f <EoN> * <BoN> arr <EoN> [ : , : , <NUMBER> ] ) <NEWLINE> <BoN> t <EoN> = <BoN> arr <EoN> [ : , : , <NUMBER> ] * ( <NUMBER> - ( <NUMBER> - <BoN> f <EoN> ) * <BoN> arr <EoN> [ : , : , <NUMBER> ] ) <NEWLINE> <BoN> v <EoN> = <BoN> arr <EoN> [ : , : , <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> hi <EoN> = <BoN> np <EoN> . <BoN> dstack <EoN> ( [ <BoN> hi <EoN> , <BoN> hi <EoN> , <BoN> hi <EoN> ] ) . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> uint 8 <EoN> ) % <NUMBER> <NEWLINE> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> choose <EoN> ( <BoN> hi <EoN> , [ <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> v <EoN> , <BoN> t <EoN> , <BoN> p <EoN> ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> q <EoN> , <BoN> v <EoN> , <BoN> p <EoN> ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> p <EoN> , <BoN> v <EoN> , <BoN> t <EoN> ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> p <EoN> , <BoN> q <EoN> , <BoN> v <EoN> ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> t <EoN> , <BoN> p <EoN> , <BoN> v <EoN> ) ) , <NEWLINE> <BoN> np <EoN> . <BoN> dstack <EoN> ( ( <BoN> v <EoN> , <BoN> p <EoN> , <BoN> q <EoN> ) ) ] ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> log every n <EoN> ( <BoN> level <EoN> , <BoN> msg <EoN> , <BoN> n <EoN> , * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> count <EoN> = <BoN> GetNextLogCountPerToken <EoN> ( <BoN> GetFileAndLine <EoN> ( ) ) <NEWLINE> <BoN> log if <EoN> ( <BoN> level <EoN> , <BoN> msg <EoN> , <BoN> not <EoN> ( <BoN> count <EoN> % <BoN> n <EoN> ) , * <BoN> args <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> deformable convolution 2 d sampler <EoN> ( <BoN> x <EoN> , <BoN> offset <EoN> , <BoN> W <EoN> , <BoN> b <EoN> = <BoN> None <EoN> , <BoN> stride <EoN> = <NUMBER> , <BoN> pad <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sy <EoN> , <BoN> sx <EoN> = <BoN> pair <EoN> ( <BoN> stride <EoN> ) <NEWLINE> <BoN> ph <EoN> , <BoN> pw <EoN> = <BoN> pair <EoN> ( <BoN> pad <EoN> ) <NEWLINE> <BoN> out c <EoN> , <BoN> <EoN> , <BoN> kh <EoN> , <BoN> kw <EoN> = <BoN> W <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> n <EoN> , <BoN> c <EoN> , <BoN> h <EoN> , <BoN> w <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> <EoN> , <BoN> khkw 2 <EoN> , <BoN> out h <EoN> , <BoN> out w <EoN> = <BoN> offset <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> khkw 2 <EoN> != <NUMBER> * <BoN> kh <EoN> * <BoN> kw <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> grid <EoN> = <BoN> offset 2 grid <EoN> ( <BoN> offset <EoN> , <BoN> kh <EoN> , <BoN> kw <EoN> , <BoN> sy <EoN> , <BoN> sx <EoN> , <BoN> ph <EoN> , <BoN> pw <EoN> , <BoN> h <EoN> , <BoN> w <EoN> ) <NEWLINE> <BoN> grid <EoN> = <BoN> grid <EoN> . <BoN> reshape <EoN> ( <BoN> n <EoN> , <NUMBER> , <BoN> kh <EoN> * <BoN> kw <EoN> , <BoN> out h <EoN> * <BoN> out w <EoN> ) <NEWLINE> <BoN> x pad <EoN> = <BoN> pad module <EoN> . <BoN> pad <EoN> ( <BoN> x <EoN> , ( ( <NUMBER> , <NUMBER> ) , ( <NUMBER> , <NUMBER> ) , ( <BoN> ph <EoN> , <BoN> ph <EoN> ) , ( <BoN> pw <EoN> , <BoN> pw <EoN> ) ) , <STRING> ) <NEWLINE> <BoN> x st <EoN> = <BoN> spatial transformer sampler <EoN> . <BoN> spatial transformer sampler <EoN> ( <NEWLINE> <BoN> x pad <EoN> , <BoN> grid <EoN> ) <NEWLINE> <NEWLINE> <BoN> x st <EoN> = <BoN> x st <EoN> . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) . <BoN> reshape <EoN> ( <BoN> n <EoN> * <BoN> out h <EoN> * <BoN> out w <EoN> , <BoN> c <EoN> * <BoN> kh <EoN> * <BoN> kw <EoN> ) <NEWLINE> <BoN> W <EoN> = <BoN> W <EoN> . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) . <BoN> reshape <EoN> ( <BoN> c <EoN> * <BoN> kh <EoN> * <BoN> kw <EoN> , <BoN> out c <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> matmul <EoN> . <BoN> matmul <EoN> ( <BoN> x st <EoN> , <BoN> W <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> y <EoN> . <BoN> reshape <EoN> ( <BoN> n <EoN> , <BoN> out h <EoN> , <BoN> out w <EoN> , <BoN> out c <EoN> ) . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> b <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> = <BoN> broadcast <EoN> . <BoN> broadcast to <EoN> ( <BoN> b <EoN> [ <BoN> None <EoN> , : , <BoN> None <EoN> , <BoN> None <EoN> ] , <BoN> y <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> y <EoN> += <BoN> b <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make layout margins <EoN> ( <BoN> ax <EoN> , <BoN> renderer <EoN> , <BoN> h pad <EoN> , <BoN> w pad <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fig <EoN> = <BoN> ax <EoN> . <BoN> figure <EoN> <NEWLINE> <BoN> inv Trans Fig <EoN> = <BoN> fig <EoN> . <BoN> trans Figure <EoN> . <BoN> inverted <EoN> ( ) . <BoN> transform bbox <EoN> <NEWLINE> <NEWLINE> <BoN> pos <EoN> = <BoN> ax <EoN> . <BoN> get position <EoN> ( <BoN> original <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> tightbbox <EoN> = <BoN> ax <EoN> . <BoN> get tightbbox <EoN> ( <BoN> renderer <EoN> = <BoN> renderer <EoN> ) <NEWLINE> <BoN> bbox <EoN> = <BoN> inv Trans Fig <EoN> ( <BoN> tightbbox <EoN> ) <NEWLINE> <NEWLINE> <BoN> h padt <EoN> = <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> h pad <EoN> <NEWLINE> <BoN> if <EoN> <BoN> h padt <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> h padt <EoN> = <BoN> h pad <EoN> <NEWLINE> <UNTAB> <BoN> w padt <EoN> = <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> w pad <EoN> <NEWLINE> <BoN> if <EoN> <BoN> w padt <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> w padt <EoN> = <BoN> w pad <EoN> <NEWLINE> <UNTAB> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> edit left margin min <EoN> ( - <BoN> bbox <EoN> . <BoN> x 0 <EoN> + <NEWLINE> <BoN> pos <EoN> . <BoN> x 0 <EoN> + <BoN> w padt <EoN> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> edit right margin min <EoN> ( <BoN> bbox <EoN> . <BoN> x 1 <EoN> - <NEWLINE> <BoN> pos <EoN> . <BoN> x 1 <EoN> + <BoN> w padt <EoN> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> edit bottom margin min <EoN> ( <NEWLINE> - <BoN> bbox <EoN> . <BoN> y 0 <EoN> + <BoN> pos <EoN> . <BoN> y 0 <EoN> + <BoN> h padt <EoN> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> edit top margin min <EoN> ( <BoN> bbox <EoN> . <BoN> y 1 <EoN> - <BoN> pos <EoN> . <BoN> y 1 <EoN> + <BoN> h padt <EoN> ) <NEWLINE> <BoN> log <EoN> . <BoN> debug <EoN> ( <STRING> , ( - <BoN> bbox <EoN> . <BoN> x 0 <EoN> + <BoN> pos <EoN> . <BoN> x 0 <EoN> + <BoN> w pad <EoN> ) ) <NEWLINE> <BoN> log <EoN> . <BoN> debug <EoN> ( <STRING> , ( <BoN> bbox <EoN> . <BoN> x 1 <EoN> - <BoN> pos <EoN> . <BoN> x 1 <EoN> + <BoN> w pad <EoN> ) ) <NEWLINE> <BoN> log <EoN> . <BoN> debug <EoN> ( <STRING> , ( - <BoN> bbox <EoN> . <BoN> y 0 <EoN> + <BoN> pos <EoN> . <BoN> y 0 <EoN> + <BoN> h padt <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> fig <EoN> . <BoN> layoutbox <EoN> . <BoN> constrained layout called <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain height min <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain width min <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> layoutbox <EoN> . <BoN> constrain height min <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> layoutbox <EoN> . <BoN> constrain width min <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain top margin <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain bottom margin <EoN> ( <NUMBER> , <NEWLINE> <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain right margin <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> poslayoutbox <EoN> . <BoN> constrain left margin <EoN> ( <NUMBER> , <BoN> strength <EoN> = <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rsqrt grad <EoN> ( <BoN> y <EoN> , <BoN> dy <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> y <EoN> , <BoN> dy <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rsqrt grad eager fallback <EoN> ( <NEWLINE> <BoN> y <EoN> , <BoN> dy <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> dy <EoN> = <BoN> dy <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> finalize <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> det <EoN> ( <BoN> a <EoN> , <BoN> overwrite a <EoN> = <BoN> False <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a 1 <EoN> = <BoN> asarray validated <EoN> ( <BoN> a <EoN> , <BoN> check finite <EoN> = <BoN> check finite <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> a 1 <EoN> . <BoN> shape <EoN> ) != <NUMBER> <BoN> or <EoN> <BoN> a 1 <EoN> . <BoN> shape <EoN> [ <NUMBER> ] != <BoN> a 1 <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> overwrite a <EoN> = <BoN> overwrite a <EoN> <BoN> or <EoN> <BoN> datacopied <EoN> ( <BoN> a 1 <EoN> , <BoN> a <EoN> ) <NEWLINE> <BoN> fdet <EoN> , = <BoN> get flinalg funcs <EoN> ( ( <STRING> , ) , ( <BoN> a 1 <EoN> , ) ) <NEWLINE> <BoN> a det <EoN> , <BoN> info <EoN> = <BoN> fdet <EoN> ( <BoN> a 1 <EoN> , <BoN> overwrite a <EoN> = <BoN> overwrite a <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> info <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % - <BoN> info <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> a det <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lrn grad eager fallback <EoN> ( <BoN> input grads <EoN> , <BoN> input image <EoN> , <BoN> output image <EoN> , <BoN> depth radius <EoN> = <NUMBER> , <BoN> bias <EoN> = <NUMBER> , <BoN> alpha <EoN> = <NUMBER> , <BoN> beta <EoN> = <NUMBER> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> depth radius <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> depth radius <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> depth radius <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> depth radius <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> bias <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bias <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> bias <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> bias <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> alpha <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> alpha <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> alpha <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> alpha <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> beta <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> beta <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> beta <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> beta <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input grads <EoN> , <BoN> input image <EoN> , <BoN> output image <EoN> ] , <BoN> ctx <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> ( <BoN> input grads <EoN> , <BoN> input image <EoN> , <BoN> output image <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input grads <EoN> , <BoN> input image <EoN> , <BoN> output image <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> depth radius <EoN> , <STRING> , <BoN> bias <EoN> , <STRING> , <BoN> alpha <EoN> , <NEWLINE> <STRING> , <BoN> beta <EoN> , <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> no dependency <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> data structures <EoN> . <BoN> No Dependency <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> as completed <EoN> ( <BoN> fs <EoN> , <BoN> timeout <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> timeout <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> end time <EoN> = <BoN> timeout <EoN> + <BoN> time <EoN> . <BoN> monotonic <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> fs <EoN> = <BoN> set <EoN> ( <BoN> fs <EoN> ) <NEWLINE> <BoN> total futures <EoN> = <BoN> len <EoN> ( <BoN> fs <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> AcquireFutures <EoN> ( <BoN> fs <EoN> ) : <NEWLINE> <TAB> <BoN> finished <EoN> = <BoN> set <EoN> ( <NEWLINE> <BoN> f <EoN> <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> fs <EoN> <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> . <BoN> state <EoN> <BoN> in <EoN> [ <BoN> CANCELLED AND NOTIFIED <EoN> , <BoN> FINISHE D <EoN> ] ) <NEWLINE> <BoN> pending <EoN> = <BoN> fs <EoN> - <BoN> finished <EoN> <NEWLINE> <BoN> waiter <EoN> = <BoN> create and install waiters <EoN> ( <BoN> fs <EoN> , <BoN> AS COMPLETED <EoN> ) <NEWLINE> <UNTAB> <BoN> finished <EoN> = <BoN> list <EoN> ( <BoN> finished <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> from <EoN> <BoN> yield finished futures <EoN> ( <BoN> finished <EoN> , <BoN> waiter <EoN> , <NEWLINE> <BoN> ref collect <EoN> = ( <BoN> fs <EoN> , ) ) <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> pending <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> timeout <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> wait timeout <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> wait timeout <EoN> = <BoN> end time <EoN> - <BoN> time <EoN> . <BoN> monotonic <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> wait timeout <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Timeout Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> len <EoN> ( <BoN> pending <EoN> ) , <BoN> total futures <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> waiter <EoN> . <BoN> event <EoN> . <BoN> wait <EoN> ( <BoN> wait timeout <EoN> ) <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> waiter <EoN> . <BoN> lock <EoN> : <NEWLINE> <TAB> <BoN> finished <EoN> = <BoN> waiter <EoN> . <BoN> finished futures <EoN> <NEWLINE> <BoN> waiter <EoN> . <BoN> finished futures <EoN> = [ ] <NEWLINE> <BoN> waiter <EoN> . <BoN> event <EoN> . <BoN> clear <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> finished <EoN> . <BoN> reverse <EoN> ( ) <NEWLINE> <BoN> yield <EoN> <BoN> from <EoN> <BoN> yield finished futures <EoN> ( <BoN> finished <EoN> , <BoN> waiter <EoN> , <NEWLINE> <BoN> ref collect <EoN> = ( <BoN> fs <EoN> , <BoN> pending <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> fs <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> f <EoN> . <BoN> condition <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> waiters <EoN> . <BoN> remove <EoN> ( <BoN> waiter <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> chebfit <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> deg <EoN> , <BoN> rcond <EoN> = <BoN> None <EoN> , <BoN> full <EoN> = <BoN> False <EoN> , <BoN> w <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> x <EoN> ) + <NUMBER> <NEWLINE> <BoN> y <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> y <EoN> ) + <NUMBER> <NEWLINE> <BoN> deg <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> deg <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> deg <EoN> . <BoN> ndim <EoN> > <NUMBER> <BoN> or <EoN> <BoN> deg <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> not <EoN> <BoN> in <EoN> <STRING> <BoN> or <EoN> <BoN> deg <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> deg <EoN> . <BoN> min <EoN> ( ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> y <EoN> . <BoN> ndim <EoN> < <NUMBER> <BoN> or <EoN> <BoN> y <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> x <EoN> ) != <BoN> len <EoN> ( <BoN> y <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> deg <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> lmax <EoN> = <BoN> deg <EoN> <NEWLINE> <BoN> order <EoN> = <BoN> lmax <EoN> + <NUMBER> <NEWLINE> <BoN> van <EoN> = <BoN> chebvander <EoN> ( <BoN> x <EoN> , <BoN> lmax <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> deg <EoN> = <BoN> np <EoN> . <BoN> sort <EoN> ( <BoN> deg <EoN> ) <NEWLINE> <BoN> lmax <EoN> = <BoN> deg <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> order <EoN> = <BoN> len <EoN> ( <BoN> deg <EoN> ) <NEWLINE> <BoN> van <EoN> = <BoN> chebvander <EoN> ( <BoN> x <EoN> , <BoN> lmax <EoN> ) [ : , <BoN> deg <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> lhs <EoN> = <BoN> van <EoN> . <BoN> T <EoN> <NEWLINE> <BoN> rhs <EoN> = <BoN> y <EoN> . <BoN> T <EoN> <NEWLINE> <BoN> if <EoN> <BoN> w <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> w <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> w <EoN> ) + <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> w <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> x <EoN> ) != <BoN> len <EoN> ( <BoN> w <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> lhs <EoN> = <BoN> lhs <EoN> * <BoN> w <EoN> <NEWLINE> <BoN> rhs <EoN> = <BoN> rhs <EoN> * <BoN> w <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rcond <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> rcond <EoN> = <BoN> len <EoN> ( <BoN> x <EoN> ) * <BoN> np <EoN> . <BoN> finfo <EoN> ( <BoN> x <EoN> . <BoN> dtype <EoN> ) . <BoN> eps <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> issubclass <EoN> ( <BoN> lhs <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> np <EoN> . <BoN> complexfloating <EoN> ) : <NEWLINE> <TAB> <BoN> scl <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( ( <BoN> np <EoN> . <BoN> square <EoN> ( <BoN> lhs <EoN> . <BoN> real <EoN> ) + <BoN> np <EoN> . <BoN> square <EoN> ( <BoN> lhs <EoN> . <BoN> imag <EoN> ) ) . <BoN> sum <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> scl <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> np <EoN> . <BoN> square <EoN> ( <BoN> lhs <EoN> ) . <BoN> sum <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> scl <EoN> [ <BoN> scl <EoN> == <NUMBER> ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> c <EoN> , <BoN> resids <EoN> , <BoN> rank <EoN> , <BoN> s <EoN> = <BoN> la <EoN> . <BoN> lstsq <EoN> ( <BoN> lhs <EoN> . <BoN> T <EoN> / <BoN> scl <EoN> , <BoN> rhs <EoN> . <BoN> T <EoN> , <BoN> rcond <EoN> ) <NEWLINE> <BoN> c <EoN> = ( <BoN> c <EoN> . <BoN> T <EoN> / <BoN> scl <EoN> ) . <BoN> T <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> deg <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> c <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> cc <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> lmax <EoN> + <NUMBER> , <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) , <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cc <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> lmax <EoN> + <NUMBER> , <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> cc <EoN> [ <BoN> deg <EoN> ] = <BoN> c <EoN> <NEWLINE> <BoN> c <EoN> = <BoN> cc <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rank <EoN> != <BoN> order <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> full <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> , <BoN> pu <EoN> . <BoN> Rank Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> full <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> c <EoN> , [ <BoN> resids <EoN> , <BoN> rank <EoN> , <BoN> s <EoN> , <BoN> rcond <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> helper simplify <EoN> ( <BoN> eq <EoN> , <BoN> hint <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> match <EoN> , <BoN> solvefun <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hint <EoN> . <BoN> endswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> solvefunc <EoN> = <BoN> globals <EoN> ( ) [ <NEWLINE> <STRING> + <BoN> hint <EoN> [ : - <BoN> len <EoN> ( <STRING> ) ] ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> solvefunc <EoN> = <BoN> globals <EoN> ( ) [ <STRING> + <BoN> hint <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> handle Integral <EoN> ( <BoN> solvefunc <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <NEWLINE> <BoN> match <EoN> , <BoN> solvefun <EoN> ) , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> hint <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> equalize <EoN> ( <BoN> image <EoN> , <BoN> selem <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> mask <EoN> = <BoN> None <EoN> , <BoN> shift x <EoN> = <BoN> False <EoN> , <BoN> shift y <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> apply scalar per pixel <EoN> ( <BoN> generic cy <EoN> . <BoN> equalize <EoN> , <BoN> image <EoN> , <BoN> selem <EoN> , <NEWLINE> <BoN> out <EoN> = <BoN> out <EoN> , <BoN> mask <EoN> = <BoN> mask <EoN> , <NEWLINE> <BoN> shift x <EoN> = <BoN> shift x <EoN> , <BoN> shift y <EoN> = <BoN> shift y <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tc <EoN> . <BoN> returns <EoN> ( <BoN> Labeled Tensor <EoN> ) <NEWLINE> @ <BoN> tc <EoN> . <BoN> accepts <EoN> ( <NEWLINE> <BoN> Labeled Tensor Like <EoN> , <NEWLINE> <BoN> tc <EoN> . <BoN> Collection <EoN> ( <NEWLINE> <BoN> tc <EoN> . <BoN> Union <EoN> ( <BoN> string types <EoN> , <BoN> tc <EoN> . <BoN> Tuple <EoN> ( <BoN> string types <EoN> , <BoN> collections <EoN> . <BoN> Hashable <EoN> ) ) ) , <NEWLINE> <BoN> tc <EoN> . <BoN> Optional <EoN> ( <BoN> string types <EoN> ) ) <NEWLINE> <BoN> def <EoN> <BoN> expand dims <EoN> ( <BoN> labeled tensor <EoN> , <BoN> axes <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> labeled tensor <EoN> ] ) <BoN> as <EoN> <BoN> scope <EoN> : <NEWLINE> <TAB> <BoN> labeled tensor <EoN> = <BoN> convert to labeled tensor <EoN> ( <BoN> labeled tensor <EoN> ) <NEWLINE> <NEWLINE> <BoN> axis names <EoN> = [ <BoN> a <EoN> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> a <EoN> , <BoN> string types <EoN> ) <BoN> else <EoN> <BoN> a <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> ] <NEWLINE> <BoN> check axis order <EoN> ( <BoN> labeled tensor <EoN> , <BoN> axis names <EoN> ) <NEWLINE> <NEWLINE> <BoN> reshaped axes <EoN> = [ ] <NEWLINE> <BoN> shape <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> axis spec <EoN> <BoN> in <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> axis spec <EoN> <BoN> in <EoN> <BoN> labeled tensor <EoN> . <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> labeled tensor <EoN> . <BoN> axes <EoN> [ <BoN> axis spec <EoN> ] <NEWLINE> <BoN> reshaped axes <EoN> . <BoN> append <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> shape <EoN> . <BoN> append <EoN> ( - <NUMBER> <BoN> if <EoN> <BoN> axis <EoN> . <BoN> size <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> axis <EoN> . <BoN> size <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> axis spec <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> reshaped axes <EoN> . <BoN> append <EoN> ( ( <BoN> axis spec <EoN> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> ( <BoN> name <EoN> , <BoN> label <EoN> ) = <BoN> axis spec <EoN> <NEWLINE> <BoN> reshaped axes <EoN> . <BoN> append <EoN> ( ( <BoN> name <EoN> , ( <BoN> label <EoN> , ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> shape <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> reshaped tensor <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <NEWLINE> <BoN> labeled tensor <EoN> . <BoN> tensor <EoN> , <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> scope <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Labeled Tensor <EoN> ( <BoN> reshaped tensor <EoN> , <BoN> reshaped axes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> invert <EoN> ( <BoN> self <EoN> , <BoN> g <EoN> , * <BoN> gens <EoN> , ** <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> polys <EoN> . <BoN> polytools <EoN> <BoN> import <EoN> <BoN> invert <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> numbers <EoN> <BoN> import <EoN> <BoN> mod inverse <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is number <EoN> <BoN> and <EoN> <BoN> getattr <EoN> ( <BoN> g <EoN> , <STRING> , <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mod inverse <EoN> ( <BoN> self <EoN> , <BoN> g <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> invert <EoN> ( <BoN> self <EoN> , <BoN> g <EoN> , * <BoN> gens <EoN> , ** <BoN> args <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set self <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> other <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> data <EoN> = <BoN> other <EoN> . <BoN> data <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> indices <EoN> = <BoN> other <EoN> . <BoN> indices <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> indptr <EoN> = <BoN> other <EoN> . <BoN> indptr <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> shape <EoN> = <BoN> check shape <EoN> ( <BoN> other <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> number weakly connected components <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <NUMBER> <BoN> for <EoN> <BoN> wcc <EoN> <BoN> in <EoN> <BoN> weakly connected components <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> info <EoN> ( <BoN> self <EoN> , <BoN> source <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> stream <EoN> , <BoN> close it <EoN> = <BoN> self <EoN> . <BoN> open <EoN> ( <BoN> source <EoN> ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> line <EoN> = <BoN> stream <EoN> . <BoN> readline <EoN> ( ) <NEWLINE> <BoN> mmid <EoN> , <BoN> matrix <EoN> , <BoN> format <EoN> , <BoN> field <EoN> , <BoN> symmetry <EoN> = [ <BoN> asstr <EoN> ( <BoN> part <EoN> . <BoN> strip <EoN> ( ) ) <BoN> for <EoN> <BoN> part <EoN> <BoN> in <EoN> <BoN> line <EoN> . <BoN> split <EoN> ( ) ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> mmid <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> matrix <EoN> . <BoN> lower <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <BoN> line <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> format <EoN> . <BoN> lower <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> format <EoN> = <BoN> self <EoN> . <BoN> FORMAT ARRAY <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> format <EoN> . <BoN> lower <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> format <EoN> = <BoN> self <EoN> . <BoN> FORMAT COORDINATE <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> line <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> line <EoN> = <BoN> stream <EoN> . <BoN> readline <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> line <EoN> = <BoN> line <EoN> . <BoN> split <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> format <EoN> == <BoN> self <EoN> . <BoN> FORMAT ARRAY <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> len <EoN> ( <BoN> line <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <BoN> line <EoN> ) <NEWLINE> <UNTAB> <BoN> rows <EoN> , <BoN> cols <EoN> = <BoN> map <EoN> ( <BoN> int <EoN> , <BoN> line <EoN> ) <NEWLINE> <BoN> entries <EoN> = <BoN> rows <EoN> * <BoN> cols <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> len <EoN> ( <BoN> line <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <BoN> line <EoN> ) <NEWLINE> <UNTAB> <BoN> rows <EoN> , <BoN> cols <EoN> , <BoN> entries <EoN> = <BoN> map <EoN> ( <BoN> int <EoN> , <BoN> line <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> rows <EoN> , <BoN> cols <EoN> , <BoN> entries <EoN> , <BoN> format <EoN> , <BoN> field <EoN> . <BoN> lower <EoN> ( ) , <NEWLINE> <BoN> symmetry <EoN> . <BoN> lower <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> close it <EoN> : <NEWLINE> <TAB> <BoN> stream <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sas <EoN> ( <BoN> l 1 <EoN> , <BoN> d <EoN> , <BoN> l 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p 1 <EoN> = <BoN> Point <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> p 2 <EoN> = <BoN> Point <EoN> ( <BoN> l 2 <EoN> , <NUMBER> ) <NEWLINE> <BoN> p 3 <EoN> = <BoN> Point <EoN> ( <BoN> cos <EoN> ( <BoN> rad <EoN> ( <BoN> d <EoN> ) ) * <BoN> l 1 <EoN> , <BoN> sin <EoN> ( <BoN> rad <EoN> ( <BoN> d <EoN> ) ) * <BoN> l 1 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Triangle <EoN> ( <BoN> p 1 <EoN> , <BoN> p 2 <EoN> , <BoN> p 3 <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> equals <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> failing expression <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shape <EoN> != <BoN> other <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> rv <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> rows <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> cols <EoN> ) : <NEWLINE> <TAB> <BoN> ans <EoN> = <BoN> self <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] . <BoN> equals <EoN> ( <BoN> other <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] , <BoN> failing expression <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ans <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ans <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> True <EoN> <BoN> and <EoN> <BoN> rv <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> rv <EoN> = <BoN> ans <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create <EoN> ( <BoN> metric <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> callable <EoN> ( <BoN> metric <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Custom Metric <EoN> ( <BoN> metric <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> metric <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> composite metric <EoN> = <BoN> Composite Eval Metric <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> child metric <EoN> <BoN> in <EoN> <BoN> metric <EoN> : <NEWLINE> <TAB> <BoN> composite metric <EoN> . <BoN> add <EoN> ( <BoN> create <EoN> ( <BoN> child metric <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> composite metric <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> create <EoN> ( <BoN> metric <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> handle zeros in scale <EoN> ( <BoN> scale <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> isscalar <EoN> ( <BoN> scale <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> scale <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> scale <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> scale <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> scale <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> scale <EoN> = <BoN> scale <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <BoN> scale <EoN> [ <BoN> scale <EoN> == <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> scale <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ode almost linear <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> match <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> ode 1 st linear <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> match <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get uid <EoN> ( <BoN> prefix <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> graph <EoN> = <BoN> get graph <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> graph <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> PER GRAPH LAYER NAME UIDS <EoN> : <NEWLINE> <TAB> <BoN> PER GRAPH LAYER NAME UIDS <EoN> [ <BoN> graph <EoN> ] = <BoN> collections <EoN> . <BoN> defaultdict <EoN> ( <BoN> int <EoN> ) <NEWLINE> <UNTAB> <BoN> layer name uids <EoN> = <BoN> PER GRAPH LAYER NAME UIDS <EoN> [ <BoN> graph <EoN> ] <NEWLINE> <BoN> layer name uids <EoN> [ <BoN> prefix <EoN> ] += <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> layer name uids <EoN> [ <BoN> prefix <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fr 0 <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> a <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> a <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> a <EoN> . <BoN> shape <EoN> = ( <NUMBER> , ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reverse havel hakimi graph <EoN> ( <BoN> aseq <EoN> , <BoN> bseq <EoN> , <BoN> create using <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> = <BoN> nx <EoN> . <BoN> empty graph <EoN> ( <NUMBER> , <BoN> create using <EoN> , <BoN> default <EoN> = <BoN> nx <EoN> . <BoN> Multi Graph <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> lena <EoN> = <BoN> len <EoN> ( <BoN> aseq <EoN> ) <NEWLINE> <BoN> lenb <EoN> = <BoN> len <EoN> ( <BoN> bseq <EoN> ) <NEWLINE> <BoN> suma <EoN> = <BoN> sum <EoN> ( <BoN> aseq <EoN> ) <NEWLINE> <BoN> sumb <EoN> = <BoN> sum <EoN> ( <BoN> bseq <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> suma <EoN> == <BoN> sumb <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> % ( <BoN> suma <EoN> , <BoN> sumb <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> G <EoN> = <BoN> add nodes with bipartite label <EoN> ( <BoN> G <EoN> , <BoN> lena <EoN> , <BoN> lenb <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> aseq <EoN> ) == <NUMBER> <BoN> or <EoN> <BoN> max <EoN> ( <BoN> aseq <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> astubs <EoN> = [ [ <BoN> aseq <EoN> [ <BoN> v <EoN> ] , <BoN> v <EoN> ] <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> lena <EoN> ) ] <NEWLINE> <BoN> bstubs <EoN> = [ [ <BoN> bseq <EoN> [ <BoN> v <EoN> - <BoN> lena <EoN> ] , <BoN> v <EoN> ] <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> lena <EoN> , <BoN> lena <EoN> + <BoN> lenb <EoN> ) ] <NEWLINE> <BoN> astubs <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> bstubs <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> while <EoN> <BoN> astubs <EoN> : <NEWLINE> <TAB> ( <BoN> degree <EoN> , <BoN> u <EoN> ) = <BoN> astubs <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> degree <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> target <EoN> <BoN> in <EoN> <BoN> bstubs <EoN> [ <NUMBER> : <BoN> degree <EoN> ] : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> target <EoN> [ <NUMBER> ] <NEWLINE> <BoN> G <EoN> . <BoN> add edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> target <EoN> [ <NUMBER> ] -= <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> target <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> bstubs <EoN> . <BoN> remove <EoN> ( <BoN> target <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> G <EoN> . <BoN> name <EoN> = <STRING> <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> row del <EoN> ( <BoN> self <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new D <EoN> = { } <NEWLINE> <BoN> k <EoN> = <BoN> a 2 idx <EoN> ( <BoN> k <EoN> , <BoN> self <EoN> . <BoN> rows <EoN> ) <NEWLINE> <BoN> for <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> ) <BoN> in <EoN> <BoN> self <EoN> . <BoN> smat <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> == <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> i <EoN> > <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> new D <EoN> [ <BoN> i <EoN> - <NUMBER> , <BoN> j <EoN> ] = <BoN> self <EoN> . <BoN> smat <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new D <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] = <BoN> self <EoN> . <BoN> smat <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> smat <EoN> = <BoN> new D <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> rows <EoN> -= <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get chief queue runner <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> gradients applied <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> chief queue runner <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> consolidate inplace <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> f <EoN> ( ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> data <EoN> = <BoN> self <EoN> . <BoN> data <EoN> . <BoN> consolidate <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> protect consolidate <EoN> ( <BoN> f <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp compose <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> u <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dup compose <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dmp zero p <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> h <EoN> = [ <BoN> f <EoN> [ <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> f <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> h <EoN> = <BoN> dmp mul <EoN> ( <BoN> h <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> h <EoN> = <BoN> dmp add term <EoN> ( <BoN> h <EoN> , <BoN> c <EoN> , <NUMBER> , <BoN> u <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> h <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains points <EoN> ( <BoN> self <EoN> , <BoN> points <EoN> , <BoN> radius <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> radius <EoN> = <BoN> self <EoN> . <BoN> process radius <EoN> ( <BoN> radius <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get path <EoN> ( ) . <BoN> contains points <EoN> ( <BoN> points <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> get transform <EoN> ( ) , <NEWLINE> <BoN> radius <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> zeros <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> order <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> ndarray <EoN> . <BoN> new <EoN> ( <BoN> matrix <EoN> , <BoN> shape <EoN> , <BoN> dtype <EoN> , <BoN> order <EoN> = <BoN> order <EoN> ) <NEWLINE> <BoN> a <EoN> . <BoN> fill <EoN> ( <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add gan model image summaries <EoN> ( <BoN> gan model <EoN> , <BoN> grid size <EoN> = <NUMBER> , <BoN> model summaries <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> gan model <EoN> , <BoN> namedtuples <EoN> . <BoN> Cycle GAN Model <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> assert is image <EoN> ( <BoN> gan model <EoN> . <BoN> real data <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> gan model <EoN> . <BoN> generated data <EoN> ) <NEWLINE> <NEWLINE> <BoN> num images <EoN> = <BoN> grid size <EoN> ** <NUMBER> <NEWLINE> <BoN> real image shape <EoN> = <BoN> gan model <EoN> . <BoN> real data <EoN> . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> : <NUMBER> ] <NEWLINE> <BoN> generated image shape <EoN> = <BoN> gan model <EoN> . <BoN> generated data <EoN> . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> : <NUMBER> ] <NEWLINE> <BoN> real channels <EoN> = <BoN> gan model <EoN> . <BoN> real data <EoN> . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> generated channels <EoN> = <BoN> gan model <EoN> . <BoN> generated data <EoN> . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> summary <EoN> . <BoN> image <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <BoN> eval utils <EoN> . <BoN> image grid <EoN> ( <NEWLINE> <BoN> gan model <EoN> . <BoN> real data <EoN> [ : <BoN> num images <EoN> ] , <NEWLINE> <BoN> grid shape <EoN> = ( <BoN> grid size <EoN> , <BoN> grid size <EoN> ) , <NEWLINE> <BoN> image shape <EoN> = <BoN> real image shape <EoN> , <NEWLINE> <BoN> num channels <EoN> = <BoN> real channels <EoN> ) , <NEWLINE> <BoN> max outputs <EoN> = <NUMBER> ) <NEWLINE> <BoN> summary <EoN> . <BoN> image <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <BoN> eval utils <EoN> . <BoN> image grid <EoN> ( <NEWLINE> <BoN> gan model <EoN> . <BoN> generated data <EoN> [ : <BoN> num images <EoN> ] , <NEWLINE> <BoN> grid shape <EoN> = ( <BoN> grid size <EoN> , <BoN> grid size <EoN> ) , <NEWLINE> <BoN> image shape <EoN> = <BoN> generated image shape <EoN> , <NEWLINE> <BoN> num channels <EoN> = <BoN> generated channels <EoN> ) , <NEWLINE> <BoN> max outputs <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> model summaries <EoN> : <NEWLINE> <TAB> <BoN> add gan model summaries <EoN> ( <BoN> gan model <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bulk <EoN> ( <BoN> size <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> BulkScope <EoN> ( <BoN> size <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get nd advanced indexing <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> gather nd <EoN> ( <BoN> self <EoN> , <BoN> self <EoN> . <BoN> get index nd <EoN> ( <BoN> key <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pow <EoN> ( <BoN> f <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> n <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> F <EoN> , <BoN> n <EoN> = <BoN> dup invert <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> f <EoN> . <BoN> mod <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) , - <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> F <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> dup rem <EoN> ( <BoN> dup pow <EoN> ( <BoN> F <EoN> , <BoN> n <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) , <BoN> f <EoN> . <BoN> mod <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> resolve calls <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> node <EoN> = <BoN> quoting <EoN> . <BoN> parse function <EoN> ( <BoN> func <EoN> ) <NEWLINE> <BoN> Resolve Calls <EoN> ( <BoN> func <EoN> ) . <BoN> visit <EoN> ( <BoN> node <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> node <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> root broyden 1 doc <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> index <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> index <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> index <EoN> [ <BoN> value <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> choose colorbrewer palette <EoN> ( <BoN> data type <EoN> , <BoN> as cmap <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> data type <EoN> . <BoN> startswith <EoN> ( <STRING> ) <BoN> and <EoN> <BoN> as cmap <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> pal <EoN> = [ ] <NEWLINE> <BoN> if <EoN> <BoN> as cmap <EoN> : <NEWLINE> <TAB> <BoN> cmap <EoN> = <BoN> init mutable colormap <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> data type <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> opts <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> variants <EoN> = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NEWLINE> @ <BoN> interact <EoN> <NEWLINE> <BoN> def <EoN> <BoN> choose sequential <EoN> ( <BoN> name <EoN> = <BoN> opts <EoN> , <BoN> n <EoN> = ( <NUMBER> , <NUMBER> ) , <NEWLINE> <BoN> desat <EoN> = <BoN> Float Slider <EoN> ( <BoN> min <EoN> = <NUMBER> , <BoN> max <EoN> = <NUMBER> , <BoN> value <EoN> = <NUMBER> ) , <NEWLINE> <BoN> variant <EoN> = <BoN> variants <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> variant <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> name <EoN> += <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> variant <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> name <EoN> += <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> as cmap <EoN> : <NEWLINE> <TAB> <BoN> colors <EoN> = <BoN> color palette <EoN> ( <BoN> name <EoN> , <NUMBER> , <BoN> desat <EoN> ) <NEWLINE> <BoN> update lut <EoN> ( <BoN> cmap <EoN> , <BoN> np <EoN> . <BoN> c <EoN> [ <BoN> colors <EoN> , <BoN> np <EoN> . <BoN> ones <EoN> ( <NUMBER> ) ] ) <NEWLINE> <BoN> show cmap <EoN> ( <BoN> cmap <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pal <EoN> [ : ] = <BoN> color palette <EoN> ( <BoN> name <EoN> , <BoN> n <EoN> , <BoN> desat <EoN> ) <NEWLINE> <BoN> palplot <EoN> ( <BoN> pal <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> data type <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> opts <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> variants <EoN> = [ <STRING> , <STRING> ] <NEWLINE> <NEWLINE> @ <BoN> interact <EoN> <NEWLINE> <BoN> def <EoN> <BoN> choose diverging <EoN> ( <BoN> name <EoN> = <BoN> opts <EoN> , <BoN> n <EoN> = ( <NUMBER> , <NUMBER> ) , <NEWLINE> <BoN> desat <EoN> = <BoN> Float Slider <EoN> ( <BoN> min <EoN> = <NUMBER> , <BoN> max <EoN> = <NUMBER> , <BoN> value <EoN> = <NUMBER> ) , <NEWLINE> <BoN> variant <EoN> = <BoN> variants <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> variant <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> name <EoN> += <STRING> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> as cmap <EoN> : <NEWLINE> <TAB> <BoN> colors <EoN> = <BoN> color palette <EoN> ( <BoN> name <EoN> , <NUMBER> , <BoN> desat <EoN> ) <NEWLINE> <BoN> update lut <EoN> ( <BoN> cmap <EoN> , <BoN> np <EoN> . <BoN> c <EoN> [ <BoN> colors <EoN> , <BoN> np <EoN> . <BoN> ones <EoN> ( <NUMBER> ) ] ) <NEWLINE> <BoN> show cmap <EoN> ( <BoN> cmap <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pal <EoN> [ : ] = <BoN> color palette <EoN> ( <BoN> name <EoN> , <BoN> n <EoN> , <BoN> desat <EoN> ) <NEWLINE> <BoN> palplot <EoN> ( <BoN> pal <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> data type <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> opts <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> ] <NEWLINE> <NEWLINE> @ <BoN> interact <EoN> <NEWLINE> <BoN> def <EoN> <BoN> choose qualitative <EoN> ( <BoN> name <EoN> = <BoN> opts <EoN> , <BoN> n <EoN> = ( <NUMBER> , <NUMBER> ) , <NEWLINE> <BoN> desat <EoN> = <BoN> Float Slider <EoN> ( <BoN> min <EoN> = <NUMBER> , <BoN> max <EoN> = <NUMBER> , <BoN> value <EoN> = <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> pal <EoN> [ : ] = <BoN> color palette <EoN> ( <BoN> name <EoN> , <BoN> n <EoN> , <BoN> desat <EoN> ) <NEWLINE> <BoN> palplot <EoN> ( <BoN> pal <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> as cmap <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cmap <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> pal <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> register parameter <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> param <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> dict <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Attribute Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> name <EoN> , <BoN> torch <EoN> . <BoN> six <EoN> . <BoN> string classes <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> torch <EoN> . <BoN> typename <EoN> ( <BoN> name <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) <BoN> and <EoN> <BoN> name <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> parameters <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> param <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parameters <EoN> [ <BoN> name <EoN> ] = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> param <EoN> , <BoN> Parameter <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> torch <EoN> . <BoN> typename <EoN> ( <BoN> param <EoN> ) , <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> param <EoN> . <BoN> grad fn <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parameters <EoN> [ <BoN> name <EoN> ] = <BoN> param <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> centre <EoN> ( <BoN> x <EoN> , <BoN> oshape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> start <EoN> = ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> ) - <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> oshape <EoN> ) ) // <NUMBER> + <NUMBER> <NEWLINE> <BoN> out <EoN> = <BoN> x <EoN> [ <BoN> tuple <EoN> ( <BoN> slice <EoN> ( <BoN> s <EoN> , <BoN> s <EoN> + <BoN> n <EoN> ) <BoN> for <EoN> <BoN> s <EoN> , <BoN> n <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> start <EoN> , <BoN> oshape <EoN> ) ) ] <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> model from json <EoN> ( <BoN> json string <EoN> , <BoN> custom objects <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> = <BoN> json <EoN> . <BoN> loads <EoN> ( <BoN> json string <EoN> ) <NEWLINE> <BoN> from <EoN> . . <BoN> layers <EoN> <BoN> import <EoN> <BoN> deserialize <EoN> <NEWLINE> <BoN> return <EoN> <BoN> deserialize <EoN> ( <BoN> config <EoN> , <BoN> custom objects <EoN> = <BoN> custom objects <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> periodic <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> depth <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> left <EoN> = ( ( <BoN> slice <EoN> ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) , ) * <BoN> axis <EoN> + <NEWLINE> ( <BoN> slice <EoN> ( <NUMBER> , <BoN> depth <EoN> ) , ) + <NEWLINE> ( <BoN> slice <EoN> ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) , ) * ( <BoN> x <EoN> . <BoN> ndim <EoN> - <BoN> axis <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> right <EoN> = ( ( <BoN> slice <EoN> ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) , ) * <BoN> axis <EoN> + <NEWLINE> ( <BoN> slice <EoN> ( - <BoN> depth <EoN> , <BoN> None <EoN> ) , ) + <NEWLINE> ( <BoN> slice <EoN> ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) , ) * ( <BoN> x <EoN> . <BoN> ndim <EoN> - <BoN> axis <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> l <EoN> = <BoN> x <EoN> [ <BoN> left <EoN> ] <NEWLINE> <BoN> r <EoN> = <BoN> x <EoN> [ <BoN> right <EoN> ] <NEWLINE> <NEWLINE> <BoN> l <EoN> , <BoN> r <EoN> = <BoN> remove overlap boundaries <EoN> ( <BoN> l <EoN> , <BoN> r <EoN> , <BoN> axis <EoN> , <BoN> depth <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> concatenate <EoN> ( [ <BoN> r <EoN> , <BoN> x <EoN> , <BoN> l <EoN> ] , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> hx <EoN> , <BoN> xs <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> ( <BoN> hy <EoN> , ) , <BoN> ys <EoN> = <BoN> self <EoN> . <BoN> call <EoN> ( [ <BoN> hx <EoN> ] , <BoN> xs <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> hy <EoN> , <BoN> ys <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> interval <EoN> = <NUMBER> , <BoN> tz <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> interval <EoN> = <BoN> interval <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> wrapped locator <EoN> = <BoN> ticker <EoN> . <BoN> Multiple Locator <EoN> ( <BoN> interval <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> tz <EoN> = <BoN> tz <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as content primitive <EoN> ( <BoN> self <EoN> , <BoN> radical <EoN> = <BoN> False <EoN> , <BoN> clear <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> con <EoN> , <BoN> prim <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( * [ <BoN> keep coeff <EoN> ( * <BoN> a <EoN> . <BoN> as content primitive <EoN> ( <NEWLINE> <BoN> radical <EoN> = <BoN> radical <EoN> , <BoN> clear <EoN> = <BoN> clear <EoN> ) ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> args <EoN> ] ) . <BoN> primitive <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> clear <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> con <EoN> . <BoN> is Integer <EoN> <BoN> and <EoN> <BoN> prim <EoN> . <BoN> is Add <EoN> : <NEWLINE> <TAB> <BoN> con <EoN> , <BoN> d <EoN> = <BoN> con <EoN> . <BoN> as numer denom <EoN> ( ) <NEWLINE> <BoN> p <EoN> = <BoN> prim <EoN> / <BoN> d <EoN> <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> a <EoN> . <BoN> as coeff Mul <EoN> ( ) [ <NUMBER> ] . <BoN> is Integer <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> p <EoN> . <BoN> args <EoN> ) : <NEWLINE> <TAB> <BoN> prim <EoN> = <BoN> p <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> con <EoN> /= <BoN> d <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> radical <EoN> <BoN> and <EoN> <BoN> prim <EoN> . <BoN> is Add <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> args <EoN> = <BoN> prim <EoN> . <BoN> args <EoN> <NEWLINE> <BoN> rads <EoN> = [ ] <NEWLINE> <BoN> common q <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> m <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> term rads <EoN> = <BoN> defaultdict <EoN> ( <BoN> list <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> ai <EoN> <BoN> in <EoN> <BoN> Mul <EoN> . <BoN> make args <EoN> ( <BoN> m <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ai <EoN> . <BoN> is Pow <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> , <BoN> e <EoN> = <BoN> ai <EoN> . <BoN> as base exp <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> e <EoN> . <BoN> is Rational <EoN> <BoN> and <EoN> <BoN> b <EoN> . <BoN> is Integer <EoN> : <NEWLINE> <TAB> <BoN> term rads <EoN> [ <BoN> e <EoN> . <BoN> q <EoN> ] . <BoN> append <EoN> ( <BoN> abs <EoN> ( <BoN> int <EoN> ( <BoN> b <EoN> ) ) ** <BoN> e <EoN> . <BoN> p <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> term rads <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> common q <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> common q <EoN> = <BoN> set <EoN> ( <BoN> term rads <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> common q <EoN> = <BoN> common q <EoN> & <BoN> set <EoN> ( <BoN> term rads <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> common q <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> rads <EoN> . <BoN> append <EoN> ( <BoN> term rads <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> r <EoN> <BoN> in <EoN> <BoN> rads <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> q <EoN> <BoN> in <EoN> <BoN> list <EoN> ( <BoN> r <EoN> . <BoN> keys <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> q <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> common q <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> . <BoN> pop <EoN> ( <BoN> q <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> q <EoN> <BoN> in <EoN> <BoN> r <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> [ <BoN> q <EoN> ] = <BoN> prod <EoN> ( <BoN> r <EoN> [ <BoN> q <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> G <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> q <EoN> <BoN> in <EoN> <BoN> common q <EoN> : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> reduce <EoN> ( <BoN> igcd <EoN> , [ <BoN> r <EoN> [ <BoN> q <EoN> ] <BoN> for <EoN> <BoN> r <EoN> <BoN> in <EoN> <BoN> rads <EoN> ] , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> g <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> G <EoN> . <BoN> append <EoN> ( <BoN> g <EoN> ** <BoN> Rational <EoN> ( <NUMBER> , <BoN> q <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> G <EoN> = <BoN> Mul <EoN> ( * <BoN> G <EoN> ) <NEWLINE> <BoN> args <EoN> = [ <BoN> ai <EoN> / <BoN> G <EoN> <BoN> for <EoN> <BoN> ai <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> prim <EoN> = <BoN> G <EoN> * <BoN> prim <EoN> . <BoN> func <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> con <EoN> , <BoN> prim <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rewrite inversion <EoN> ( <BoN> fac <EoN> , <BoN> po <EoN> , <BoN> g <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> <EoN> , <BoN> s <EoN> = <BoN> get coeff exp <EoN> ( <BoN> po <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> get coeff exp <EoN> ( <BoN> g <EoN> . <BoN> argument <EoN> , <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> tr <EoN> ( <BoN> l <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> t <EoN> + <BoN> s <EoN> / <BoN> b <EoN> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> l <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> powdenest <EoN> ( <BoN> fac <EoN> / <BoN> a <EoN> ** ( <BoN> s <EoN> / <BoN> b <EoN> ) , <BoN> polar <EoN> = <BoN> True <EoN> ) , <NEWLINE> <BoN> meijerg <EoN> ( <BoN> tr <EoN> ( <BoN> g <EoN> . <BoN> an <EoN> ) , <BoN> tr <EoN> ( <BoN> g <EoN> . <BoN> aother <EoN> ) , <BoN> tr <EoN> ( <BoN> g <EoN> . <BoN> bm <EoN> ) , <BoN> tr <EoN> ( <BoN> g <EoN> . <BoN> bother <EoN> ) , <BoN> g <EoN> . <BoN> argument <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict proba <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Fitted Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ovr <EoN> = ( <BoN> self <EoN> . <BoN> multi class <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] <BoN> or <EoN> <NEWLINE> ( <BoN> self <EoN> . <BoN> multi class <EoN> == <STRING> <BoN> and <EoN> ( <BoN> self <EoN> . <BoN> classes <EoN> . <BoN> size <EoN> <= <NUMBER> <BoN> or <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> solver <EoN> == <STRING> ) ) ) <NEWLINE> <BoN> if <EoN> <BoN> ovr <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> super <EoN> ( <BoN> Logistic Regression <EoN> , <BoN> self <EoN> ) . <BoN> predict proba lr <EoN> ( <BoN> X <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> decision <EoN> = <BoN> self <EoN> . <BoN> decision function <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> decision <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> decision 2 d <EoN> = <BoN> np <EoN> . <BoN> c <EoN> [ - <BoN> decision <EoN> , <BoN> decision <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> decision 2 d <EoN> = <BoN> decision <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> softmax <EoN> ( <BoN> decision 2 d <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> shrink mask <EoN> ( <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> m <EoN> . <BoN> dtype <EoN> . <BoN> names <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> m <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nomask <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> m <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate metadata <EoN> ( <BoN> self <EoN> , <BoN> existing <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> metadata <EoN> = [ <NEWLINE> <BoN> c <EoN> . <BoN> name <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> values axes <EoN> <BoN> if <EoN> <BoN> c <EoN> . <BoN> metadata <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to json <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> = <BoN> self <EoN> . <BoN> get config <EoN> ( ) <NEWLINE> <BoN> tokenizer config <EoN> = { <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> , <NEWLINE> <STRING> : <BoN> config <EoN> <NEWLINE> } <NEWLINE> <BoN> return <EoN> <BoN> json <EoN> . <BoN> dumps <EoN> ( <BoN> tokenizer config <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> broadcast to <EoN> ( <BoN> input <EoN> , <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> input <EoN> , <BoN> shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> broadcast to eager fallback <EoN> ( <NEWLINE> <BoN> input <EoN> , <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> broadcast to <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> broadcast to <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> wait for session <EoN> ( <BoN> self <EoN> , <BoN> master <EoN> , <BoN> config <EoN> = <BoN> None <EoN> , <BoN> max wait secs <EoN> = <BoN> float <EoN> ( <STRING> ) ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> target <EoN> = <BoN> master <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> max wait secs <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> max wait secs <EoN> = <BoN> float <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> timer <EoN> = <BoN> CountDownTimer <EoN> ( <BoN> max wait secs <EoN> ) <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> sess <EoN> = <BoN> session <EoN> . <BoN> Session <EoN> ( <BoN> self <EoN> . <BoN> target <EoN> , <BoN> graph <EoN> = <BoN> self <EoN> . <BoN> graph <EoN> , <BoN> config <EoN> = <BoN> config <EoN> ) <NEWLINE> <BoN> not ready msg <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> not ready local msg <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> local init success <EoN> , <BoN> not ready local msg <EoN> = <BoN> self <EoN> . <BoN> try run local init op <EoN> ( <NEWLINE> <BoN> sess <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> local init success <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> is ready <EoN> , <BoN> not ready msg <EoN> = <BoN> self <EoN> . <BoN> model ready <EoN> ( <BoN> sess <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> is ready <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sess <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> safe close <EoN> ( <BoN> sess <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> remaining ms after wait <EoN> = ( <NEWLINE> <BoN> timer <EoN> . <BoN> secs remaining <EoN> ( ) - <BoN> self <EoN> . <BoN> recovery wait secs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> remaining ms after wait <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> errors <EoN> . <BoN> Deadline Exceeded Error <EoN> ( <NEWLINE> <BoN> None <EoN> , <BoN> None <EoN> , <NEWLINE> <STRING> % ( <BoN> max wait secs <EoN> , ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> <NEWLINE> <STRING> , <NEWLINE> <BoN> not ready local msg <EoN> , <BoN> not ready msg <EoN> ) <NEWLINE> <BoN> time <EoN> . <BoN> sleep <EoN> ( <BoN> self <EoN> . <BoN> recovery wait secs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sanitize column <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> value <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sp maker <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> , <BoN> index <EoN> = <BoN> None <EoN> : <BoN> Sparse Array <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> index <EoN> = <BoN> index <EoN> , <BoN> fill value <EoN> = <BoN> self <EoN> . <BoN> default fill value <EoN> , <NEWLINE> <BoN> kind <EoN> = <BoN> self <EoN> . <BoN> default kind <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> Sparse Series <EoN> ) : <NEWLINE> <TAB> <BoN> clean <EoN> = <BoN> value <EoN> . <BoN> reindex <EoN> ( <BoN> self <EoN> . <BoN> index <EoN> ) . <BoN> as sparse array <EoN> ( <NEWLINE> <BoN> fill value <EoN> = <BoN> self <EoN> . <BoN> default fill value <EoN> , <BoN> kind <EoN> = <BoN> self <EoN> . <BoN> default kind <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> Sparse Array <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> value <EoN> ) != <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> index <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> clean <EoN> = <BoN> value <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> value <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> Series <EoN> ) : <NEWLINE> <TAB> <BoN> clean <EoN> = <BoN> value <EoN> . <BoN> reindex <EoN> ( <BoN> self <EoN> . <BoN> index <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> Sparse Series <EoN> ) : <NEWLINE> <TAB> <BoN> clean <EoN> = <BoN> sp maker <EoN> ( <BoN> clean <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> value <EoN> ) != <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> index <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> clean <EoN> = <BoN> sp maker <EoN> ( <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> clean <EoN> = <BoN> sp maker <EoN> ( <BoN> value <EoN> , <BoN> self <EoN> . <BoN> index <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> clean <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> concat <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> concat <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> move to front <EoN> ( <BoN> self <EoN> , <BoN> sprite <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> change layer <EoN> ( <BoN> sprite <EoN> , <BoN> self <EoN> . <BoN> get top layer <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> median test <EoN> ( * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ties <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> correction <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <BoN> lambda <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> nan policy <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> kwds <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> bad kwd <EoN> = <BoN> kwds <EoN> . <BoN> keys <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> bad kwd <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ties options <EoN> = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> ties <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> ties options <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % ( <BoN> ties <EoN> , <BoN> str <EoN> ( <BoN> ties options <EoN> ) [ <NUMBER> : - <NUMBER> ] ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> data <EoN> = [ <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> arg <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> data <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> d <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % ( <BoN> k <EoN> + <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> d <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> k <EoN> + <NUMBER> , <BoN> d <EoN> . <BoN> ndim <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> cdata <EoN> = <BoN> np <EoN> . <BoN> concatenate <EoN> ( <BoN> data <EoN> ) <NEWLINE> <BoN> contains nan <EoN> , <BoN> nan policy <EoN> = <BoN> contains nan <EoN> ( <BoN> cdata <EoN> , <BoN> nan policy <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> contains nan <EoN> <BoN> and <EoN> <BoN> nan policy <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> nan <EoN> , <BoN> np <EoN> . <BoN> nan <EoN> , <BoN> np <EoN> . <BoN> nan <EoN> , <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> contains nan <EoN> : <NEWLINE> <TAB> <BoN> grand median <EoN> = <BoN> np <EoN> . <BoN> median <EoN> ( <BoN> cdata <EoN> [ ~ <BoN> np <EoN> . <BoN> isnan <EoN> ( <BoN> cdata <EoN> ) ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> grand median <EoN> = <BoN> np <EoN> . <BoN> median <EoN> ( <BoN> cdata <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> table <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <NUMBER> , <BoN> len <EoN> ( <BoN> data <EoN> ) ) , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> sample <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> data <EoN> ) : <NEWLINE> <TAB> <BoN> sample <EoN> = <BoN> sample <EoN> [ ~ <BoN> np <EoN> . <BoN> isnan <EoN> ( <BoN> sample <EoN> ) ] <NEWLINE> <NEWLINE> <BoN> nabove <EoN> = <BoN> count nonzero <EoN> ( <BoN> sample <EoN> > <BoN> grand median <EoN> ) <NEWLINE> <BoN> nbelow <EoN> = <BoN> count nonzero <EoN> ( <BoN> sample <EoN> < <BoN> grand median <EoN> ) <NEWLINE> <BoN> nequal <EoN> = <BoN> sample <EoN> . <BoN> size <EoN> - ( <BoN> nabove <EoN> + <BoN> nbelow <EoN> ) <NEWLINE> <BoN> table <EoN> [ <NUMBER> , <BoN> k <EoN> ] += <BoN> nabove <EoN> <NEWLINE> <BoN> table <EoN> [ <NUMBER> , <BoN> k <EoN> ] += <BoN> nbelow <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ties <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> table <EoN> [ <NUMBER> , <BoN> k <EoN> ] += <BoN> nequal <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ties <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> table <EoN> [ <NUMBER> , <BoN> k <EoN> ] += <BoN> nequal <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> rowsums <EoN> = <BoN> table <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> rowsums <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <BoN> grand median <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rowsums <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <BoN> grand median <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ties <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> zero cols <EoN> = <BoN> np <EoN> . <BoN> where <EoN> ( ( <BoN> table <EoN> == <NUMBER> ) . <BoN> all <EoN> ( <BoN> axis <EoN> = <NUMBER> ) ) [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> zero cols <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % ( <BoN> zero cols <EoN> [ <NUMBER> ] + <NUMBER> , <BoN> grand median <EoN> ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> stat <EoN> , <BoN> p <EoN> , <BoN> dof <EoN> , <BoN> expected <EoN> = <BoN> chi 2 contingency <EoN> ( <BoN> table <EoN> , <BoN> lambda <EoN> = <BoN> lambda <EoN> , <NEWLINE> <BoN> correction <EoN> = <BoN> correction <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> stat <EoN> , <BoN> p <EoN> , <BoN> grand median <EoN> , <BoN> table <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> generate <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> s <EoN> = <BoN> self <EoN> . <BoN> class <EoN> . <BoN> new <EoN> ( <BoN> self <EoN> . <BoN> class <EoN> ) <NEWLINE> <BoN> s <EoN> . <BoN> dict <EoN> = <BoN> self <EoN> . <BoN> dict <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> s <EoN> . <BoN> reset exported <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reference duplicate name <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <BoN> name <EoN> == <BoN> n <EoN> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> names <EoN> ) > <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> diff <EoN> ( <BoN> f <EoN> , <BoN> m <EoN> = <NUMBER> , <BoN> j <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> m <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> m <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> j <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> j <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> dmp diff in <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> m <EoN> , <BoN> j <EoN> , <BoN> f <EoN> . <BoN> lev <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> within grid <EoN> ( <BoN> self <EoN> , <BoN> xi <EoN> , <BoN> yi <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> xi <EoN> >= <NUMBER> <BoN> and <EoN> <BoN> xi <EoN> <= <BoN> self <EoN> . <BoN> nx <EoN> - <NUMBER> <BoN> and <EoN> <BoN> yi <EoN> >= <NUMBER> <BoN> and <EoN> <BoN> yi <EoN> <= <BoN> self <EoN> . <BoN> ny <EoN> - <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> keys <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> fields <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> count <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> level <EoN> = <BoN> None <EoN> , <BoN> numeric only <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> get axis number <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> level <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> count level <EoN> ( <BoN> level <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <NEWLINE> <BoN> numeric only <EoN> = <BoN> numeric only <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> numeric only <EoN> : <NEWLINE> <TAB> <BoN> frame <EoN> = <BoN> self <EoN> . <BoN> get numeric data <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> frame <EoN> = <BoN> self <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> frame <EoN> . <BoN> get axis <EoN> ( <BoN> axis <EoN> ) ) == <NUMBER> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> Series <EoN> ( <NUMBER> , <BoN> index <EoN> = <BoN> frame <EoN> . <BoN> get agg axis <EoN> ( <BoN> axis <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> frame <EoN> . <BoN> is mixed type <EoN> <BoN> or <EoN> <BoN> frame <EoN> . <BoN> data <EoN> . <BoN> any extension types <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> notna <EoN> ( <BoN> frame <EoN> ) . <BoN> sum <EoN> ( <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> series counts <EoN> = <BoN> notna <EoN> ( <BoN> frame <EoN> ) . <BoN> sum <EoN> ( <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> counts <EoN> = <BoN> series counts <EoN> . <BoN> values <EoN> <NEWLINE> <BoN> result <EoN> = <BoN> Series <EoN> ( <BoN> counts <EoN> , <BoN> index <EoN> = <BoN> frame <EoN> . <BoN> get agg axis <EoN> ( <BoN> axis <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> rlshift <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from extents <EoN> ( * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> points <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> args <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) . <BoN> reshape <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> Bbox <EoN> ( <BoN> points <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> semantic feasibility <EoN> ( <BoN> self <EoN> , <BoN> G 1 node <EoN> , <BoN> G 2 node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> feasible <EoN> = <BoN> semantic feasibility <EoN> ( <BoN> self <EoN> , <BoN> G 1 node <EoN> , <BoN> G 2 node <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> feasible <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> G 1 adj <EoN> = <BoN> self <EoN> . <BoN> G 1 <EoN> . <BoN> pred <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> G 2 adj <EoN> = <BoN> self <EoN> . <BoN> G 2 <EoN> . <BoN> pred <EoN> <NEWLINE> <BoN> feasible <EoN> = <BoN> semantic feasibility <EoN> ( <BoN> self <EoN> , <BoN> G 1 node <EoN> , <BoN> G 2 node <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> G 1 adj <EoN> = <BoN> self <EoN> . <BoN> G 1 <EoN> . <BoN> adj <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> G 2 adj <EoN> = <BoN> self <EoN> . <BoN> G 2 <EoN> . <BoN> adj <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> feasible <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> public <EoN> <NEWLINE> <BoN> def <EoN> <BoN> primitive element <EoN> ( <BoN> extension <EoN> , <BoN> x <EoN> = <BoN> None <EoN> , ** <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> extension <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> cls <EoN> = <BoN> sympify <EoN> ( <BoN> x <EoN> ) , <BoN> Poly <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> cls <EoN> = <BoN> Dummy <EoN> ( <STRING> ) , <BoN> Pure Poly <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> args <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> gen <EoN> , <BoN> coeffs <EoN> = <BoN> extension <EoN> [ <NUMBER> ] , [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> gen <EoN> , <BoN> Algebraic Number <EoN> ) : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> gen <EoN> . <BoN> minpoly <EoN> . <BoN> replace <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> minimal polynomial <EoN> ( <BoN> gen <EoN> , <BoN> x <EoN> , <BoN> polys <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> ext <EoN> <BoN> in <EoN> <BoN> extension <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> factors <EoN> = <BoN> factor list <EoN> ( <BoN> g <EoN> , <BoN> extension <EoN> = <BoN> ext <EoN> ) <NEWLINE> <BoN> g <EoN> = <BoN> choose factor <EoN> ( <BoN> factors <EoN> , <BoN> x <EoN> , <BoN> gen <EoN> ) <NEWLINE> <BoN> s <EoN> , <BoN> <EoN> , <BoN> g <EoN> = <BoN> g <EoN> . <BoN> sqf norm <EoN> ( ) <NEWLINE> <BoN> gen <EoN> += <BoN> s <EoN> * <BoN> ext <EoN> <NEWLINE> <BoN> coeffs <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> args <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> g <EoN> . <BoN> as expr <EoN> ( ) , <BoN> coeffs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> ( <BoN> g <EoN> ) , <BoN> coeffs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> generator <EoN> = <BoN> numbered symbols <EoN> ( <STRING> , <BoN> cls <EoN> = <BoN> Dummy <EoN> ) <NEWLINE> <NEWLINE> <BoN> F <EoN> , <BoN> Y <EoN> = [ ] , [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> ext <EoN> <BoN> in <EoN> <BoN> extension <EoN> : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> next <EoN> ( <BoN> generator <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> ext <EoN> . <BoN> is Poly <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ext <EoN> . <BoN> is univariate <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> ext <EoN> . <BoN> as expr <EoN> ( <BoN> y <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> ext <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> minpoly <EoN> ( <BoN> ext <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> F <EoN> . <BoN> append <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> Y <EoN> . <BoN> append <EoN> ( <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> coeffs generator <EoN> = <BoN> args <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> coeffs generator <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> coeffs <EoN> <BoN> in <EoN> <BoN> coeffs generator <EoN> ( <BoN> len <EoN> ( <BoN> Y <EoN> ) ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> x <EoN> - <BoN> sum <EoN> ( [ <BoN> c <EoN> * <BoN> y <EoN> <BoN> for <EoN> <BoN> c <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> coeffs <EoN> , <BoN> Y <EoN> ) ] ) <NEWLINE> <BoN> G <EoN> = <BoN> groebner <EoN> ( <BoN> F <EoN> + [ <BoN> f <EoN> ] , <BoN> Y <EoN> + [ <BoN> x <EoN> ] , <BoN> order <EoN> = <STRING> , <BoN> field <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> H <EoN> , <BoN> g <EoN> = <BoN> G <EoN> [ : - <NUMBER> ] , <BoN> cls <EoN> ( <BoN> G <EoN> [ - <NUMBER> ] , <BoN> x <EoN> , <BoN> domain <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> h <EoN> , <BoN> y <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> zip <EoN> ( <BoN> H <EoN> , <BoN> Y <EoN> ) ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> H <EoN> [ <BoN> i <EoN> ] = <BoN> Poly <EoN> ( <BoN> y <EoN> - <BoN> h <EoN> , <BoN> x <EoN> , <NEWLINE> <BoN> domain <EoN> = <STRING> ) . <BoN> all coeffs <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Coercion Failed <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> <EoN> , <BoN> g <EoN> = <BoN> g <EoN> . <BoN> clear denoms <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> args <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> g <EoN> . <BoN> as expr <EoN> ( ) , <BoN> coeffs <EoN> , <BoN> H <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> g <EoN> , <BoN> coeffs <EoN> , <BoN> H <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> result type many <EoN> ( * <BoN> arrays and dtypes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> result type <EoN> ( * <BoN> arrays and dtypes <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> reduce <EoN> ( <BoN> np <EoN> . <BoN> result type <EoN> , <BoN> arrays and dtypes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is int 64 dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> arr or dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> tipo <EoN> = <BoN> get dtype type <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> issubclass <EoN> ( <BoN> tipo <EoN> , <BoN> np <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> random point <EoN> ( <BoN> self <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> random <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> seed <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> rng <EoN> = <BoN> random <EoN> . <BoN> Random <EoN> ( <BoN> seed <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> rng <EoN> = <BoN> random <EoN> <NEWLINE> <UNTAB> <BoN> t <EoN> = <BoN> Dummy <EoN> ( ) <NEWLINE> <BoN> pt <EoN> = <BoN> self <EoN> . <BoN> arbitrary point <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> , <BoN> Ray <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> abs <EoN> ( <BoN> rng <EoN> . <BoN> gauss <EoN> ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> , <BoN> Segment <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> rng <EoN> . <BoN> random <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> , <BoN> Line <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> rng <EoN> . <BoN> gauss <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> pt <EoN> . <BoN> subs <EoN> ( <BoN> t <EoN> , <BoN> Rational <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lazyselect <EoN> ( <BoN> condlist <EoN> , <BoN> choicelist <EoN> , <BoN> arrays <EoN> , <BoN> default <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> arrays <EoN> = <BoN> np <EoN> . <BoN> broadcast arrays <EoN> ( * <BoN> arrays <EoN> ) <NEWLINE> <BoN> tcode <EoN> = <BoN> np <EoN> . <BoN> mintypecode <EoN> ( [ <BoN> a <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> arrays <EoN> ] ) <NEWLINE> <BoN> out <EoN> = <BoN> valarray <EoN> ( <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> arrays <EoN> [ <NUMBER> ] ) , <BoN> value <EoN> = <BoN> default <EoN> , <BoN> typecode <EoN> = <BoN> tcode <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> index <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> condlist <EoN> ) ) : <NEWLINE> <TAB> <BoN> func <EoN> , <BoN> cond <EoN> = <BoN> choicelist <EoN> [ <BoN> index <EoN> ] , <BoN> condlist <EoN> [ <BoN> index <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> cond <EoN> <BoN> is <EoN> <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> cond <EoN> , <BoN> <EoN> = <BoN> np <EoN> . <BoN> broadcast arrays <EoN> ( <BoN> cond <EoN> , <BoN> arrays <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> temp <EoN> = <BoN> tuple <EoN> ( <BoN> np <EoN> . <BoN> extract <EoN> ( <BoN> cond <EoN> , <BoN> arr <EoN> ) <BoN> for <EoN> <BoN> arr <EoN> <BoN> in <EoN> <BoN> arrays <EoN> ) <NEWLINE> <BoN> np <EoN> . <BoN> place <EoN> ( <BoN> out <EoN> , <BoN> cond <EoN> , <BoN> func <EoN> ( * <BoN> temp <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get variable value <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> load variable <EoN> ( <BoN> self <EoN> . <BoN> model dir <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reset uids <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> global <EoN> <BoN> GRAPH UID DICTS <EoN> <NEWLINE> <BoN> GRAPH UID DICTS <EoN> = { } <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> adagrad update <EoN> ( <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> grad <EoN> = <BoN> None <EoN> , <BoN> history <EoN> = <BoN> None <EoN> , <BoN> lr <EoN> = <BoN> Null <EoN> , <BoN> epsilon <EoN> = <BoN> Null <EoN> , <BoN> wd <EoN> = <BoN> Null <EoN> , <BoN> rescale grad <EoN> = <BoN> Null <EoN> , <BoN> clip gradient <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> mx op <EoN> . <BoN> register <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> convert reciprocal <EoN> ( <BoN> node <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> helper <EoN> , <BoN> <EoN> , <BoN> <EoN> = <BoN> import onnx modules <EoN> ( ) <NEWLINE> <BoN> name <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> proc nodes <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> inputs <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> input node id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <BoN> input node <EoN> = <BoN> proc nodes <EoN> [ <BoN> input node id <EoN> ] . <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <STRING> , <NEWLINE> [ <BoN> input node <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> ) <NEWLINE> <BoN> return <EoN> [ <BoN> node <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> quantized add eager fallback <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> min x <EoN> , <BoN> max x <EoN> , <BoN> min y <EoN> , <BoN> max y <EoN> , <BoN> Toutput <EoN> = <BoN> dtypes <EoN> . <BoN> qint 32 <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> Toutput <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> Toutput <EoN> = <BoN> dtypes <EoN> . <BoN> qint 32 <EoN> <NEWLINE> <UNTAB> <BoN> Toutput <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> Toutput <EoN> , <STRING> ) <NEWLINE> <BoN> attr T 1 <EoN> , ( <BoN> x <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> x <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> attr T 2 <EoN> , ( <BoN> y <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> y <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> min x <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> min x <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> max x <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> max x <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> min y <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> min y <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> max y <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> max y <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> x <EoN> , <BoN> y <EoN> , <BoN> min x <EoN> , <BoN> max x <EoN> , <BoN> min y <EoN> , <BoN> max y <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T 1 <EoN> , <STRING> , <BoN> attr T 2 <EoN> , <STRING> , <BoN> Toutput <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedAddOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add edges from <EoN> ( <BoN> self <EoN> , <BoN> ebunch <EoN> , ** <BoN> attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> ebunch <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> add edge <EoN> ( <BoN> e <EoN> , ** <BoN> attr <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is full slice <EoN> ( <BoN> obj <EoN> , <BoN> l <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> slice <EoN> ) <BoN> and <EoN> <BoN> obj <EoN> . <BoN> start <EoN> == <NUMBER> <BoN> and <EoN> <BoN> obj <EoN> . <BoN> stop <EoN> == <BoN> l <EoN> <BoN> and <EoN> <NEWLINE> <BoN> obj <EoN> . <BoN> step <EoN> <BoN> is <EoN> <BoN> None <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cast scalar to array <EoN> ( <BoN> shape <EoN> , <BoN> value <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> , <BoN> fill value <EoN> = <BoN> infer dtype from scalar <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fill value <EoN> = <BoN> value <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> values <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> values <EoN> . <BoN> fill <EoN> ( <BoN> fill value <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> values <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> str contains <EoN> ( <BoN> arr <EoN> , <BoN> pat <EoN> , <BoN> case <EoN> = <BoN> True <EoN> , <BoN> flags <EoN> = <NUMBER> , <BoN> na <EoN> = <BoN> np <EoN> . <BoN> nan <EoN> , <BoN> regex <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> regex <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> case <EoN> : <NEWLINE> <TAB> <BoN> flags <EoN> |= <BoN> re <EoN> . <BoN> IGNORECAS E <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> regex <EoN> = <BoN> re <EoN> . <BoN> compile <EoN> ( <BoN> pat <EoN> , <BoN> flags <EoN> = <BoN> flags <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> regex <EoN> . <BoN> groups <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> User Warning <EoN> , <NEWLINE> <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> bool <EoN> ( <BoN> regex <EoN> . <BoN> search <EoN> ( <BoN> x <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> case <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> pat <EoN> <BoN> in <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> upper pat <EoN> = <BoN> pat <EoN> . <BoN> upper <EoN> ( ) <NEWLINE> <BoN> f <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> upper pat <EoN> <BoN> in <EoN> <BoN> x <EoN> <NEWLINE> <BoN> uppered <EoN> = <BoN> na map <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> upper <EoN> ( ) , <BoN> arr <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> na map <EoN> ( <BoN> f <EoN> , <BoN> uppered <EoN> , <BoN> na <EoN> , <BoN> dtype <EoN> = <BoN> bool <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> na map <EoN> ( <BoN> f <EoN> , <BoN> arr <EoN> , <BoN> na <EoN> , <BoN> dtype <EoN> = <BoN> bool <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> categorical to palette <EoN> ( <BoN> self <EoN> , <BoN> data <EoN> , <BoN> order <EoN> , <BoN> palette <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> order <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> levels <EoN> = <BoN> categorical order <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> levels <EoN> = <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> n colors <EoN> = <BoN> len <EoN> ( <BoN> levels <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> palette <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> missing <EoN> = <BoN> set <EoN> ( <BoN> levels <EoN> ) - <BoN> set <EoN> ( <BoN> palette <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> missing <EoN> ) : <NEWLINE> <TAB> <BoN> err <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> err <EoN> . <BoN> format <EoN> ( <BoN> missing <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> palette <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n colors <EoN> <= <BoN> len <EoN> ( <BoN> get color cycle <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> colors <EoN> = <BoN> color palette <EoN> ( <BoN> None <EoN> , <BoN> n colors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> colors <EoN> = <BoN> color palette <EoN> ( <STRING> , <BoN> n colors <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> palette <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> palette <EoN> ) != <BoN> n colors <EoN> : <NEWLINE> <TAB> <BoN> err <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> err <EoN> ) <NEWLINE> <UNTAB> <BoN> colors <EoN> = <BoN> palette <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> colors <EoN> = <BoN> color palette <EoN> ( <BoN> palette <EoN> , <BoN> n colors <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> palette <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> levels <EoN> , <BoN> colors <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> levels <EoN> , <BoN> palette <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> new timer <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Timer Mac <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> c str array <EoN> ( <BoN> strings <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> arr <EoN> = ( <BoN> ctypes <EoN> . <BoN> c char p <EoN> * <BoN> len <EoN> ( <BoN> strings <EoN> ) ) ( ) <NEWLINE> <BoN> arr <EoN> [ : ] = [ <BoN> s <EoN> . <BoN> encode <EoN> ( <STRING> ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> strings <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> arr <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> size <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> % <BoN> self <EoN> . <BoN> name <EoN> , <NEWLINE> [ <BoN> self <EoN> . <BoN> resource handle <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> colocate with <EoN> ( <BoN> self <EoN> . <BoN> resource handle <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gen lookup ops <EoN> . <BoN> lookup table size v 2 <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> resource handle <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get extent <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> extent <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> extent <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sz <EoN> = <BoN> self <EoN> . <BoN> get size <EoN> ( ) <NEWLINE> <BoN> numrows <EoN> , <BoN> numcols <EoN> = <BoN> sz <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> origin <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> ( - <NUMBER> , <BoN> numcols <EoN> - <NUMBER> , <BoN> numrows <EoN> - <NUMBER> , - <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( - <NUMBER> , <BoN> numcols <EoN> - <NUMBER> , - <NUMBER> , <BoN> numrows <EoN> - <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> unroll <EoN> ( <BoN> self <EoN> , <BoN> length <EoN> , <BoN> inputs <EoN> , <BoN> begin state <EoN> = <BoN> None <EoN> , <BoN> layout <EoN> = <STRING> , <BoN> merge outputs <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> reset <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> inputs <EoN> , <BoN> <EoN> = <BoN> normalize sequence <EoN> ( <BoN> length <EoN> , <BoN> inputs <EoN> , <BoN> layout <EoN> , <BoN> False <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> begin state <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> begin state <EoN> = <BoN> self <EoN> . <BoN> begin state <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> states <EoN> = <BoN> begin state <EoN> <NEWLINE> <BoN> outputs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> length <EoN> ) : <NEWLINE> <TAB> <BoN> output <EoN> , <BoN> states <EoN> = <BoN> self <EoN> ( <BoN> inputs <EoN> [ <BoN> i <EoN> ] , <BoN> states <EoN> ) <NEWLINE> <BoN> outputs <EoN> . <BoN> append <EoN> ( <BoN> output <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> outputs <EoN> , <BoN> <EoN> = <BoN> normalize sequence <EoN> ( <BoN> length <EoN> , <BoN> outputs <EoN> , <BoN> layout <EoN> , <BoN> merge outputs <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> outputs <EoN> , <BoN> states <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> discrete log pollard rho <EoN> ( <BoN> n <EoN> , <BoN> a <EoN> , <BoN> b <EoN> , <BoN> order <EoN> = <BoN> None <EoN> , <BoN> retries <EoN> = <NUMBER> , <BoN> rseed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> %= <BoN> n <EoN> <NEWLINE> <BoN> b <EoN> %= <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> order <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> order <EoN> = <BoN> n order <EoN> ( <BoN> b <EoN> , <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> prng <EoN> = <BoN> Random <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> rseed <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prng <EoN> . <BoN> seed <EoN> ( <BoN> rseed <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> retries <EoN> ) : <NEWLINE> <TAB> <BoN> aa <EoN> = <BoN> prng <EoN> . <BoN> randint <EoN> ( <NUMBER> , <BoN> order <EoN> - <NUMBER> ) <NEWLINE> <BoN> ba <EoN> = <BoN> prng <EoN> . <BoN> randint <EoN> ( <NUMBER> , <BoN> order <EoN> - <NUMBER> ) <NEWLINE> <BoN> xa <EoN> = <BoN> pow <EoN> ( <BoN> b <EoN> , <BoN> aa <EoN> , <BoN> n <EoN> ) * <BoN> pow <EoN> ( <BoN> a <EoN> , <BoN> ba <EoN> , <BoN> n <EoN> ) % <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> c <EoN> = <BoN> xa <EoN> % <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> a <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = <BoN> aa <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> ba <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> xa <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> aa <EoN> + <BoN> aa <EoN> ) % <BoN> order <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> ba <EoN> + <BoN> ba <EoN> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> b <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> aa <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <BoN> bb <EoN> = <BoN> ba <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> order <EoN> ) : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> xa <EoN> % <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xa <EoN> = <BoN> a <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ba <EoN> = ( <BoN> ba <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xa <EoN> = <BoN> xa <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> aa <EoN> = ( <BoN> aa <EoN> + <BoN> aa <EoN> ) % <BoN> order <EoN> <NEWLINE> <BoN> ba <EoN> = ( <BoN> ba <EoN> + <BoN> ba <EoN> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xa <EoN> = <BoN> b <EoN> * <BoN> xa <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> aa <EoN> = ( <BoN> aa <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> c <EoN> = <BoN> xb <EoN> % <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> a <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> bb <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> xb <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> ab <EoN> + <BoN> ab <EoN> ) % <BoN> order <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> bb <EoN> + <BoN> bb <EoN> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> b <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> ab <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> c <EoN> = <BoN> xb <EoN> % <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> a <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> bb <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> c <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> xb <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> ab <EoN> + <BoN> ab <EoN> ) % <BoN> order <EoN> <NEWLINE> <BoN> bb <EoN> = ( <BoN> bb <EoN> + <BoN> bb <EoN> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xb <EoN> = <BoN> b <EoN> * <BoN> xb <EoN> % <BoN> n <EoN> <NEWLINE> <BoN> ab <EoN> = ( <BoN> ab <EoN> + <NUMBER> ) % <BoN> order <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> xa <EoN> == <BoN> xb <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = ( <BoN> ba <EoN> - <BoN> bb <EoN> ) % <BoN> order <EoN> <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mod inverse <EoN> ( <BoN> r <EoN> , <BoN> order <EoN> ) * ( <BoN> ab <EoN> - <BoN> aa <EoN> ) % <BoN> order <EoN> <NEWLINE> <UNTAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> floor <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> argmax <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Arg Max <EoN> ( <BoN> axis <EoN> ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> other <EoN> = <BoN> sympify <EoN> ( <BoN> other <EoN> , <BoN> strict <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> ret <EoN> = <BoN> sympify <EoN> ( <BoN> self <EoN> . <BoN> contains <EoN> ( <BoN> other <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> ret <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ret <EoN> = <BoN> Contains <EoN> ( <BoN> other <EoN> , <BoN> self <EoN> , <BoN> evaluate <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> output difference <EoN> ( <BoN> self <EoN> , <BoN> example <EoN> , <BoN> got <EoN> , <BoN> optionflags <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> want <EoN> = <BoN> example <EoN> . <BoN> want <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> optionflags <EoN> & <BoN> DONT ACCEPT BLANKLINE <EoN> ) : <NEWLINE> <TAB> <BoN> got <EoN> = <BoN> re <EoN> . <BoN> sub <EoN> ( <STRING> , <BoN> BLANKLINE MARKER <EoN> , <BoN> got <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> do a fancy diff <EoN> ( <BoN> want <EoN> , <BoN> got <EoN> , <BoN> optionflags <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> want lines <EoN> = <BoN> want <EoN> . <BoN> splitlines <EoN> ( <BoN> keepends <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> got lines <EoN> = <BoN> got <EoN> . <BoN> splitlines <EoN> ( <BoN> keepends <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> optionflags <EoN> & <BoN> REPORT UDIFF <EoN> : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> difflib <EoN> . <BoN> unified diff <EoN> ( <BoN> want lines <EoN> , <BoN> got lines <EoN> , <BoN> n <EoN> = <NUMBER> ) <NEWLINE> <BoN> diff <EoN> = <BoN> list <EoN> ( <BoN> diff <EoN> ) [ <NUMBER> : ] <NEWLINE> <BoN> kind <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> optionflags <EoN> & <BoN> REPORT CDIFF <EoN> : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> difflib <EoN> . <BoN> context diff <EoN> ( <BoN> want lines <EoN> , <BoN> got lines <EoN> , <BoN> n <EoN> = <NUMBER> ) <NEWLINE> <BoN> diff <EoN> = <BoN> list <EoN> ( <BoN> diff <EoN> ) [ <NUMBER> : ] <NEWLINE> <BoN> kind <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> optionflags <EoN> & <BoN> REPORT NDIFF <EoN> : <NEWLINE> <TAB> <BoN> engine <EoN> = <BoN> difflib <EoN> . <BoN> Differ <EoN> ( <BoN> charjunk <EoN> = <BoN> difflib <EoN> . <BoN> IS CHARACTER JUNK <EoN> ) <NEWLINE> <BoN> diff <EoN> = <BoN> list <EoN> ( <BoN> engine <EoN> . <BoN> compare <EoN> ( <BoN> want lines <EoN> , <BoN> got lines <EoN> ) ) <NEWLINE> <BoN> kind <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <NUMBER> , <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> diff <EoN> = [ <BoN> line <EoN> . <BoN> rstrip <EoN> ( ) + <STRING> <BoN> for <EoN> <BoN> line <EoN> <BoN> in <EoN> <BoN> diff <EoN> ] <NEWLINE> <BoN> return <EoN> <STRING> % <BoN> kind <EoN> + <BoN> indent <EoN> ( <STRING> . <BoN> join <EoN> ( <BoN> diff <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> want <EoN> <BoN> and <EoN> <BoN> got <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % ( <BoN> indent <EoN> ( <BoN> want <EoN> ) , <BoN> indent <EoN> ( <BoN> got <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> want <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % <BoN> indent <EoN> ( <BoN> want <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> got <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> % <BoN> indent <EoN> ( <BoN> got <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> russellrao <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> w <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> u <EoN> = <BoN> validate vector <EoN> ( <BoN> u <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> validate vector <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> u <EoN> . <BoN> dtype <EoN> == <BoN> v <EoN> . <BoN> dtype <EoN> == <BoN> bool <EoN> <BoN> and <EoN> <BoN> w <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ntt <EoN> = ( <BoN> u <EoN> & <BoN> v <EoN> ) . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> n <EoN> = <BoN> float <EoN> ( <BoN> len <EoN> ( <BoN> u <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> w <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ntt <EoN> = ( <BoN> u <EoN> * <BoN> v <EoN> ) . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> n <EoN> = <BoN> float <EoN> ( <BoN> len <EoN> ( <BoN> u <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> w <EoN> = <BoN> validate weights <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> ntt <EoN> = ( <BoN> u <EoN> * <BoN> v <EoN> * <BoN> w <EoN> ) . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> n <EoN> = <BoN> w <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> float <EoN> ( <BoN> n <EoN> - <BoN> ntt <EoN> ) / <BoN> n <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> commit <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> parent <EoN> . <BoN> is active <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Invalid Request Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> do commit <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> is active <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> batch dot <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> axes <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> axes <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> axes <EoN> = ( <BoN> axes <EoN> , <BoN> axes <EoN> ) <NEWLINE> <UNTAB> <BoN> x ndim <EoN> = <BoN> ndim <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> y ndim <EoN> = <BoN> ndim <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> axes <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> axes <EoN> = [ <BoN> x ndim <EoN> - <NUMBER> , <BoN> y ndim <EoN> - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x ndim <EoN> > <BoN> y ndim <EoN> : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> x ndim <EoN> - <BoN> y ndim <EoN> <NEWLINE> <BoN> y <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> y <EoN> , <NEWLINE> <BoN> array ops <EoN> . <BoN> concat <EoN> ( <NEWLINE> [ <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> y <EoN> ) , [ <NUMBER> ] * ( <BoN> diff <EoN> ) ] , <BoN> axis <EoN> = <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> y ndim <EoN> > <BoN> x ndim <EoN> : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> y ndim <EoN> - <BoN> x ndim <EoN> <NEWLINE> <BoN> x <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> , <NEWLINE> <BoN> array ops <EoN> . <BoN> concat <EoN> ( <NEWLINE> [ <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> x <EoN> ) , [ <NUMBER> ] * ( <BoN> diff <EoN> ) ] , <BoN> axis <EoN> = <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> diff <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ndim <EoN> ( <BoN> x <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> ndim <EoN> ( <BoN> y <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> axes <EoN> [ <NUMBER> ] == <BoN> axes <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> axes <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <BoN> array ops <EoN> . <BoN> transpose <EoN> ( <BoN> x <EoN> , [ <NUMBER> , <NUMBER> ] ) , <BoN> y <EoN> ) , <BoN> axes <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> adj x <EoN> = <BoN> None <EoN> <BoN> if <EoN> <BoN> axes <EoN> [ <NUMBER> ] == <BoN> ndim <EoN> ( <BoN> x <EoN> ) - <NUMBER> <BoN> else <EoN> <BoN> True <EoN> <NEWLINE> <BoN> adj y <EoN> = <BoN> True <EoN> <BoN> if <EoN> <BoN> axes <EoN> [ <NUMBER> ] == <BoN> ndim <EoN> ( <BoN> y <EoN> ) - <NUMBER> <BoN> else <EoN> <BoN> None <EoN> <NEWLINE> <BoN> out <EoN> = <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> adjoint a <EoN> = <BoN> adj x <EoN> , <BoN> adjoint b <EoN> = <BoN> adj y <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> diff <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x ndim <EoN> > <BoN> y ndim <EoN> : <NEWLINE> <TAB> <BoN> idx <EoN> = <BoN> x ndim <EoN> + <BoN> y ndim <EoN> - <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> idx <EoN> = <BoN> x ndim <EoN> - <NUMBER> <NEWLINE> <UNTAB> <BoN> out <EoN> = <BoN> array ops <EoN> . <BoN> squeeze <EoN> ( <BoN> out <EoN> , <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> idx <EoN> , <BoN> idx <EoN> + <BoN> diff <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ndim <EoN> ( <BoN> out <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> expand dims <EoN> ( <BoN> out <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sfilter <EoN> ( <BoN> pred <EoN> , <BoN> brule <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> filtered brl <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> filter <EoN> ( <BoN> pred <EoN> , <BoN> brule <EoN> ( <BoN> expr <EoN> ) ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> filtered brl <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> all coeffs <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> dom <EoN> . <BoN> to sympy <EoN> ( <BoN> c <EoN> ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> all coeffs <EoN> ( ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> key without properties <EoN> ( <BoN> self <EoN> , <BoN> properties <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fields values <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> k <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> fields <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> properties <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> fields values <EoN> . <BoN> append <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> k <EoN> , <BoN> self <EoN> [ <BoN> i <EoN> ] ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <STRING> . <BoN> format <EoN> ( <BoN> type <EoN> ( <BoN> self <EoN> ) . <BoN> name <EoN> , <STRING> . <BoN> join <EoN> ( <BoN> fields values <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rgb 2 ycbcr <EoN> ( <BoN> rgb <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> arr <EoN> = <BoN> convert <EoN> ( <BoN> ycbcr from rgb <EoN> , <BoN> rgb <EoN> ) <NEWLINE> <BoN> arr <EoN> [ ... , <NUMBER> ] += <NUMBER> <NEWLINE> <BoN> arr <EoN> [ ... , <NUMBER> ] += <NUMBER> <NEWLINE> <BoN> arr <EoN> [ ... , <NUMBER> ] += <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> arr <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random generalized negative binomial <EoN> ( <BoN> mu <EoN> = <BoN> Null <EoN> , <BoN> alpha <EoN> = <BoN> Null <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> ctx <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> degree <EoN> ( <BoN> f <EoN> , <BoN> x <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> i <EoN> = <BoN> f <EoN> . <BoN> ring <EoN> . <BoN> index <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> - <BoN> oo <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> i <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> max <EoN> ( [ <BoN> monom <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> monom <EoN> <BoN> in <EoN> <BoN> f <EoN> . <BoN> itermonoms <EoN> ( ) ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get fontstyle <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> fontproperties <EoN> . <BoN> get style <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> extract jpeg shape <EoN> ( <BoN> contents <EoN> , <BoN> output type <EoN> = <BoN> dtypes <EoN> . <BoN> int 32 <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> contents <EoN> , <NEWLINE> <STRING> , <BoN> output type <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> extract jpeg shape eager fallback <EoN> ( <NEWLINE> <BoN> contents <EoN> , <BoN> output type <EoN> = <BoN> output type <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> output type <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> output type <EoN> = <BoN> dtypes <EoN> . <BoN> int 32 <EoN> <NEWLINE> <UNTAB> <BoN> output type <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> output type <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> contents <EoN> = <BoN> contents <EoN> , <BoN> output type <EoN> = <BoN> output type <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> get task id <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> = <BoN> json <EoN> . <BoN> loads <EoN> ( <BoN> os <EoN> . <BoN> environ <EoN> . <BoN> get <EoN> ( <STRING> ) <BoN> or <EoN> <STRING> ) <NEWLINE> <BoN> task env <EoN> = <BoN> config <EoN> . <BoN> get <EoN> ( <STRING> , { } ) <NEWLINE> <BoN> task index <EoN> = <BoN> task env <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> task index <EoN> ) <BoN> if <EoN> <BoN> task index <EoN> <BoN> else <EoN> <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save figure <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverse <EoN> ( <BoN> self <EoN> , <BoN> argindex <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> erfc <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> norm factor <EoN> ( <BoN> p <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p <EoN> = <BoN> asarray <EoN> ( <BoN> p <EoN> , <BoN> dtype <EoN> = <BoN> complex <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> G <EoN> ( <BoN> w <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> abs <EoN> ( <BoN> k <EoN> / <BoN> prod <EoN> ( <NUMBER> * <BoN> w <EoN> - <BoN> p <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> cutoff <EoN> ( <BoN> w <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> ( <BoN> w <EoN> ) - <NUMBER> / <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> optimize <EoN> . <BoN> newton <EoN> ( <BoN> cutoff <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> step 5 <EoN> ( <BoN> state <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> count <EoN> = <NUMBER> <NEWLINE> <BoN> path <EoN> = <BoN> state <EoN> . <BoN> path <EoN> <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> state <EoN> . <BoN> Z 0 r <EoN> <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> state <EoN> . <BoN> Z 0 c <EoN> <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> row <EoN> = <BoN> np <EoN> . <BoN> argmax <EoN> ( <BoN> state <EoN> . <BoN> marked <EoN> [ : , <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] ] == <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> row <EoN> , <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] ] == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> count <EoN> += <NUMBER> <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> row <EoN> <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> path <EoN> [ <BoN> count <EoN> - <NUMBER> , <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> col <EoN> = <BoN> np <EoN> . <BoN> argmax <EoN> ( <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] ] == <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> row <EoN> , <BoN> col <EoN> ] != <NUMBER> : <NEWLINE> <TAB> <BoN> col <EoN> = - <NUMBER> <NEWLINE> <UNTAB> <BoN> count <EoN> += <NUMBER> <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> path <EoN> [ <BoN> count <EoN> - <NUMBER> , <NUMBER> ] <NEWLINE> <BoN> path <EoN> [ <BoN> count <EoN> , <NUMBER> ] = <BoN> col <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> count <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] , <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] ] == <NUMBER> : <NEWLINE> <TAB> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] , <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] ] = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] , <BoN> path <EoN> [ <BoN> i <EoN> , <NUMBER> ] ] = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> state <EoN> . <BoN> clear covers <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> state <EoN> . <BoN> marked <EoN> [ <BoN> state <EoN> . <BoN> marked <EoN> == <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> step 3 <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get server version info <EoN> ( <BoN> self <EoN> , <BoN> connection <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is scalar multiple <EoN> ( <BoN> self <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> s <EoN> , <BoN> o <EoN> = <BoN> Point <EoN> . <BoN> normalize dimension <EoN> ( <BoN> self <EoN> , <BoN> Point <EoN> ( <BoN> p <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> s <EoN> . <BoN> ambient dimension <EoN> == <NUMBER> : <NEWLINE> <TAB> ( <BoN> x 1 <EoN> , <BoN> y 1 <EoN> ) , ( <BoN> x 2 <EoN> , <BoN> y 2 <EoN> ) = <BoN> s <EoN> . <BoN> args <EoN> , <BoN> o <EoN> . <BoN> args <EoN> <NEWLINE> <BoN> rv <EoN> = ( <BoN> x 1 <EoN> * <BoN> y 2 <EoN> - <BoN> x 2 <EoN> * <BoN> y 1 <EoN> ) . <BoN> equals <EoN> ( <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> rv <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Undecidable <EoN> ( <BoN> filldedent <EoN> ( <NEWLINE> <STRING> % ( <BoN> s <EoN> , <BoN> o <EoN> ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> m <EoN> = <BoN> Matrix <EoN> ( [ <BoN> s <EoN> . <BoN> args <EoN> , <BoN> o <EoN> . <BoN> args <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> m <EoN> . <BoN> rank <EoN> ( ) < <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> intra community edges <EoN> ( <BoN> G <EoN> , <BoN> partition <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <BoN> G <EoN> . <BoN> subgraph <EoN> ( <BoN> block <EoN> ) . <BoN> size <EoN> ( ) <BoN> for <EoN> <BoN> block <EoN> <BoN> in <EoN> <BoN> partition <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sqrt <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> python sqrt <EoN> ( <BoN> a <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> flag is registered <EoN> ( <BoN> self <EoN> , <BoN> flag obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> flag dict <EoN> = <BoN> self <EoN> . <BoN> flags <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> name <EoN> = <BoN> flag obj <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> if <EoN> <BoN> flag dict <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> , <BoN> None <EoN> ) == <BoN> flag obj <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> short name <EoN> = <BoN> flag obj <EoN> . <BoN> short name <EoN> <NEWLINE> <BoN> if <EoN> ( <BoN> short name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> flag dict <EoN> . <BoN> get <EoN> ( <BoN> short name <EoN> , <BoN> None <EoN> ) == <BoN> flag obj <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max pool grad grad v 2 <EoN> ( <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> , <BoN> ksize <EoN> , <BoN> strides <EoN> , <BoN> padding <EoN> , <BoN> data format <EoN> = <STRING> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> orig input <EoN> , <NEWLINE> <BoN> orig output <EoN> , <BoN> grad <EoN> , <BoN> ksize <EoN> , <BoN> strides <EoN> , <STRING> , <BoN> padding <EoN> , <STRING> , <NEWLINE> <BoN> data format <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> max pool grad grad v 2 eager fallback <EoN> ( <NEWLINE> <BoN> orig input <EoN> , <BoN> orig output <EoN> , <BoN> grad <EoN> , <BoN> ksize <EoN> , <BoN> strides <EoN> , <BoN> padding <EoN> = <BoN> padding <EoN> , <NEWLINE> <BoN> data format <EoN> = <BoN> data format <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> padding <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> padding <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> data format <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data format <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> data format <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> data format <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> orig input <EoN> = <BoN> orig input <EoN> , <BoN> orig output <EoN> = <BoN> orig output <EoN> , <NEWLINE> <BoN> grad <EoN> = <BoN> grad <EoN> , <BoN> ksize <EoN> = <BoN> ksize <EoN> , <BoN> strides <EoN> = <BoN> strides <EoN> , <NEWLINE> <BoN> padding <EoN> = <BoN> padding <EoN> , <BoN> data format <EoN> = <BoN> data format <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict ops <EoN> ( <BoN> self <EoN> , <BoN> features <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> variable scope <EoN> . <BoN> variable scope <EoN> ( <STRING> , <BoN> use resource <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> prediction <EoN> = <BoN> self <EoN> . <BoN> model <EoN> . <BoN> predict <EoN> ( <BoN> features <EoN> = <BoN> features <EoN> ) <NEWLINE> <UNTAB> <BoN> prediction <EoN> [ <BoN> feature keys <EoN> . <BoN> Prediction Results <EoN> . <BoN> TIME S <EoN> ] = <BoN> features <EoN> [ <NEWLINE> <BoN> feature keys <EoN> . <BoN> Prediction Features <EoN> . <BoN> TIME S <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> estimator lib <EoN> . <BoN> Estimator Spec <EoN> ( <NEWLINE> <BoN> predictions <EoN> = <BoN> prediction <EoN> , <BoN> mode <EoN> = <BoN> estimator lib <EoN> . <BoN> Mode Keys <EoN> . <BoN> PREDIC T <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> args <EoN> , <BoN> loc <EoN> , <BoN> scale <EoN> = <BoN> self <EoN> . <BoN> parse args <EoN> ( * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) <NEWLINE> <BoN> x <EoN> , <BoN> loc <EoN> , <BoN> scale <EoN> = <BoN> map <EoN> ( <BoN> asarray <EoN> , ( <BoN> x <EoN> , <BoN> loc <EoN> , <BoN> scale <EoN> ) ) <NEWLINE> <BoN> args <EoN> = <BoN> tuple <EoN> ( <BoN> map <EoN> ( <BoN> asarray <EoN> , <BoN> args <EoN> ) ) <NEWLINE> <BoN> dtyp <EoN> = <BoN> np <EoN> . <BoN> find common type <EoN> ( [ <BoN> x <EoN> . <BoN> dtype <EoN> , <BoN> np <EoN> . <BoN> float 64 <EoN> ] , [ ] ) <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( ( <BoN> x <EoN> - <BoN> loc <EoN> ) / <BoN> scale <EoN> , <BoN> dtype <EoN> = <BoN> dtyp <EoN> ) <NEWLINE> <BoN> cond 0 <EoN> = <BoN> self <EoN> . <BoN> argcheck <EoN> ( * <BoN> args <EoN> ) & ( <BoN> scale <EoN> > <NUMBER> ) <NEWLINE> <BoN> cond 1 <EoN> = <BoN> self <EoN> . <BoN> open support mask <EoN> ( <BoN> x <EoN> ) & ( <BoN> scale <EoN> > <NUMBER> ) <NEWLINE> <BoN> cond 2 <EoN> = <BoN> cond 0 <EoN> & ( <BoN> x <EoN> <= <BoN> self <EoN> . <BoN> a <EoN> ) <NEWLINE> <BoN> cond <EoN> = <BoN> cond 0 <EoN> & <BoN> cond 1 <EoN> <NEWLINE> <BoN> output <EoN> = <BoN> zeros <EoN> ( <BoN> shape <EoN> ( <BoN> cond <EoN> ) , <BoN> dtyp <EoN> ) <NEWLINE> <BoN> place <EoN> ( <BoN> output <EoN> , ( <NUMBER> - <BoN> cond 0 <EoN> ) + <BoN> np <EoN> . <BoN> isnan <EoN> ( <BoN> x <EoN> ) , <BoN> self <EoN> . <BoN> badvalue <EoN> ) <NEWLINE> <BoN> place <EoN> ( <BoN> output <EoN> , <BoN> cond 2 <EoN> , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> cond <EoN> ) : <NEWLINE> <TAB> <BoN> goodargs <EoN> = <BoN> argsreduce <EoN> ( <BoN> cond <EoN> , * ( ( <BoN> x <EoN> , ) + <BoN> args <EoN> ) ) <NEWLINE> <BoN> place <EoN> ( <BoN> output <EoN> , <BoN> cond <EoN> , <BoN> self <EoN> . <BoN> sf <EoN> ( * <BoN> goodargs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> output <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> output <EoN> [ ( ) ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> output <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> monomial count <EoN> ( <BoN> V <EoN> , <BoN> N <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> factorial <EoN> <NEWLINE> <BoN> return <EoN> <BoN> factorial <EoN> ( <BoN> V <EoN> + <BoN> N <EoN> ) / <BoN> factorial <EoN> ( <BoN> V <EoN> ) / <BoN> factorial <EoN> ( <BoN> N <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> setup residual graph <EoN> ( <BoN> G <EoN> , <BoN> weight <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> residual graph <EoN> = <BoN> G <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> edges <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> weight <EoN> : <NEWLINE> <TAB> <BoN> residual graph <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] [ <STRING> ] = ( <BoN> id <EoN> ( <BoN> u <EoN> ) , <BoN> id <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> residual graph <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] [ <STRING> ] = ( <BoN> G <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] [ <BoN> weight <EoN> ] , <BoN> id <EoN> ( <BoN> u <EoN> ) , <BoN> id <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> residual graph <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make signature <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> spec <EoN> = <BoN> signature <EoN> ( <BoN> func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> spec <EoN> . <BoN> defaults <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> n wo defaults <EoN> = <BoN> len <EoN> ( <BoN> spec <EoN> . <BoN> args <EoN> ) <NEWLINE> <BoN> defaults <EoN> = ( <STRING> , ) * <BoN> n wo defaults <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> n wo defaults <EoN> = <BoN> len <EoN> ( <BoN> spec <EoN> . <BoN> args <EoN> ) - <BoN> len <EoN> ( <BoN> spec <EoN> . <BoN> defaults <EoN> ) <NEWLINE> <BoN> defaults <EoN> = ( <STRING> , ) * <BoN> n wo defaults <EoN> + <BoN> tuple <EoN> ( <BoN> spec <EoN> . <BoN> defaults <EoN> ) <NEWLINE> <UNTAB> <BoN> args <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> var <EoN> , <BoN> default <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> zip <EoN> ( <BoN> spec <EoN> . <BoN> args <EoN> , <BoN> defaults <EoN> ) ) : <NEWLINE> <TAB> <BoN> args <EoN> . <BoN> append <EoN> ( <BoN> var <EoN> <BoN> if <EoN> <BoN> default <EoN> == <STRING> <BoN> else <EoN> <BoN> var <EoN> + <STRING> + <BoN> repr <EoN> ( <BoN> default <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> spec <EoN> . <BoN> varargs <EoN> : <NEWLINE> <TAB> <BoN> args <EoN> . <BoN> append <EoN> ( <STRING> + <BoN> spec <EoN> . <BoN> varargs <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> spec <EoN> . <BoN> keywords <EoN> : <NEWLINE> <TAB> <BoN> args <EoN> . <BoN> append <EoN> ( <STRING> + <BoN> spec <EoN> . <BoN> keywords <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> args <EoN> , <BoN> spec <EoN> . <BoN> args <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> serialize <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> serializer <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exceptions <EoN> . <BoN> Error <EoN> ( <NEWLINE> <STRING> % <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> s <EoN> = <STRING> <NEWLINE> <NEWLINE> <BoN> multi value <EoN> = <BoN> self <EoN> . <BoN> value <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> self <EoN> . <BoN> value <EoN> <BoN> in <EoN> <BoN> multi value <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> s <EoN> : <BoN> s <EoN> += <STRING> <NEWLINE> <BoN> s <EoN> += <BoN> Flag <EoN> . <BoN> serialize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> value <EoN> = <BoN> multi value <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> close <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> . <BoN> io <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> io <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Internal Error <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> , <BoN> INTERNA L <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate read indexer <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> indexer <EoN> , <BoN> axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> ax <EoN> = <BoN> self <EoN> . <BoN> obj <EoN> . <BoN> get axis <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> key <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> missing <EoN> = ( <BoN> indexer <EoN> < <NUMBER> ) . <BoN> sum <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> missing <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> missing <EoN> == <BoN> len <EoN> ( <BoN> indexer <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> key <EoN> = <BoN> key <EoN> , <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> obj <EoN> . <BoN> get axis name <EoN> ( <BoN> axis <EoN> ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> missing key warning <EoN> = <BoN> textwrap <EoN> . <BoN> dedent <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> ax <EoN> . <BoN> is categorical <EoN> ( ) <BoN> or <EoN> <BoN> ax <EoN> . <BoN> is interval <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> missing key warning <EoN> , <NEWLINE> <BoN> Future Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> estimate fun jac <EoN> ( <BoN> fun <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> p <EoN> , <BoN> f 0 <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n <EoN> , <BoN> m <EoN> = <BoN> y <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> f 0 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> f 0 <EoN> = <BoN> fun <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> p <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> dtype <EoN> = <BoN> y <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> df dy <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> n <EoN> , <BoN> n <EoN> , <BoN> m <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> h <EoN> = <BoN> EP S <EoN> ** <NUMBER> * ( <NUMBER> + <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> y <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> y new <EoN> = <BoN> y <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> y new <EoN> [ <BoN> i <EoN> ] += <BoN> h <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> hi <EoN> = <BoN> y new <EoN> [ <BoN> i <EoN> ] - <BoN> y <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> f new <EoN> = <BoN> fun <EoN> ( <BoN> x <EoN> , <BoN> y new <EoN> , <BoN> p <EoN> ) <NEWLINE> <BoN> df dy <EoN> [ : , <BoN> i <EoN> , : ] = ( <BoN> f new <EoN> - <BoN> f 0 <EoN> ) / <BoN> hi <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> p <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> df dp <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> df dp <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> n <EoN> , <BoN> k <EoN> , <BoN> m <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> h <EoN> = <BoN> EP S <EoN> ** <NUMBER> * ( <NUMBER> + <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> p <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> k <EoN> ) : <NEWLINE> <TAB> <BoN> p new <EoN> = <BoN> p <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> p new <EoN> [ <BoN> i <EoN> ] += <BoN> h <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> hi <EoN> = <BoN> p new <EoN> [ <BoN> i <EoN> ] - <BoN> p <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> f new <EoN> = <BoN> fun <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> p new <EoN> ) <NEWLINE> <BoN> df dp <EoN> [ : , <BoN> i <EoN> , : ] = ( <BoN> f new <EoN> - <BoN> f 0 <EoN> ) / <BoN> hi <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> df dy <EoN> , <BoN> df dp <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fail <EoN> ( <BoN> self <EoN> , <BoN> msg <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> self <EoN> . <BoN> failure Exception <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> error <EoN> ( <BoN> self <EoN> , <BoN> msg <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> log <EoN> ( <BoN> logging <EoN> . <BoN> ERRO R <EoN> , <BoN> msg <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> begin nested <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> branch from <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> branch from <EoN> . <BoN> begin nested <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> transaction <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> transaction <EoN> = <BoN> Root Transaction <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> transaction <EoN> = <BoN> Nested Transaction <EoN> ( <BoN> self <EoN> , <BoN> self <EoN> . <BoN> transaction <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> transaction <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp sub ground <EoN> ( <BoN> f <EoN> , <BoN> c <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> dmp sub term <EoN> ( <BoN> f <EoN> , <BoN> dmp ground <EoN> ( <BoN> c <EoN> , <BoN> u <EoN> - <NUMBER> ) , <NUMBER> , <BoN> u <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rotate <EoN> ( <BoN> self <EoN> , <BoN> angle <EoN> = <NUMBER> , <BoN> pt <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> matrices <EoN> <BoN> import <EoN> <BoN> Matrix <EoN> , <BoN> rot axis 3 <EoN> <NEWLINE> <BoN> if <EoN> <BoN> pt <EoN> : <NEWLINE> <TAB> <BoN> pt <EoN> = - <BoN> Point <EoN> ( <BoN> pt <EoN> , <BoN> dim <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pt <EoN> = <BoN> Point <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> rv <EoN> = <BoN> self <EoN> . <BoN> translate <EoN> ( * <BoN> pt <EoN> . <BoN> args <EoN> ) <NEWLINE> <BoN> f <EoN> = <BoN> list <EoN> ( <BoN> rv <EoN> . <BoN> functions <EoN> ) <NEWLINE> <BoN> f <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> f <EoN> = <BoN> Matrix <EoN> ( <NUMBER> , <NUMBER> , <BoN> f <EoN> ) <NEWLINE> <BoN> f <EoN> *= <BoN> rot axis 3 <EoN> ( <BoN> angle <EoN> ) <NEWLINE> <BoN> rv <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> f <EoN> [ <NUMBER> , : <NUMBER> ] . <BoN> tolist <EoN> ( ) [ <NUMBER> ] , <BoN> self <EoN> . <BoN> limits <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> pt <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> pt <EoN> = - <BoN> pt <EoN> <NEWLINE> <BoN> return <EoN> <BoN> rv <EoN> . <BoN> translate <EoN> ( * <BoN> pt <EoN> . <BoN> args <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> PO Sform <EoN> ( <BoN> variables <EoN> , <BoN> minterms <EoN> , <BoN> dontcares <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> variables <EoN> = [ <BoN> sympify <EoN> ( <BoN> v <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> variables <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> minterms <EoN> == [ ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> false <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> minterms <EoN> = [ <BoN> list <EoN> ( <BoN> i <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> minterms <EoN> ] <NEWLINE> <BoN> dontcares <EoN> = [ <BoN> list <EoN> ( <BoN> i <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> ( <BoN> dontcares <EoN> <BoN> or <EoN> [ ] ) ] <NEWLINE> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> dontcares <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> minterms <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> d <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> maxterms <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> product <EoN> ( [ <NUMBER> , <NUMBER> ] , <BoN> repeat <EoN> = <BoN> len <EoN> ( <BoN> variables <EoN> ) ) : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> list <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> if <EoN> ( <BoN> t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> minterms <EoN> ) <BoN> and <EoN> ( <BoN> t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> dontcares <EoN> ) : <NEWLINE> <TAB> <BoN> maxterms <EoN> . <BoN> append <EoN> ( <BoN> t <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> old <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> new <EoN> = <BoN> maxterms <EoN> + <BoN> dontcares <EoN> <NEWLINE> <BoN> while <EoN> <BoN> new <EoN> != <BoN> old <EoN> : <NEWLINE> <TAB> <BoN> old <EoN> = <BoN> new <EoN> <NEWLINE> <BoN> new <EoN> = <BoN> simplified pairs <EoN> ( <BoN> old <EoN> ) <NEWLINE> <UNTAB> <BoN> essential <EoN> = <BoN> rem redundancy <EoN> ( <BoN> new <EoN> , <BoN> maxterms <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> And <EoN> ( * [ <BoN> convert to varsPOS <EoN> ( <BoN> x <EoN> , <BoN> variables <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> essential <EoN> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load <EoN> ( <BoN> f <EoN> , <BoN> as gray <EoN> = <BoN> False <EoN> , <BoN> as grey <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> as grey <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> as gray <EoN> = <BoN> as grey <EoN> <NEWLINE> <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> use plugin <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> imread <EoN> ( <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> data dir <EoN> , <BoN> f <EoN> ) , <BoN> as gray <EoN> = <BoN> as gray <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get label info <EoN> ( <BoN> G <EoN> , <BoN> label name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <NEWLINE> <BoN> labels <EoN> = [ ] <NEWLINE> <BoN> label to id <EoN> = { } <NEWLINE> <BoN> lid <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> n <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> G <EoN> . <BoN> nodes <EoN> ( <BoN> data <EoN> = <BoN> True <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> label name <EoN> <BoN> in <EoN> <BoN> n <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> label <EoN> = <BoN> n <EoN> [ <NUMBER> ] [ <BoN> label name <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> label <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> label to id <EoN> : <NEWLINE> <TAB> <BoN> label to id <EoN> [ <BoN> label <EoN> ] = <BoN> lid <EoN> <NEWLINE> <BoN> lid <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> labels <EoN> . <BoN> append <EoN> ( [ <BoN> i <EoN> , <BoN> label to id <EoN> [ <BoN> label <EoN> ] ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> labels <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> labels <EoN> ) <NEWLINE> <BoN> label dict <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> label <EoN> <BoN> for <EoN> <BoN> label <EoN> , <BoN> <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <NEWLINE> <BoN> label to id <EoN> . <BoN> items <EoN> ( ) , <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> [ <NUMBER> ] ) ] ) <NEWLINE> <BoN> return <EoN> ( <BoN> labels <EoN> , <BoN> label dict <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is exp <EoN> ( <BoN> var <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> neg <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> neg info <EoN> = <BoN> is neg <EoN> ( <BoN> var <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> neg info <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> neg <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> var <EoN> = <BoN> neg info <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> var <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> var <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> tensor <EoN> . <BoN> exp <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> neg <EoN> , <BoN> var <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , * <BoN> packages <EoN> , ** <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> , <NEWLINE> <BoN> Deprecation Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <BoN> frame <EoN> = <BoN> self <EoN> . <BoN> parent frame <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> info modules <EoN> = { } <NEWLINE> <BoN> if <EoN> <BoN> options <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> imported packages <EoN> = [ ] <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> verbose <EoN> = <BoN> verbose <EoN> = <BoN> options <EoN> . <BoN> get <EoN> ( <STRING> , - <NUMBER> ) <NEWLINE> <BoN> postpone <EoN> = <BoN> options <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> init info modules <EoN> ( <BoN> packages <EoN> <BoN> or <EoN> <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> log <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> parent name <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> package name <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> get sorted names <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> package name <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> imported packages <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> info module <EoN> = <BoN> self <EoN> . <BoN> info modules <EoN> [ <BoN> package name <EoN> ] <NEWLINE> <BoN> global symbols <EoN> = <BoN> getattr <EoN> ( <BoN> info module <EoN> , <STRING> , [ ] ) <NEWLINE> <BoN> postpone import <EoN> = <BoN> getattr <EoN> ( <BoN> info module <EoN> , <STRING> , <BoN> False <EoN> ) <NEWLINE> <BoN> if <EoN> ( <BoN> postpone <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> global symbols <EoN> ) <BoN> or <EoN> ( <BoN> postpone import <EoN> <BoN> and <EoN> <BoN> postpone <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> old object <EoN> = <BoN> frame <EoN> . <BoN> f locals <EoN> . <BoN> get <EoN> ( <BoN> package name <EoN> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> cmdstr <EoN> = <STRING> + <BoN> package name <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> execcmd <EoN> ( <BoN> cmdstr <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> imported packages <EoN> . <BoN> append <EoN> ( <BoN> package name <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> verbose <EoN> != - <NUMBER> : <NEWLINE> <TAB> <BoN> new object <EoN> = <BoN> frame <EoN> . <BoN> f locals <EoN> . <BoN> get <EoN> ( <BoN> package name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> old object <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> old object <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> new object <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> warn <EoN> ( <STRING> % ( <BoN> package name <EoN> , <BoN> self <EoN> . <BoN> obj 2 repr <EoN> ( <BoN> new object <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> obj 2 repr <EoN> ( <BoN> old object <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> package name <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parent export names <EoN> . <BoN> append <EoN> ( <BoN> package name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> symbol <EoN> <BoN> in <EoN> <BoN> global symbols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> symbol <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> symbols <EoN> = <BoN> eval <EoN> ( <STRING> % ( <BoN> package name <EoN> ) , <NEWLINE> <BoN> frame <EoN> . <BoN> f globals <EoN> , <BoN> frame <EoN> . <BoN> f locals <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> symbols <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> symbols <EoN> = <BoN> eval <EoN> ( <STRING> % ( <BoN> package name <EoN> ) , <NEWLINE> <BoN> frame <EoN> . <BoN> f globals <EoN> , <BoN> frame <EoN> . <BoN> f locals <EoN> ) <NEWLINE> <BoN> symbols <EoN> = [ <BoN> s <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> symbols <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> s <EoN> . <BoN> startswith <EoN> ( <STRING> ) ] <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> symbols <EoN> = [ <BoN> symbol <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> verbose <EoN> != - <NUMBER> : <NEWLINE> <TAB> <BoN> old objects <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> frame <EoN> . <BoN> f locals <EoN> : <NEWLINE> <TAB> <BoN> old objects <EoN> [ <BoN> s <EoN> ] = <BoN> frame <EoN> . <BoN> f locals <EoN> [ <BoN> s <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> cmdstr <EoN> = <STRING> + <BoN> package name <EoN> + <STRING> + <BoN> symbol <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> execcmd <EoN> ( <BoN> cmdstr <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> verbose <EoN> != - <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> s <EoN> , <BoN> old object <EoN> <BoN> in <EoN> <BoN> old objects <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> new object <EoN> = <BoN> frame <EoN> . <BoN> f locals <EoN> [ <BoN> s <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> new object <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> old object <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> warn <EoN> ( <STRING> % ( <BoN> s <EoN> , <BoN> self <EoN> . <BoN> obj 2 repr <EoN> ( <BoN> new object <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> obj 2 repr <EoN> ( <BoN> old object <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> symbol <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parent export names <EoN> . <BoN> extend <EoN> ( <BoN> symbols <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parent export names <EoN> . <BoN> append <EoN> ( <BoN> symbol <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> all timeseries index generator <EoN> ( <BoN> k <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> make index funcs <EoN> = [ <BoN> make Date Index <EoN> , <BoN> make Period Index <EoN> , <BoN> make Timedelta Index <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> make index func <EoN> <BoN> in <EoN> <BoN> make index funcs <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> make index func <EoN> ( <BoN> k <EoN> = <BoN> k <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> normalize slice <EoN> ( <BoN> idx <EoN> , <BoN> dim <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> idx <EoN> , <BoN> slice <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> math <EoN> . <BoN> isnan <EoN> ( <BoN> dim <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> idx <EoN> <NEWLINE> <UNTAB> <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> step <EoN> = <BoN> idx <EoN> . <BoN> indices <EoN> ( <BoN> dim <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> step <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> start <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> start <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stop <EoN> >= <BoN> dim <EoN> : <NEWLINE> <TAB> <BoN> stop <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> step <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> step <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stop <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> start <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> stop <EoN> < <BoN> start <EoN> : <NEWLINE> <TAB> <BoN> stop <EoN> = <BoN> start <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> step <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> start <EoN> >= <BoN> dim <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> start <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stop <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> stop <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> slice <EoN> ( <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> step <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> idx <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add suffix <EoN> ( <BoN> self <EoN> , <BoN> suffix <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new data <EoN> = <BoN> self <EoN> . <BoN> data <EoN> . <BoN> add suffix <EoN> ( <BoN> suffix <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> new data <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> has bridges <EoN> ( <BoN> G <EoN> , <BoN> root <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> next <EoN> ( <BoN> bridges <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> create <EoN> ( <BoN> self <EoN> , <BoN> bind <EoN> = <BoN> None <EoN> , <BoN> checkfirst <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> bind <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bind <EoN> = <BoN> bind or error <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> t <EoN> = <BoN> self <EoN> . <BoN> dialect impl <EoN> ( <BoN> bind <EoN> . <BoN> dialect <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> t <EoN> . <BoN> class <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> class <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> t <EoN> , <BoN> Schema Type <EoN> ) : <NEWLINE> <TAB> <BoN> t <EoN> . <BoN> create <EoN> ( <BoN> bind <EoN> = <BoN> bind <EoN> , <BoN> checkfirst <EoN> = <BoN> checkfirst <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> center <EoN> ( <BoN> self <EoN> , <BoN> width <EoN> , <BoN> fillchar <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> asarray <EoN> ( <BoN> center <EoN> ( <BoN> self <EoN> , <BoN> width <EoN> , <BoN> fillchar <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> if delegate has method <EoN> ( <BoN> delegate <EoN> = ( <STRING> , <STRING> ) ) <NEWLINE> <BoN> def <EoN> <BoN> inverse transform <EoN> ( <BoN> self <EoN> , <BoN> Xt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> check is fitted <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> best estimator <EoN> . <BoN> inverse transform <EoN> ( <BoN> Xt <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> ensure c contiguous <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> x <EoN> . <BoN> flags <EoN> . <BoN> c contiguous <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> x <EoN> = <BoN> self <EoN> . <BoN> x <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> c <EoN> . <BoN> flags <EoN> . <BoN> c contiguous <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> c <EoN> = <BoN> self <EoN> . <BoN> c <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> maybe cast to datetime <EoN> ( <BoN> value <EoN> , <BoN> dtype <EoN> , <BoN> errors <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> tools <EoN> . <BoN> timedeltas <EoN> <BoN> import <EoN> <BoN> to timedelta <EoN> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> tools <EoN> . <BoN> datetimes <EoN> <BoN> import <EoN> <BoN> to datetime <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> dtype <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> is datetime 64 <EoN> = <BoN> is datetime 64 dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <BoN> is datetime 64 tz <EoN> = <BoN> is datetime 64 tz dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <BoN> is timedelta 64 <EoN> = <BoN> is timedelta 64 dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is datetime 64 <EoN> <BoN> or <EoN> <BoN> is datetime 64 tz <EoN> <BoN> or <EoN> <BoN> is timedelta 64 <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is datetime 64 <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> is dtype equal <EoN> ( <BoN> dtype <EoN> , <BoN> NS DTYPE <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> name <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> . <BoN> name <EoN> ) , <NEWLINE> <BoN> Future Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> dtype <EoN> = <BoN> NS DTYPE <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> is datetime 64 tz <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is scalar <EoN> ( <BoN> value <EoN> ) <BoN> and <EoN> <BoN> isna <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> value <EoN> = [ <BoN> value <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> is timedelta 64 <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> is dtype equal <EoN> ( <BoN> dtype <EoN> , <BoN> TD DTYPE <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> name <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> . <BoN> name <EoN> ) , <NEWLINE> <BoN> Future Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> dtype <EoN> = <BoN> TD DTYPE <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> is scalar <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> value <EoN> == <BoN> i Na T <EoN> <BoN> or <EoN> <BoN> isna <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> i Na T <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> value <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> value <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> i Na T <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> value <EoN> . <BoN> shape <EoN> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> is dtype equal <EoN> ( <BoN> value <EoN> . <BoN> dtype <EoN> , <NEWLINE> <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is datetime 64 <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> to datetime <EoN> ( <BoN> value <EoN> , <BoN> errors <EoN> = <BoN> errors <EoN> ) . <BoN> values <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is datetime 64 tz <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> is dt string <EoN> = <BoN> is string dtype <EoN> ( <BoN> value <EoN> ) <NEWLINE> <BoN> value <EoN> = <BoN> to datetime <EoN> ( <BoN> value <EoN> , <BoN> errors <EoN> = <BoN> errors <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> is dt string <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> value <EoN> . <BoN> tz localize <EoN> ( <BoN> dtype <EoN> . <BoN> tz <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> value <EoN> = ( <BoN> value <EoN> . <BoN> tz localize <EoN> ( <STRING> ) <NEWLINE> . <BoN> tz convert <EoN> ( <BoN> dtype <EoN> . <BoN> tz <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> is timedelta 64 <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> to timedelta <EoN> ( <BoN> value <EoN> , <BoN> errors <EoN> = <BoN> errors <EoN> ) . <BoN> values <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> ( <BoN> Attribute Error <EoN> , <BoN> Value Error <EoN> , <BoN> Type Error <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> is datetime 64 dtype <EoN> ( <BoN> value <EoN> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> is datetime 64 dtype <EoN> ( <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is object dtype <EoN> ( <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> value <EoN> . <BoN> dtype <EoN> != <BoN> NS DTYPE <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> value <EoN> . <BoN> astype <EoN> ( <BoN> NS DTYPE <EoN> ) <NEWLINE> <UNTAB> <BoN> ints <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> value <EoN> ) . <BoN> view <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> tslib <EoN> . <BoN> ints to pydatetime <EoN> ( <BoN> ints <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> is array <EoN> = <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is array <EoN> <BoN> and <EoN> <BoN> value <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> value <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> kind <EoN> == <STRING> <BoN> and <EoN> <BoN> dtype <EoN> != <BoN> NS DTYPE <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> value <EoN> . <BoN> astype <EoN> ( <BoN> NS DTYPE <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> dtype <EoN> . <BoN> kind <EoN> == <STRING> <BoN> and <EoN> <BoN> dtype <EoN> != <BoN> TD DTYPE <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> to timedelta <EoN> ( <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> ( <BoN> is array <EoN> <BoN> and <EoN> <BoN> not <EoN> ( <BoN> issubclass <EoN> ( <BoN> value <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> np <EoN> . <BoN> integer <EoN> ) <BoN> or <EoN> <NEWLINE> <BoN> value <EoN> . <BoN> dtype <EoN> == <BoN> np <EoN> . <BoN> object <EoN> ) ) : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> maybe infer to datetimelike <EoN> ( <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> value <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverse <EoN> ( <BoN> self <EoN> , <BoN> argindex <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> erfcinv <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> apply dense <EoN> ( <BoN> self <EoN> , <BoN> grad <EoN> , <BoN> var <EoN> , <BoN> state <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sin <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get knots <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> tck <EoN> [ : <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> edit height <EoN> ( <BoN> self <EoN> , <BoN> height <EoN> , <BoN> strength <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sol <EoN> = <BoN> self <EoN> . <BoN> solver <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> [ <BoN> self <EoN> . <BoN> height <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> sol <EoN> . <BoN> has Edit Variable <EoN> ( <BoN> i <EoN> ) : <NEWLINE> <TAB> <BoN> sol <EoN> . <BoN> add Edit Variable <EoN> ( <BoN> i <EoN> , <BoN> strength <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> sol <EoN> . <BoN> suggest Value <EoN> ( <BoN> self <EoN> . <BoN> height <EoN> , <BoN> height <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> total used bytes <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> total used bytes <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> step <EoN> ( <BoN> self <EoN> , <BoN> closure <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> param groups <EoN> ) == <NUMBER> <NEWLINE> <NEWLINE> <BoN> group <EoN> = <BoN> self <EoN> . <BoN> param groups <EoN> [ <NUMBER> ] <NEWLINE> <BoN> lr <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> max iter <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> max eval <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> tolerance grad <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> tolerance change <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> line search fn <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <BoN> history size <EoN> = <BoN> group <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> state <EoN> = <BoN> self <EoN> . <BoN> state <EoN> [ <BoN> self <EoN> . <BoN> params <EoN> [ <NUMBER> ] ] <NEWLINE> <BoN> state <EoN> . <BoN> setdefault <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> state <EoN> . <BoN> setdefault <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> orig loss <EoN> = <BoN> closure <EoN> ( ) <NEWLINE> <BoN> loss <EoN> = <BoN> float <EoN> ( <BoN> orig loss <EoN> ) <NEWLINE> <BoN> current evals <EoN> = <NUMBER> <NEWLINE> <BoN> state <EoN> [ <STRING> ] += <NUMBER> <NEWLINE> <NEWLINE> <BoN> flat grad <EoN> = <BoN> self <EoN> . <BoN> gather flat grad <EoN> ( ) <NEWLINE> <BoN> abs grad sum <EoN> = <BoN> flat grad <EoN> . <BoN> abs <EoN> ( ) . <BoN> sum <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> abs grad sum <EoN> <= <BoN> tolerance grad <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> orig loss <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> d <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> t <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> old dirs <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> old stps <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> H diag <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> prev flat grad <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> prev loss <EoN> = <BoN> state <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> n iter <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> n iter <EoN> < <BoN> max iter <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> n iter <EoN> += <NUMBER> <NEWLINE> <BoN> state <EoN> [ <STRING> ] += <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> state <EoN> [ <STRING> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> flat grad <EoN> . <BoN> neg <EoN> ( ) <NEWLINE> <BoN> old dirs <EoN> = [ ] <NEWLINE> <BoN> old stps <EoN> = [ ] <NEWLINE> <BoN> H diag <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> flat grad <EoN> . <BoN> sub <EoN> ( <BoN> prev flat grad <EoN> ) <NEWLINE> <BoN> s <EoN> = <BoN> d <EoN> . <BoN> mul <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> ys <EoN> = <BoN> y <EoN> . <BoN> dot <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ys <EoN> > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> old dirs <EoN> ) == <BoN> history size <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> old dirs <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <BoN> old stps <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> old dirs <EoN> . <BoN> append <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> old stps <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> H diag <EoN> = <BoN> ys <EoN> / <BoN> y <EoN> . <BoN> dot <EoN> ( <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> num old <EoN> = <BoN> len <EoN> ( <BoN> old dirs <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> state <EoN> : <NEWLINE> <TAB> <BoN> state <EoN> [ <STRING> ] = [ <BoN> None <EoN> ] * <BoN> history size <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = [ <BoN> None <EoN> ] * <BoN> history size <EoN> <NEWLINE> <UNTAB> <BoN> ro <EoN> = <BoN> state <EoN> [ <STRING> ] <NEWLINE> <BoN> al <EoN> = <BoN> state <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> num old <EoN> ) : <NEWLINE> <TAB> <BoN> ro <EoN> [ <BoN> i <EoN> ] = <NUMBER> / <BoN> old dirs <EoN> [ <BoN> i <EoN> ] . <BoN> dot <EoN> ( <BoN> old stps <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> q <EoN> = <BoN> flat grad <EoN> . <BoN> neg <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> num old <EoN> - <NUMBER> , - <NUMBER> , - <NUMBER> ) : <NEWLINE> <TAB> <BoN> al <EoN> [ <BoN> i <EoN> ] = <BoN> old stps <EoN> [ <BoN> i <EoN> ] . <BoN> dot <EoN> ( <BoN> q <EoN> ) * <BoN> ro <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> q <EoN> . <BoN> add <EoN> ( - <BoN> al <EoN> [ <BoN> i <EoN> ] , <BoN> old dirs <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> d <EoN> = <BoN> r <EoN> = <BoN> torch <EoN> . <BoN> mul <EoN> ( <BoN> q <EoN> , <BoN> H diag <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> num old <EoN> ) : <NEWLINE> <TAB> <BoN> be i <EoN> = <BoN> old dirs <EoN> [ <BoN> i <EoN> ] . <BoN> dot <EoN> ( <BoN> r <EoN> ) * <BoN> ro <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> r <EoN> . <BoN> add <EoN> ( <BoN> al <EoN> [ <BoN> i <EoN> ] - <BoN> be i <EoN> , <BoN> old stps <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> prev flat grad <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prev flat grad <EoN> = <BoN> flat grad <EoN> . <BoN> clone <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> prev flat grad <EoN> . <BoN> copy <EoN> ( <BoN> flat grad <EoN> ) <NEWLINE> <UNTAB> <BoN> prev loss <EoN> = <BoN> loss <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> state <EoN> [ <STRING> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> min <EoN> ( <NUMBER> , <NUMBER> / <BoN> abs grad sum <EoN> ) * <BoN> lr <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> lr <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> gtd <EoN> = <BoN> flat grad <EoN> . <BoN> dot <EoN> ( <BoN> d <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ls func evals <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> line search fn <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> add grad <EoN> ( <BoN> t <EoN> , <BoN> d <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n iter <EoN> != <BoN> max iter <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> loss <EoN> = <BoN> float <EoN> ( <BoN> closure <EoN> ( ) ) <NEWLINE> <BoN> flat grad <EoN> = <BoN> self <EoN> . <BoN> gather flat grad <EoN> ( ) <NEWLINE> <BoN> abs grad sum <EoN> = <BoN> flat grad <EoN> . <BoN> abs <EoN> ( ) . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> ls func evals <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> current evals <EoN> += <BoN> ls func evals <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] += <BoN> ls func evals <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n iter <EoN> == <BoN> max iter <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> current evals <EoN> >= <BoN> max eval <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> abs grad sum <EoN> <= <BoN> tolerance grad <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> gtd <EoN> > - <BoN> tolerance change <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> d <EoN> . <BoN> mul <EoN> ( <BoN> t <EoN> ) . <BoN> abs <EoN> ( ) . <BoN> sum <EoN> ( ) <= <BoN> tolerance change <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> loss <EoN> - <BoN> prev loss <EoN> ) < <BoN> tolerance change <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> state <EoN> [ <STRING> ] = <BoN> d <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> t <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> old dirs <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> old stps <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> H diag <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> prev flat grad <EoN> <NEWLINE> <BoN> state <EoN> [ <STRING> ] = <BoN> prev loss <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> orig loss <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as hex <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> hex <EoN> = [ <BoN> mpl <EoN> . <BoN> colors <EoN> . <BoN> rgb 2 hex <EoN> ( <BoN> rgb <EoN> ) <BoN> for <EoN> <BoN> rgb <EoN> <BoN> in <EoN> <BoN> self <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> ColorPalette <EoN> ( <BoN> hex <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> release savepoint <EoN> ( <BoN> self <EoN> , <BoN> conn <EoN> , <BoN> release savepoint <EoN> , <BoN> name <EoN> , <BoN> context <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> release savepoint <EoN> ( <BoN> name <EoN> , <BoN> context <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> array 3 d <EoN> ( <BoN> surface <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> w <EoN> , <BoN> h <EoN> = <BoN> surface <EoN> . <BoN> get size <EoN> ( ) <NEWLINE> <BoN> array <EoN> = <BoN> numpy <EoN> . <BoN> empty <EoN> ( ( <BoN> w <EoN> , <BoN> h <EoN> , <NUMBER> ) , <BoN> numpy <EoN> . <BoN> uint 8 <EoN> ) <NEWLINE> <BoN> surface to array <EoN> ( <BoN> array <EoN> , <BoN> surface <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> array <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> normalize nested keys <EoN> ( <BoN> config <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config norm <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> config <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> Mapping <EoN> ) : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> normalize nested keys <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> key norm <EoN> = <BoN> normalize key <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> config norm <EoN> [ <BoN> key norm <EoN> ] = <BoN> value <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> config norm <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abc <EoN> . <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> num accelerators per worker <EoN> ( <BoN> self <EoN> , <BoN> session config <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> memoize <EoN> ( ) <NEWLINE> <BoN> def <EoN> <BoN> raw <EoN> ( <BoN> code <EoN> , <BoN> name <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check cuda available <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> cupy <EoN> . <BoN> Raw Kernel <EoN> ( <BoN> code <EoN> , <BoN> name <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lrn eager fallback <EoN> ( <BoN> input <EoN> , <BoN> depth radius <EoN> = <NUMBER> , <BoN> bias <EoN> = <NUMBER> , <BoN> alpha <EoN> = <NUMBER> , <BoN> beta <EoN> = <NUMBER> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> depth radius <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> depth radius <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> depth radius <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> depth radius <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> bias <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bias <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> bias <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> bias <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> alpha <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> alpha <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> alpha <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> alpha <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> beta <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> beta <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> beta <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> beta <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> input <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> ] , <BoN> ctx <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> depth radius <EoN> , <STRING> , <BoN> bias <EoN> , <STRING> , <BoN> alpha <EoN> , <NEWLINE> <STRING> , <BoN> beta <EoN> , <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> canon <EoN> ( * <BoN> rules <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> exhaust <EoN> ( <BoN> top down <EoN> ( <BoN> exhaust <EoN> ( <BoN> do one <EoN> ( * <BoN> rules <EoN> ) ) , ** <BoN> kwargs <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> consolidate <EoN> ( <BoN> blocks <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> gkey <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> consolidate key <EoN> <NEWLINE> <BoN> grouper <EoN> = <BoN> itertools <EoN> . <BoN> groupby <EoN> ( <BoN> sorted <EoN> ( <BoN> blocks <EoN> , <BoN> key <EoN> = <BoN> gkey <EoN> ) , <BoN> gkey <EoN> ) <NEWLINE> <NEWLINE> <BoN> new blocks <EoN> = [ ] <NEWLINE> <BoN> for <EoN> ( <BoN> can consolidate <EoN> , <BoN> dtype <EoN> ) , <BoN> group blocks <EoN> <BoN> in <EoN> <BoN> grouper <EoN> : <NEWLINE> <TAB> <BoN> merged blocks <EoN> = <BoN> merge blocks <EoN> ( <BoN> list <EoN> ( <BoN> group blocks <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <NEWLINE> <BoN> can consolidate <EoN> = <BoN> can consolidate <EoN> ) <NEWLINE> <BoN> new blocks <EoN> = <BoN> extend blocks <EoN> ( <BoN> merged blocks <EoN> , <BoN> new blocks <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> new blocks <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get values <EoN> ( <BoN> self <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> is object dtype <EoN> ( <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> . <BoN> astype <EoN> ( <BoN> object <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as estimator spec <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> host calls <EoN> = { } <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> eval metrics <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> host calls <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> eval metrics <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> host call <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> host calls <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> host call <EoN> <NEWLINE> <UNTAB> <BoN> host call ret <EoN> = <BoN> OutfeedHostCall <EoN> . <BoN> create cpu hostcall <EoN> ( <BoN> host calls <EoN> ) <NEWLINE> <BoN> eval metric ops <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> eval metrics <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> eval metric ops <EoN> = <BoN> host call ret <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> hooks <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> host call <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> hooks <EoN> = [ <BoN> OutfeedHostCallHook <EoN> ( <BoN> host call ret <EoN> [ <STRING> ] ) ] <NEWLINE> <UNTAB> <BoN> hooks <EoN> = <BoN> tuple <EoN> ( <BoN> hooks <EoN> <BoN> or <EoN> [ ] ) <NEWLINE> <BoN> scaffold <EoN> = <BoN> self <EoN> . <BoN> scaffold fn <EoN> ( ) <BoN> if <EoN> <BoN> self <EoN> . <BoN> scaffold fn <EoN> <BoN> else <EoN> <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> model fn lib <EoN> . <BoN> Estimator Spec <EoN> ( <NEWLINE> <BoN> mode <EoN> = <BoN> self <EoN> . <BoN> mode <EoN> , <NEWLINE> <BoN> predictions <EoN> = <BoN> self <EoN> . <BoN> predictions <EoN> , <NEWLINE> <BoN> loss <EoN> = <BoN> self <EoN> . <BoN> loss <EoN> , <NEWLINE> <BoN> train op <EoN> = <BoN> self <EoN> . <BoN> train op <EoN> , <NEWLINE> <BoN> eval metric ops <EoN> = <BoN> eval metric ops <EoN> , <NEWLINE> <BoN> export outputs <EoN> = <BoN> self <EoN> . <BoN> export outputs <EoN> , <NEWLINE> <BoN> scaffold <EoN> = <BoN> scaffold <EoN> , <NEWLINE> <BoN> training hooks <EoN> = <BoN> self <EoN> . <BoN> training hooks <EoN> + <BoN> hooks <EoN> , <NEWLINE> <BoN> evaluation hooks <EoN> = <BoN> self <EoN> . <BoN> evaluation hooks <EoN> + <BoN> hooks <EoN> , <NEWLINE> <BoN> prediction hooks <EoN> = <BoN> self <EoN> . <BoN> prediction hooks <EoN> + <BoN> hooks <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> scale count <EoN> ( <BoN> self <EoN> , <BoN> density <EoN> , <BoN> counts <EoN> , <BoN> scale hue <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> hue names <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> counts <EoN> . <BoN> max <EoN> ( ) == <NUMBER> : <NEWLINE> <TAB> <BoN> d <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> count <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> counts <EoN> , <BoN> density <EoN> ) : <NEWLINE> <TAB> <BoN> d <EoN> /= <BoN> d <EoN> . <BoN> max <EoN> ( ) <NEWLINE> <BoN> d <EoN> *= <BoN> count <EoN> / <BoN> counts <EoN> . <BoN> max <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> group <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> density <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> group <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> counts <EoN> [ <BoN> i <EoN> ] . <BoN> max <EoN> ( ) == <NUMBER> : <NEWLINE> <TAB> <BoN> d <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> count <EoN> = <BoN> counts <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> scale hue <EoN> : <NEWLINE> <TAB> <BoN> scaler <EoN> = <BoN> count <EoN> / <BoN> counts <EoN> [ <BoN> i <EoN> ] . <BoN> max <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> scaler <EoN> = <BoN> count <EoN> / <BoN> counts <EoN> . <BoN> max <EoN> ( ) <NEWLINE> <UNTAB> <BoN> d <EoN> /= <BoN> d <EoN> . <BoN> max <EoN> ( ) <NEWLINE> <BoN> d <EoN> *= <BoN> scaler <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reduce log sum exp <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> keep dims <EoN> = <BoN> True <EoN> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> attrs <EoN> <BoN> else <EoN> <BoN> attrs <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> exp op <EoN> = <BoN> symbol <EoN> . <BoN> exp <EoN> ( <BoN> inputs <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> sum op <EoN> = <BoN> symbol <EoN> . <BoN> sum <EoN> ( <BoN> exp op <EoN> , <BoN> axis <EoN> = <BoN> attrs <EoN> . <BoN> get <EoN> ( <STRING> ) , <NEWLINE> <BoN> keepdims <EoN> = <BoN> keep dims <EoN> ) <NEWLINE> <BoN> log sym <EoN> = <BoN> symbol <EoN> . <BoN> log <EoN> ( <BoN> sum op <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> log sym <EoN> , <BoN> attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> svd reduce <EoN> ( <BoN> self <EoN> , <BoN> max rank <EoN> , <BoN> to retain <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> collapsed <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> max rank <EoN> <NEWLINE> <BoN> if <EoN> <BoN> to retain <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> q <EoN> = <BoN> to retain <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> q <EoN> = <BoN> p <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> cs <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> = <BoN> min <EoN> ( <BoN> p <EoN> , <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> cs <EoN> [ <NUMBER> ] ) ) <NEWLINE> <UNTAB> <BoN> q <EoN> = <BoN> max <EoN> ( <NUMBER> , <BoN> min <EoN> ( <BoN> q <EoN> , <BoN> p <EoN> - <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> m <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> cs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> < <BoN> p <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> C <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> self <EoN> . <BoN> cs <EoN> ) . <BoN> T <EoN> <NEWLINE> <BoN> D <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> self <EoN> . <BoN> ds <EoN> ) . <BoN> T <EoN> <NEWLINE> <NEWLINE> <BoN> D <EoN> , <BoN> R <EoN> = <BoN> qr <EoN> ( <BoN> D <EoN> , <BoN> mode <EoN> = <STRING> ) <NEWLINE> <BoN> C <EoN> = <BoN> dot <EoN> ( <BoN> C <EoN> , <BoN> R <EoN> . <BoN> T <EoN> . <BoN> conj <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> U <EoN> , <BoN> S <EoN> , <BoN> W H <EoN> = <BoN> svd <EoN> ( <BoN> C <EoN> , <BoN> full matrices <EoN> = <BoN> False <EoN> , <BoN> compute uv <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> C <EoN> = <BoN> dot <EoN> ( <BoN> C <EoN> , <BoN> inv <EoN> ( <BoN> W H <EoN> ) ) <NEWLINE> <BoN> D <EoN> = <BoN> dot <EoN> ( <BoN> D <EoN> , <BoN> W H <EoN> . <BoN> T <EoN> . <BoN> conj <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> q <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> cs <EoN> [ <BoN> k <EoN> ] = <BoN> C <EoN> [ : , <BoN> k <EoN> ] . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> ds <EoN> [ <BoN> k <EoN> ] = <BoN> D <EoN> [ : , <BoN> k <EoN> ] . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> del <EoN> <BoN> self <EoN> . <BoN> cs <EoN> [ <BoN> q <EoN> : ] <NEWLINE> <BoN> del <EoN> <BoN> self <EoN> . <BoN> ds <EoN> [ <BoN> q <EoN> : ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> neighbors <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> iter <EoN> ( <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> n <EoN> ] ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Network X Error <EoN> ( <STRING> % ( <BoN> n <EoN> , ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> depth first select <EoN> ( <BoN> rectangles <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> min area <EoN> , <BoN> j <EoN> = <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> <EoN> , ( <BoN> u <EoN> , <BoN> v <EoN> ) , ( <BoN> s <EoN> , <BoN> t <EoN> ) , <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> rectangles <EoN> ) : <NEWLINE> <TAB> <BoN> area <EoN> = ( <BoN> s <EoN> - <BoN> u <EoN> ) * ( <BoN> t <EoN> - <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> min area <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> area <EoN> < <BoN> min area <EoN> : <NEWLINE> <TAB> <BoN> min area <EoN> , <BoN> j <EoN> = <BoN> area <EoN> , <BoN> i <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> rectangles <EoN> . <BoN> pop <EoN> ( <BoN> j <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assert all finite <EoN> ( <BoN> X <EoN> , <BoN> allow nan <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert all finite <EoN> ( <BoN> X <EoN> . <BoN> data <EoN> <BoN> if <EoN> <BoN> sp <EoN> . <BoN> issparse <EoN> ( <BoN> X <EoN> ) <BoN> else <EoN> <BoN> X <EoN> , <BoN> allow nan <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> filldedent <EoN> ( <BoN> s <EoN> , <BoN> w <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> + <BoN> fill <EoN> ( <BoN> dedent <EoN> ( <BoN> str <EoN> ( <BoN> s <EoN> ) ) . <BoN> strip <EoN> ( <STRING> ) , <BoN> width <EoN> = <BoN> w <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compile function <EoN> ( <BoN> node <EoN> , <BoN> globals <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , <BoN> gast <EoN> . <BoN> AS T <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , <BoN> six <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> <NEWLINE> <UNTAB> <BoN> node <EoN> = <BoN> gast <EoN> . <BoN> parse <EoN> ( <BoN> node <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , <BoN> gast <EoN> . <BoN> Module <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> succ <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> body <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> succ <EoN> , <BoN> gast <EoN> . <BoN> Function Def <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> succ <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> , <BoN> gast <EoN> . <BoN> Function Def <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> node <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> <NEWLINE> <UNTAB> <BoN> module <EoN> = <BoN> compile file <EoN> ( <BoN> node <EoN> , <BoN> globals <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> getattr <EoN> ( <BoN> module <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval derivative <EoN> ( <BoN> self <EoN> , <BoN> sym <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> f <EoN> , <BoN> limits <EoN> = <BoN> self <EoN> . <BoN> function <EoN> , <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> limits <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> limit <EoN> = <BoN> limits <EoN> . <BoN> pop <EoN> ( - <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> limit <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> a <EoN> , <BoN> b <EoN> = <BoN> limit <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> limit <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> b <EoN> = <BoN> limit <EoN> <NEWLINE> <BoN> a <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> b <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> x <EoN> = <BoN> limit <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> limits <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> f <EoN> , * <BoN> tuple <EoN> ( <BoN> limits <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> do <EoN> ( <BoN> f <EoN> , <BoN> ab <EoN> ) : <NEWLINE> <TAB> <BoN> dab dsym <EoN> = <BoN> diff <EoN> ( <BoN> ab <EoN> , <BoN> sym <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dab dsym <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> f <EoN> , <BoN> Integral <EoN> ) : <NEWLINE> <TAB> <BoN> limits <EoN> = [ ( <BoN> x <EoN> , <BoN> x <EoN> ) <BoN> if <EoN> ( <BoN> len <EoN> ( <BoN> l <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> l <EoN> [ <NUMBER> ] == <BoN> x <EoN> ) <BoN> else <EoN> <BoN> l <EoN> <NEWLINE> <BoN> for <EoN> <BoN> l <EoN> <BoN> in <EoN> <BoN> f <EoN> . <BoN> limits <EoN> ] <NEWLINE> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> f <EoN> . <BoN> function <EoN> , * <BoN> limits <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , <BoN> ab <EoN> ) * <BoN> dab dsym <EoN> <NEWLINE> <UNTAB> <BoN> rv <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> b <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> rv <EoN> += <BoN> do <EoN> ( <BoN> f <EoN> , <BoN> b <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> a <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> rv <EoN> -= <BoN> do <EoN> ( <BoN> f <EoN> , <BoN> a <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> limit <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> sym <EoN> == <BoN> x <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> arg <EoN> = <BoN> f <EoN> <NEWLINE> <BoN> rv <EoN> += <BoN> arg <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> u <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> arg <EoN> = <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , <BoN> u <EoN> ) . <BoN> diff <EoN> ( <BoN> sym <EoN> ) . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> rv <EoN> += <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> arg <EoN> , <BoN> Tuple <EoN> ( <BoN> x <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ldflags <EoN> ( <BoN> libs <EoN> = <BoN> True <EoN> , <BoN> flags <EoN> = <BoN> False <EoN> , <BoN> libs dir <EoN> = <BoN> False <EoN> , <BoN> include dir <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ldflags str <EoN> = <BoN> theano <EoN> . <BoN> config <EoN> . <BoN> blas <EoN> . <BoN> ldflags <EoN> <NEWLINE> <BoN> return <EoN> <BoN> ldflags <EoN> ( <BoN> ldflags str <EoN> = <BoN> ldflags str <EoN> , <NEWLINE> <BoN> libs <EoN> = <BoN> libs <EoN> , <NEWLINE> <BoN> flags <EoN> = <BoN> flags <EoN> , <NEWLINE> <BoN> libs dir <EoN> = <BoN> libs dir <EoN> , <NEWLINE> <BoN> include dir <EoN> = <BoN> include dir <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set inputs <EoN> ( <BoN> self <EoN> , <BoN> inputs <EoN> , <BoN> outputs <EoN> = <BoN> None <EoN> , <BoN> training <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> inputs <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> inputs <EoN> ) == <NUMBER> <NEWLINE> <BoN> inputs <EoN> = <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> build <EoN> ( <BoN> input shape <EoN> = ( <BoN> None <EoN> , ) + <BoN> inputs <EoN> . <BoN> shape <EoN> [ <NUMBER> : ] ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> inputs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> inputs <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> input names <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> feed inputs <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> feed input names <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> feed input shapes <EoN> = [ ] <NEWLINE> <BoN> inputs <EoN> = <BoN> to list <EoN> ( <BoN> inputs <EoN> , <BoN> allow tuple <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> inputs <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> % ( <BoN> i <EoN> + <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> input names <EoN> . <BoN> append <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> v <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> v <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> np <EoN> . <BoN> expand dims <EoN> ( <BoN> v <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> v <EoN> , ( <BoN> np <EoN> . <BoN> ndarray <EoN> ) ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> shape <EoN> = ( <BoN> None <EoN> , ) + <BoN> v <EoN> . <BoN> shape <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> placeholder <EoN> = <BoN> K <EoN> . <BoN> placeholder <EoN> ( <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> inputs <EoN> . <BoN> append <EoN> ( <BoN> placeholder <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> feed inputs <EoN> . <BoN> append <EoN> ( <BoN> placeholder <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> feed input names <EoN> . <BoN> append <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> feed input shapes <EoN> . <BoN> append <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> inputs <EoN> . <BoN> append <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> K <EoN> . <BoN> is placeholder <EoN> ( <BoN> v <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> feed inputs <EoN> . <BoN> append <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> feed input names <EoN> . <BoN> append <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> feed input shapes <EoN> . <BoN> append <EoN> ( <BoN> K <EoN> . <BoN> int shape <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> outputs <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> expects training arg <EoN> : <NEWLINE> <TAB> <BoN> outputs <EoN> = <BoN> self <EoN> . <BoN> call <EoN> ( <BoN> unpack singleton <EoN> ( <BoN> self <EoN> . <BoN> inputs <EoN> ) , <BoN> training <EoN> = <BoN> training <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> outputs <EoN> = <BoN> self <EoN> . <BoN> call <EoN> ( <BoN> unpack singleton <EoN> ( <BoN> self <EoN> . <BoN> inputs <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> outputs <EoN> = <BoN> to list <EoN> ( <BoN> outputs <EoN> , <BoN> allow tuple <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> outputs <EoN> = <BoN> outputs <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> output names <EoN> = [ <NEWLINE> <STRING> % ( <BoN> i <EoN> + <NUMBER> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> outputs <EoN> ) ) ] <NEWLINE> <BoN> self <EoN> . <BoN> built <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check stack trace <EoN> ( <BoN> f or fgraph <EoN> , <BoN> ops to check <EoN> = <STRING> , <BoN> bug print <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> f or fgraph <EoN> , <BoN> theano <EoN> . <BoN> compile <EoN> . <BoN> function module <EoN> . <BoN> Function <EoN> ) : <NEWLINE> <TAB> <BoN> fgraph <EoN> = <BoN> f or fgraph <EoN> . <BoN> maker <EoN> . <BoN> fgraph <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> f or fgraph <EoN> , <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> fg <EoN> . <BoN> Function Graph <EoN> ) : <NEWLINE> <TAB> <BoN> fgraph <EoN> = <BoN> f or fgraph <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> ops to check <EoN> , <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Op <EoN> ) <BoN> or <EoN> <NEWLINE> ( <BoN> inspect <EoN> . <BoN> isclass <EoN> ( <BoN> ops to check <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> issubclass <EoN> ( <BoN> ops to check <EoN> , <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Op <EoN> ) ) ) : <NEWLINE> <TAB> <BoN> ops to check <EoN> = ( <BoN> ops to check <EoN> , ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> ops to check <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ops to check <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> apply nodes to check <EoN> = [ <BoN> fgraph <EoN> . <BoN> outputs <EoN> [ <BoN> i <EoN> ] . <BoN> owner <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NEWLINE> <BoN> len <EoN> ( <BoN> fgraph <EoN> . <BoN> outputs <EoN> ) ) ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ops to check <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> apply nodes to check <EoN> = <BoN> fgraph <EoN> . <BoN> apply nodes <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> ops to check <EoN> , ( <BoN> tuple <EoN> , <BoN> list <EoN> ) ) : <NEWLINE> <NEWLINE> <TAB> <BoN> op instances <EoN> = [ ] <NEWLINE> <BoN> op classes <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> obj <EoN> <BoN> in <EoN> <BoN> ops to check <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Op <EoN> ) : <NEWLINE> <TAB> <BoN> op instances <EoN> . <BoN> append <EoN> ( <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> op classes <EoN> . <BoN> append <EoN> ( <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> op classes <EoN> = <BoN> tuple <EoN> ( <BoN> op classes <EoN> ) <NEWLINE> <NEWLINE> <BoN> apply nodes to check <EoN> = ( <NEWLINE> [ <BoN> node <EoN> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> fgraph <EoN> . <BoN> apply nodes <EoN> <BoN> if <EoN> <BoN> node <EoN> . <BoN> op <EoN> <BoN> in <EoN> <BoN> ops to check <EoN> ] + <NEWLINE> [ <BoN> node <EoN> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> fgraph <EoN> . <BoN> apply nodes <EoN> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> , <BoN> op classes <EoN> ) <BoN> or <EoN> <NEWLINE> ( <BoN> hasattr <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> , <STRING> ) <BoN> and <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> . <BoN> scalar op <EoN> , <BoN> op classes <EoN> ) ) ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> ops to check <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> apply nodes to check <EoN> = [ <BoN> node <EoN> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> fgraph <EoN> . <BoN> apply nodes <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ops to check <EoN> ( <BoN> node <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> apply nodes to check <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <STRING> <NEWLINE> <BoN> if <EoN> <BoN> bug print <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> bug print <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> bug print <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> apply nodes to check <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> output <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> outputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> output <EoN> . <BoN> tag <EoN> , <STRING> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> output <EoN> . <BoN> tag <EoN> . <BoN> trace <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup chebyshevt <EoN> ( <BoN> n <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> seq <EoN> = [ [ <BoN> K <EoN> . <BoN> one <EoN> ] , [ <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> ] ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> dup mul ground <EoN> ( <BoN> dup lshift <EoN> ( <BoN> seq <EoN> [ - <NUMBER> ] , <NUMBER> , <BoN> K <EoN> ) , <BoN> K <EoN> ( <NUMBER> ) , <BoN> K <EoN> ) <NEWLINE> <BoN> seq <EoN> . <BoN> append <EoN> ( <BoN> dup sub <EoN> ( <BoN> a <EoN> , <BoN> seq <EoN> [ - <NUMBER> ] , <BoN> K <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> seq <EoN> [ <BoN> n <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> number strongly connected components <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <NUMBER> <BoN> for <EoN> <BoN> scc <EoN> <BoN> in <EoN> <BoN> strongly connected components <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> generative <EoN> <NEWLINE> <BoN> def <EoN> <BoN> bindparams <EoN> ( <BoN> self <EoN> , * <BoN> binds <EoN> , ** <BoN> names to values <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> bindparams <EoN> = <BoN> new params <EoN> = <BoN> self <EoN> . <BoN> bindparams <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> bind <EoN> <BoN> in <EoN> <BoN> binds <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> existing <EoN> = <BoN> new params <EoN> [ <BoN> bind <EoN> . <BoN> key <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Argument Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> bind <EoN> . <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new params <EoN> [ <BoN> existing <EoN> . <BoN> key <EoN> ] = <BoN> bind <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> key <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> names to values <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> existing <EoN> = <BoN> new params <EoN> [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Argument Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new params <EoN> [ <BoN> key <EoN> ] = <BoN> existing <EoN> . <BoN> with value <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> repr <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> shape info <EoN> = <STRING> . <BoN> join <EoN> ( [ <STRING> % <BoN> x <EoN> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> shape <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <STRING> % ( <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> , <NEWLINE> <BoN> shape info <EoN> , <BoN> self <EoN> . <BoN> context <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fractional max pool eager fallback <EoN> ( <BoN> value <EoN> , <BoN> pooling ratio <EoN> , <BoN> pseudo random <EoN> = <BoN> False <EoN> , <BoN> overlapping <EoN> = <BoN> False <EoN> , <BoN> deterministic <EoN> = <BoN> False <EoN> , <BoN> seed <EoN> = <NUMBER> , <BoN> seed 2 <EoN> = <NUMBER> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> pooling ratio <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> pooling ratio <EoN> ) <NEWLINE> <UNTAB> <BoN> pooling ratio <EoN> = [ <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> f <EoN> , <STRING> ) <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> pooling ratio <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> pseudo random <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> pseudo random <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> pseudo random <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> pseudo random <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> overlapping <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> overlapping <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> overlapping <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> overlapping <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> deterministic <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> deterministic <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> deterministic <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> deterministic <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> seed <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> seed <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> seed <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> seed 2 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed 2 <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> seed 2 <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> seed 2 <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> value <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> value <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> value <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> pooling ratio <EoN> , <STRING> , <BoN> pseudo random <EoN> , <NEWLINE> <STRING> , <BoN> overlapping <EoN> , <STRING> , <BoN> deterministic <EoN> , <STRING> , <BoN> seed <EoN> , <NEWLINE> <STRING> , <BoN> seed 2 <EoN> , <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> FractionalMaxPoolOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> bytes <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> config <EoN> <BoN> import <EoN> <BoN> get option <EoN> <NEWLINE> <NEWLINE> <BoN> encoding <EoN> = <BoN> get option <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> unicode <EoN> ( ) . <BoN> encode <EoN> ( <BoN> encoding <EoN> , <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> fake quant with min max args gradient <EoN> ( <BoN> gradients <EoN> , <BoN> inputs <EoN> , <BoN> min <EoN> = - <NUMBER> , <BoN> max <EoN> = <NUMBER> , <BoN> num bits <EoN> = <NUMBER> , <BoN> narrow range <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> gradients <EoN> , <BoN> inputs <EoN> , <STRING> , <BoN> min <EoN> , <STRING> , <NEWLINE> <BoN> max <EoN> , <STRING> , <BoN> num bits <EoN> , <STRING> , <BoN> narrow range <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fake quant with min max args gradient eager fallback <EoN> ( <NEWLINE> <BoN> gradients <EoN> , <BoN> inputs <EoN> , <BoN> min <EoN> = <BoN> min <EoN> , <BoN> max <EoN> = <BoN> max <EoN> , <BoN> num bits <EoN> = <BoN> num bits <EoN> , <NEWLINE> <BoN> narrow range <EoN> = <BoN> narrow range <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> fake quant with min max args gradient <EoN> , <BoN> gradients <EoN> = <BoN> gradients <EoN> , <NEWLINE> <BoN> inputs <EoN> = <BoN> inputs <EoN> , <BoN> min <EoN> = <BoN> min <EoN> , <NEWLINE> <BoN> max <EoN> = <BoN> max <EoN> , <NEWLINE> <BoN> num bits <EoN> = <BoN> num bits <EoN> , <NEWLINE> <BoN> narrow range <EoN> = <BoN> narrow range <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> min <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> min <EoN> = - <NUMBER> <NEWLINE> <UNTAB> <BoN> min <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> min <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> max <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> max <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> max <EoN> = <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> max <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> num bits <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> num bits <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> num bits <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> num bits <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> narrow range <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> narrow range <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> narrow range <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> narrow range <EoN> , <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> gradients <EoN> = <BoN> gradients <EoN> , <BoN> inputs <EoN> = <BoN> inputs <EoN> , <NEWLINE> <BoN> min <EoN> = <BoN> min <EoN> , <BoN> max <EoN> = <BoN> max <EoN> , <NEWLINE> <BoN> num bits <EoN> = <BoN> num bits <EoN> , <NEWLINE> <BoN> narrow range <EoN> = <BoN> narrow range <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> fake quant with min max args gradient <EoN> , <BoN> gradients <EoN> = <BoN> gradients <EoN> , <NEWLINE> <BoN> inputs <EoN> = <BoN> inputs <EoN> , <BoN> min <EoN> = <BoN> min <EoN> , <NEWLINE> <BoN> max <EoN> = <BoN> max <EoN> , <BoN> num bits <EoN> = <BoN> num bits <EoN> , <NEWLINE> <BoN> narrow range <EoN> = <BoN> narrow range <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <NEWLINE> <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add pruned saver <EoN> ( <BoN> base meta graph def <EoN> , <BoN> meta graph def <EoN> , <BoN> removed op names <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> base meta graph def <EoN> . <BoN> Has Field <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> filename tensor name <EoN> = <BoN> base meta graph def <EoN> . <BoN> saver def <EoN> . <BoN> filename tensor name <EoN> <NEWLINE> <BoN> save tensor name <EoN> = <BoN> base meta graph def <EoN> . <BoN> saver def <EoN> . <BoN> save tensor name <EoN> <NEWLINE> <BoN> restore op name <EoN> = <BoN> base meta graph def <EoN> . <BoN> saver def <EoN> . <BoN> restore op name <EoN> <NEWLINE> <NEWLINE> <BoN> check tensor not removed <EoN> ( <BoN> filename tensor name <EoN> , <BoN> removed op names <EoN> ) <NEWLINE> <BoN> check tensor not removed <EoN> ( <BoN> save tensor name <EoN> , <BoN> removed op names <EoN> ) <NEWLINE> <BoN> check tensor not removed <EoN> ( <BoN> restore op name <EoN> , <BoN> removed op names <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> meta graph def <EoN> . <BoN> saver def <EoN> . <BoN> Copy From <EoN> ( <BoN> base meta graph def <EoN> . <BoN> saver def <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> info repr <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> info repr option <EoN> = ( <BoN> get option <EoN> ( <STRING> ) == <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> info repr option <EoN> <BoN> and <EoN> <BoN> not <EoN> ( <BoN> self <EoN> . <BoN> repr fits horizontal <EoN> ( ) <BoN> and <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> repr fits vertical <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cluster spec <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> shouldResolve <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> full name <EoN> = <STRING> % ( <NEWLINE> <BoN> self <EoN> . <BoN> project <EoN> , <BoN> self <EoN> . <BoN> zone <EoN> , <BoN> compat <EoN> . <BoN> as text <EoN> ( <BoN> self <EoN> . <BoN> tpu <EoN> ) ) <NEWLINE> <BoN> service <EoN> = <BoN> self <EoN> . <BoN> tpuService <EoN> ( ) <NEWLINE> <BoN> request <EoN> = <BoN> service <EoN> . <BoN> projects <EoN> ( ) . <BoN> locations <EoN> ( ) . <BoN> nodes <EoN> ( ) . <BoN> get <EoN> ( <BoN> name <EoN> = <BoN> full name <EoN> ) <NEWLINE> <BoN> response <EoN> = <BoN> request <EoN> . <BoN> execute <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> response <EoN> <BoN> and <EoN> <BoN> response <EoN> [ <STRING> ] != <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> % <NEWLINE> ( <BoN> compat <EoN> . <BoN> as text <EoN> ( <BoN> self <EoN> . <BoN> tpu <EoN> ) , <BoN> response <EoN> [ <STRING> ] ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> response <EoN> <BoN> and <EoN> <BoN> response <EoN> [ <STRING> ] != <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> % <NEWLINE> ( <BoN> compat <EoN> . <BoN> as text <EoN> ( <BoN> self <EoN> . <BoN> tpu <EoN> ) , <BoN> response <EoN> [ <STRING> ] ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> response <EoN> : <NEWLINE> <TAB> <BoN> worker list <EoN> = [ <NEWLINE> <STRING> % ( <BoN> endpoint <EoN> [ <STRING> ] , <BoN> endpoint <EoN> [ <STRING> ] ) <NEWLINE> <BoN> for <EoN> <BoN> endpoint <EoN> <BoN> in <EoN> <BoN> response <EoN> [ <STRING> ] <NEWLINE> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> instance url <EoN> = <STRING> % ( <BoN> response <EoN> [ <STRING> ] , <BoN> response <EoN> [ <STRING> ] ) <NEWLINE> <BoN> worker list <EoN> = [ <BoN> instance url <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> cluster spec <EoN> = { <BoN> self <EoN> . <BoN> task type <EoN> : <BoN> worker list <EoN> } <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rpc layer <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> tpus <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> tpu <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> tpu <EoN> . <BoN> split <EoN> ( <BoN> ENDPOINTS SEPARATOR <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> self <EoN> . <BoN> rpc layer <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> tpu <EoN> . <BoN> startswith <EoN> ( <BoN> self <EoN> . <BoN> rpc layer <EoN> + <STRING> ) ) : <NEWLINE> <TAB> <BoN> tpus <EoN> . <BoN> append <EoN> ( <BoN> tpu <EoN> [ <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> rpc layer <EoN> + <STRING> ) : ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> tpus <EoN> . <BoN> append <EoN> ( <BoN> tpu <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> cluster spec <EoN> = { <BoN> self <EoN> . <BoN> task type <EoN> : <BoN> tpus <EoN> } <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> coordinator address <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> cluster spec <EoN> [ <BoN> self <EoN> . <BoN> coordinator name <EoN> ] = [ <BoN> self <EoN> . <BoN> coordinator address <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> server lib <EoN> . <BoN> Cluster Spec <EoN> ( <BoN> cluster spec <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample gamma <EoN> ( <BoN> alpha <EoN> = <BoN> None <EoN> , <BoN> beta <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> target <EoN> , <BoN> identifier <EoN> , <BoN> fn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> event key <EoN> ( <BoN> target <EoN> , <BoN> identifier <EoN> , <BoN> fn <EoN> ) . <BoN> contains <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on change input <EoN> ( <BoN> self <EoN> , <BoN> fgraph <EoN> , <BoN> app <EoN> , <BoN> i <EoN> , <BoN> old r <EoN> , <BoN> new r <EoN> , <BoN> reason <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> app <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> app <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> debug all apps <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Protocol Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> clients <EoN> [ <BoN> old r <EoN> ] [ <BoN> app <EoN> ] -= <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> clients <EoN> [ <BoN> old r <EoN> ] [ <BoN> app <EoN> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> self <EoN> . <BoN> clients <EoN> [ <BoN> old r <EoN> ] [ <BoN> app <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> clients <EoN> . <BoN> setdefault <EoN> ( <BoN> new r <EoN> , <BoN> Ordered Dict <EoN> ( ) ) . <BoN> setdefault <EoN> ( <BoN> app <EoN> , <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> clients <EoN> [ <BoN> new r <EoN> ] [ <BoN> app <EoN> ] += <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> o idx <EoN> , <BoN> i idx list <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> getattr <EoN> ( <BoN> app <EoN> . <BoN> op <EoN> , <STRING> , <NEWLINE> <BoN> Ordered Dict <EoN> ( ) ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> i idx list <EoN> ) > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <BoN> i idx <EoN> = <BoN> i idx list <EoN> [ <NUMBER> ] <NEWLINE> <BoN> output <EoN> = <BoN> app <EoN> . <BoN> outputs <EoN> [ <BoN> o idx <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> i idx <EoN> == <BoN> i <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> app <EoN> . <BoN> inputs <EoN> [ <BoN> i idx <EoN> ] <BoN> is <EoN> <BoN> not <EoN> <BoN> new r <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Protocol Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> view i <EoN> [ <BoN> output <EoN> ] = <BoN> new r <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> view o <EoN> [ <BoN> old r <EoN> ] . <BoN> remove <EoN> ( <BoN> output <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> view o <EoN> [ <BoN> old r <EoN> ] : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> self <EoN> . <BoN> view o <EoN> [ <BoN> old r <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> view o <EoN> . <BoN> setdefault <EoN> ( <BoN> new r <EoN> , <BoN> Ordered Set <EoN> ( ) ) . <BoN> add <EoN> ( <BoN> output <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> algo <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> app <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> fail validate <EoN> : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> self <EoN> . <BoN> fail validate <EoN> [ <BoN> app <EoN> ] <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> fast destroy <EoN> ( <BoN> app <EoN> , <BoN> reason <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> stale droot <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> isin <EoN> ( <BoN> self <EoN> , <BoN> values <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> values <EoN> , <BoN> type <EoN> ( <BoN> self <EoN> ) ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> type <EoN> ( <BoN> self <EoN> ) ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> astype <EoN> ( <BoN> object <EoN> ) . <BoN> isin <EoN> ( <BoN> values <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> algorithms <EoN> . <BoN> isin <EoN> ( <BoN> self <EoN> . <BoN> asi 8 <EoN> , <BoN> values <EoN> . <BoN> asi 8 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> expm 1 <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> expm 1 <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> mouseevent <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> callable <EoN> ( <BoN> self <EoN> . <BoN> contains <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> mouseevent <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> x <EoN> , <BoN> y <EoN> = <BoN> mouseevent <EoN> . <BoN> x <EoN> , <BoN> mouseevent <EoN> . <BoN> y <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> trans <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> trans Axes <EoN> . <BoN> inverted <EoN> ( ) <NEWLINE> <BoN> xaxes <EoN> , <BoN> yaxes <EoN> = <BoN> trans <EoN> . <BoN> transform point <EoN> ( ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> , { } <NEWLINE> <UNTAB> <BoN> l <EoN> , <BoN> b <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> trans Axes <EoN> . <BoN> transform point <EoN> ( ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <BoN> r <EoN> , <BoN> t <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> trans Axes <EoN> . <BoN> transform point <EoN> ( ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <BoN> inaxis <EoN> = <NUMBER> <= <BoN> xaxes <EoN> <= <NUMBER> <BoN> and <EoN> ( <NEWLINE> <BoN> b <EoN> - <BoN> self <EoN> . <BoN> pickradius <EoN> < <BoN> y <EoN> < <BoN> b <EoN> <BoN> or <EoN> <NEWLINE> <BoN> t <EoN> < <BoN> y <EoN> < <BoN> t <EoN> + <BoN> self <EoN> . <BoN> pickradius <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> inaxis <EoN> , { } <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> isspmatrix bsr <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> isinstance <EoN> ( <BoN> x <EoN> , <BoN> bsr matrix <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast lesser <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mkdirp <EoN> ( <BoN> d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> os <EoN> . <BoN> makedirs <EoN> ( <BoN> d <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> e <EoN> . <BoN> errno <EoN> != <BoN> errno <EoN> . <BoN> EEXIS T <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on units changed <EoN> ( <BoN> self <EoN> , <BoN> scalex <EoN> = <BoN> False <EoN> , <BoN> scaley <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> relim <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> autoscale view <EoN> ( <BoN> scalex <EoN> = <BoN> scalex <EoN> , <BoN> scaley <EoN> = <BoN> scaley <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> plus <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> putmask <EoN> ( <BoN> a <EoN> , <BoN> mask <EoN> , <BoN> values <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> a <EoN> , <BoN> Masked Array <EoN> ) : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> a <EoN> . <BoN> view <EoN> ( <BoN> Masked Array <EoN> ) <NEWLINE> <UNTAB> ( <BoN> valdata <EoN> , <BoN> valmask <EoN> ) = ( <BoN> getdata <EoN> ( <BoN> values <EoN> ) , <BoN> getmask <EoN> ( <BoN> values <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> getmask <EoN> ( <BoN> a <EoN> ) <BoN> is <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> valmask <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> . <BoN> sharedmask <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> a <EoN> . <BoN> mask <EoN> = <BoN> make mask none <EoN> ( <BoN> a <EoN> . <BoN> shape <EoN> , <BoN> a <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> np <EoN> . <BoN> copyto <EoN> ( <BoN> a <EoN> . <BoN> mask <EoN> , <BoN> valmask <EoN> , <BoN> where <EoN> = <BoN> mask <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> a <EoN> . <BoN> hardmask <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> valmask <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> a <EoN> . <BoN> mask <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> np <EoN> . <BoN> copyto <EoN> ( <BoN> m <EoN> , <BoN> valmask <EoN> , <BoN> where <EoN> = <BoN> mask <EoN> ) <NEWLINE> <BoN> a <EoN> . <BoN> mask <EoN> |= <BoN> m <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> valmask <EoN> <BoN> is <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> valmask <EoN> = <BoN> getmaskarray <EoN> ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <BoN> np <EoN> . <BoN> copyto <EoN> ( <BoN> a <EoN> . <BoN> mask <EoN> , <BoN> valmask <EoN> , <BoN> where <EoN> = <BoN> mask <EoN> ) <NEWLINE> <UNTAB> <BoN> np <EoN> . <BoN> copyto <EoN> ( <BoN> a <EoN> . <BoN> data <EoN> , <BoN> valdata <EoN> , <BoN> where <EoN> = <BoN> mask <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> restore <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create Font List <EoN> ( <BoN> fontfiles <EoN> , <BoN> fontext <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> fontlist <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> seen <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> fpath <EoN> <BoN> in <EoN> <BoN> fontfiles <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> debug <EoN> ( <STRING> , <BoN> fpath <EoN> ) <NEWLINE> <BoN> fname <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> split <EoN> ( <BoN> fpath <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> fname <EoN> <BoN> in <EoN> <BoN> seen <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> seen <EoN> . <BoN> add <EoN> ( <BoN> fname <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fontext <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> fpath <EoN> , <STRING> ) <BoN> as <EoN> <BoN> fh <EoN> : <NEWLINE> <TAB> <BoN> font <EoN> = <BoN> afm <EoN> . <BoN> AF M <EoN> ( <BoN> fh <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Environment Error <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> fpath <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Runtime Error <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> fpath <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> prop <EoN> = <BoN> afm Font Property <EoN> ( <BoN> fpath <EoN> , <BoN> font <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> font <EoN> = <BoN> ft 2 font <EoN> . <BoN> F T 2 Font <EoN> ( <BoN> fpath <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Runtime Error <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> fpath <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Unicode Error <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> fpath <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> prop <EoN> = <BoN> ttf Font Property <EoN> ( <BoN> font <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Key Error <EoN> , <BoN> Runtime Error <EoN> , <BoN> Value Error <EoN> , <BoN> Not Implemented Error <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> fontlist <EoN> . <BoN> append <EoN> ( <BoN> prop <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> fontlist <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shutdown <EoN> ( <BoN> self <EoN> , <BoN> wait <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> dumps <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> . <BoN> lower <EoN> ( ) , [ <BoN> x <EoN> . <BoN> dumps <EoN> ( ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> ts <EoN> ] ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate indexer <EoN> ( <BoN> self <EoN> , <BoN> form <EoN> , <BoN> key <EoN> , <BoN> kind <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> kind <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is integer <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> kind <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> invalid indexer <EoN> ( <BoN> form <EoN> , <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> key <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> create batch <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> features <EoN> = <BoN> self <EoN> . <BoN> reader <EoN> . <BoN> read full <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> ( { <BoN> feature name <EoN> : <BoN> feature value <EoN> [ <BoN> None <EoN> , ... ] <NEWLINE> <BoN> for <EoN> <BoN> feature name <EoN> , <BoN> feature value <EoN> <BoN> in <EoN> <BoN> features <EoN> . <BoN> items <EoN> ( ) } , <NEWLINE> <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cast inplace <EoN> ( <BoN> terms <EoN> , <BoN> acceptable dtypes <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dt <EoN> = <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> term <EoN> <BoN> in <EoN> <BoN> terms <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> term <EoN> . <BoN> type <EoN> <BoN> in <EoN> <BoN> acceptable dtypes <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> new value <EoN> = <BoN> term <EoN> . <BoN> value <EoN> . <BoN> astype <EoN> ( <BoN> dt <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> new value <EoN> = <BoN> dt <EoN> . <BoN> type <EoN> ( <BoN> term <EoN> . <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> term <EoN> . <BoN> update <EoN> ( <BoN> new value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> simple blockify <EoN> ( <BoN> tuples <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> values <EoN> , <BoN> placement <EoN> = <BoN> stack arrays <EoN> ( <BoN> tuples <EoN> , <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> values <EoN> . <BoN> dtype <EoN> != <BoN> dtype <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> values <EoN> . <BoN> astype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> block <EoN> = <BoN> make block <EoN> ( <BoN> values <EoN> , <BoN> placement <EoN> = <BoN> placement <EoN> ) <NEWLINE> <BoN> return <EoN> [ <BoN> block <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lagcompanion <EoN> ( <BoN> c <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> [ <BoN> c <EoN> ] = <BoN> pu <EoN> . <BoN> as series <EoN> ( [ <BoN> c <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> c <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> c <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array <EoN> ( [ [ <NUMBER> + <BoN> c <EoN> [ <NUMBER> ] / <BoN> c <EoN> [ <NUMBER> ] ] ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> c <EoN> ) - <NUMBER> <NEWLINE> <BoN> mat <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> c <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> top <EoN> = <BoN> mat <EoN> . <BoN> reshape <EoN> ( - <NUMBER> ) [ <NUMBER> : : <BoN> n <EoN> + <NUMBER> ] <NEWLINE> <BoN> mid <EoN> = <BoN> mat <EoN> . <BoN> reshape <EoN> ( - <NUMBER> ) [ <NUMBER> : : <BoN> n <EoN> + <NUMBER> ] <NEWLINE> <BoN> bot <EoN> = <BoN> mat <EoN> . <BoN> reshape <EoN> ( - <NUMBER> ) [ <BoN> n <EoN> : : <BoN> n <EoN> + <NUMBER> ] <NEWLINE> <BoN> top <EoN> [ ... ] = - <BoN> np <EoN> . <BoN> arange <EoN> ( <NUMBER> , <BoN> n <EoN> ) <NEWLINE> <BoN> mid <EoN> [ ... ] = <NUMBER> * <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> n <EoN> ) + <NUMBER> <NEWLINE> <BoN> bot <EoN> [ ... ] = <BoN> top <EoN> <NEWLINE> <BoN> mat <EoN> [ : , - <NUMBER> ] += ( <BoN> c <EoN> [ : - <NUMBER> ] / <BoN> c <EoN> [ - <NUMBER> ] ) * <BoN> n <EoN> <NEWLINE> <BoN> return <EoN> <BoN> mat <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make tensor descriptor array <EoN> ( <BoN> xs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> descs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> xs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> + ( <NUMBER> , ) * ( <NUMBER> - <BoN> x <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> . <BoN> reshape <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> desc <EoN> = <BoN> cudnn <EoN> . <BoN> create tensor nd descriptor <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> descs <EoN> . <BoN> append <EoN> ( <BoN> desc <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Pointer Array <EoN> ( [ <BoN> d <EoN> . <BoN> value <EoN> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> descs <EoN> ] , <BoN> descs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> glyph to path <EoN> ( <BoN> self <EoN> , <BoN> font <EoN> , <BoN> currx <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> verts <EoN> , <BoN> codes <EoN> = <BoN> font <EoN> . <BoN> get path <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> currx <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> verts <EoN> [ : , <NUMBER> ] += <BoN> currx <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> verts <EoN> , <BoN> codes <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> recv bytes <EoN> ( <BoN> self <EoN> , <BoN> maxlength <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> check closed <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> check readable <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> maxlength <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> maxlength <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> buf <EoN> = <BoN> self <EoN> . <BoN> recv bytes <EoN> ( <BoN> maxlength <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> buf <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> bad message length <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> buf <EoN> . <BoN> getvalue <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> matrix conv <EoN> ( <BoN> self <EoN> , <BoN> m 1 <EoN> , <BoN> m 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> n <EoN> = ( <BoN> m 1 <EoN> [ <NUMBER> , <NUMBER> , <NUMBER> ] ) . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> != ( <BoN> m 2 <EoN> [ <NUMBER> , <NUMBER> , <NUMBER> ] ) . <BoN> shape <EoN> . <BoN> as list <EoN> ( ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> cbrt <EoN> ( <BoN> len <EoN> ( <BoN> m 1 <EoN> ) ) ) <NEWLINE> <BoN> l <EoN> = <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> cbrt <EoN> ( <BoN> len <EoN> ( <BoN> m 2 <EoN> ) ) ) <NEWLINE> <BoN> result <EoN> = { } <NEWLINE> <BoN> size <EoN> = <BoN> k <EoN> + <BoN> l <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> size <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> size <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> r <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> size <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> , <BoN> r <EoN> ] = <BoN> array ops <EoN> . <BoN> zeros <EoN> ( [ <BoN> n <EoN> , <BoN> n <EoN> ] , <BoN> self <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> index 1 <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> min <EoN> ( <BoN> k <EoN> , <BoN> i <EoN> + <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> index 2 <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> min <EoN> ( <BoN> k <EoN> , <BoN> j <EoN> + <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> index 3 <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> min <EoN> ( <BoN> k <EoN> , <BoN> r <EoN> + <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> i <EoN> - <BoN> index 1 <EoN> ) < <BoN> l <EoN> <BoN> and <EoN> ( <BoN> j <EoN> - <BoN> index 2 <EoN> ) < <BoN> l <EoN> <BoN> and <EoN> ( <BoN> r <EoN> - <BoN> index 3 <EoN> ) < <BoN> l <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> , <BoN> r <EoN> ] += <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> m 1 <EoN> [ <BoN> index 1 <EoN> , <BoN> index 2 <EoN> , <BoN> index 3 <EoN> ] , <NEWLINE> <BoN> m 2 <EoN> [ <BoN> i <EoN> - <BoN> index 1 <EoN> , <BoN> j <EoN> - <BoN> index 2 <EoN> , <NEWLINE> <BoN> r <EoN> - <BoN> index 3 <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverse <EoN> ( <BoN> self <EoN> , <BoN> argindex <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> acoth <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get dashdirection <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dashdirection <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random uniform <EoN> ( <BoN> shape <EoN> , <BoN> minval <EoN> = <NUMBER> , <BoN> maxval <EoN> = <NUMBER> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> floatx <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> seed <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed <EoN> = <BoN> np <EoN> . <BoN> random <EoN> . <BoN> randint <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> random uniform <EoN> ( <BoN> shape <EoN> , <BoN> minval <EoN> = <BoN> minval <EoN> , <BoN> maxval <EoN> = <BoN> maxval <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> is jpeg <EoN> ( <BoN> contents <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> substr <EoN> = <BoN> string ops <EoN> . <BoN> substr <EoN> ( <BoN> contents <EoN> , <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> equal <EoN> ( <BoN> substr <EoN> , <STRING> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> contextlib <EoN> . <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> constrain devices and set default <EoN> ( <BoN> self <EoN> , <BoN> sess <EoN> , <BoN> use gpu <EoN> , <BoN> force gpu <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> sess <EoN> . <BoN> graph <EoN> . <BoN> as default <EoN> ( ) , <BoN> sess <EoN> . <BoN> as default <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> force gpu <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> gpu name <EoN> = <BoN> gpu device name <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> gpu name <EoN> : <NEWLINE> <TAB> <BoN> gpu name <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> sess <EoN> . <BoN> graph <EoN> . <BoN> device <EoN> ( <BoN> gpu name <EoN> ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> sess <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> use gpu <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> sess <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> sess <EoN> . <BoN> graph <EoN> . <BoN> device <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> sess <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sequences to matrix <EoN> ( <BoN> self <EoN> , <BoN> sequences <EoN> , <BoN> mode <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> num words <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> word index <EoN> : <NEWLINE> <TAB> <BoN> num words <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> word index <EoN> ) + <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> num words <EoN> = <BoN> self <EoN> . <BoN> num words <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mode <EoN> == <STRING> <BoN> and <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> document count <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> len <EoN> ( <BoN> sequences <EoN> ) , <BoN> num words <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> seq <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> sequences <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> seq <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> counts <EoN> = <BoN> defaultdict <EoN> ( <BoN> int <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> seq <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> j <EoN> >= <BoN> num words <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> counts <EoN> [ <BoN> j <EoN> ] += <NUMBER> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> j <EoN> , <BoN> c <EoN> <BoN> in <EoN> <BoN> list <EoN> ( <BoN> counts <EoN> . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> x <EoN> [ <BoN> i <EoN> ] [ <BoN> j <EoN> ] = <BoN> c <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> x <EoN> [ <BoN> i <EoN> ] [ <BoN> j <EoN> ] = <BoN> c <EoN> / <BoN> len <EoN> ( <BoN> seq <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> x <EoN> [ <BoN> i <EoN> ] [ <BoN> j <EoN> ] = <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> tf <EoN> = <NUMBER> + <BoN> np <EoN> . <BoN> log <EoN> ( <BoN> c <EoN> ) <NEWLINE> <BoN> idf <EoN> = <BoN> np <EoN> . <BoN> log <EoN> ( <NUMBER> + <BoN> self <EoN> . <BoN> document count <EoN> / <NEWLINE> ( <NUMBER> + <BoN> self <EoN> . <BoN> index docs <EoN> . <BoN> get <EoN> ( <BoN> j <EoN> , <NUMBER> ) ) ) <NEWLINE> <BoN> x <EoN> [ <BoN> i <EoN> ] [ <BoN> j <EoN> ] = <BoN> tf <EoN> * <BoN> idf <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> , <BoN> mode <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> softplus <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> nn <EoN> . <BoN> softplus <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get func name <EoN> ( <BoN> func <EoN> , <BoN> resolv alias <EoN> = <BoN> True <EoN> , <BoN> win characters <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> module <EoN> = <BoN> func <EoN> . <BoN> module <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> = <BoN> inspect <EoN> . <BoN> getmodule <EoN> ( <BoN> func <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> module <EoN> = <BoN> func <EoN> . <BoN> class <EoN> . <BoN> module <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> module <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> module <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> module <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> abspath <EoN> ( <BoN> inspect <EoN> . <BoN> getsourcefile <EoN> ( <BoN> func <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> filename <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> parts <EoN> = <BoN> filename <EoN> . <BoN> split <EoN> ( <BoN> os <EoN> . <BoN> sep <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> parts <EoN> [ - <NUMBER> ] . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> parts <EoN> [ - <NUMBER> ] = <STRING> <NEWLINE> <UNTAB> <BoN> filename <EoN> = <STRING> . <BoN> join <EoN> ( <BoN> parts <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> filename <EoN> . <BoN> endswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> filename <EoN> [ : - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> module <EoN> = <BoN> module <EoN> + <STRING> + <BoN> filename <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> module <EoN> = <BoN> module <EoN> . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> func <EoN> . <BoN> func name <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> func <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> resolv alias <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) <BoN> and <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> func <EoN> . <BoN> func globals <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> func <EoN> . <BoN> func globals <EoN> [ <BoN> name <EoN> ] <BoN> is <EoN> <BoN> func <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> % <BoN> name <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> inspect <EoN> . <BoN> ismethod <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> func <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> klass <EoN> = <BoN> func <EoN> . <BoN> im class <EoN> <NEWLINE> <BoN> module <EoN> . <BoN> append <EoN> ( <BoN> klass <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> os <EoN> . <BoN> name <EoN> == <STRING> <BoN> and <EoN> <BoN> win characters <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> clean win chars <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> module <EoN> = [ <BoN> clean win chars <EoN> ( <BoN> s <EoN> ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> module <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> module <EoN> , <BoN> name <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> cacheit <EoN> <NEWLINE> <BoN> def <EoN> <BoN> as leading term <EoN> ( <BoN> self <EoN> , * <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> powsimp <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> symbols <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> c <EoN> . <BoN> as leading term <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> sympify <EoN> ( <BoN> symbols <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> x <EoN> . <BoN> is symbol <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> obj <EoN> = <BoN> self <EoN> . <BoN> eval as leading term <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> obj <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> powsimp <EoN> ( <BoN> obj <EoN> , <BoN> deep <EoN> = <BoN> True <EoN> , <BoN> combine <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> % ( <BoN> self <EoN> , <BoN> x <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> inplace swap column <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> m <EoN> += <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> n <EoN> += <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> X <EoN> , <BoN> sp <EoN> . <BoN> csc matrix <EoN> ) : <NEWLINE> <TAB> <BoN> inplace swap row csr <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> X <EoN> , <BoN> sp <EoN> . <BoN> csr matrix <EoN> ) : <NEWLINE> <TAB> <BoN> inplace swap row csc <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise typeerror <EoN> ( <BoN> X <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> generic signature fn <EoN> ( <BoN> examples <EoN> , <BoN> unused features <EoN> , <BoN> predictions <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> examples <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> tensors <EoN> = { <STRING> : <BoN> examples <EoN> } <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> predictions <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> predictions <EoN> = { <STRING> : <BoN> predictions <EoN> } <NEWLINE> <UNTAB> <BoN> tensors <EoN> . <BoN> update <EoN> ( <BoN> predictions <EoN> ) <NEWLINE> <BoN> default signature <EoN> = <BoN> exporter <EoN> . <BoN> generic signature <EoN> ( <BoN> tensors <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> default signature <EoN> , { } <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> no automatic dependency tracking <EoN> <NEWLINE> <BoN> def <EoN> <BoN> maybe initialize checkpointable <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> unconditional checkpoint dependencies <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> unconditional dependency names <EoN> = { } <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> unconditional deferred dependencies <EoN> = { } <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> update uid <EoN> = - <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> name based restores <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get nd basic indexing <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> shape <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> integer types <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> > <BoN> shape <EoN> [ <NUMBER> ] - <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> key <EoN> , <BoN> shape <EoN> [ <NUMBER> ] ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> at <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> py slice <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> . <BoN> step <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> key <EoN> . <BoN> step <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> . <BoN> step <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> op <EoN> . <BoN> slice <EoN> ( <BoN> self <EoN> , <BoN> begin <EoN> = ( <BoN> key <EoN> . <BoN> start <EoN> , ) , <BoN> end <EoN> = ( <BoN> key <EoN> . <BoN> stop <EoN> , ) , <BoN> step <EoN> = ( <BoN> key <EoN> . <BoN> step <EoN> , ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> key <EoN> . <BoN> start <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> key <EoN> . <BoN> stop <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> slice <EoN> ( <BoN> key <EoN> . <BoN> start <EoN> , <BoN> key <EoN> . <BoN> stop <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> str <EoN> ( <BoN> key <EoN> ) , <BoN> str <EoN> ( <BoN> type <EoN> ( <BoN> key <EoN> ) ) ) ) <NEWLINE> <UNTAB> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> key <EoN> ) != <NUMBER> , <STRING> <NEWLINE> <BoN> begin <EoN> = [ ] <NEWLINE> <BoN> end <EoN> = [ ] <NEWLINE> <BoN> step <EoN> = [ ] <NEWLINE> <BoN> kept axes <EoN> = [ ] <NEWLINE> <BoN> i <EoN> = - <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> slice i <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> slice i <EoN> , <BoN> integer types <EoN> ) : <NEWLINE> <TAB> <BoN> begin <EoN> . <BoN> append <EoN> ( <BoN> slice i <EoN> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <BoN> slice i <EoN> + <NUMBER> <BoN> if <EoN> <BoN> slice i <EoN> != - <NUMBER> <BoN> else <EoN> <BoN> self <EoN> . <BoN> shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <BoN> step <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> slice i <EoN> , <BoN> py slice <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> slice i <EoN> . <BoN> step <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> % ( <BoN> str <EoN> ( <BoN> key <EoN> ) , <BoN> str <EoN> ( <BoN> slice i <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> begin <EoN> . <BoN> append <EoN> ( <BoN> slice i <EoN> . <BoN> start <EoN> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <BoN> slice i <EoN> . <BoN> stop <EoN> ) <NEWLINE> <BoN> step <EoN> . <BoN> append <EoN> ( <BoN> slice i <EoN> . <BoN> step <EoN> ) <NEWLINE> <BoN> kept axes <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % ( <BoN> str <EoN> ( <BoN> slice i <EoN> ) , <BoN> str <EoN> ( <BoN> type <EoN> ( <BoN> slice i <EoN> ) ) ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> kept axes <EoN> . <BoN> extend <EoN> ( <BoN> range <EoN> ( <BoN> i <EoN> + <NUMBER> , <BoN> len <EoN> ( <BoN> shape <EoN> ) ) ) <NEWLINE> <BoN> sliced nd <EoN> = <BoN> op <EoN> . <BoN> slice <EoN> ( <BoN> self <EoN> , <BoN> begin <EoN> , <BoN> end <EoN> , <BoN> step <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> kept axes <EoN> ) == <BoN> len <EoN> ( <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sliced nd <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> oshape <EoN> = [ ] <NEWLINE> <BoN> sliced shape <EoN> = <BoN> sliced nd <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> for <EoN> <BoN> axis <EoN> <BoN> in <EoN> <BoN> kept axes <EoN> : <NEWLINE> <TAB> <BoN> oshape <EoN> . <BoN> append <EoN> ( <BoN> sliced shape <EoN> [ <BoN> axis <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> oshape <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> oshape <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> oshape <EoN> = <BoN> tuple <EoN> ( <BoN> oshape <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> oshape <EoN> ) == <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> sliced shape <EoN> ) , <STRING> <STRING> % ( <BoN> oshape <EoN> , <BoN> sliced shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> sliced nd <EoN> . <BoN> reshape <EoN> ( <BoN> oshape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> old poly ring <EoN> ( <BoN> self <EoN> , * <BoN> symbols <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> polys <EoN> . <BoN> domains <EoN> . <BoN> old polynomialring <EoN> <BoN> import <EoN> <BoN> Polynomial Ring <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Polynomial Ring <EoN> ( <BoN> self <EoN> , * <BoN> symbols <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> iterterms <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> iter <EoN> ( <BoN> self <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get registered canvas class <EoN> ( <BoN> format <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> format <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> default backends <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> backend class <EoN> = <BoN> default backends <EoN> [ <BoN> format <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> backend class <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> backend class <EoN> = <BoN> importlib <EoN> . <BoN> import module <EoN> ( <BoN> backend class <EoN> ) . <BoN> Figure Canvas <EoN> <NEWLINE> <BoN> default backends <EoN> [ <BoN> format <EoN> ] = <BoN> backend class <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> backend class <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> set env var <EoN> ( <BoN> key <EoN> , <BoN> val <EoN> , <BoN> default val <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> prev val <EoN> = <BoN> os <EoN> . <BoN> environ <EoN> . <BoN> get <EoN> ( <BoN> key <EoN> , <BoN> default val <EoN> ) <NEWLINE> <BoN> os <EoN> . <BoN> environ <EoN> [ <BoN> key <EoN> ] = <BoN> val <EoN> <NEWLINE> <BoN> return <EoN> <BoN> prev val <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> quadts <EoN> ( <BoN> ctx <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <STRING> <NEWLINE> <BoN> return <EoN> <BoN> ctx <EoN> . <BoN> quad <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> build doc <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> com <EoN> . <BoN> Abstract Method Error <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get pixel distance along axis <EoN> ( <BoN> self <EoN> , <BoN> where <EoN> , <BoN> perturb <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> trans <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> trans Data <EoN> <NEWLINE> <NEWLINE> <BoN> transinv <EoN> = <BoN> trans <EoN> . <BoN> inverted <EoN> ( ) <NEWLINE> <BoN> pix <EoN> = <BoN> trans <EoN> . <BoN> transform point <EoN> ( ( <BoN> where <EoN> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> ptp <EoN> = <BoN> transinv <EoN> . <BoN> transform point <EoN> ( ( <BoN> pix <EoN> [ <NUMBER> ] + <BoN> perturb <EoN> , <BoN> pix <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> dx <EoN> = <BoN> abs <EoN> ( <BoN> ptp <EoN> [ <NUMBER> ] - <BoN> where <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dx <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> has <EoN> ( <BoN> self <EoN> , * <BoN> patterns <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval has <EoN> ( * <BoN> patterns <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> evaluate <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is aligned <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> result type <EoN> , <BoN> self <EoN> . <BoN> aligned axes <EoN> = <BoN> align <EoN> ( <BoN> self <EoN> . <BoN> expr <EoN> . <BoN> terms <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> res <EoN> = <BoN> self <EoN> . <BoN> evaluate <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> reconstruct object <EoN> ( <BoN> self <EoN> . <BoN> result type <EoN> , <BoN> res <EoN> , <BoN> self <EoN> . <BoN> aligned axes <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> expr <EoN> . <BoN> terms <EoN> . <BoN> return type <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> suitable edge <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> nodes <EoN> = <BoN> iter <EoN> ( <BoN> self <EoN> . <BoN> remaining degree <EoN> ) <NEWLINE> <BoN> u <EoN> = <BoN> next <EoN> ( <BoN> nodes <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> any <EoN> ( <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> graph <EoN> [ <BoN> u <EoN> ] <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> nodes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> exponents <EoN> ( <BoN> expr <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> exponents <EoN> ( <BoN> expr <EoN> , <BoN> x <EoN> , <BoN> res <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expr <EoN> == <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> . <BoN> update <EoN> ( [ <NUMBER> ] ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> expr <EoN> . <BoN> is Pow <EoN> <BoN> and <EoN> <BoN> expr <EoN> . <BoN> base <EoN> == <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> . <BoN> update <EoN> ( [ <BoN> expr <EoN> . <BoN> exp <EoN> ] ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> expr <EoN> . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> exponents <EoN> ( <BoN> arg <EoN> , <BoN> x <EoN> , <BoN> res <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> res <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> exponents <EoN> ( <BoN> expr <EoN> , <BoN> x <EoN> , <BoN> res <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> render <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> font output <EoN> . <BoN> render glyph <EoN> ( <NEWLINE> <BoN> x <EoN> - <BoN> self <EoN> . <BoN> metrics <EoN> . <BoN> xmin <EoN> , <BoN> y <EoN> + <BoN> self <EoN> . <BoN> metrics <EoN> . <BoN> ymin <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> font <EoN> , <BoN> self <EoN> . <BoN> font class <EoN> , <BoN> self <EoN> . <BoN> c <EoN> , <BoN> self <EoN> . <BoN> fontsize <EoN> , <BoN> self <EoN> . <BoN> dpi <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> crop <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> begin <EoN> = <BoN> Null <EoN> , <BoN> end <EoN> = <BoN> Null <EoN> , <BoN> step <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> register kl <EoN> ( <BoN> Dist 1 <EoN> , <BoN> Dist 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> f <EoN> ( <BoN> kl <EoN> ) : <NEWLINE> <TAB> <BoN> KLDIVERGENCE <EoN> [ <BoN> Dist 1 <EoN> , <BoN> Dist 2 <EoN> ] = <BoN> kl <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sequence categorical column with vocabulary file <EoN> ( <NEWLINE> <BoN> key <EoN> , <BoN> vocabulary file <EoN> , <BoN> vocabulary size <EoN> = <BoN> None <EoN> , <BoN> num oov buckets <EoN> = <NUMBER> , <NEWLINE> <BoN> default value <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> string <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> fc <EoN> . <BoN> SequenceCategoricalColumn <EoN> ( <NEWLINE> <BoN> fc <EoN> . <BoN> categorical column with vocabulary file <EoN> ( <NEWLINE> <BoN> key <EoN> = <BoN> key <EoN> , <NEWLINE> <BoN> vocabulary file <EoN> = <BoN> vocabulary file <EoN> , <NEWLINE> <BoN> vocabulary size <EoN> = <BoN> vocabulary size <EoN> , <NEWLINE> <BoN> num oov buckets <EoN> = <BoN> num oov buckets <EoN> , <NEWLINE> <BoN> default value <EoN> = <BoN> default value <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtype <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> map diag <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> square grid <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> diag axes <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> diag axes <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> var <EoN> , <BoN> ax <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> x vars <EoN> , <NEWLINE> <BoN> np <EoN> . <BoN> diag <EoN> ( <BoN> self <EoN> . <BoN> axes <EoN> ) ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> diag sharey <EoN> : <NEWLINE> <TAB> <BoN> diag ax <EoN> = <BoN> ax <EoN> . <BoN> make twin axes <EoN> ( <BoN> sharex <EoN> = <BoN> ax <EoN> , <NEWLINE> <BoN> sharey <EoN> = <BoN> diag axes <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> frameon <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> diag ax <EoN> = <BoN> ax <EoN> . <BoN> make twin axes <EoN> ( <BoN> sharex <EoN> = <BoN> ax <EoN> , <BoN> frameon <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> diag ax <EoN> . <BoN> set axis off <EoN> ( ) <NEWLINE> <BoN> diag axes <EoN> . <BoN> append <EoN> ( <BoN> diag ax <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> diag axes <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> diag axes <EoN> , <BoN> np <EoN> . <BoN> object <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> fixed color <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> var <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> x vars <EoN> ) : <NEWLINE> <TAB> <BoN> ax <EoN> = <BoN> self <EoN> . <BoN> diag axes <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> hue grouped <EoN> = <BoN> self <EoN> . <BoN> data <EoN> [ <BoN> var <EoN> ] . <BoN> groupby <EoN> ( <BoN> self <EoN> . <BoN> hue vals <EoN> ) <NEWLINE> <NEWLINE> <BoN> plt <EoN> . <BoN> sca <EoN> ( <BoN> ax <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> label k <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> hue names <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> data k <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> hue grouped <EoN> . <BoN> get group <EoN> ( <BoN> label k <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> data k <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fixed color <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> color <EoN> = <BoN> self <EoN> . <BoN> palette <EoN> [ <BoN> k <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> color <EoN> = <BoN> fixed color <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> func <EoN> ( <BoN> data k <EoN> , <BoN> label <EoN> = <BoN> label k <EoN> , <BoN> color <EoN> = <BoN> color <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> clean axis <EoN> ( <BoN> ax <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> add axis labels <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add edges from <EoN> ( <BoN> self <EoN> , <BoN> ebunch to add <EoN> , ** <BoN> attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> keylist <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> ebunch to add <EoN> : <NEWLINE> <TAB> <BoN> ne <EoN> = <BoN> len <EoN> ( <BoN> e <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ne <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> key <EoN> , <BoN> dd <EoN> = <BoN> e <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ne <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> dd <EoN> = <BoN> e <EoN> <NEWLINE> <BoN> key <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ne <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> u <EoN> , <BoN> v <EoN> = <BoN> e <EoN> <NEWLINE> <BoN> dd <EoN> = { } <NEWLINE> <BoN> key <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Network X Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> e <EoN> ) ) <NEWLINE> <UNTAB> <BoN> ddd <EoN> = { } <NEWLINE> <BoN> ddd <EoN> . <BoN> update <EoN> ( <BoN> attr <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> ddd <EoN> . <BoN> update <EoN> ( <BoN> dd <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ne <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> key <EoN> = <BoN> dd <EoN> <NEWLINE> <UNTAB> <BoN> key <EoN> = <BoN> self <EoN> . <BoN> add edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> key <EoN> ) <NEWLINE> <BoN> self <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] [ <BoN> key <EoN> ] . <BoN> update <EoN> ( <BoN> ddd <EoN> ) <NEWLINE> <BoN> keylist <EoN> . <BoN> append <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> keylist <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to indices <EoN> ( <BoN> self <EoN> , <BoN> tokens <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> to reduce <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> tokens <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> tokens <EoN> = [ <BoN> tokens <EoN> ] <NEWLINE> <BoN> to reduce <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> indices <EoN> = [ <BoN> self <EoN> . <BoN> token to idx <EoN> [ <BoN> token <EoN> ] <BoN> if <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> token to idx <EoN> <NEWLINE> <BoN> else <EoN> <BoN> C <EoN> . <BoN> UNKNOWN IDX <EoN> <BoN> for <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> tokens <EoN> ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> indices <EoN> [ <NUMBER> ] <BoN> if <EoN> <BoN> to reduce <EoN> <BoN> else <EoN> <BoN> indices <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> element <EoN> , * <BoN> order by <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> element <EoN> = <BoN> element <EoN> <NEWLINE> <BoN> if <EoN> <BoN> order by <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> order by <EoN> = <BoN> Clause List <EoN> ( <NEWLINE> * <BoN> util <EoN> . <BoN> to list <EoN> ( <BoN> order by <EoN> ) , <NEWLINE> <BoN> literal as text <EoN> = <BoN> literal as label reference <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> spin <EoN> ( <BoN> self <EoN> , <BoN> angle <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> rot <EoN> += <BoN> angle <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> profile graph <EoN> ( <BoN> self <EoN> , <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> opts <EoN> = <BoN> build options <EoN> ( <BoN> options <EoN> ) <NEWLINE> <BoN> tfprof node <EoN> = <BoN> tfprof output pb 2 <EoN> . <BoN> Graph Node Proto <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> tfprof node <EoN> . <BoN> Parse From String <EoN> ( <NEWLINE> <BoN> print mdl <EoN> . <BoN> Profile <EoN> ( <STRING> . <BoN> encode <EoN> ( <STRING> ) , <BoN> opts <EoN> . <BoN> Serialize To String <EoN> ( ) ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> message <EoN> . <BoN> Decode Error <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> sys <EoN> . <BoN> stderr <EoN> . <BoN> write <EoN> ( <STRING> % <BoN> e <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tfprof node <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to embed <EoN> ( <BoN> self <EoN> , <BoN> keep tz <EoN> = <BoN> False <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> astype <EoN> ( <BoN> dtype <EoN> ) . <BoN> to embed <EoN> ( <BoN> keep tz <EoN> = <BoN> keep tz <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> keep tz <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> tz <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> copy <EoN> ( <BoN> deep <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> add arg scope <EoN> <NEWLINE> <BoN> def <EoN> <BoN> flatten <EoN> ( <BoN> inputs <EoN> , <BoN> outputs collections <EoN> = <BoN> None <EoN> , <BoN> scope <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> scope <EoN> , <STRING> , [ <BoN> inputs <EoN> ] ) <BoN> as <EoN> <BoN> sc <EoN> : <NEWLINE> <TAB> <BoN> inputs <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> inputs <EoN> ) <NEWLINE> <BoN> outputs <EoN> = <BoN> core layers <EoN> . <BoN> flatten <EoN> ( <BoN> inputs <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> utils <EoN> . <BoN> collect named outputs <EoN> ( <BoN> outputs collections <EoN> , <BoN> sc <EoN> , <BoN> outputs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> calculate dendrogram <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> hierarchy <EoN> . <BoN> dendrogram <EoN> ( <BoN> self <EoN> . <BoN> linkage <EoN> , <BoN> no plot <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> color threshold <EoN> = - <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> touch <EoN> ( <BoN> self <EoN> , <BoN> mode <EoN> = <NUMBER> , <BoN> exist ok <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> raise closed <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> exist ok <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> accessor <EoN> . <BoN> utime <EoN> ( <BoN> self <EoN> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> flags <EoN> = <BoN> os <EoN> . <BoN> O CREAT <EoN> | <BoN> os <EoN> . <BoN> O WRONLY <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> exist ok <EoN> : <NEWLINE> <TAB> <BoN> flags <EoN> |= <BoN> os <EoN> . <BoN> O EXCL <EoN> <NEWLINE> <UNTAB> <BoN> fd <EoN> = <BoN> self <EoN> . <BoN> raw open <EoN> ( <BoN> flags <EoN> , <BoN> mode <EoN> ) <NEWLINE> <BoN> os <EoN> . <BoN> close <EoN> ( <BoN> fd <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is dtype equal <EoN> ( <BoN> source <EoN> , <BoN> target <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> source <EoN> = <BoN> get dtype <EoN> ( <BoN> source <EoN> ) <NEWLINE> <BoN> target <EoN> = <BoN> get dtype <EoN> ( <BoN> target <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> source <EoN> == <BoN> target <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Attribute Error <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sparse segment sum <EoN> ( <BoN> data <EoN> , <BoN> indices <EoN> , <BoN> segment ids <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> data <EoN> , <NEWLINE> <BoN> indices <EoN> , <BoN> segment ids <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sparse segment sum eager fallback <EoN> ( <NEWLINE> <BoN> data <EoN> , <BoN> indices <EoN> , <BoN> segment ids <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> data <EoN> = <BoN> data <EoN> , <BoN> indices <EoN> = <BoN> indices <EoN> , <NEWLINE> <BoN> segment ids <EoN> = <BoN> segment ids <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Sparse Embedding <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> input dim <EoN> = <BoN> Null <EoN> , <BoN> output dim <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> sparse grad <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> inplace swap row <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> X <EoN> , <BoN> sp <EoN> . <BoN> csc matrix <EoN> ) : <NEWLINE> <TAB> <BoN> inplace swap row csc <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> X <EoN> , <BoN> sp <EoN> . <BoN> csr matrix <EoN> ) : <NEWLINE> <TAB> <BoN> inplace swap row csr <EoN> ( <BoN> X <EoN> , <BoN> m <EoN> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise typeerror <EoN> ( <BoN> X <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lexicographical topological sort <EoN> ( <BoN> G <EoN> , <BoN> key <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> def <EoN> <BoN> key <EoN> ( <BoN> x <EoN> ) : <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> create tuple <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> key <EoN> ( <BoN> node <EoN> ) , <BoN> node <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> indegree map <EoN> = { <BoN> v <EoN> : <BoN> d <EoN> <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> in degree <EoN> ( ) <BoN> if <EoN> <BoN> d <EoN> > <NUMBER> } <NEWLINE> <NEWLINE> <BoN> zero indegree <EoN> = [ <BoN> create tuple <EoN> ( <BoN> v <EoN> ) <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> in degree <EoN> ( ) <BoN> if <EoN> <BoN> d <EoN> == <NUMBER> ] <NEWLINE> <BoN> heapq <EoN> . <BoN> heapify <EoN> ( <BoN> zero indegree <EoN> ) <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> zero indegree <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> node <EoN> = <BoN> heapq <EoN> . <BoN> heappop <EoN> ( <BoN> zero indegree <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> node <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> <EoN> , <BoN> child <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> edges <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> indegree map <EoN> [ <BoN> child <EoN> ] -= <NUMBER> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> indegree map <EoN> [ <BoN> child <EoN> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> heapq <EoN> . <BoN> heappush <EoN> ( <BoN> zero indegree <EoN> , <BoN> create tuple <EoN> ( <BoN> child <EoN> ) ) <NEWLINE> <BoN> del <EoN> <BoN> indegree map <EoN> [ <BoN> child <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> yield <EoN> <BoN> node <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> indegree map <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Unfeasible <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get data <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> ndarray <EoN> . <BoN> view <EoN> ( <BoN> self <EoN> , <BoN> self <EoN> . <BoN> baseclass <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> time series reader <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> reader <EoN> = <BoN> time series reader <EoN> <NEWLINE> <BoN> super <EoN> ( <BoN> Whole Dataset Input Fn <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> equals <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> ABC Index Class <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> type <EoN> ( <BoN> self <EoN> ) ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> type <EoN> ( <BoN> self <EoN> ) ( <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> is dtype equal <EoN> ( <BoN> self <EoN> . <BoN> dtype <EoN> , <BoN> other <EoN> . <BoN> dtype <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> , <BoN> ABC Period Index <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> ABC Period Index <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> freq <EoN> != <BoN> other <EoN> . <BoN> freq <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array equal <EoN> ( <BoN> self <EoN> . <BoN> asi 8 <EoN> , <BoN> other <EoN> . <BoN> asi 8 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> edges from line <EoN> ( <BoN> geom <EoN> , <BoN> attrs <EoN> , <BoN> simplify <EoN> = <BoN> True <EoN> , <BoN> geom attrs <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> osgeo <EoN> <BoN> import <EoN> <BoN> ogr <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> geom <EoN> . <BoN> Get Geometry Type <EoN> ( ) == <BoN> ogr <EoN> . <BoN> wkb Line String <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> simplify <EoN> : <NEWLINE> <TAB> <BoN> edge attrs <EoN> = <BoN> attrs <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> last <EoN> = <BoN> geom <EoN> . <BoN> Get Point Count <EoN> ( ) - <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> geom attrs <EoN> : <NEWLINE> <TAB> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> geom <EoN> . <BoN> Export To Wkb <EoN> ( ) <NEWLINE> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> geom <EoN> . <BoN> Export To Wkt <EoN> ( ) <NEWLINE> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> geom <EoN> . <BoN> Export To Json <EoN> ( ) <NEWLINE> <UNTAB> <BoN> yield <EoN> ( <BoN> geom <EoN> . <BoN> GetPoint 2 D <EoN> ( <NUMBER> ) , <BoN> geom <EoN> . <BoN> GetPoint 2 D <EoN> ( <BoN> last <EoN> ) , <BoN> edge attrs <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> geom <EoN> . <BoN> Get Point Count <EoN> ( ) - <NUMBER> ) : <NEWLINE> <TAB> <BoN> pt 1 <EoN> = <BoN> geom <EoN> . <BoN> GetPoint 2 D <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> pt 2 <EoN> = <BoN> geom <EoN> . <BoN> GetPoint 2 D <EoN> ( <BoN> i <EoN> + <NUMBER> ) <NEWLINE> <BoN> edge attrs <EoN> = <BoN> attrs <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> geom attrs <EoN> : <NEWLINE> <TAB> <BoN> segment <EoN> = <BoN> ogr <EoN> . <BoN> Geometry <EoN> ( <BoN> ogr <EoN> . <BoN> wkb Line String <EoN> ) <NEWLINE> <BoN> segment <EoN> . <BoN> AddPoint 2 D <EoN> ( <BoN> pt 1 <EoN> [ <NUMBER> ] , <BoN> pt 1 <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> segment <EoN> . <BoN> AddPoint 2 D <EoN> ( <BoN> pt 2 <EoN> [ <NUMBER> ] , <BoN> pt 2 <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> segment <EoN> . <BoN> Export To Wkb <EoN> ( ) <NEWLINE> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> segment <EoN> . <BoN> Export To Wkt <EoN> ( ) <NEWLINE> <BoN> edge attrs <EoN> [ <STRING> ] = <BoN> segment <EoN> . <BoN> Export To Json <EoN> ( ) <NEWLINE> <BoN> del <EoN> <BoN> segment <EoN> <NEWLINE> <UNTAB> <BoN> yield <EoN> ( <BoN> pt 1 <EoN> , <BoN> pt 2 <EoN> , <BoN> edge attrs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> geom <EoN> . <BoN> Get Geometry Type <EoN> ( ) == <BoN> ogr <EoN> . <BoN> wkb Multi Line String <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> geom <EoN> . <BoN> Get Geometry Count <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> geom i <EoN> = <BoN> geom <EoN> . <BoN> Get Geometry Ref <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> edge <EoN> <BoN> in <EoN> <BoN> edges from line <EoN> ( <BoN> geom i <EoN> , <BoN> attrs <EoN> , <BoN> simplify <EoN> , <BoN> geom attrs <EoN> ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> edge <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dilation 2 d backprop input eager fallback <EoN> ( <BoN> input <EoN> , <BoN> filter <EoN> , <BoN> out backprop <EoN> , <BoN> strides <EoN> , <BoN> rates <EoN> , <BoN> padding <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> strides <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> strides <EoN> ) <NEWLINE> <UNTAB> <BoN> strides <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> strides <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> rates <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> rates <EoN> ) <NEWLINE> <UNTAB> <BoN> rates <EoN> = [ <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> i <EoN> , <STRING> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> rates <EoN> ] <NEWLINE> <BoN> padding <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> padding <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> , <BoN> filter <EoN> , <BoN> out backprop <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> ( <BoN> input <EoN> , <BoN> filter <EoN> , <BoN> out backprop <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> , <BoN> filter <EoN> , <BoN> out backprop <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> , <STRING> , <BoN> strides <EoN> , <STRING> , <BoN> rates <EoN> , <STRING> , <NEWLINE> <BoN> padding <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <NEWLINE> <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shares lineage <EoN> ( <BoN> self <EoN> , <BoN> othercolumn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> bool <EoN> ( <BoN> self <EoN> . <BoN> proxy set <EoN> . <BoN> intersection <EoN> ( <BoN> othercolumn <EoN> . <BoN> proxy set <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> a <EoN> , <BoN> Axes <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> hash <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> object <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> a existing <EoN> = <BoN> self <EoN> . <BoN> get <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> a existing <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> Stack <EoN> . <BoN> remove <EoN> ( <BoN> self <EoN> , ( <BoN> key <EoN> , <BoN> a existing <EoN> ) ) <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> key <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> ind <EoN> += <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> Stack <EoN> . <BoN> push <EoN> ( <BoN> self <EoN> , ( <BoN> key <EoN> , ( <BoN> self <EoN> . <BoN> ind <EoN> , <BoN> a <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> public <EoN> <NEWLINE> <BoN> def <EoN> <BoN> vring <EoN> ( <BoN> symbols <EoN> , <BoN> domain <EoN> , <BoN> order <EoN> = <BoN> lex <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ring <EoN> = <BoN> Poly Ring <EoN> ( <BoN> symbols <EoN> , <BoN> domain <EoN> , <BoN> order <EoN> ) <NEWLINE> <BoN> pollute <EoN> ( [ <BoN> sym <EoN> . <BoN> name <EoN> <BoN> for <EoN> <BoN> sym <EoN> <BoN> in <EoN> <BoN> ring <EoN> . <BoN> symbols <EoN> ] , <BoN> ring <EoN> . <BoN> gens <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ring <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> freedman diaconis bins <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> a <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> h <EoN> = <NUMBER> * <BoN> iqr <EoN> ( <BoN> a <EoN> ) / ( <BoN> len <EoN> ( <BoN> a <EoN> ) ** ( <NUMBER> / <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> h <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> a <EoN> . <BoN> size <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> ceil <EoN> ( ( <BoN> a <EoN> . <BoN> max <EoN> ( ) - <BoN> a <EoN> . <BoN> min <EoN> ( ) ) / <BoN> h <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> confusion matrix <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> labels <EoN> = <BoN> None <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y type <EoN> , <BoN> y true <EoN> , <BoN> y pred <EoN> = <BoN> check targets <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> y type <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> y type <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> labels <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> labels <EoN> = <BoN> unique labels <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> labels <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> labels <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( [ <BoN> l <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> y true <EoN> <BoN> for <EoN> <BoN> l <EoN> <BoN> in <EoN> <BoN> labels <EoN> ] ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( <BoN> y true <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> sample weight <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> check consistent length <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> sample weight <EoN> ) <NEWLINE> <NEWLINE> <BoN> n labels <EoN> = <BoN> labels <EoN> . <BoN> size <EoN> <NEWLINE> <BoN> label to ind <EoN> = <BoN> dict <EoN> ( ( <BoN> y <EoN> , <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> labels <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> y pred <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> label to ind <EoN> . <BoN> get <EoN> ( <BoN> x <EoN> , <BoN> n labels <EoN> + <NUMBER> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> y pred <EoN> ] ) <NEWLINE> <BoN> y true <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> label to ind <EoN> . <BoN> get <EoN> ( <BoN> x <EoN> , <BoN> n labels <EoN> + <NUMBER> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> y true <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ind <EoN> = <BoN> np <EoN> . <BoN> logical and <EoN> ( <BoN> y pred <EoN> < <BoN> n labels <EoN> , <BoN> y true <EoN> < <BoN> n labels <EoN> ) <NEWLINE> <BoN> y pred <EoN> = <BoN> y pred <EoN> [ <BoN> ind <EoN> ] <NEWLINE> <BoN> y true <EoN> = <BoN> y true <EoN> [ <BoN> ind <EoN> ] <NEWLINE> <NEWLINE> <BoN> sample weight <EoN> = <BoN> sample weight <EoN> [ <BoN> ind <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sample weight <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> in <EoN> { <STRING> , <STRING> , <STRING> } : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 64 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> C M <EoN> = <BoN> coo matrix <EoN> ( ( <BoN> sample weight <EoN> , ( <BoN> y true <EoN> , <BoN> y pred <EoN> ) ) , <NEWLINE> <BoN> shape <EoN> = ( <BoN> n labels <EoN> , <BoN> n labels <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <NEWLINE> ) . <BoN> toarray <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> C M <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> op <EoN> , <BoN> value index <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> op <EoN> , <BoN> Operation <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> op <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> op <EoN> = <BoN> op <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> value index <EoN> = <BoN> value index <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> as dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> tf output <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> shape val <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> consumers <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> id <EoN> = <BoN> uid <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get input at <EoN> ( <BoN> self <EoN> , <BoN> node index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get node attribute at index <EoN> ( <BoN> node index <EoN> , <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> transition params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> transition params <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> transition params <EoN> , <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> num tags <EoN> = <BoN> tensor shape <EoN> . <BoN> dimension value <EoN> ( <BoN> transition params <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> calculate shapes <EoN> ( <BoN> broadcast shape <EoN> , <BoN> dim sizes <EoN> , <BoN> list of core dims <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> broadcast shape <EoN> + <BoN> tuple <EoN> ( <BoN> dim sizes <EoN> [ <BoN> dim <EoN> ] <BoN> for <EoN> <BoN> dim <EoN> <BoN> in <EoN> <BoN> core dims <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> core dims <EoN> <BoN> in <EoN> <BoN> list of core dims <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get xheight <EoN> ( <BoN> self <EoN> , <BoN> font <EoN> , <BoN> fontsize <EoN> , <BoN> dpi <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> communicability exp <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> scipy <EoN> . <BoN> linalg <EoN> <NEWLINE> <BoN> nodelist <EoN> = <BoN> list <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> A <EoN> = <BoN> nx <EoN> . <BoN> to numpy matrix <EoN> ( <BoN> G <EoN> , <BoN> nodelist <EoN> ) <NEWLINE> <NEWLINE> <BoN> A <EoN> [ <BoN> A <EoN> != <NUMBER> ] = <NUMBER> <NEWLINE> <NEWLINE> <BoN> exp A <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> expm <EoN> ( <BoN> A <EoN> . <BoN> A <EoN> ) <NEWLINE> <BoN> mapping <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> nodelist <EoN> , <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> nodelist <EoN> ) ) ) ) <NEWLINE> <BoN> c <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> <BoN> in <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> [ <BoN> u <EoN> ] = { } <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] = <BoN> float <EoN> ( <BoN> exp A <EoN> [ <BoN> mapping <EoN> [ <BoN> u <EoN> ] , <BoN> mapping <EoN> [ <BoN> v <EoN> ] ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create fertile stats variable eager fallback <EoN> ( <BoN> stats handle <EoN> , <BoN> stats config <EoN> , <BoN> params <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> params <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> params <EoN> , <STRING> ) <NEWLINE> <BoN> stats handle <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> stats handle <EoN> , <BoN> dtypes <EoN> . <BoN> resource <EoN> ) <NEWLINE> <BoN> stats config <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> stats config <EoN> , <BoN> dtypes <EoN> . <BoN> string <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> stats handle <EoN> , <BoN> stats config <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> params <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <NEWLINE> <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> separate <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Separate <EoN> ( <BoN> axis <EoN> ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> check arguments <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> argument checked <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> assert <EoN> ( <BoN> self <EoN> . <BoN> symbol <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> argument checked <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> check arguments <EoN> ( <BoN> self <EoN> . <BoN> symbol <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> allow extra params <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> arg params <EoN> : <NEWLINE> <TAB> <BoN> arg names <EoN> = <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> symbol <EoN> . <BoN> list arguments <EoN> ( ) ) <NEWLINE> <BoN> self <EoN> . <BoN> arg params <EoN> = { <BoN> k <EoN> : <BoN> v <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> arg params <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> arg names <EoN> } <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> aux params <EoN> : <NEWLINE> <TAB> <BoN> aux names <EoN> = <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> symbol <EoN> . <BoN> list auxiliary states <EoN> ( ) ) <NEWLINE> <BoN> self <EoN> . <BoN> aux params <EoN> = { <BoN> k <EoN> : <BoN> v <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> aux params <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> aux names <EoN> } <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add n <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from str <EoN> ( <BoN> x <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> = <BoN> round fast <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> . <BoN> strip <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> special str <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> special str <EoN> [ <BoN> x <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> , <BoN> q <EoN> = <BoN> x <EoN> . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> from rational <EoN> ( <BoN> int <EoN> ( <BoN> p <EoN> ) , <BoN> int <EoN> ( <BoN> q <EoN> ) , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> man <EoN> , <BoN> exp <EoN> = <BoN> str to man exp <EoN> ( <BoN> x <EoN> , <BoN> base <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> exp <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> from int <EoN> ( <BoN> man <EoN> , <BoN> prec <EoN> + <NUMBER> ) <NEWLINE> <BoN> s <EoN> = <BoN> mpf mul <EoN> ( <BoN> s <EoN> , <BoN> mpf pow int <EoN> ( <BoN> ften <EoN> , <BoN> exp <EoN> , <BoN> prec <EoN> + <NUMBER> ) , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> exp <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> from int <EoN> ( <BoN> man <EoN> * <NUMBER> ** <BoN> exp <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> from rational <EoN> ( <BoN> man <EoN> , <NUMBER> ** - <BoN> exp <EoN> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check is fitted <EoN> ( <BoN> self <EoN> , <STRING> ) <NEWLINE> <BoN> X <EoN> = <BoN> self <EoN> . <BoN> check input <EoN> ( <BoN> X <EoN> , <BoN> check positive <EoN> = <BoN> True <EoN> , <BoN> check shape <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> transform function <EoN> = { <STRING> : <BoN> boxcox <EoN> , <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> yeo johnson transform <EoN> <NEWLINE> } [ <BoN> self <EoN> . <BoN> method <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> lmbda <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> lambdas <EoN> ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> invalid <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> X <EoN> [ : , <BoN> i <EoN> ] = <BoN> transform function <EoN> ( <BoN> X <EoN> [ : , <BoN> i <EoN> ] , <BoN> lmbda <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> standardize <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> = <BoN> self <EoN> . <BoN> scaler <EoN> . <BoN> transform <EoN> ( <BoN> X <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> X <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> batch flatten <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> tf <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> , <BoN> tf <EoN> . <BoN> stack <EoN> ( [ - <NUMBER> , <BoN> prod <EoN> ( <BoN> shape <EoN> ( <BoN> x <EoN> ) [ <NUMBER> : ] ) ] ) ) <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> parent <EoN> , <BoN> skip <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> parent <EoN> = <BoN> parent <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> index <EoN> = <BoN> len <EoN> ( <BoN> parent <EoN> . <BoN> pages <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> shape <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> = ( ) <NEWLINE> <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> axes <EoN> = <STRING> <NEWLINE> <BoN> self <EoN> . <BoN> tags <EoN> = <BoN> Tiff Tags <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> offset <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> fromfile <EoN> ( <BoN> skip <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> skip <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> process tags <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> class callcount <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> rval <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> , <BoN> count <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> self <EoN> . <BoN> apply callcount <EoN> ) : <NEWLINE> <TAB> <BoN> typ <EoN> = <BoN> type <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> ) <NEWLINE> <BoN> rval <EoN> . <BoN> setdefault <EoN> ( <BoN> typ <EoN> , <NUMBER> ) <NEWLINE> <BoN> rval <EoN> [ <BoN> typ <EoN> ] += <BoN> count <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rval <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> matthews corrcoef <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y type <EoN> , <BoN> y true <EoN> , <BoN> y pred <EoN> = <BoN> check targets <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> ) <NEWLINE> <BoN> check consistent length <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> sample weight <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> y type <EoN> <BoN> not <EoN> <BoN> in <EoN> { <STRING> , <STRING> } : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> y type <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> lb <EoN> = <BoN> Label Encoder <EoN> ( ) <NEWLINE> <BoN> lb <EoN> . <BoN> fit <EoN> ( <BoN> np <EoN> . <BoN> hstack <EoN> ( [ <BoN> y true <EoN> , <BoN> y pred <EoN> ] ) ) <NEWLINE> <BoN> y true <EoN> = <BoN> lb <EoN> . <BoN> transform <EoN> ( <BoN> y true <EoN> ) <NEWLINE> <BoN> y pred <EoN> = <BoN> lb <EoN> . <BoN> transform <EoN> ( <BoN> y pred <EoN> ) <NEWLINE> <NEWLINE> <BoN> C <EoN> = <BoN> confusion matrix <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> sample weight <EoN> = <BoN> sample weight <EoN> ) <NEWLINE> <BoN> t sum <EoN> = <BoN> C <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> p sum <EoN> = <BoN> C <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> n correct <EoN> = <BoN> np <EoN> . <BoN> trace <EoN> ( <BoN> C <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> n samples <EoN> = <BoN> p sum <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> cov ytyp <EoN> = <BoN> n correct <EoN> * <BoN> n samples <EoN> - <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> t sum <EoN> , <BoN> p sum <EoN> ) <NEWLINE> <BoN> cov ypyp <EoN> = <BoN> n samples <EoN> ** <NUMBER> - <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> p sum <EoN> , <BoN> p sum <EoN> ) <NEWLINE> <BoN> cov ytyt <EoN> = <BoN> n samples <EoN> ** <NUMBER> - <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> t sum <EoN> , <BoN> t sum <EoN> ) <NEWLINE> <BoN> mcc <EoN> = <BoN> cov ytyp <EoN> / <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> cov ytyt <EoN> * <BoN> cov ypyp <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> isnan <EoN> ( <BoN> mcc <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mcc <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> contextlib <EoN> . <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> report scope <EoN> ( <BoN> observation <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> current <EoN> = <BoN> reporters <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> old <EoN> = <BoN> current <EoN> . <BoN> observation <EoN> <NEWLINE> <BoN> current <EoN> . <BoN> observation <EoN> = <BoN> observation <EoN> <NEWLINE> <BoN> yield <EoN> <NEWLINE> <BoN> current <EoN> . <BoN> observation <EoN> = <BoN> old <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> unify gens <EoN> ( <BoN> f gens <EoN> , <BoN> g gens <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> f gens <EoN> = <BoN> list <EoN> ( <BoN> f gens <EoN> ) <NEWLINE> <BoN> g gens <EoN> = <BoN> list <EoN> ( <BoN> g gens <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> f gens <EoN> == <BoN> g gens <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> f gens <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> gens <EoN> , <BoN> common <EoN> , <BoN> k <EoN> = [ ] , [ ] , <NUMBER> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> gen <EoN> <BoN> in <EoN> <BoN> f gens <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> gen <EoN> <BoN> in <EoN> <BoN> g gens <EoN> : <NEWLINE> <TAB> <BoN> common <EoN> . <BoN> append <EoN> ( <BoN> gen <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> gen <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> g gens <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> gen <EoN> <BoN> in <EoN> <BoN> common <EoN> : <NEWLINE> <TAB> <BoN> g gens <EoN> [ <BoN> i <EoN> ] , <BoN> k <EoN> = <BoN> common <EoN> [ <BoN> k <EoN> ] , <BoN> k <EoN> + <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> gen <EoN> <BoN> in <EoN> <BoN> common <EoN> : <NEWLINE> <TAB> <BoN> i <EoN> = <BoN> f gens <EoN> . <BoN> index <EoN> ( <BoN> gen <EoN> ) <NEWLINE> <NEWLINE> <BoN> gens <EoN> . <BoN> extend <EoN> ( <BoN> f gens <EoN> [ : <BoN> i <EoN> ] ) <NEWLINE> <BoN> f gens <EoN> = <BoN> f gens <EoN> [ <BoN> i <EoN> + <NUMBER> : ] <NEWLINE> <NEWLINE> <BoN> i <EoN> = <BoN> g gens <EoN> . <BoN> index <EoN> ( <BoN> gen <EoN> ) <NEWLINE> <NEWLINE> <BoN> gens <EoN> . <BoN> extend <EoN> ( <BoN> g gens <EoN> [ : <BoN> i <EoN> ] ) <NEWLINE> <BoN> g gens <EoN> = <BoN> g gens <EoN> [ <BoN> i <EoN> + <NUMBER> : ] <NEWLINE> <NEWLINE> <BoN> gens <EoN> . <BoN> append <EoN> ( <BoN> gen <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> gens <EoN> . <BoN> extend <EoN> ( <BoN> f gens <EoN> ) <NEWLINE> <BoN> gens <EoN> . <BoN> extend <EoN> ( <BoN> g gens <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> gens <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert Not Equal <EoN> ( <BoN> self <EoN> , <BoN> first <EoN> , <BoN> second <EoN> , <BoN> msg <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> first <EoN> != <BoN> second <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <BoN> self <EoN> . <BoN> formatMessage <EoN> ( <BoN> msg <EoN> , <STRING> % ( <BoN> safe repr <EoN> ( <BoN> first <EoN> ) , <NEWLINE> <BoN> safe repr <EoN> ( <BoN> second <EoN> ) ) ) <NEWLINE> <BoN> raise <EoN> <BoN> self <EoN> . <BoN> failure Exception <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get source inputs <EoN> ( <BoN> tensor <EoN> , <BoN> layer <EoN> = <BoN> None <EoN> , <BoN> node index <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> tensor <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tensor <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> layer <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> node index <EoN> : <NEWLINE> <TAB> <BoN> layer <EoN> , <BoN> node index <EoN> , <BoN> <EoN> = <BoN> tensor <EoN> . <BoN> keras history <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> layer <EoN> . <BoN> inbound nodes <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> tensor <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> node <EoN> = <BoN> layer <EoN> . <BoN> inbound nodes <EoN> [ <BoN> node index <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> node <EoN> . <BoN> inbound layers <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> node <EoN> . <BoN> input tensors <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> source tensors <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> node <EoN> . <BoN> inbound layers <EoN> ) ) : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> node <EoN> . <BoN> input tensors <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> layer <EoN> = <BoN> node <EoN> . <BoN> inbound layers <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> node index <EoN> = <BoN> node <EoN> . <BoN> node indices <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> previous sources <EoN> = <BoN> get source inputs <EoN> ( <BoN> x <EoN> , <BoN> layer <EoN> , <BoN> node index <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> previous sources <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> source tensors <EoN> : <NEWLINE> <TAB> <BoN> source tensors <EoN> . <BoN> append <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> source tensors <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fft <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = - <NUMBER> , <BoN> overwrite x <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tmp <EoN> = <BoN> asfarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> work function <EoN> = <BoN> DTYPE TO FFT <EoN> [ <BoN> tmp <EoN> . <BoN> dtype <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> tmp <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> istype <EoN> ( <BoN> tmp <EoN> , <BoN> numpy <EoN> . <BoN> complex 64 <EoN> ) <BoN> or <EoN> <BoN> istype <EoN> ( <BoN> tmp <EoN> , <BoN> numpy <EoN> . <BoN> complex 128 <EoN> ) ) : <NEWLINE> <TAB> <BoN> overwrite x <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> overwrite x <EoN> = <BoN> overwrite x <EoN> <BoN> or <EoN> <BoN> datacopied <EoN> ( <BoN> tmp <EoN> , <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> tmp <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> n <EoN> != <BoN> tmp <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] : <NEWLINE> <TAB> <BoN> tmp <EoN> , <BoN> copy made <EoN> = <BoN> fix shape <EoN> ( <BoN> tmp <EoN> , <BoN> n <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> overwrite x <EoN> = <BoN> overwrite x <EoN> <BoN> or <EoN> <BoN> copy made <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> == - <NUMBER> <BoN> or <EoN> <BoN> axis <EoN> == <BoN> len <EoN> ( <BoN> tmp <EoN> . <BoN> shape <EoN> ) - <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> work function <EoN> ( <BoN> tmp <EoN> , <BoN> n <EoN> , <NUMBER> , <NUMBER> , <BoN> overwrite x <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> tmp <EoN> = <BoN> swapaxes <EoN> ( <BoN> tmp <EoN> , <BoN> axis <EoN> , - <NUMBER> ) <NEWLINE> <BoN> tmp <EoN> = <BoN> work function <EoN> ( <BoN> tmp <EoN> , <BoN> n <EoN> , <NUMBER> , <NUMBER> , <BoN> overwrite x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> swapaxes <EoN> ( <BoN> tmp <EoN> , <BoN> axis <EoN> , - <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> asarray square <EoN> ( <BoN> A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> A <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> A <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> A <EoN> . <BoN> shape <EoN> ) != <NUMBER> <BoN> or <EoN> <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] != <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> A <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> matvec <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> matmat <EoN> ( <BoN> x <EoN> . <BoN> reshape <EoN> ( - <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> turan graph <EoN> ( <BoN> n <EoN> , <BoN> r <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <NUMBER> <= <BoN> r <EoN> <= <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Network X Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> partitions <EoN> = [ <BoN> n <EoN> // <BoN> r <EoN> ] * ( <BoN> r <EoN> - ( <BoN> n <EoN> % <BoN> r <EoN> ) ) + [ <BoN> n <EoN> // <BoN> r <EoN> + <NUMBER> ] * ( <BoN> n <EoN> % <BoN> r <EoN> ) <NEWLINE> <BoN> G <EoN> = <BoN> complete multipartite graph <EoN> ( * <BoN> partitions <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> image gradients <EoN> ( <BoN> image <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> image <EoN> . <BoN> get shape <EoN> ( ) . <BoN> ndims <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> image <EoN> . <BoN> get shape <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> image shape <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> image <EoN> ) <NEWLINE> <BoN> batch size <EoN> , <BoN> height <EoN> , <BoN> width <EoN> , <BoN> depth <EoN> = <BoN> array ops <EoN> . <BoN> unstack <EoN> ( <BoN> image shape <EoN> ) <NEWLINE> <BoN> dy <EoN> = <BoN> image <EoN> [ : , <NUMBER> : , : , : ] - <BoN> image <EoN> [ : , : - <NUMBER> , : , : ] <NEWLINE> <BoN> dx <EoN> = <BoN> image <EoN> [ : , : , <NUMBER> : , : ] - <BoN> image <EoN> [ : , : , : - <NUMBER> , : ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> shape <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <BoN> batch size <EoN> , <NUMBER> , <BoN> width <EoN> , <BoN> depth <EoN> ] ) <NEWLINE> <BoN> dy <EoN> = <BoN> array ops <EoN> . <BoN> concat <EoN> ( [ <BoN> dy <EoN> , <BoN> array ops <EoN> . <BoN> zeros <EoN> ( <BoN> shape <EoN> , <BoN> image <EoN> . <BoN> dtype <EoN> ) ] , <NUMBER> ) <NEWLINE> <BoN> dy <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> dy <EoN> , <BoN> image shape <EoN> ) <NEWLINE> <NEWLINE> <BoN> shape <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <BoN> batch size <EoN> , <BoN> height <EoN> , <NUMBER> , <BoN> depth <EoN> ] ) <NEWLINE> <BoN> dx <EoN> = <BoN> array ops <EoN> . <BoN> concat <EoN> ( [ <BoN> dx <EoN> , <BoN> array ops <EoN> . <BoN> zeros <EoN> ( <BoN> shape <EoN> , <BoN> image <EoN> . <BoN> dtype <EoN> ) ] , <NUMBER> ) <NEWLINE> <BoN> dx <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> dx <EoN> , <BoN> image shape <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dy <EoN> , <BoN> dx <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> simple version match <EoN> ( <BoN> pat <EoN> = <STRING> , <BoN> ignore <EoN> = <STRING> , <BoN> start <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> matcher <EoN> ( <BoN> self <EoN> , <BoN> version string <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> version string <EoN> = <BoN> version string <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> pos <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> start <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> re <EoN> . <BoN> match <EoN> ( <BoN> start <EoN> , <BoN> version string <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> pos <EoN> = <BoN> m <EoN> . <BoN> end <EoN> ( ) <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> re <EoN> . <BoN> search <EoN> ( <BoN> pat <EoN> , <BoN> version string <EoN> [ <BoN> pos <EoN> : ] ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ignore <EoN> <BoN> and <EoN> <BoN> re <EoN> . <BoN> match <EoN> ( <BoN> ignore <EoN> , <BoN> m <EoN> . <BoN> group <EoN> ( <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> pos <EoN> = <BoN> m <EoN> . <BoN> end <EoN> ( ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> m <EoN> . <BoN> group <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> matcher <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get orientation <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is horizontal <EoN> ( ) <BoN> else <EoN> <STRING> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> cacheit <EoN> <NEWLINE> <BoN> def <EoN> <BoN> sort key <EoN> ( <BoN> self <EoN> , <BoN> order <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> inner key <EoN> ( <BoN> arg <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> arg <EoN> , <BoN> Basic <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arg <EoN> . <BoN> sort key <EoN> ( <BoN> order <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arg <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> args <EoN> = <BoN> self <EoN> . <BoN> sorted args <EoN> <NEWLINE> <BoN> args <EoN> = <BoN> len <EoN> ( <BoN> args <EoN> ) , <BoN> tuple <EoN> ( [ <BoN> inner key <EoN> ( <BoN> arg <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> class key <EoN> ( ) , <BoN> args <EoN> , <BoN> S <EoN> . <BoN> One <EoN> . <BoN> sort key <EoN> ( ) , <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <NEWLINE> <BoN> warn once <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> validate args <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> graph parents <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> self <EoN> . <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> super <EoN> ( <BoN> Absolute Value <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <NEWLINE> <BoN> forward min event ndims <EoN> = <NUMBER> , <NEWLINE> <BoN> is constant jacobian <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> validate args <EoN> = <BoN> validate args <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> square <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> square <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <NEWLINE> <BoN> None <EoN> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sloppy interleave <EoN> ( <BoN> map func <EoN> , <BoN> cycle length <EoN> , <BoN> block length <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> interleave ops <EoN> . <BoN> parallel interleave <EoN> ( <NEWLINE> <BoN> map func <EoN> , <BoN> cycle length <EoN> , <BoN> block length <EoN> , <BoN> sloppy <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set view <EoN> ( <BoN> self <EoN> , <BoN> view <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> xmin <EoN> , <BoN> xmax <EoN> , <BoN> ymin <EoN> , <BoN> ymax <EoN> = <BoN> view <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> set xlim <EoN> ( ( <BoN> xmin <EoN> , <BoN> xmax <EoN> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> set ylim <EoN> ( ( <BoN> ymin <EoN> , <BoN> ymax <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check advanced indexing dimensions <EoN> ( <BoN> input <EoN> , <BoN> idx list <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dim seen <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> index <EoN> <BoN> in <EoN> <BoN> idx list <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> index <EoN> <BoN> is <EoN> <BoN> np <EoN> . <BoN> newaxis <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> index <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) <BoN> and <EoN> <BoN> index <EoN> . <BoN> dtype <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> index <EoN> . <BoN> ndim <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> index <EoN> . <BoN> shape <EoN> [ <BoN> i <EoN> ] != <BoN> input <EoN> . <BoN> shape <EoN> [ <BoN> dim seen <EoN> + <BoN> i <EoN> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> dim seen <EoN> + <BoN> i <EoN> , <BoN> input <EoN> . <BoN> shape <EoN> [ <BoN> dim seen <EoN> + <BoN> i <EoN> ] , <NEWLINE> <BoN> index <EoN> . <BoN> shape <EoN> [ <BoN> i <EoN> ] ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> dim seen <EoN> += <BoN> index <EoN> . <BoN> ndim <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dim seen <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tan <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> launch <EoN> ( <BoN> self <EoN> , <BoN> args <EoN> , <BoN> ctx <EoN> , <BoN> grid dims <EoN> , <BoN> block dims <EoN> , <BoN> shared mem <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> ctx <EoN> . <BoN> device type <EoN> == <STRING> , <STRING> <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> grid dims <EoN> ) == <NUMBER> , <STRING> <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> block dims <EoN> ) == <NUMBER> , <STRING> <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> dtypes <EoN> ) , <STRING> % ( <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> , <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> dtypes <EoN> ) , <BoN> len <EoN> ( <BoN> args <EoN> ) ) <NEWLINE> <BoN> void args <EoN> = [ ] <NEWLINE> <BoN> ref holder <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> arg <EoN> , <BoN> is nd <EoN> , <BoN> dtype <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> zip <EoN> ( <BoN> args <EoN> , <BoN> self <EoN> . <BoN> is ndarray <EoN> , <BoN> self <EoN> . <BoN> dtypes <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is nd <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> isinstance <EoN> ( <BoN> arg <EoN> , <BoN> ND Array <EoN> ) , <STRING> % ( <NEWLINE> <BoN> i <EoN> , <BoN> type <EoN> ( <BoN> arg <EoN> ) ) <NEWLINE> <BoN> void args <EoN> . <BoN> append <EoN> ( <BoN> arg <EoN> . <BoN> handle <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> isinstance <EoN> ( <BoN> arg <EoN> , <BoN> numeric types <EoN> ) , <STRING> % ( <NEWLINE> <BoN> i <EoN> , <BoN> type <EoN> ( <BoN> arg <EoN> ) ) <NEWLINE> <BoN> ref holder <EoN> . <BoN> append <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> arg <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) ) <NEWLINE> <BoN> void args <EoN> . <BoN> append <EoN> ( <BoN> ref holder <EoN> [ - <NUMBER> ] . <BoN> ctypes <EoN> . <BoN> data as <EoN> ( <BoN> ctypes <EoN> . <BoN> c void p <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MX Rtc Cuda Kernel Call <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> handle <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> device id <EoN> , <NEWLINE> <BoN> c array <EoN> ( <BoN> ctypes <EoN> . <BoN> c void p <EoN> , <BoN> void args <EoN> ) , <NEWLINE> <BoN> mx uint <EoN> ( <BoN> grid dims <EoN> [ <NUMBER> ] ) , <BoN> mx uint <EoN> ( <BoN> grid dims <EoN> [ <NUMBER> ] ) , <BoN> mx uint <EoN> ( <BoN> grid dims <EoN> [ <NUMBER> ] ) , <NEWLINE> <BoN> mx uint <EoN> ( <BoN> block dims <EoN> [ <NUMBER> ] ) , <BoN> mx uint <EoN> ( <BoN> block dims <EoN> [ <NUMBER> ] ) , <BoN> mx uint <EoN> ( <BoN> block dims <EoN> [ <NUMBER> ] ) , <NEWLINE> <BoN> mx uint <EoN> ( <BoN> shared mem <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cosh <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Cosh <EoN> ( ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> procrustes <EoN> ( <BoN> data 1 <EoN> , <BoN> data 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mtx 1 <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> data 1 <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> double <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> mtx 2 <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> data 2 <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> double <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> mtx 1 <EoN> . <BoN> ndim <EoN> != <NUMBER> <BoN> or <EoN> <BoN> mtx 2 <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mtx 1 <EoN> . <BoN> shape <EoN> != <BoN> mtx 2 <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mtx 1 <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> mtx 1 <EoN> -= <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> mtx 1 <EoN> , <NUMBER> ) <NEWLINE> <BoN> mtx 2 <EoN> -= <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> mtx 2 <EoN> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> norm 1 <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> mtx 1 <EoN> ) <NEWLINE> <BoN> norm 2 <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> mtx 2 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> norm 1 <EoN> == <NUMBER> <BoN> or <EoN> <BoN> norm 2 <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> mtx 1 <EoN> /= <BoN> norm 1 <EoN> <NEWLINE> <BoN> mtx 2 <EoN> /= <BoN> norm 2 <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> R <EoN> , <BoN> s <EoN> = <BoN> orthogonal procrustes <EoN> ( <BoN> mtx 1 <EoN> , <BoN> mtx 2 <EoN> ) <NEWLINE> <BoN> mtx 2 <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> mtx 2 <EoN> , <BoN> R <EoN> . <BoN> T <EoN> ) * <BoN> s <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> disparity <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> np <EoN> . <BoN> square <EoN> ( <BoN> mtx 1 <EoN> - <BoN> mtx 2 <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> mtx 1 <EoN> , <BoN> mtx 2 <EoN> , <BoN> disparity <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is self handle <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> x <EoN> , <BoN> ops <EoN> . <BoN> Eager Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> <BoN> is <EoN> <BoN> self <EoN> . <BoN> handle <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> x <EoN> . <BoN> op <EoN> . <BoN> type <EoN> == <STRING> <NEWLINE> <NEWLINE> <BoN> and <EoN> <BoN> x <EoN> . <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) <NEWLINE> <BoN> and <EoN> ( <BoN> x <EoN> . <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) == <NEWLINE> <BoN> self <EoN> . <BoN> handle <EoN> . <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> and <EoN> ( <BoN> x <EoN> . <BoN> op <EoN> . <BoN> device <EoN> == <BoN> self <EoN> . <BoN> handle <EoN> . <BoN> op <EoN> . <BoN> device <EoN> <NEWLINE> <BoN> or <EoN> <BoN> get colocation <EoN> ( <BoN> x <EoN> . <BoN> op <EoN> ) == <BoN> get colocation <EoN> ( <BoN> self <EoN> . <BoN> handle <EoN> . <BoN> op <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> axes ticklabels overlap <EoN> ( <BoN> ax <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <BoN> axis ticklabels overlap <EoN> ( <BoN> ax <EoN> . <BoN> get xticklabels <EoN> ( ) ) , <NEWLINE> <BoN> axis ticklabels overlap <EoN> ( <BoN> ax <EoN> . <BoN> get yticklabels <EoN> ( ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> accept reject <EoN> ( <BoN> self <EoN> , <BoN> energy new <EoN> , <BoN> energy old <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> w <EoN> = <BoN> math <EoN> . <BoN> exp <EoN> ( <BoN> min <EoN> ( <NUMBER> , - <BoN> float <EoN> ( <BoN> energy new <EoN> - <BoN> energy old <EoN> ) * <BoN> self <EoN> . <BoN> beta <EoN> ) ) <NEWLINE> <BoN> rand <EoN> = <BoN> self <EoN> . <BoN> random state <EoN> . <BoN> rand <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> w <EoN> >= <BoN> rand <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compute lwork <EoN> ( <BoN> routine <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> wi <EoN> = <BoN> routine <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> wi <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> info <EoN> = <BoN> wi <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> info <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % ( <BoN> info <EoN> , ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> lwork <EoN> = [ <BoN> w <EoN> . <BoN> real <EoN> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> wi <EoN> [ : - <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> dtype <EoN> = <BoN> getattr <EoN> ( <BoN> routine <EoN> , <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> == <BoN> np <EoN> . <BoN> float 32 <EoN> <BoN> or <EoN> <BoN> dtype <EoN> == <BoN> np <EoN> . <BoN> complex 64 <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> lwork <EoN> = <BoN> np <EoN> . <BoN> nextafter <EoN> ( <BoN> lwork <EoN> , <BoN> np <EoN> . <BoN> inf <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> lwork <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> lwork <EoN> , <BoN> np <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> np <EoN> . <BoN> logical or <EoN> ( <BoN> lwork <EoN> < <NUMBER> , <BoN> lwork <EoN> > <BoN> np <EoN> . <BoN> iinfo <EoN> ( <BoN> np <EoN> . <BoN> int 32 <EoN> ) . <BoN> max <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> lwork <EoN> = <BoN> lwork <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> lwork <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lwork <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> lwork <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set many <EoN> ( <BoN> self <EoN> , <BoN> i <EoN> , <BoN> j <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> i <EoN> , <BoN> j <EoN> , <BoN> M <EoN> , <BoN> N <EoN> = <BoN> self <EoN> . <BoN> prepare indices <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> ) <NEWLINE> <NEWLINE> <BoN> n samples <EoN> = <BoN> len <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> offsets <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> n samples <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> indices <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> ret <EoN> = <BoN> sparsetools <EoN> . <BoN> csr sample offsets <EoN> ( <BoN> M <EoN> , <BoN> N <EoN> , <BoN> self <EoN> . <BoN> indptr <EoN> , <BoN> self <EoN> . <BoN> indices <EoN> , <NEWLINE> <BoN> n samples <EoN> , <BoN> i <EoN> , <BoN> j <EoN> , <BoN> offsets <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ret <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> sum duplicates <EoN> ( ) <NEWLINE> <BoN> sparsetools <EoN> . <BoN> csr sample offsets <EoN> ( <BoN> M <EoN> , <BoN> N <EoN> , <BoN> self <EoN> . <BoN> indptr <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> indices <EoN> , <BoN> n samples <EoN> , <BoN> i <EoN> , <BoN> j <EoN> , <NEWLINE> <BoN> offsets <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> - <NUMBER> <BoN> not <EoN> <BoN> in <EoN> <BoN> offsets <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> data <EoN> [ <BoN> offsets <EoN> ] = <BoN> x <EoN> <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> self <EoN> . <BoN> format <EoN> , <NEWLINE> <BoN> Sparse Efficiency Warning <EoN> ) <NEWLINE> <NEWLINE> <BoN> mask <EoN> = <BoN> offsets <EoN> > - <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> data <EoN> [ <BoN> offsets <EoN> [ <BoN> mask <EoN> ] ] = <BoN> x <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <NEWLINE> <BoN> mask <EoN> = ~ <BoN> mask <EoN> <NEWLINE> <BoN> i <EoN> = <BoN> i <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <BoN> i <EoN> [ <BoN> i <EoN> < <NUMBER> ] += <BoN> M <EoN> <NEWLINE> <BoN> j <EoN> = <BoN> j <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <BoN> j <EoN> [ <BoN> j <EoN> < <NUMBER> ] += <BoN> N <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> insert many <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> , <BoN> x <EoN> [ <BoN> mask <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> round <EoN> ( <BoN> self <EoN> , <BoN> mode <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> basic <EoN> . <BoN> round <EoN> ( <BoN> self <EoN> , <BoN> mode <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> test two <EoN> ( <BoN> self <EoN> , <BoN> pred dates <EoN> , <BoN> succ dates <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> time respecting <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> pred dates <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> succ dates <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <NUMBER> < <BoN> len <EoN> ( <BoN> succ dates <EoN> ) <BoN> and <EoN> <NUMBER> < <BoN> len <EoN> ( <BoN> pred dates <EoN> ) <BoN> and <EoN> <BoN> succ dates <EoN> [ <NUMBER> ] < <BoN> pred dates <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> time respecting <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> time respecting <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> infer objects <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> data <EoN> . <BoN> convert <EoN> ( <BoN> datetime <EoN> = <BoN> True <EoN> , <BoN> numeric <EoN> = <BoN> False <EoN> , <NEWLINE> <BoN> timedelta <EoN> = <BoN> True <EoN> , <BoN> coerce <EoN> = <BoN> False <EoN> , <NEWLINE> <BoN> copy <EoN> = <BoN> True <EoN> ) ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get graph def from disk <EoN> ( <BoN> filename <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> gfile <EoN> . <BoN> Fast G File <EoN> ( <BoN> filename <EoN> , <STRING> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> graph pb 2 <EoN> . <BoN> Graph Def <EoN> . <BoN> From String <EoN> ( <BoN> f <EoN> . <BoN> read <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <NEWLINE> <BoN> None <EoN> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> dense to sparse batch <EoN> ( <BoN> batch size <EoN> , <BoN> row shape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> batching <EoN> . <BoN> dense to sparse batch <EoN> ( <BoN> batch size <EoN> , <BoN> row shape <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> choice <EoN> ( <BoN> a <EoN> , <BoN> size <EoN> = <BoN> None <EoN> , <BoN> replace <EoN> = <BoN> True <EoN> , <BoN> p <EoN> = <BoN> None <EoN> , <BoN> random state <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> random state <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> random state <EoN> = <BoN> check random state <EoN> ( <BoN> random state <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> random state <EoN> . <BoN> choice <EoN> ( <BoN> a <EoN> , <BoN> size <EoN> , <BoN> replace <EoN> , <BoN> p <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> random <EoN> . <BoN> choice <EoN> ( <BoN> a <EoN> , <BoN> size <EoN> , <BoN> replace <EoN> , <BoN> p <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init global step <EoN> ( <BoN> self <EoN> , <BoN> global step <EoN> = <BoN> USE DEFAULT <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> global step <EoN> <BoN> is <EoN> <BoN> Supervisor <EoN> . <BoN> USE DEFAULT <EoN> : <NEWLINE> <TAB> <BoN> global step <EoN> = <BoN> self <EoN> . <BoN> get first op from collection <EoN> ( <NEWLINE> <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> GLOBAL STEP <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> global step <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> global step <EoN> = <BoN> self <EoN> . <BoN> default global step tensor <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> global step <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> GLOBAL STEP <EoN> , <BoN> global step <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> global step <EoN> = <BoN> global step <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sqrt <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sqrt eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> sqrt <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> sqrt <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverse <EoN> ( <BoN> self <EoN> , <BoN> argindex <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> cot <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> normalize dimension <EoN> ( <BoN> cls <EoN> , * <BoN> points <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> dim <EoN> = <BoN> getattr <EoN> ( <BoN> cls <EoN> , <STRING> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> dim <EoN> = <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> dim <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dim <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dim <EoN> = <BoN> max <EoN> ( <BoN> i <EoN> . <BoN> ambient dimension <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> points <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> all <EoN> ( <BoN> i <EoN> . <BoN> ambient dimension <EoN> == <BoN> dim <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> points <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> points <EoN> ) <NEWLINE> <UNTAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> dim <EoN> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> return <EoN> [ <BoN> Point <EoN> ( <BoN> i <EoN> , ** <BoN> kwargs <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> points <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <NEWLINE> <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> set union <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> validate indices <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> <EoN> = <BoN> convert to tensors or sparse tensors <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> set operation <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <STRING> , <BoN> validate indices <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> remove <EoN> ( <BoN> target <EoN> , <BoN> identifier <EoN> , <BoN> fn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> event key <EoN> ( <BoN> target <EoN> , <BoN> identifier <EoN> , <BoN> fn <EoN> ) . <BoN> remove <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pearsonr <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> n <EoN> ) = <BoN> chk size <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> ( <BoN> x <EoN> , <BoN> y <EoN> ) = ( <BoN> x <EoN> . <BoN> ravel <EoN> ( ) , <BoN> y <EoN> . <BoN> ravel <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> m <EoN> = <BoN> ma <EoN> . <BoN> mask or <EoN> ( <BoN> ma <EoN> . <BoN> getmask <EoN> ( <BoN> x <EoN> ) , <BoN> ma <EoN> . <BoN> getmask <EoN> ( <BoN> y <EoN> ) ) <NEWLINE> <BoN> n <EoN> -= <BoN> m <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> df <EoN> = <BoN> n <EoN> - <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> df <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> masked <EoN> , <BoN> masked <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> ( <BoN> mx <EoN> , <BoN> my <EoN> ) = ( <BoN> x <EoN> . <BoN> mean <EoN> ( ) , <BoN> y <EoN> . <BoN> mean <EoN> ( ) ) <NEWLINE> ( <BoN> xm <EoN> , <BoN> ym <EoN> ) = ( <BoN> x <EoN> - <BoN> mx <EoN> , <BoN> y <EoN> - <BoN> my <EoN> ) <NEWLINE> <NEWLINE> <BoN> r num <EoN> = <BoN> ma <EoN> . <BoN> add <EoN> . <BoN> reduce <EoN> ( <BoN> xm <EoN> * <BoN> ym <EoN> ) <NEWLINE> <BoN> r den <EoN> = <BoN> ma <EoN> . <BoN> sqrt <EoN> ( <BoN> ma <EoN> . <BoN> dot <EoN> ( <BoN> xm <EoN> , <BoN> xm <EoN> ) * <BoN> ma <EoN> . <BoN> dot <EoN> ( <BoN> ym <EoN> , <BoN> ym <EoN> ) ) <NEWLINE> <BoN> r <EoN> = <BoN> r num <EoN> / <BoN> r den <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> r <EoN> = <BoN> min <EoN> ( <BoN> r <EoN> , <NUMBER> ) <NEWLINE> <BoN> r <EoN> = <BoN> max <EoN> ( <BoN> r <EoN> , - <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> <BoN> is <EoN> <BoN> masked <EoN> <BoN> or <EoN> <BoN> abs <EoN> ( <BoN> r <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> prob <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> t squared <EoN> = ( <BoN> df <EoN> / ( ( <NUMBER> - <BoN> r <EoN> ) * ( <NUMBER> + <BoN> r <EoN> ) ) ) * <BoN> r <EoN> * <BoN> r <EoN> <NEWLINE> <BoN> prob <EoN> = <BoN> betai <EoN> ( <NUMBER> * <BoN> df <EoN> , <NUMBER> , <BoN> df <EoN> / ( <BoN> df <EoN> + <BoN> t squared <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> r <EoN> , <BoN> prob <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> recurrence memo <EoN> ( <BoN> initial <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cache <EoN> = <BoN> initial <EoN> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> decorator <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> @ <BoN> wraps <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> g <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> L <EoN> = <BoN> len <EoN> ( <BoN> cache <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> <= <BoN> L <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cache <EoN> [ <BoN> n <EoN> ] <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> L <EoN> , <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> cache <EoN> . <BoN> append <EoN> ( <BoN> f <EoN> ( <BoN> i <EoN> , <BoN> cache <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> cache <EoN> [ - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> g <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> decorator <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> multi take <EoN> ( <BoN> self <EoN> , <BoN> tup <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> o <EoN> = <BoN> self <EoN> . <BoN> obj <EoN> <NEWLINE> <BoN> d <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> axis <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> tup <EoN> , <BoN> o <EoN> . <BoN> AXIS ORDERS <EoN> ) : <NEWLINE> <TAB> <BoN> ax <EoN> = <BoN> o <EoN> . <BoN> get axis <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> indexer <EoN> , <BoN> keyarr <EoN> = <BoN> ax <EoN> . <BoN> convert listlike indexer <EoN> ( <BoN> key <EoN> , <NEWLINE> <BoN> kind <EoN> = <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> indexer <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> ( <BoN> indexer <EoN> != - <NUMBER> ) . <BoN> all <EoN> ( ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> validate read indexer <EoN> ( <BoN> key <EoN> , <BoN> indexer <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> d <EoN> [ <BoN> axis <EoN> ] = ( <BoN> ax <EoN> [ <BoN> indexer <EoN> ] , <BoN> indexer <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> ax <EoN> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> len <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> self <EoN> . <BoN> convert for reindex <EoN> ( <BoN> key <EoN> , <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <BoN> indexer <EoN> = <BoN> ax <EoN> . <BoN> get indexer for <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> keyarr <EoN> = <BoN> ax <EoN> . <BoN> reindex <EoN> ( <BoN> keyarr <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> self <EoN> . <BoN> validate read indexer <EoN> ( <BoN> keyarr <EoN> , <BoN> indexer <EoN> , <NEWLINE> <BoN> o <EoN> . <BoN> get axis number <EoN> ( <BoN> axis <EoN> ) ) <NEWLINE> <BoN> d <EoN> [ <BoN> axis <EoN> ] = ( <BoN> keyarr <EoN> , <BoN> indexer <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> o <EoN> . <BoN> reindex with indexers <EoN> ( <BoN> d <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> , <BoN> allow dups <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Key Error <EoN> , <BoN> Indexing Error <EoN> ) <BoN> as <EoN> <BoN> detail <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> self <EoN> . <BoN> exception <EoN> ( <BoN> detail <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> local over kwdict <EoN> ( <BoN> local var <EoN> , <BoN> kwargs <EoN> , * <BoN> keys <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> out <EoN> = <BoN> local var <EoN> <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> keys <EoN> : <NEWLINE> <TAB> <BoN> kwarg val <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <BoN> key <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> kwarg val <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> kwarg val <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> % <BoN> key <EoN> , <NEWLINE> <BoN> Ignored Keyword Warning <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> select dtypes <EoN> ( <BoN> self <EoN> , <BoN> include <EoN> = <BoN> None <EoN> , <BoN> exclude <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> is list like <EoN> ( <BoN> include <EoN> ) : <NEWLINE> <TAB> <BoN> include <EoN> = ( <BoN> include <EoN> , ) <BoN> if <EoN> <BoN> include <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> else <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> is list like <EoN> ( <BoN> exclude <EoN> ) : <NEWLINE> <TAB> <BoN> exclude <EoN> = ( <BoN> exclude <EoN> , ) <BoN> if <EoN> <BoN> exclude <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> else <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> selection <EoN> = <BoN> tuple <EoN> ( <BoN> map <EoN> ( <BoN> frozenset <EoN> , ( <BoN> include <EoN> , <BoN> exclude <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> any <EoN> ( <BoN> selection <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> include <EoN> , <BoN> exclude <EoN> = <BoN> map <EoN> ( <NEWLINE> <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> frozenset <EoN> ( <BoN> map <EoN> ( <BoN> get dtype from object <EoN> , <BoN> x <EoN> ) ) , <BoN> selection <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> dtypes <EoN> <BoN> in <EoN> ( <BoN> include <EoN> , <BoN> exclude <EoN> ) : <NEWLINE> <TAB> <BoN> invalidate string dtypes <EoN> ( <BoN> dtypes <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> include <EoN> . <BoN> isdisjoint <EoN> ( <BoN> exclude <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> inc ex <EoN> = ( <BoN> include <EoN> & <BoN> exclude <EoN> ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> include these <EoN> = <BoN> Series <EoN> ( <BoN> not <EoN> <BoN> bool <EoN> ( <BoN> include <EoN> ) , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> columns <EoN> ) <NEWLINE> <BoN> exclude these <EoN> = <BoN> Series <EoN> ( <BoN> not <EoN> <BoN> bool <EoN> ( <BoN> exclude <EoN> ) , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> columns <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> is dtype instance mapper <EoN> ( <BoN> idx <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> idx <EoN> , <BoN> functools <EoN> . <BoN> partial <EoN> ( <BoN> issubclass <EoN> , <BoN> dtype <EoN> . <BoN> type <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> idx <EoN> , <BoN> f <EoN> <BoN> in <EoN> <BoN> itertools <EoN> . <BoN> starmap <EoN> ( <BoN> is dtype instance mapper <EoN> , <NEWLINE> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> dtypes <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> include <EoN> : <NEWLINE> <TAB> <BoN> include these <EoN> . <BoN> iloc <EoN> [ <BoN> idx <EoN> ] = <BoN> any <EoN> ( <BoN> map <EoN> ( <BoN> f <EoN> , <BoN> include <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> exclude <EoN> : <NEWLINE> <TAB> <BoN> exclude these <EoN> . <BoN> iloc <EoN> [ <BoN> idx <EoN> ] = <BoN> not <EoN> <BoN> any <EoN> ( <BoN> map <EoN> ( <BoN> f <EoN> , <BoN> exclude <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> dtype indexer <EoN> = <BoN> include these <EoN> & <BoN> exclude these <EoN> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> loc <EoN> [ <BoN> com <EoN> . <BoN> get info slice <EoN> ( <BoN> self <EoN> , <BoN> dtype indexer <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> placeholder <EoN> ( <BoN> dtype <EoN> , <BoN> shape <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> gen array ops <EoN> . <BoN> placeholder <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> in top k <EoN> ( <BoN> predictions <EoN> , <BoN> targets <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> nn <EoN> . <BoN> in top k <EoN> ( <BoN> predictions <EoN> , <BoN> targets <EoN> , <BoN> k <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> xavier normal <EoN> ( <BoN> tensor <EoN> , <BoN> gain <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fan in <EoN> , <BoN> fan out <EoN> = <BoN> calculate fan in and fan out <EoN> ( <BoN> tensor <EoN> ) <NEWLINE> <BoN> std <EoN> = <BoN> gain <EoN> * <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> / ( <BoN> fan in <EoN> + <BoN> fan out <EoN> ) ) <NEWLINE> <BoN> with <EoN> <BoN> torch <EoN> . <BoN> no grad <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tensor <EoN> . <BoN> normal <EoN> ( <NUMBER> , <BoN> std <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> int <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> order angles golden ratio <EoN> ( <BoN> theta <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> interval <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> angle distance <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <BoN> difference <EoN> = <BoN> a <EoN> - <BoN> b <EoN> <NEWLINE> <BoN> return <EoN> <BoN> min <EoN> ( <BoN> abs <EoN> ( <BoN> difference <EoN> % <BoN> interval <EoN> ) , <BoN> abs <EoN> ( <BoN> difference <EoN> % - <BoN> interval <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> remaining <EoN> = <BoN> list <EoN> ( <BoN> np <EoN> . <BoN> argsort <EoN> ( <BoN> theta <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> index <EoN> = <BoN> remaining <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <BoN> angle <EoN> = <BoN> theta <EoN> [ <BoN> index <EoN> ] <NEWLINE> <BoN> yield <EoN> <BoN> index <EoN> <NEWLINE> <NEWLINE> <BoN> angle increment <EoN> = <BoN> interval <EoN> * ( <NUMBER> - ( <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) - <NUMBER> ) / <NUMBER> ) <NEWLINE> <BoN> while <EoN> <BoN> remaining <EoN> : <NEWLINE> <TAB> <BoN> angle <EoN> = ( <BoN> angle <EoN> + <BoN> angle increment <EoN> ) % <BoN> interval <EoN> <NEWLINE> <BoN> insert point <EoN> = <BoN> np <EoN> . <BoN> searchsorted <EoN> ( <BoN> theta <EoN> [ <BoN> remaining <EoN> ] , <BoN> angle <EoN> ) <NEWLINE> <BoN> index below <EoN> = <BoN> insert point <EoN> - <NUMBER> <NEWLINE> <BoN> index above <EoN> = <NUMBER> <BoN> if <EoN> <BoN> insert point <EoN> == <BoN> len <EoN> ( <BoN> remaining <EoN> ) <BoN> else <EoN> <BoN> insert point <EoN> <NEWLINE> <BoN> distance below <EoN> = <BoN> angle distance <EoN> ( <BoN> angle <EoN> , <BoN> theta <EoN> [ <BoN> remaining <EoN> [ <BoN> index below <EoN> ] ] ) <NEWLINE> <BoN> distance above <EoN> = <BoN> angle distance <EoN> ( <BoN> angle <EoN> , <BoN> theta <EoN> [ <BoN> remaining <EoN> [ <BoN> index above <EoN> ] ] ) <NEWLINE> <BoN> if <EoN> <BoN> distance below <EoN> < <BoN> distance above <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> remaining <EoN> . <BoN> pop <EoN> ( <BoN> index below <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> remaining <EoN> . <BoN> pop <EoN> ( <BoN> index above <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rfft <EoN> ( <BoN> a <EoN> , <BoN> n <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = - <NUMBER> , <BoN> norm <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> a <EoN> = <BoN> array <EoN> ( <BoN> a <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> output <EoN> = <BoN> raw fft <EoN> ( <BoN> a <EoN> , <BoN> n <EoN> , <BoN> axis <EoN> , <BoN> fftpack <EoN> . <BoN> rffti <EoN> , <BoN> fftpack <EoN> . <BoN> rfftf <EoN> , <NEWLINE> <BoN> real fft cache <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> unitary <EoN> ( <BoN> norm <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> a <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] <NEWLINE> <UNTAB> <BoN> output <EoN> *= <NUMBER> / <BoN> sqrt <EoN> ( <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> output <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tick values <EoN> ( <BoN> self <EoN> , <BoN> vmin <EoN> , <BoN> vmax <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> central diff weights <EoN> ( <BoN> Np <EoN> , <BoN> ndiv <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> Np <EoN> < <BoN> ndiv <EoN> + <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> Np <EoN> % <NUMBER> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> from <EoN> <BoN> scipy <EoN> <BoN> import <EoN> <BoN> linalg <EoN> <NEWLINE> <BoN> ho <EoN> = <BoN> Np <EoN> >> <NUMBER> <NEWLINE> <BoN> x <EoN> = <BoN> arange <EoN> ( - <BoN> ho <EoN> , <BoN> ho <EoN> + <NUMBER> ) <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> [ : , <BoN> newaxis <EoN> ] <NEWLINE> <BoN> X <EoN> = <BoN> x <EoN> ** <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> Np <EoN> ) : <NEWLINE> <TAB> <BoN> X <EoN> = <BoN> hstack <EoN> ( [ <BoN> X <EoN> , <BoN> x <EoN> ** <BoN> k <EoN> ] ) <NEWLINE> <UNTAB> <BoN> w <EoN> = <BoN> product <EoN> ( <BoN> arange <EoN> ( <NUMBER> , <BoN> ndiv <EoN> + <NUMBER> ) , <BoN> axis <EoN> = <NUMBER> ) * <BoN> linalg <EoN> . <BoN> inv <EoN> ( <BoN> X <EoN> ) [ <BoN> ndiv <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> w <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> dispose <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> pool <EoN> . <BoN> dispose <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> pool <EoN> = <BoN> self <EoN> . <BoN> pool <EoN> . <BoN> recreate <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> dispatch <EoN> . <BoN> engine disposed <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assert array less <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> err msg <EoN> = <STRING> , <BoN> verbose <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tracebackhide <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> assert array compare <EoN> ( <BoN> operator <EoN> . <BoN> lt <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> err msg <EoN> = <BoN> err msg <EoN> , <NEWLINE> <BoN> verbose <EoN> = <BoN> verbose <EoN> , <NEWLINE> <BoN> header <EoN> = <STRING> , <NEWLINE> <BoN> equal inf <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> begin twophase <EoN> ( <BoN> self <EoN> , <BoN> conn <EoN> , <BoN> xid <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> roll <EoN> ( <BoN> x <EoN> , <BoN> shift <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> x <EoN> . <BoN> flatten <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> roll <EoN> ( <BoN> y <EoN> , <BoN> shift <EoN> , <BoN> axis <EoN> = <NUMBER> ) . <BoN> reshape <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> axis <EoN> += <BoN> x <EoN> . <BoN> ndim <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> shift <EoN> = <BoN> shift <EoN> % <BoN> x <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> allslice <EoN> = <BoN> slice <EoN> ( <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> front slice <EoN> = <BoN> slice <EoN> ( - <BoN> shift <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> front list <EoN> = ( [ <BoN> allslice <EoN> ] * <BoN> axis <EoN> + [ <BoN> front slice <EoN> ] + <NEWLINE> [ <BoN> allslice <EoN> ] * ( <BoN> x <EoN> . <BoN> ndim <EoN> - <BoN> axis <EoN> - <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> end slice <EoN> = <BoN> slice <EoN> ( <NUMBER> , - <BoN> shift <EoN> ) <NEWLINE> <BoN> end list <EoN> = ( [ <BoN> allslice <EoN> ] * <BoN> axis <EoN> + [ <BoN> end slice <EoN> ] + <NEWLINE> [ <BoN> allslice <EoN> ] * ( <BoN> x <EoN> . <BoN> ndim <EoN> - <BoN> axis <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> return <EoN> <BoN> join <EoN> ( <BoN> axis <EoN> , <NEWLINE> <BoN> x <EoN> . <BoN> getitem <EoN> ( <BoN> tuple <EoN> ( <BoN> front list <EoN> ) ) , <NEWLINE> <BoN> x <EoN> . <BoN> getitem <EoN> ( <BoN> tuple <EoN> ( <BoN> end list <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> draw frame <EoN> ( <BoN> self <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> set frame on <EoN> ( <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sdca fprint <EoN> ( <BoN> input <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> input <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sdca fprint eager fallback <EoN> ( <NEWLINE> <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> sdca fprint <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> sdca fprint <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> grow tree v 4 eager fallback <EoN> ( <BoN> tree handle <EoN> , <BoN> stats handle <EoN> , <BoN> finished nodes <EoN> , <BoN> params <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> params <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> params <EoN> , <STRING> ) <NEWLINE> <BoN> tree handle <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> tree handle <EoN> , <BoN> dtypes <EoN> . <BoN> resource <EoN> ) <NEWLINE> <BoN> stats handle <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> stats handle <EoN> , <BoN> dtypes <EoN> . <BoN> resource <EoN> ) <NEWLINE> <BoN> finished nodes <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> finished nodes <EoN> , <BoN> dtypes <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> tree handle <EoN> , <BoN> stats handle <EoN> , <BoN> finished nodes <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> params <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> fgraph <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> optimize <EoN> ( <BoN> fgraph <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rs asin <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> rs is puiseux <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rs puiseux <EoN> ( <BoN> rs asin <EoN> , <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> has constant term <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> R <EoN> = <BoN> p <EoN> . <BoN> ring <EoN> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> R <EoN> . <BoN> gens <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> p <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> dp <EoN> = <BoN> rs diff <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> p 1 <EoN> = <NUMBER> - <BoN> rs square <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> - <NUMBER> ) <NEWLINE> <BoN> p 1 <EoN> = <BoN> rs nth root <EoN> ( <BoN> p 1 <EoN> , - <NUMBER> , <BoN> x <EoN> , <BoN> prec <EoN> - <NUMBER> ) <NEWLINE> <BoN> p 1 <EoN> = <BoN> rs mul <EoN> ( <BoN> dp <EoN> , <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> - <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> rs integrate <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> one <EoN> = <BoN> R <EoN> ( <NUMBER> ) <NEWLINE> <BoN> c <EoN> = [ <NUMBER> , <BoN> one <EoN> , <NUMBER> ] <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> prec <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> c <EoN> . <BoN> append <EoN> ( ( <BoN> k <EoN> - <NUMBER> ) ** <NUMBER> * <BoN> c <EoN> [ - <NUMBER> ] / ( <BoN> k <EoN> * ( <BoN> k <EoN> - <NUMBER> ) ) ) <NEWLINE> <BoN> c <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rs series from list <EoN> ( <BoN> p <EoN> , <BoN> c <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tc <EoN> . <BoN> returns <EoN> ( <BoN> tc <EoN> . <BoN> List <EoN> ( <BoN> core <EoN> . <BoN> Labeled Tensor <EoN> ) ) <NEWLINE> @ <BoN> tc <EoN> . <BoN> accepts <EoN> ( <BoN> core <EoN> . <BoN> Labeled Tensor Like <EoN> , <NEWLINE> <BoN> tc <EoN> . <BoN> Optional <EoN> ( <BoN> string types <EoN> ) , <BoN> tc <EoN> . <BoN> Optional <EoN> ( <BoN> string types <EoN> ) ) <NEWLINE> <BoN> def <EoN> <BoN> unpack <EoN> ( <BoN> labeled tensor <EoN> , <BoN> axis name <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> labeled tensor <EoN> ] ) <BoN> as <EoN> <BoN> scope <EoN> : <NEWLINE> <TAB> <BoN> labeled tensor <EoN> = <BoN> core <EoN> . <BoN> convert to labeled tensor <EoN> ( <BoN> labeled tensor <EoN> ) <NEWLINE> <NEWLINE> <BoN> axis names <EoN> = <BoN> list <EoN> ( <BoN> labeled tensor <EoN> . <BoN> axes <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> axis name <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> axis name <EoN> = <BoN> axis names <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis name <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> axis names <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <BoN> axis name <EoN> , <BoN> axis names <EoN> ) ) <NEWLINE> <UNTAB> <BoN> axis <EoN> = <BoN> axis names <EoN> . <BoN> index <EoN> ( <BoN> axis name <EoN> ) <NEWLINE> <NEWLINE> <BoN> unpack ops <EoN> = <BoN> array ops <EoN> . <BoN> unstack <EoN> ( <BoN> labeled tensor <EoN> . <BoN> tensor <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> name <EoN> = <BoN> scope <EoN> ) <NEWLINE> <BoN> axes <EoN> = [ <BoN> a <EoN> <BoN> for <EoN> <BoN> i <EoN> , <BoN> a <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> labeled tensor <EoN> . <BoN> axes <EoN> . <BoN> values <EoN> ( ) ) <BoN> if <EoN> <BoN> i <EoN> != <BoN> axis <EoN> ] <NEWLINE> <BoN> return <EoN> [ <BoN> core <EoN> . <BoN> Labeled Tensor <EoN> ( <BoN> t <EoN> , <BoN> axes <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> unpack ops <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> y true <EoN> , <BoN> y pred <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y pred <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> y pred <EoN> ) <NEWLINE> <BoN> y true <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> y true <EoN> ) <NEWLINE> <BoN> is sparse <EoN> = <BoN> y pred <EoN> . <BoN> shape <EoN> != <BoN> y true <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is sparse <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sparse categorical crossentropy <EoN> ( <NEWLINE> <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> from logits <EoN> = <BoN> self <EoN> . <BoN> from logits <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> y true <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> y true <EoN> , <BoN> y pred <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> label smoothing <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> num classes <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> y true <EoN> ) [ <NUMBER> ] , <BoN> y pred <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> smooth positives <EoN> = <NUMBER> - <BoN> self <EoN> . <BoN> label smoothing <EoN> <NEWLINE> <BoN> smooth negatives <EoN> = <BoN> self <EoN> . <BoN> label smoothing <EoN> / <BoN> num classes <EoN> <NEWLINE> <BoN> y true <EoN> = <BoN> y true <EoN> * <BoN> smooth positives <EoN> + <BoN> smooth negatives <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> categorical crossentropy <EoN> ( <NEWLINE> <BoN> y true <EoN> , <BoN> y pred <EoN> , <BoN> from logits <EoN> = <BoN> self <EoN> . <BoN> from logits <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> force backprop mode <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> configuration <EoN> . <BoN> using config <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> keepdims wrapper <EoN> ( <BoN> a callable <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> @ <BoN> wraps <EoN> ( <BoN> a callable <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> keepdims wrapped callable <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> keepdims <EoN> = <BoN> None <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> a callable <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> keepdims <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> axes <EoN> = <BoN> axis <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> axes <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> axes <EoN> = <BoN> range <EoN> ( <BoN> x <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> axes <EoN> , ( <BoN> Container <EoN> , <BoN> Iterable <EoN> , <BoN> Sequence <EoN> ) ) : <NEWLINE> <TAB> <BoN> axes <EoN> = [ <BoN> axes <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> r slice <EoN> = <BoN> tuple <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> each axis <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> x <EoN> . <BoN> ndim <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> each axis <EoN> <BoN> in <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> r slice <EoN> += ( <BoN> None <EoN> , ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> r slice <EoN> += ( <BoN> slice <EoN> ( <BoN> None <EoN> ) , ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> r <EoN> = <BoN> r <EoN> [ <BoN> r slice <EoN> ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> keepdims wrapped callable <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get value <EoN> ( <BoN> self <EoN> , <BoN> index <EoN> , <BoN> col <EoN> , <BoN> takeable <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <BoN> Future Warning <EoN> , <NEWLINE> <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get value <EoN> ( <BoN> index <EoN> , <BoN> col <EoN> , <BoN> takeable <EoN> = <BoN> takeable <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> G 1 <EoN> , <BoN> G 2 <EoN> , <BoN> temporal attribute name <EoN> , <BoN> delta <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> temporal attribute name <EoN> = <BoN> temporal attribute name <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> delta <EoN> = <BoN> delta <EoN> <NEWLINE> <BoN> super <EoN> ( <BoN> Time Respecting Di Graph Matcher <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> G 1 <EoN> , <BoN> G 2 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> and <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> graph def from checkpoint <EoN> ( <BoN> checkpoint dir <EoN> , <BoN> output node names <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> checkpoint path <EoN> = <BoN> saver lib <EoN> . <BoN> latest checkpoint <EoN> ( <BoN> checkpoint dir <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> checkpoint path <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> checkpoint dir <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> saver for restore <EoN> = <BoN> saver lib <EoN> . <BoN> import meta graph <EoN> ( <NEWLINE> <BoN> checkpoint path <EoN> + <STRING> , <BoN> clear devices <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> session <EoN> . <BoN> Session <EoN> ( ) <BoN> as <EoN> <BoN> sess <EoN> : <NEWLINE> <TAB> <BoN> saver for restore <EoN> . <BoN> restore <EoN> ( <BoN> sess <EoN> , <BoN> checkpoint path <EoN> ) <NEWLINE> <BoN> graph def <EoN> = <BoN> ops <EoN> . <BoN> get default graph <EoN> ( ) . <BoN> as graph def <EoN> ( ) <NEWLINE> <BoN> output graph def <EoN> = <BoN> graph util <EoN> . <BoN> convert variables to constants <EoN> ( <NEWLINE> <BoN> sess <EoN> , <BoN> graph def <EoN> , <BoN> output node names <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> output graph def <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> decode <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> typ <EoN> = <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> typ <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> obj <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> freq <EoN> = <BoN> obj <EoN> [ <STRING> ] <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> obj <EoN> <BoN> else <EoN> <BoN> obj <EoN> [ <STRING> ] <NEWLINE> <BoN> return <EoN> <BoN> Timestamp <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> tz <EoN> = <BoN> obj <EoN> [ <STRING> ] , <BoN> freq <EoN> = <BoN> freq <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Na T <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Period <EoN> ( <BoN> ordinal <EoN> = <BoN> obj <EoN> [ <STRING> ] , <BoN> freq <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype for <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> data <EoN> = <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> dtype <EoN> , <NEWLINE> <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) ) <NEWLINE> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> data <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype for <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> data <EoN> = <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> dtype <EoN> , <NEWLINE> <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) ) <NEWLINE> <BoN> data <EoN> = [ <BoN> tuple <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> data <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] . <BoN> from tuples <EoN> ( <BoN> data <EoN> , <BoN> names <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> np <EoN> . <BoN> int 64 <EoN> , <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) ) <NEWLINE> <BoN> d <EoN> = <BoN> dict <EoN> ( <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] , <BoN> freq <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] . <BoN> from ordinals <EoN> ( <BoN> data <EoN> , ** <BoN> d <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> np <EoN> . <BoN> int 64 <EoN> , <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) ) <NEWLINE> <BoN> d <EoN> = <BoN> dict <EoN> ( <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] , <BoN> freq <EoN> = <BoN> obj <EoN> [ <STRING> ] , <BoN> verify integrity <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> data <EoN> , ** <BoN> d <EoN> ) <NEWLINE> <BoN> tz <EoN> = <BoN> obj <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> tz <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> tz localize <EoN> ( <STRING> ) . <BoN> tz convert <EoN> ( <BoN> tz <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] . <BoN> from arrays <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> from codes <EoN> = <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] . <BoN> from codes <EoN> <NEWLINE> <BoN> return <EoN> <BoN> from codes <EoN> ( <BoN> codes <EoN> = <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> categories <EoN> = <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> ordered <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Interval <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype for <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> pd dtype <EoN> = <BoN> pandas dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> index <EoN> = <BoN> obj <EoN> [ <STRING> ] <NEWLINE> <BoN> result <EoN> = <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> dtype <EoN> , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] ) , <NEWLINE> <BoN> index <EoN> = <BoN> index <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> pd dtype <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> axes <EoN> = <BoN> obj <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> create block <EoN> ( <BoN> b <EoN> ) : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> safe reshape <EoN> ( <BoN> unconvert <EoN> ( <NEWLINE> <BoN> b <EoN> [ <STRING> ] , <BoN> dtype for <EoN> ( <BoN> b <EoN> [ <STRING> ] ) , <NEWLINE> <BoN> b <EoN> [ <STRING> ] ) , <BoN> b <EoN> [ <STRING> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> placement <EoN> = <BoN> b <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> placement <EoN> = <BoN> axes <EoN> [ <NUMBER> ] . <BoN> get indexer <EoN> ( <BoN> b <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> make block <EoN> ( <BoN> values <EoN> = <BoN> values <EoN> , <NEWLINE> <BoN> klass <EoN> = <BoN> getattr <EoN> ( <BoN> internals <EoN> , <BoN> b <EoN> [ <STRING> ] ) , <NEWLINE> <BoN> placement <EoN> = <BoN> placement <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> b <EoN> [ <STRING> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> blocks <EoN> = [ <BoN> create block <EoN> ( <BoN> b <EoN> ) <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> obj <EoN> [ <STRING> ] ] <NEWLINE> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> Block Manager <EoN> ( <BoN> blocks <EoN> , <BoN> axes <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> parse <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> datetime 64 <EoN> ( <BoN> parse <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> parse <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) . <BoN> date <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> timedelta <EoN> ( * <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> timedelta 64 <EoN> ( <BoN> int <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] , <NEWLINE> <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> globals <EoN> ( ) [ <BoN> obj <EoN> [ <STRING> ] ] ( <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> unconvert <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> np <EoN> . <BoN> type Dict <EoN> [ <BoN> obj <EoN> [ <STRING> ] ] , <NEWLINE> <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) ) . <BoN> reshape <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> obj <EoN> . <BoN> get <EoN> ( <STRING> ) == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> c 2 f <EoN> ( <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] , <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype for <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dtype <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dtype <EoN> . <BoN> type <EoN> ( <BoN> obj <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> typ <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> complex <EoN> ( <BoN> obj <EoN> [ <STRING> ] + <STRING> + <BoN> obj <EoN> [ <STRING> ] + <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , ( <BoN> dict <EoN> , <BoN> list <EoN> , <BoN> set <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> obj <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> obj <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Fully Connected <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> bias <EoN> = <BoN> None <EoN> , <BoN> num hidden <EoN> = <BoN> Null <EoN> , <BoN> no bias <EoN> = <BoN> Null <EoN> , <BoN> flatten <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> xor <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is memory usage qualified <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> is object <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> byte <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> read <EoN> ( <NUMBER> ) [ <NUMBER> ] <NEWLINE> <BoN> self <EoN> . <BoN> dtable <EoN> [ <BoN> byte <EoN> ] ( <BoN> self <EoN> , <BoN> byte <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> byte <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> state <EoN> <BoN> is <EoN> <BoN> dvistate <EoN> . <BoN> post post <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> setup dtype <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> dtype <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> dtype <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> typ <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> typlist <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> typ <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> NUMPY TYPE MAP <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> . <BoN> append <EoN> ( ( <STRING> + <BoN> str <EoN> ( <BoN> i <EoN> ) , <BoN> self <EoN> . <BoN> byteorder <EoN> + <NEWLINE> <BoN> self <EoN> . <BoN> NUMPY TYPE MAP <EoN> [ <BoN> typ <EoN> ] ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> . <BoN> append <EoN> ( ( <STRING> + <BoN> str <EoN> ( <BoN> i <EoN> ) , <STRING> + <BoN> str <EoN> ( <BoN> typ <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> broadcast <EoN> ( <BoN> self <EoN> , <BoN> tensor <EoN> , <BoN> destinations <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> validate destinations <EoN> ( <BoN> destinations <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> broadcast <EoN> ( <BoN> tensor <EoN> , <BoN> destinations <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trim overlap <EoN> ( <BoN> x <EoN> , <BoN> depth <EoN> , <BoN> boundary <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> axes <EoN> = <BoN> coerce depth <EoN> ( <BoN> x <EoN> . <BoN> ndim <EoN> , <BoN> depth <EoN> ) <NEWLINE> <BoN> boundary 2 <EoN> = <BoN> coerce boundary <EoN> ( <BoN> x <EoN> . <BoN> ndim <EoN> , <BoN> boundary <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> trim internal <EoN> ( <BoN> x <EoN> , <BoN> axes <EoN> = <BoN> axes <EoN> , <BoN> boundary <EoN> = <BoN> boundary 2 <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sub eager fallback <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , <BoN> inputs T <EoN> = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> x <EoN> , <BoN> y <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> ( <BoN> x <EoN> , <BoN> y <EoN> ) = <BoN> inputs T <EoN> <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> x <EoN> , <BoN> y <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> score <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> = <BoN> self <EoN> . <BoN> filter sk params <EoN> ( <BoN> Sequential <EoN> . <BoN> evaluate <EoN> , <BoN> kwargs <EoN> ) <NEWLINE> <BoN> loss <EoN> = <BoN> self <EoN> . <BoN> model <EoN> . <BoN> evaluate <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> loss <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> - <BoN> loss <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> - <BoN> loss <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert has rank <EoN> ( <BoN> self <EoN> , <BoN> rank <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rank <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <BoN> None <EoN> , <BoN> rank <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <BoN> self <EoN> , <BoN> rank <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> apply gradients <EoN> ( <BoN> self <EoN> , <BoN> grads and vars <EoN> , <BoN> global step <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> local vars <EoN> = [ <BoN> v <EoN> <BoN> for <EoN> <BoN> g <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> grads and vars <EoN> <BoN> if <EoN> <BoN> g <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> grads <EoN> = [ <BoN> g <EoN> <BoN> for <EoN> <BoN> g <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> grads and vars <EoN> <BoN> if <EoN> <BoN> g <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> variable creator <EoN> ( <BoN> next creator <EoN> , <BoN> collections <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> collections <EoN> : <NEWLINE> <TAB> <BoN> collections <EoN> = [ <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> LOCAL VARIABLES <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> GLOBAL VARIABLES <EoN> <BoN> in <EoN> <BoN> collections <EoN> : <NEWLINE> <TAB> <BoN> collections <EoN> = <BoN> list <EoN> ( <BoN> collections <EoN> ) <NEWLINE> <BoN> collections <EoN> . <BoN> append <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> LOCAL VARIABLES <EoN> ) <NEWLINE> <BoN> collections <EoN> . <BoN> remove <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> GLOBAL VARIABLES <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> next creator <EoN> ( <BoN> collections <EoN> = <BoN> collections <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> variable scope <EoN> . <BoN> variable creator scope <EoN> ( <BoN> variable creator <EoN> ) : <NEWLINE> <TAB> <BoN> local update op <EoN> = <BoN> self <EoN> . <BoN> opt <EoN> . <BoN> apply gradients <EoN> ( <BoN> grads and vars <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> update ops <EoN> = [ ] <NEWLINE> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> local update op <EoN> ) <NEWLINE> <BoN> grad vars <EoN> = [ <BoN> self <EoN> . <BoN> grad map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> g <EoN> , <BoN> grad var <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> grads <EoN> , <BoN> grad vars <EoN> ) : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign add <EoN> ( <BoN> grad var <EoN> , <BoN> g <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> global center vars <EoN> = [ <BoN> self <EoN> . <BoN> global map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> Update global variables <EoN> ( ) : <NEWLINE> <TAB> <BoN> global norm <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> g <EoN> <BoN> in <EoN> <BoN> grad vars <EoN> : <NEWLINE> <TAB> <BoN> global norm <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> g <EoN> , <BoN> g <EoN> / <BoN> self <EoN> . <BoN> period <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> global norm <EoN> ) : <NEWLINE> <TAB> <BoN> apply global op <EoN> = <BoN> self <EoN> . <BoN> opt <EoN> . <BoN> apply gradients <EoN> ( <NEWLINE> <BoN> zip <EoN> ( <BoN> grad vars <EoN> , <BoN> global center vars <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> apply global op <EoN> ] ) : <NEWLINE> <TAB> <BoN> update ops <EoN> = [ ] <NEWLINE> <BoN> if <EoN> <BoN> global step <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> colocate with <EoN> ( <BoN> global step <EoN> ) : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign add <EoN> ( <BoN> global step <EoN> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> lvar <EoN> <BoN> in <EoN> <BoN> local vars <EoN> : <NEWLINE> <TAB> <BoN> g val <EoN> = <BoN> self <EoN> . <BoN> global map <EoN> [ <BoN> lvar <EoN> ] . <BoN> read value <EoN> ( ) <NEWLINE> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> lvar <EoN> , <BoN> g val <EoN> ) ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> grad var <EoN> <BoN> in <EoN> <BoN> grad vars <EoN> : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> grad var <EoN> , <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> grad var <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> variable update <EoN> = <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * ( <BoN> update ops <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> variable update <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> local update <EoN> = <BoN> state ops <EoN> . <BoN> assign add <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> local step <EoN> , <NUMBER> , <BoN> name <EoN> = <STRING> ) . <BoN> op <EoN> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> local update <EoN> ] ) : <NEWLINE> <TAB> <BoN> condition <EoN> = <BoN> math ops <EoN> . <BoN> equal <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> mod <EoN> ( <BoN> self <EoN> . <BoN> local step <EoN> , <BoN> self <EoN> . <BoN> period <EoN> ) , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> update ops <EoN> ) : <NEWLINE> <TAB> <BoN> conditional update <EoN> = <BoN> control flow ops <EoN> . <BoN> cond <EoN> ( <NEWLINE> <BoN> condition <EoN> , <BoN> Update global variables <EoN> , <BoN> control flow ops <EoN> . <BoN> no op <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> conditional update <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> moon <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> load <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sin <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> wrap function <EoN> ( <BoN> fn <EoN> , <BoN> signature <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> holder <EoN> = <BoN> Variable Holder <EoN> ( <BoN> fn <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Wrapped Function <EoN> ( <NEWLINE> <BoN> func graph <EoN> . <BoN> func graph from py func <EoN> ( <NEWLINE> <BoN> name <EoN> , <NEWLINE> <BoN> holder <EoN> , <NEWLINE> <BoN> args <EoN> = <BoN> None <EoN> , <BoN> kwargs <EoN> = <BoN> None <EoN> , <BoN> signature <EoN> = <BoN> signature <EoN> , <NEWLINE> <BoN> add control dependencies <EoN> = <BoN> False <EoN> ) , <NEWLINE> <BoN> variable holder <EoN> = <BoN> holder <EoN> , <NEWLINE> <BoN> signature <EoN> = <BoN> signature <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sequence <EoN> ( <BoN> seq <EoN> , <BoN> limits <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> seq <EoN> = <BoN> sympify <EoN> ( <BoN> seq <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is sequence <EoN> ( <BoN> seq <EoN> , <BoN> Tuple <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Seq Per <EoN> ( <BoN> seq <EoN> , <BoN> limits <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Seq Formula <EoN> ( <BoN> seq <EoN> , <BoN> limits <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get init op <EoN> ( <BoN> self <EoN> , <BoN> task index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> Add sync queues and barrier <EoN> ( <BoN> enqueue after list <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sync queues <EoN> = [ <NEWLINE> <BoN> data flow ops <EoN> . <BoN> FIFO Queue <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> num worker <EoN> , [ <BoN> dtypes <EoN> . <BoN> bool <EoN> ] , <NEWLINE> <BoN> shapes <EoN> = [ [ ] ] , <NEWLINE> <BoN> shared name <EoN> = <STRING> % ( <STRING> , <BoN> i <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> num worker <EoN> ) <NEWLINE> ] <NEWLINE> <BoN> queue ops <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> token <EoN> = <BoN> constant op <EoN> . <BoN> constant <EoN> ( <BoN> False <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> enqueue after list <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> q <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> sync queues <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> == <BoN> task index <EoN> : <NEWLINE> <TAB> <BoN> queue ops <EoN> . <BoN> append <EoN> ( <BoN> control flow ops <EoN> . <BoN> no op <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> queue ops <EoN> . <BoN> append <EoN> ( <BoN> q <EoN> . <BoN> enqueue <EoN> ( <BoN> token <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> queue ops <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> sync queues <EoN> [ <BoN> task index <EoN> ] . <BoN> dequeue many <EoN> ( <BoN> len <EoN> ( <BoN> sync queues <EoN> ) - <NUMBER> ) ) <NEWLINE> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * <BoN> queue ops <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> init ops <EoN> = [ ] <NEWLINE> <BoN> local vars <EoN> = <BoN> variables <EoN> . <BoN> trainable variables <EoN> ( ) <NEWLINE> <BoN> global center vars <EoN> = [ <BoN> self <EoN> . <BoN> global map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <BoN> local center vars <EoN> = [ <BoN> self <EoN> . <BoN> local map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> local vars <EoN> <BoN> and <EoN> <BoN> global center vars <EoN> <BoN> and <EoN> <BoN> local center vars <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> lvar <EoN> , <BoN> gc var <EoN> , <BoN> lc var <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> local vars <EoN> , <BoN> global center vars <EoN> , <NEWLINE> <BoN> local center vars <EoN> ) : <NEWLINE> <TAB> <BoN> init ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> lvar <EoN> , <BoN> gc var <EoN> ) ) <NEWLINE> <BoN> init ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> lc var <EoN> , <BoN> gc var <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> init op <EoN> = <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * ( <BoN> init ops <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> synchronous <EoN> == <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> init op <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sync queue op <EoN> = <BoN> Add sync queues and barrier <EoN> ( [ <BoN> init op <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> sync queue op <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> docfiller <EoN> <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> mat stream <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Mat File 4 Reader <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> mat stream <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> matrix reader <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set solout <EoN> ( <BoN> self <EoN> , <BoN> solout <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> integrator <EoN> . <BoN> supports solout <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> integrator <EoN> . <BoN> set solout <EoN> ( <BoN> solout <EoN> , <BoN> complex <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> + <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> cbook <EoN> . <BoN> deprecated <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> vector lengths <EoN> ( <BoN> X <EoN> , <BoN> P <EoN> = <NUMBER> , <BoN> axis <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> X <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> X <EoN> ** ( <BoN> P <EoN> ) , <BoN> axis <EoN> = <BoN> axis <EoN> ) ) ** ( <NUMBER> / <BoN> P <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dtype for <EoN> ( <BoN> t <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> dtype dict <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dtype dict <EoN> [ <BoN> t <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> type Dict <EoN> . <BoN> get <EoN> ( <BoN> t <EoN> , <BoN> t <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> convert function input <EoN> ( <BoN> input <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> , <BoN> Symbolic Input <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> input <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> , <BoN> gof <EoN> . <BoN> Constant <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> , <NEWLINE> <BoN> input <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> In <EoN> ( <BoN> input <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> orig <EoN> = <BoN> input <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> input <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> input <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> [ <NUMBER> ] , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> input <EoN> [ <NUMBER> ] <NEWLINE> <BoN> input <EoN> = <BoN> input <EoN> [ <NUMBER> : ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> [ <NUMBER> ] , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input <EoN> [ <NUMBER> ] ) != <NUMBER> <BoN> or <EoN> <BoN> len <EoN> ( <BoN> input <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> orig <EoN> ) <NEWLINE> <UNTAB> ( <BoN> variable <EoN> , <BoN> update <EoN> ) , <BoN> value <EoN> = <BoN> input <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> [ <NUMBER> ] , <BoN> gof <EoN> . <BoN> Variable <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> variable <EoN> , <BoN> update <EoN> , <BoN> value <EoN> = <BoN> input <EoN> [ <NUMBER> ] , <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> input <EoN> ) == <NUMBER> : <NEWLINE> <TAB> ( <BoN> variable <EoN> , <BoN> value <EoN> ) , <BoN> update <EoN> = <BoN> input <EoN> , <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> orig <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> input <EoN> [ <NUMBER> ] , <BoN> Symbolic Input <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> input <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> input <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> input <EoN> , <BoN> value <EoN> = <BoN> input <EoN> <NEWLINE> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> input <EoN> . <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> input <EoN> . <BoN> value <EoN> = <BoN> value <EoN> <NEWLINE> <BoN> return <EoN> <BoN> input <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> input <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> variable <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> variable <EoN> ) , <BoN> variable <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> update <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> update <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> update <EoN> ) , <BoN> update <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> value <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> value <EoN> , ( <BoN> gof <EoN> . <BoN> Variable <EoN> , <BoN> Symbolic Input <EoN> ) ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> variable <EoN> , <BoN> value <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> In <EoN> ( <BoN> variable <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> value <EoN> = <BoN> value <EoN> , <BoN> update <EoN> = <BoN> update <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <NEWLINE> <BoN> type <EoN> ( <BoN> input <EoN> ) , <BoN> input <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp fateman poly F 2 <EoN> ( <BoN> n <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> u <EoN> = [ <BoN> K <EoN> ( <NUMBER> ) , <BoN> K <EoN> ( <NUMBER> ) ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> u <EoN> = [ <BoN> dmp one <EoN> ( <BoN> i <EoN> , <BoN> K <EoN> ) , <BoN> u <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> m <EoN> = <BoN> n <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <BoN> v <EoN> = <BoN> dmp add term <EoN> ( <BoN> u <EoN> , <BoN> dmp ground <EoN> ( <BoN> K <EoN> ( <NUMBER> ) , <BoN> m <EoN> - <NUMBER> ) , <NUMBER> , <BoN> n <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> f <EoN> = <BoN> dmp sqr <EoN> ( [ <BoN> dmp one <EoN> ( <BoN> m <EoN> , <BoN> K <EoN> ) , <BoN> dmp neg <EoN> ( <BoN> v <EoN> , <BoN> m <EoN> , <BoN> K <EoN> ) ] , <BoN> n <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> g <EoN> = <BoN> dmp sqr <EoN> ( [ <BoN> dmp one <EoN> ( <BoN> m <EoN> , <BoN> K <EoN> ) , <BoN> v <EoN> ] , <BoN> n <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> v <EoN> = <BoN> dmp add term <EoN> ( <BoN> u <EoN> , <BoN> dmp one <EoN> ( <BoN> m <EoN> - <NUMBER> , <BoN> K <EoN> ) , <NUMBER> , <BoN> n <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> h <EoN> = <BoN> dmp sqr <EoN> ( [ <BoN> dmp one <EoN> ( <BoN> m <EoN> , <BoN> K <EoN> ) , <BoN> v <EoN> ] , <BoN> n <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dmp mul <EoN> ( <BoN> f <EoN> , <BoN> h <EoN> , <BoN> n <EoN> , <BoN> K <EoN> ) , <BoN> dmp mul <EoN> ( <BoN> g <EoN> , <BoN> h <EoN> , <BoN> n <EoN> , <BoN> K <EoN> ) , <BoN> h <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> orthogonality <EoN> ( <BoN> A <EoN> , <BoN> g <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> norm g <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> g <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> issparse <EoN> ( <BoN> A <EoN> ) : <NEWLINE> <TAB> <BoN> norm A <EoN> = <BoN> scipy <EoN> . <BoN> sparse <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> A <EoN> , <BoN> ord <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> norm A <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> A <EoN> , <BoN> ord <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> norm g <EoN> == <NUMBER> <BoN> or <EoN> <BoN> norm A <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> norm A g <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> norm <EoN> ( <BoN> A <EoN> . <BoN> dot <EoN> ( <BoN> g <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> orth <EoN> = <BoN> norm A g <EoN> / ( <BoN> norm A <EoN> * <BoN> norm g <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> orth <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gather nd <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> indices <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get antialiased <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> antialiased <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pmf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> n <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> exp <EoN> ( <BoN> self <EoN> . <BoN> logpmf <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> p <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tensors to item <EoN> ( <BoN> self <EoN> , <BoN> keys to tensors <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> image buffer <EoN> = <BoN> keys to tensors <EoN> [ <BoN> self <EoN> . <BoN> image key <EoN> ] <NEWLINE> <BoN> image format <EoN> = <BoN> keys to tensors <EoN> [ <BoN> self <EoN> . <BoN> format key <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> repeated <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> functional ops <EoN> . <BoN> map fn <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> self <EoN> . <BoN> decode <EoN> ( <BoN> x <EoN> , <BoN> image format <EoN> ) , <NEWLINE> <BoN> image buffer <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> decode <EoN> ( <BoN> image buffer <EoN> , <BoN> image format <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> dir deletions <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> accessors <EoN> | <BoN> self <EoN> . <BoN> deprecations <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> copy <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> copyto <EoN> ( <BoN> self <EoN> . <BoN> context <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exp <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> q <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> vector norm <EoN> = <BoN> sqrt <EoN> ( <BoN> q <EoN> . <BoN> b <EoN> ** <NUMBER> + <BoN> q <EoN> . <BoN> c <EoN> ** <NUMBER> + <BoN> q <EoN> . <BoN> d <EoN> ** <NUMBER> ) <NEWLINE> <BoN> a <EoN> = <BoN> exp <EoN> ( <BoN> q <EoN> . <BoN> a <EoN> ) * <BoN> cos <EoN> ( <BoN> vector norm <EoN> ) <NEWLINE> <BoN> b <EoN> = <BoN> exp <EoN> ( <BoN> q <EoN> . <BoN> a <EoN> ) * <BoN> sin <EoN> ( <BoN> vector norm <EoN> ) * <BoN> q <EoN> . <BoN> b <EoN> / <BoN> vector norm <EoN> <NEWLINE> <BoN> c <EoN> = <BoN> exp <EoN> ( <BoN> q <EoN> . <BoN> a <EoN> ) * <BoN> sin <EoN> ( <BoN> vector norm <EoN> ) * <BoN> q <EoN> . <BoN> c <EoN> / <BoN> vector norm <EoN> <NEWLINE> <BoN> d <EoN> = <BoN> exp <EoN> ( <BoN> q <EoN> . <BoN> a <EoN> ) * <BoN> sin <EoN> ( <BoN> vector norm <EoN> ) * <BoN> q <EoN> . <BoN> d <EoN> / <BoN> vector norm <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Quaternion <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max memory allocated <EoN> ( <BoN> device <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> device <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> device <EoN> = <BoN> current device <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> cuda maxMemoryAllocated <EoN> ( <BoN> device <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> degree <EoN> ( <BoN> G <EoN> , <BoN> nbunch <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> . <BoN> degree <EoN> ( <BoN> nbunch <EoN> , <BoN> weight <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> groups <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tables <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> check if open <EoN> ( ) <NEWLINE> <BoN> return <EoN> [ <NEWLINE> <BoN> g <EoN> <BoN> for <EoN> <BoN> g <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> handle <EoN> . <BoN> walk nodes <EoN> ( ) <NEWLINE> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> g <EoN> , <BoN> table mod <EoN> . <BoN> link <EoN> . <BoN> Link <EoN> ) <BoN> and <EoN> <NEWLINE> ( <BoN> getattr <EoN> ( <BoN> g <EoN> . <BoN> v attrs <EoN> , <STRING> , <BoN> None <EoN> ) <BoN> or <EoN> <NEWLINE> <BoN> getattr <EoN> ( <BoN> g <EoN> , <STRING> , <BoN> None <EoN> ) <BoN> or <EoN> <NEWLINE> ( <BoN> isinstance <EoN> ( <BoN> g <EoN> , <BoN> table mod <EoN> . <BoN> table <EoN> . <BoN> Table <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> g <EoN> . <BoN> v name <EoN> != <BoN> u <EoN> ( <STRING> ) ) ) ) <NEWLINE> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> accumulate nv 2 <EoN> ( <BoN> inputs <EoN> , <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> inputs <EoN> , <NEWLINE> <STRING> , <BoN> shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> accumulate nv 2 eager fallback <EoN> ( <NEWLINE> <BoN> inputs <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> inputs <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> inputs <EoN> ) <NEWLINE> <UNTAB> <BoN> attr N <EoN> = <BoN> len <EoN> ( <BoN> inputs <EoN> ) <NEWLINE> <BoN> shape <EoN> = <BoN> execute <EoN> . <BoN> make shape <EoN> ( <BoN> shape <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> inputs <EoN> = <BoN> inputs <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> has neighbor <EoN> ( <BoN> self <EoN> , <BoN> u <EoN> , <BoN> v <EoN> , <BoN> key <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> has edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lstsq <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> q <EoN> , <BoN> r <EoN> = <BoN> qr <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> solve triangular <EoN> ( <BoN> r <EoN> , <BoN> q <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <BoN> residuals <EoN> = <BoN> b <EoN> - <BoN> a <EoN> . <BoN> dot <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> residuals <EoN> = ( <BoN> residuals <EoN> ** <NUMBER> ) . <BoN> sum <EoN> ( <BoN> keepdims <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> token <EoN> = <BoN> tokenize <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> rname <EoN> = <STRING> + <BoN> token <EoN> <NEWLINE> <BoN> rdsk <EoN> = { ( <BoN> rname <EoN> , ) : ( <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> matrix rank <EoN> , ( <BoN> r <EoN> . <BoN> name <EoN> , <NUMBER> , <NUMBER> ) ) } <NEWLINE> <BoN> rdsk <EoN> = <BoN> sharedict <EoN> . <BoN> merge <EoN> ( <BoN> r <EoN> . <BoN> dask <EoN> , ( <BoN> rname <EoN> , <BoN> rdsk <EoN> ) , <BoN> dependencies <EoN> = { <BoN> rname <EoN> : { <BoN> r <EoN> . <BoN> name <EoN> } } ) <NEWLINE> <NEWLINE> <BoN> rank <EoN> = <BoN> Array <EoN> ( <BoN> rdsk <EoN> , <BoN> rname <EoN> , <BoN> shape <EoN> = ( ) , <BoN> chunks <EoN> = ( ) , <BoN> dtype <EoN> = <BoN> int <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sname <EoN> = <STRING> + <BoN> token <EoN> <NEWLINE> <BoN> rt <EoN> = <BoN> r <EoN> . <BoN> T <EoN> <NEWLINE> <BoN> sdsk <EoN> = { ( <BoN> sname <EoN> , <NUMBER> ) : ( <BoN> sort decreasing <EoN> , <NEWLINE> ( <BoN> np <EoN> . <BoN> sqrt <EoN> , <NEWLINE> ( <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> eigvals <EoN> , <NEWLINE> ( <BoN> np <EoN> . <BoN> dot <EoN> , ( <BoN> rt <EoN> . <BoN> name <EoN> , <NUMBER> , <NUMBER> ) , ( <BoN> r <EoN> . <BoN> name <EoN> , <NUMBER> , <NUMBER> ) ) ) ) ) } <NEWLINE> <BoN> sdsk <EoN> = <BoN> sharedict <EoN> . <BoN> merge <EoN> ( <BoN> rt <EoN> . <BoN> dask <EoN> , ( <BoN> sname <EoN> , <BoN> sdsk <EoN> ) , <BoN> dependencies <EoN> = { <BoN> sname <EoN> : { <BoN> rt <EoN> . <BoN> name <EoN> } } ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> ss <EoN> = <BoN> np <EoN> . <BoN> linalg <EoN> . <BoN> lstsq <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( [ [ <NUMBER> , <NUMBER> ] , [ <NUMBER> , <NUMBER> ] ] , <BoN> dtype <EoN> = <BoN> a <EoN> . <BoN> dtype <EoN> ) , <NEWLINE> <BoN> np <EoN> . <BoN> array <EoN> ( [ <NUMBER> , <NUMBER> ] , <BoN> dtype <EoN> = <BoN> b <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <BoN> s <EoN> = <BoN> Array <EoN> ( <BoN> sdsk <EoN> , <BoN> sname <EoN> , <BoN> shape <EoN> = ( <BoN> r <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , ) , <NEWLINE> <BoN> chunks <EoN> = <BoN> r <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <BoN> dtype <EoN> = <BoN> ss <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> , <BoN> residuals <EoN> , <BoN> rank <EoN> , <BoN> s <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> eval cond <EoN> ( <BoN> cond <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> cond <EoN> , <BoN> bool <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cond <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> condsimp <EoN> ( <BoN> cond <EoN> . <BoN> doit <EoN> ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hypot <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get n splits <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> = <BoN> None <EoN> , <BoN> y <EoN> = <BoN> None <EoN> , <BoN> groups <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> groups <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> groups <EoN> = <BoN> check array <EoN> ( <BoN> groups <EoN> , <BoN> ensure 2 d <EoN> = <BoN> False <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> comb <EoN> ( <BoN> len <EoN> ( <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> groups <EoN> ) ) , <BoN> self <EoN> . <BoN> n groups <EoN> , <BoN> exact <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> draw spring <EoN> ( <BoN> G <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> draw <EoN> ( <BoN> G <EoN> , <BoN> spring layout <EoN> ( <BoN> G <EoN> ) , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> validate float or None <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> s <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> float <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> s <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> merge dict <EoN> ( <BoN> d 1 <EoN> , <BoN> d 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> d <EoN> = <BoN> d 1 <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> d 2 <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> d <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> k <EoN> ] += <BoN> v <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> d <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> to tree <EoN> ( <BoN> Z <EoN> , <BoN> rd <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> Z <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> Z <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <BoN> is valid linkage <EoN> ( <BoN> Z <EoN> , <BoN> throw <EoN> = <BoN> True <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> n <EoN> = <BoN> Z <EoN> . <BoN> shape <EoN> [ <NUMBER> ] + <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> d <EoN> = [ <BoN> None <EoN> ] * ( <BoN> n <EoN> * <NUMBER> - <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <NUMBER> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> i <EoN> ] = <BoN> Cluster Node <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> nd <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <NUMBER> , <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> fi <EoN> = <BoN> int <EoN> ( <BoN> Z <EoN> [ <BoN> i <EoN> , <NUMBER> ] ) <NEWLINE> <BoN> fj <EoN> = <BoN> int <EoN> ( <BoN> Z <EoN> [ <BoN> i <EoN> , <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> fi <EoN> > <BoN> i <EoN> + <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) % <BoN> fi <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fj <EoN> > <BoN> i <EoN> + <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) % <BoN> fj <EoN> ) <NEWLINE> <UNTAB> <BoN> nd <EoN> = <BoN> Cluster Node <EoN> ( <BoN> i <EoN> + <BoN> n <EoN> , <BoN> d <EoN> [ <BoN> fi <EoN> ] , <BoN> d <EoN> [ <BoN> fj <EoN> ] , <BoN> Z <EoN> [ <BoN> i <EoN> , <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> Z <EoN> [ <BoN> i <EoN> , <NUMBER> ] != <BoN> nd <EoN> . <BoN> count <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( ( <STRING> <NEWLINE> <STRING> ) % <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> d <EoN> [ <BoN> n <EoN> + <BoN> i <EoN> ] = <BoN> nd <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rd <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> nd <EoN> , <BoN> d <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nd <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> format data short <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> % <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logistic loss and grad <EoN> ( <BoN> w <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> alpha <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n samples <EoN> , <BoN> n features <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> grad <EoN> = <BoN> np <EoN> . <BoN> empty like <EoN> ( <BoN> w <EoN> ) <NEWLINE> <NEWLINE> <BoN> w <EoN> , <BoN> c <EoN> , <BoN> yz <EoN> = <BoN> intercept dot <EoN> ( <BoN> w <EoN> , <BoN> X <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( <BoN> n samples <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> out <EoN> = - <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> sample weight <EoN> * <BoN> log logistic <EoN> ( <BoN> yz <EoN> ) ) + <NUMBER> * <BoN> alpha <EoN> * <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> w <EoN> , <BoN> w <EoN> ) <NEWLINE> <NEWLINE> <BoN> z <EoN> = <BoN> expit <EoN> ( <BoN> yz <EoN> ) <NEWLINE> <BoN> z 0 <EoN> = <BoN> sample weight <EoN> * ( <BoN> z <EoN> - <NUMBER> ) * <BoN> y <EoN> <NEWLINE> <NEWLINE> <BoN> grad <EoN> [ : <BoN> n features <EoN> ] = <BoN> safe sparse dot <EoN> ( <BoN> X <EoN> . <BoN> T <EoN> , <BoN> z 0 <EoN> ) + <BoN> alpha <EoN> * <BoN> w <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> grad <EoN> . <BoN> shape <EoN> [ <NUMBER> ] > <BoN> n features <EoN> : <NEWLINE> <TAB> <BoN> grad <EoN> [ - <NUMBER> ] = <BoN> z 0 <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> , <BoN> grad <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eject <EoN> ( <BoN> f <EoN> , * <BoN> gens <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dom <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> dom <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dom <EoN> . <BoN> is Numerical <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Domain Error <EoN> ( <STRING> % <BoN> dom <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> , <BoN> k <EoN> = <BoN> len <EoN> ( <BoN> f <EoN> . <BoN> gens <EoN> ) , <BoN> len <EoN> ( <BoN> gens <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> . <BoN> gens <EoN> [ : <BoN> k <EoN> ] == <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> gens <EoN> , <BoN> front <EoN> = <BoN> f <EoN> . <BoN> gens <EoN> [ <BoN> k <EoN> : ] , <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> f <EoN> . <BoN> gens <EoN> [ - <BoN> k <EoN> : ] == <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> gens <EoN> , <BoN> front <EoN> = <BoN> f <EoN> . <BoN> gens <EoN> [ : - <BoN> k <EoN> ] , <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> dom <EoN> = <BoN> dom <EoN> . <BoN> inject <EoN> ( * <BoN> gens <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> eject <EoN> ( <BoN> dom <EoN> , <BoN> front <EoN> = <BoN> front <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Operation Not Supported <EoN> ( <BoN> f <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> new <EoN> ( <BoN> result <EoN> , * <BoN> gens <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ensure arraylike <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> is array like <EoN> ( <BoN> values <EoN> ) : <NEWLINE> <TAB> <BoN> inferred <EoN> = <BoN> lib <EoN> . <BoN> infer dtype <EoN> ( <BoN> values <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> inferred <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> values <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> list <EoN> ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <BoN> values <EoN> = <BoN> construct 1 d object array from listlike <EoN> ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> values <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> assert same float dtype <EoN> ( <BoN> tensors <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> tensors <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> assert same base type <EoN> ( <BoN> tensors <EoN> , <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> dtype <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> float 32 <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> dtype <EoN> . <BoN> is floating <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dtype <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup lshift <EoN> ( <BoN> f <EoN> , <BoN> n <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> + [ <BoN> K <EoN> . <BoN> zero <EoN> ] * <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fractional max pool <EoN> ( <BoN> value <EoN> , <BoN> pooling ratio <EoN> , <BoN> pseudo random <EoN> = <BoN> False <EoN> , <BoN> overlapping <EoN> = <BoN> False <EoN> , <BoN> deterministic <EoN> = <BoN> False <EoN> , <BoN> seed <EoN> = <NUMBER> , <BoN> seed 2 <EoN> = <NUMBER> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> value <EoN> , <NEWLINE> <STRING> , <BoN> pooling ratio <EoN> , <STRING> , <BoN> pseudo random <EoN> , <NEWLINE> <STRING> , <BoN> overlapping <EoN> , <STRING> , <BoN> deterministic <EoN> , <STRING> , <NEWLINE> <BoN> seed <EoN> , <STRING> , <BoN> seed 2 <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> FractionalMaxPoolOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fractional max pool eager fallback <EoN> ( <NEWLINE> <BoN> value <EoN> , <BoN> pooling ratio <EoN> = <BoN> pooling ratio <EoN> , <BoN> pseudo random <EoN> = <BoN> pseudo random <EoN> , <NEWLINE> <BoN> overlapping <EoN> = <BoN> overlapping <EoN> , <BoN> deterministic <EoN> = <BoN> deterministic <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> , <NEWLINE> <BoN> seed 2 <EoN> = <BoN> seed 2 <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> pooling ratio <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> pooling ratio <EoN> ) <NEWLINE> <UNTAB> <BoN> pooling ratio <EoN> = [ <BoN> execute <EoN> . <BoN> make float <EoN> ( <BoN> f <EoN> , <STRING> ) <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> pooling ratio <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> pseudo random <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> pseudo random <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> pseudo random <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> pseudo random <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> overlapping <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> overlapping <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> overlapping <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> overlapping <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> deterministic <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> deterministic <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> deterministic <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> deterministic <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> seed <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> seed <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> seed <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> seed 2 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed 2 <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> seed 2 <EoN> = <BoN> execute <EoN> . <BoN> make int <EoN> ( <BoN> seed 2 <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> value <EoN> = <BoN> value <EoN> , <BoN> pooling ratio <EoN> = <BoN> pooling ratio <EoN> , <NEWLINE> <BoN> pseudo random <EoN> = <BoN> pseudo random <EoN> , <NEWLINE> <BoN> overlapping <EoN> = <BoN> overlapping <EoN> , <NEWLINE> <BoN> deterministic <EoN> = <BoN> deterministic <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> , <NEWLINE> <BoN> seed 2 <EoN> = <BoN> seed 2 <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <NEWLINE> <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> FractionalMaxPoolOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval <EoN> ( <BoN> self <EoN> , <BoN> expr <EoN> , <BoN> assumptions <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> res <EoN> , <BoN> res <EoN> = <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <BoN> mro <EoN> = <BoN> inspect <EoN> . <BoN> getmro <EoN> ( <BoN> type <EoN> ( <BoN> expr <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> handler <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> handlers <EoN> : <NEWLINE> <TAB> <BoN> cls <EoN> = <BoN> get class <EoN> ( <BoN> handler <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> subclass <EoN> <BoN> in <EoN> <BoN> mro <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> eval <EoN> = <BoN> getattr <EoN> ( <BoN> cls <EoN> , <BoN> subclass <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> res <EoN> = <BoN> eval <EoN> ( <BoN> expr <EoN> , <BoN> assumptions <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> res <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> res <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> res <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> res <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> res <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> res <EoN> != <BoN> res <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> start pan <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> button <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> pan start <EoN> = <BoN> types <EoN> . <BoN> Simple Namespace <EoN> ( <NEWLINE> <BoN> lim <EoN> = <BoN> self <EoN> . <BoN> view Lim <EoN> . <BoN> frozen <EoN> ( ) , <NEWLINE> <BoN> trans <EoN> = <BoN> self <EoN> . <BoN> trans Data <EoN> . <BoN> frozen <EoN> ( ) , <NEWLINE> <BoN> trans inverse <EoN> = <BoN> self <EoN> . <BoN> trans Data <EoN> . <BoN> inverted <EoN> ( ) . <BoN> frozen <EoN> ( ) , <NEWLINE> <BoN> bbox <EoN> = <BoN> self <EoN> . <BoN> bbox <EoN> . <BoN> frozen <EoN> ( ) , <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> , <NEWLINE> <BoN> y <EoN> = <BoN> y <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> idxmax <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> skipna <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> get axis number <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> indices <EoN> = <BoN> nanops <EoN> . <BoN> nanargmax <EoN> ( <BoN> self <EoN> . <BoN> values <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> skipna <EoN> = <BoN> skipna <EoN> ) <NEWLINE> <BoN> index <EoN> = <BoN> self <EoN> . <BoN> get axis <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> result <EoN> = [ <BoN> index <EoN> [ <BoN> i <EoN> ] <BoN> if <EoN> <BoN> i <EoN> >= <NUMBER> <BoN> else <EoN> <BoN> np <EoN> . <BoN> nan <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> indices <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> Series <EoN> ( <BoN> result <EoN> , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> get agg axis <EoN> ( <BoN> axis <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> replace <EoN> ( <BoN> self <EoN> , <BoN> old <EoN> , <BoN> new <EoN> , <BoN> count <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> asarray <EoN> ( <BoN> replace <EoN> ( <BoN> self <EoN> , <BoN> old <EoN> , <BoN> new <EoN> , <BoN> count <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getstate <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> state <EoN> = <BoN> self <EoN> . <BoN> dict <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> state <EoN> : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> state <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> state <EoN> [ <STRING> ] . <BoN> pop <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> state <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> next <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> next <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fromfile <EoN> ( <BoN> self <EoN> , <BoN> parent <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fh <EoN> = <BoN> parent <EoN> . <BoN> filehandle <EoN> <NEWLINE> <BoN> byteorder <EoN> = <BoN> parent <EoN> . <BoN> byteorder <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> offset <EoN> = <BoN> fh <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> value offset <EoN> = <BoN> self <EoN> . <BoN> offset <EoN> + <BoN> parent <EoN> . <BoN> offset size <EoN> + <NUMBER> <NEWLINE> <NEWLINE> <BoN> fmt <EoN> , <BoN> size <EoN> = { <NUMBER> : ( <STRING> , <NUMBER> ) , <NUMBER> : ( <STRING> , <NUMBER> ) } [ <BoN> parent <EoN> . <BoN> offset size <EoN> ] <NEWLINE> <BoN> data <EoN> = <BoN> fh <EoN> . <BoN> read <EoN> ( <BoN> size <EoN> ) <NEWLINE> <BoN> code <EoN> , <BoN> dtype <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> byteorder <EoN> + <BoN> fmt <EoN> [ : <NUMBER> ] , <BoN> data <EoN> [ : <NUMBER> ] ) <NEWLINE> <BoN> count <EoN> , <BoN> value <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> byteorder <EoN> + <BoN> fmt <EoN> [ <NUMBER> : ] , <BoN> data <EoN> [ <NUMBER> : ] ) <NEWLINE> <BoN> self <EoN> . <BoN> value <EoN> = <BoN> value <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> type <EoN> = <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> code <EoN> <BoN> in <EoN> <BoN> TIFF TAGS <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> cout <EoN> , <BoN> <EoN> = <BoN> TIFF TAGS <EoN> [ <BoN> code <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> cout <EoN> <BoN> and <EoN> <BoN> cout <EoN> != <BoN> count <EoN> : <NEWLINE> <TAB> <BoN> count <EoN> = <BoN> cout <EoN> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> % <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> code <EoN> <BoN> in <EoN> <BoN> CUSTOM TAGS <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> CUSTOM TAGS <EoN> [ <BoN> code <EoN> ] [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> str <EoN> ( <BoN> code <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> TIFF DATA TYPES <EoN> [ <BoN> self <EoN> . <BoN> type <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Tiff Tag <EoN> . <BoN> Error <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> type <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> fmt <EoN> = <STRING> % ( <BoN> byteorder <EoN> , <BoN> count <EoN> * <BoN> int <EoN> ( <BoN> dtype <EoN> [ <NUMBER> ] ) , <BoN> dtype <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> size <EoN> = <BoN> struct <EoN> . <BoN> calcsize <EoN> ( <BoN> fmt <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> size <EoN> > <BoN> parent <EoN> . <BoN> offset size <EoN> <BoN> or <EoN> <BoN> code <EoN> <BoN> in <EoN> <BoN> CUSTOM TAGS <EoN> : <NEWLINE> <TAB> <BoN> pos <EoN> = <BoN> fh <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> tof <EoN> = { <NUMBER> : <STRING> , <NUMBER> : <STRING> } [ <BoN> parent <EoN> . <BoN> offset size <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> value offset <EoN> = <BoN> offset <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> byteorder <EoN> + <BoN> tof <EoN> , <BoN> value <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> offset <EoN> < <NUMBER> <BoN> or <EoN> <BoN> offset <EoN> > <BoN> parent <EoN> . <BoN> filehandle <EoN> . <BoN> size <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Tiff Tag <EoN> . <BoN> Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> offset <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Tiff Tag <EoN> . <BoN> Error <EoN> ( <STRING> % <BoN> code <EoN> ) <NEWLINE> <UNTAB> <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> offset <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> code <EoN> <BoN> in <EoN> <BoN> CUSTOM TAGS <EoN> : <NEWLINE> <TAB> <BoN> readfunc <EoN> = <BoN> CUSTOM TAGS <EoN> [ <BoN> code <EoN> ] [ <NUMBER> ] <NEWLINE> <BoN> value <EoN> = <BoN> readfunc <EoN> ( <BoN> fh <EoN> , <BoN> byteorder <EoN> , <BoN> dtype <EoN> , <BoN> count <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> Record <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> code <EoN> <BoN> in <EoN> <BoN> TIFF TAGS <EoN> <BoN> or <EoN> <BoN> dtype <EoN> [ - <NUMBER> ] == <STRING> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> fmt <EoN> , <BoN> fh <EoN> . <BoN> read <EoN> ( <BoN> size <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> read numpy <EoN> ( <BoN> fh <EoN> , <BoN> byteorder <EoN> , <BoN> dtype <EoN> , <BoN> count <EoN> ) <NEWLINE> <UNTAB> <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> pos <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <BoN> fmt <EoN> , <BoN> value <EoN> [ : <BoN> size <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> code <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> CUSTOM TAGS <EoN> <BoN> and <EoN> <BoN> code <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <NEWLINE> <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> value <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> value <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> ( <BoN> dtype <EoN> . <BoN> endswith <EoN> ( <STRING> ) <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> bytes <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> type <EoN> != <NUMBER> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> stripascii <EoN> ( <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> code <EoN> = <BoN> code <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> dtype <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> count <EoN> = <BoN> count <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> value <EoN> = <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from config <EoN> ( <BoN> cls <EoN> , <BoN> config <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> cls <EoN> ( ** <BoN> config <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> construct from string <EoN> ( <BoN> cls <EoN> , <BoN> string <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> string <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> ( <BoN> string <EoN> ) <NEWLINE> <UNTAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> typ <EoN> = <BoN> type <EoN> ( <BoN> string <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> validate markevery <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> slice <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> tup Max Length <EoN> = <NUMBER> <NEWLINE> <BoN> tup Type <EoN> = <BoN> type <EoN> ( <BoN> s <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> s <EoN> ) != <BoN> tup Max Length <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> % ( <BoN> tup Max Length <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tup Type <EoN> <BoN> is <EoN> <BoN> int <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> isinstance <EoN> ( <BoN> e <EoN> , <BoN> int <EoN> ) <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tup Type <EoN> <BoN> is <EoN> <BoN> float <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> isinstance <EoN> ( <BoN> e <EoN> , <BoN> float <EoN> ) <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tup Type <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> float <EoN> <BoN> and <EoN> <BoN> tup Type <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> int <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> isinstance <EoN> ( <BoN> e <EoN> , <BoN> int <EoN> ) <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , ( <BoN> float <EoN> , <BoN> int <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> buffer put lines <EoN> ( <BoN> buf <EoN> , <BoN> lines <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> isinstance <EoN> ( <BoN> x <EoN> , <BoN> compat <EoN> . <BoN> text type <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> lines <EoN> ) : <NEWLINE> <TAB> <BoN> lines <EoN> = [ <BoN> compat <EoN> . <BoN> text type <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> lines <EoN> ] <NEWLINE> <UNTAB> <BoN> buf <EoN> . <BoN> write <EoN> ( <STRING> . <BoN> join <EoN> ( <BoN> lines <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> hamiltonian path <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> G <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> G <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> arbitrary element <EoN> ( <BoN> G <EoN> ) ] <NEWLINE> <UNTAB> <BoN> v <EoN> = <BoN> arbitrary element <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> hampath <EoN> = <BoN> hamiltonian path <EoN> ( <BoN> G <EoN> . <BoN> subgraph <EoN> ( <BoN> set <EoN> ( <BoN> G <EoN> ) - { <BoN> v <EoN> } ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> index <EoN> = <BoN> index satisfying <EoN> ( <BoN> hampath <EoN> , <BoN> lambda <EoN> <BoN> u <EoN> : <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> G <EoN> [ <BoN> u <EoN> ] ) <NEWLINE> <BoN> hampath <EoN> . <BoN> insert <EoN> ( <BoN> index <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> hampath <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to json <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> = <BoN> self <EoN> . <BoN> get config <EoN> ( ) <NEWLINE> <BoN> timeseries generator config <EoN> = { <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> , <NEWLINE> <STRING> : <BoN> config <EoN> <NEWLINE> } <NEWLINE> <BoN> return <EoN> <BoN> json <EoN> . <BoN> dumps <EoN> ( <BoN> timeseries generator config <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get sketch params <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> sketch <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> k components <EoN> ( <BoN> G <EoN> , <BoN> flow func <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> k components <EoN> = <BoN> defaultdict <EoN> ( <BoN> list <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> flow func <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> flow func <EoN> = <BoN> default flow func <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> component <EoN> <BoN> in <EoN> <BoN> nx <EoN> . <BoN> connected components <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> comp <EoN> = <BoN> set <EoN> ( <BoN> component <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> comp <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> k components <EoN> [ <NUMBER> ] . <BoN> append <EoN> ( <BoN> comp <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> bicomponents <EoN> = <BoN> list <EoN> ( <BoN> nx <EoN> . <BoN> biconnected component subgraphs <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> bicomponent <EoN> <BoN> in <EoN> <BoN> bicomponents <EoN> : <NEWLINE> <TAB> <BoN> bicomp <EoN> = <BoN> set <EoN> ( <BoN> bicomponent <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> bicomp <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> k components <EoN> [ <NUMBER> ] . <BoN> append <EoN> ( <BoN> bicomp <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> B <EoN> <BoN> in <EoN> <BoN> bicomponents <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> B <EoN> ) <= <NUMBER> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> nx <EoN> . <BoN> node connectivity <EoN> ( <BoN> B <EoN> , <BoN> flow func <EoN> = <BoN> flow func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> k components <EoN> [ <BoN> k <EoN> ] . <BoN> append <EoN> ( <BoN> set <EoN> ( <BoN> B <EoN> . <BoN> nodes <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> cuts <EoN> = <BoN> list <EoN> ( <BoN> nx <EoN> . <BoN> all node cuts <EoN> ( <BoN> B <EoN> , <BoN> k <EoN> = <BoN> k <EoN> , <BoN> flow func <EoN> = <BoN> flow func <EoN> ) ) <NEWLINE> <BoN> stack <EoN> = [ ( <BoN> k <EoN> , <BoN> generate partition <EoN> ( <BoN> B <EoN> , <BoN> cuts <EoN> , <BoN> k <EoN> ) ) ] <NEWLINE> <BoN> while <EoN> <BoN> stack <EoN> : <NEWLINE> <TAB> ( <BoN> parent k <EoN> , <BoN> partition <EoN> ) = <BoN> stack <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> nodes <EoN> = <BoN> next <EoN> ( <BoN> partition <EoN> ) <NEWLINE> <BoN> C <EoN> = <BoN> B <EoN> . <BoN> subgraph <EoN> ( <BoN> nodes <EoN> ) <NEWLINE> <BoN> this k <EoN> = <BoN> nx <EoN> . <BoN> node connectivity <EoN> ( <BoN> C <EoN> , <BoN> flow func <EoN> = <BoN> flow func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> this k <EoN> > <BoN> parent k <EoN> <BoN> and <EoN> <BoN> this k <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> k components <EoN> [ <BoN> this k <EoN> ] . <BoN> append <EoN> ( <BoN> set <EoN> ( <BoN> C <EoN> . <BoN> nodes <EoN> ( ) ) ) <NEWLINE> <UNTAB> <BoN> cuts <EoN> = <BoN> list <EoN> ( <BoN> nx <EoN> . <BoN> all node cuts <EoN> ( <BoN> C <EoN> , <BoN> k <EoN> = <BoN> this k <EoN> , <BoN> flow func <EoN> = <BoN> flow func <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> cuts <EoN> : <NEWLINE> <TAB> <BoN> stack <EoN> . <BoN> append <EoN> ( ( <BoN> this k <EoN> , <BoN> generate partition <EoN> ( <BoN> C <EoN> , <BoN> cuts <EoN> , <BoN> this k <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> stack <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> reconstruct k components <EoN> ( <BoN> k components <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reduce <EoN> ( <BoN> self <EoN> , <BoN> initial state <EoN> , <BoN> reduce func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> initial state <EoN> = <BoN> nest <EoN> . <BoN> pack sequence as <EoN> ( <BoN> initial state <EoN> , [ <NEWLINE> <BoN> sparse tensor lib <EoN> . <BoN> Sparse Tensor <EoN> . <BoN> from value <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> sparse tensor lib <EoN> . <BoN> is sparse <EoN> ( <BoN> t <EoN> ) <BoN> else <EoN> <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <NEWLINE> <BoN> t <EoN> , <BoN> name <EoN> = <STRING> % <BoN> i <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> initial state <EoN> ) ) <NEWLINE> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> state classes <EoN> = <BoN> sparse <EoN> . <BoN> get classes <EoN> ( <BoN> initial state <EoN> ) <NEWLINE> <BoN> state shapes <EoN> = <BoN> nest <EoN> . <BoN> pack sequence as <EoN> ( <NEWLINE> <BoN> initial state <EoN> , [ <BoN> t <EoN> . <BoN> get shape <EoN> ( ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> initial state <EoN> ) ] ) <NEWLINE> <BoN> state types <EoN> = <BoN> nest <EoN> . <BoN> pack sequence as <EoN> ( <NEWLINE> <BoN> initial state <EoN> , [ <BoN> t <EoN> . <BoN> dtype <EoN> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> initial state <EoN> ) ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> need to rerun <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> while <EoN> <BoN> need to rerun <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> wrapped func <EoN> = <BoN> Structured Function Wrapper <EoN> ( <NEWLINE> <BoN> reduce func <EoN> , <NEWLINE> <STRING> , <NEWLINE> <BoN> input classes <EoN> = ( <BoN> state classes <EoN> , <BoN> self <EoN> . <BoN> output classes <EoN> ) , <NEWLINE> <BoN> input shapes <EoN> = ( <BoN> state shapes <EoN> , <BoN> self <EoN> . <BoN> output shapes <EoN> ) , <NEWLINE> <BoN> input types <EoN> = ( <BoN> state types <EoN> , <BoN> self <EoN> . <BoN> output types <EoN> ) , <NEWLINE> <BoN> add to graph <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> output classes <EoN> = <BoN> wrapped func <EoN> . <BoN> output classes <EoN> <NEWLINE> <BoN> for <EoN> <BoN> new state class <EoN> , <BoN> state class <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <NEWLINE> <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> output classes <EoN> ) , <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> state classes <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> issubclass <EoN> ( <BoN> new state class <EoN> , <BoN> state class <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % ( <BoN> state classes <EoN> , <NEWLINE> <BoN> wrapped func <EoN> . <BoN> output classes <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> output types <EoN> = <BoN> wrapped func <EoN> . <BoN> output types <EoN> <NEWLINE> <BoN> for <EoN> <BoN> new state type <EoN> , <BoN> state type <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <NEWLINE> <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> output types <EoN> ) , <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> state types <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> new state type <EoN> != <BoN> state type <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % ( <BoN> state types <EoN> , <NEWLINE> <BoN> wrapped func <EoN> . <BoN> output types <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> output shapes <EoN> = <BoN> wrapped func <EoN> . <BoN> output shapes <EoN> <NEWLINE> <BoN> flat state shapes <EoN> = <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> state shapes <EoN> ) <NEWLINE> <BoN> flat new state shapes <EoN> = <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> output shapes <EoN> ) <NEWLINE> <BoN> weakened state shapes <EoN> = [ <NEWLINE> <BoN> original <EoN> . <BoN> most specific compatible shape <EoN> ( <BoN> new <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> original <EoN> , <BoN> new <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> flat state shapes <EoN> , <BoN> flat new state shapes <EoN> ) <NEWLINE> ] <NEWLINE> <NEWLINE> <BoN> need to rerun <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> original shape <EoN> , <BoN> weakened shape <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> flat state shapes <EoN> , <NEWLINE> <BoN> weakened state shapes <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> original shape <EoN> . <BoN> ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> ( <NEWLINE> <BoN> weakened shape <EoN> . <BoN> ndims <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <NEWLINE> <BoN> original shape <EoN> . <BoN> as list <EoN> ( ) != <BoN> weakened shape <EoN> . <BoN> as list <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> need to rerun <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> need to rerun <EoN> : <NEWLINE> <TAB> <BoN> state shapes <EoN> = <BoN> nest <EoN> . <BoN> pack sequence as <EoN> ( <BoN> state shapes <EoN> , <NEWLINE> <BoN> weakened state shapes <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> reduce func <EoN> = <BoN> wrapped func <EoN> . <BoN> function <EoN> <NEWLINE> <BoN> reduce func <EoN> . <BoN> add to graph <EoN> ( <BoN> ops <EoN> . <BoN> get default graph <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> sparse <EoN> . <BoN> deserialize sparse tensors <EoN> ( <NEWLINE> <BoN> nest <EoN> . <BoN> pack sequence as <EoN> ( <NEWLINE> <BoN> output types <EoN> , <NEWLINE> <BoN> gen dataset ops <EoN> . <BoN> reduce dataset <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> as variant tensor <EoN> ( ) , <NEWLINE> <BoN> nest <EoN> . <BoN> flatten <EoN> ( <BoN> sparse <EoN> . <BoN> serialize sparse tensors <EoN> ( <BoN> initial state <EoN> ) ) , <NEWLINE> <BoN> reduce func <EoN> . <BoN> captured inputs <EoN> , <NEWLINE> <BoN> f <EoN> = <BoN> reduce func <EoN> , <NEWLINE> <BoN> output shapes <EoN> = <BoN> nest <EoN> . <BoN> flatten <EoN> ( <NEWLINE> <BoN> sparse <EoN> . <BoN> as dense shapes <EoN> ( <BoN> output shapes <EoN> , <BoN> output classes <EoN> ) ) , <NEWLINE> <BoN> output types <EoN> = <BoN> nest <EoN> . <BoN> flatten <EoN> ( <NEWLINE> <BoN> sparse <EoN> . <BoN> as dense types <EoN> ( <BoN> output types <EoN> , <BoN> output classes <EoN> ) ) ) ) , <NEWLINE> <BoN> output types <EoN> , <NEWLINE> <BoN> output shapes <EoN> , <NEWLINE> <BoN> output classes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load diabetes <EoN> ( <BoN> return X y <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> module path <EoN> = <BoN> dirname <EoN> ( <BoN> file <EoN> ) <NEWLINE> <BoN> base dir <EoN> = <BoN> join <EoN> ( <BoN> module path <EoN> , <STRING> ) <NEWLINE> <BoN> data filename <EoN> = <BoN> join <EoN> ( <BoN> base dir <EoN> , <STRING> ) <NEWLINE> <BoN> data <EoN> = <BoN> np <EoN> . <BoN> loadtxt <EoN> ( <BoN> data filename <EoN> ) <NEWLINE> <BoN> target filename <EoN> = <BoN> join <EoN> ( <BoN> base dir <EoN> , <STRING> ) <NEWLINE> <BoN> target <EoN> = <BoN> np <EoN> . <BoN> loadtxt <EoN> ( <BoN> target filename <EoN> ) <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> join <EoN> ( <BoN> module path <EoN> , <STRING> , <STRING> ) ) <BoN> as <EoN> <BoN> rst file <EoN> : <NEWLINE> <TAB> <BoN> fdescr <EoN> = <BoN> rst file <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> return X y <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> data <EoN> , <BoN> target <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Bunch <EoN> ( <BoN> data <EoN> = <BoN> data <EoN> , <BoN> target <EoN> = <BoN> target <EoN> , <BoN> DESC R <EoN> = <BoN> fdescr <EoN> , <NEWLINE> <BoN> feature names <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <BoN> data filename <EoN> = <BoN> data filename <EoN> , <NEWLINE> <BoN> target filename <EoN> = <BoN> target filename <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get kerning <EoN> ( <BoN> self <EoN> , <BoN> next <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> advance <EoN> = <BoN> self <EoN> . <BoN> metrics <EoN> . <BoN> advance <EoN> - <BoN> self <EoN> . <BoN> width <EoN> <NEWLINE> <BoN> kern <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> next <EoN> , <BoN> Char <EoN> ) : <NEWLINE> <TAB> <BoN> kern <EoN> = <BoN> self <EoN> . <BoN> font output <EoN> . <BoN> get kern <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> font <EoN> , <BoN> self <EoN> . <BoN> font class <EoN> , <BoN> self <EoN> . <BoN> c <EoN> , <BoN> self <EoN> . <BoN> fontsize <EoN> , <NEWLINE> <BoN> next <EoN> . <BoN> font <EoN> , <BoN> next <EoN> . <BoN> font class <EoN> , <BoN> next <EoN> . <BoN> c <EoN> , <BoN> next <EoN> . <BoN> fontsize <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> dpi <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> advance <EoN> + <BoN> kern <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> scipy univariate kde <EoN> ( <BoN> data <EoN> , <BoN> bw <EoN> , <BoN> gridsize <EoN> , <BoN> cut <EoN> , <BoN> clip <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> kde <EoN> = <BoN> stats <EoN> . <BoN> gaussian kde <EoN> ( <BoN> data <EoN> , <BoN> bw method <EoN> = <BoN> bw <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> kde <EoN> = <BoN> stats <EoN> . <BoN> gaussian kde <EoN> ( <BoN> data <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> bw <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> , <BoN> User Warning <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> bw <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> bw <EoN> = <STRING> <BoN> if <EoN> <BoN> bw <EoN> == <STRING> <BoN> else <EoN> <BoN> bw <EoN> <NEWLINE> <BoN> bw <EoN> = <BoN> getattr <EoN> ( <BoN> kde <EoN> , <STRING> % <BoN> bw <EoN> ) ( ) * <BoN> np <EoN> . <BoN> std <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <BoN> grid <EoN> = <BoN> kde support <EoN> ( <BoN> data <EoN> , <BoN> bw <EoN> , <BoN> gridsize <EoN> , <BoN> cut <EoN> , <BoN> clip <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> kde <EoN> ( <BoN> grid <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> grid <EoN> , <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> translate connect args <EoN> ( <BoN> self <EoN> , <BoN> names <EoN> = [ ] , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> translated <EoN> = { } <NEWLINE> <BoN> attribute names <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> for <EoN> <BoN> sname <EoN> <BoN> in <EoN> <BoN> attribute names <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> names <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> names <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> sname <EoN> <BoN> in <EoN> <BoN> kw <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> kw <EoN> [ <BoN> sname <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> sname <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> getattr <EoN> ( <BoN> self <EoN> , <BoN> sname <EoN> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> translated <EoN> [ <BoN> name <EoN> ] = <BoN> getattr <EoN> ( <BoN> self <EoN> , <BoN> sname <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> translated <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> new shared <EoN> ( <BoN> cls <EoN> , <BoN> size <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> torch <EoN> . <BoN> multiprocessing <EoN> <BoN> import <EoN> <BoN> get sharing strategy <EoN> <NEWLINE> <BoN> if <EoN> <BoN> cls <EoN> . <BoN> is cuda <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> ( <BoN> size <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> get sharing strategy <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> . <BoN> new using filename <EoN> ( <BoN> size <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cls <EoN> . <BoN> new using fd <EoN> ( <BoN> size <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> array 3 d <EoN> ( <BoN> surface <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> numpysf <EoN> . <BoN> array 3 d <EoN> ( <BoN> surface <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> triad graph <EoN> ( <BoN> triad name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> triad name <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> TRIAD EDGES <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> triad name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> G <EoN> = <BoN> Di Graph <EoN> ( ) <NEWLINE> <BoN> G <EoN> . <BoN> add nodes from <EoN> ( <STRING> ) <NEWLINE> <BoN> G <EoN> . <BoN> add edges from <EoN> ( <BoN> TRIAD EDGES <EoN> [ <BoN> triad name <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> integrate rk 12 <EoN> ( <BoN> x 0 <EoN> , <BoN> y 0 <EoN> , <BoN> dmap <EoN> , <BoN> f <EoN> , <BoN> maxlength <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> maxerror <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> maxds <EoN> = <BoN> min <EoN> ( <NUMBER> / <BoN> dmap <EoN> . <BoN> mask <EoN> . <BoN> nx <EoN> , <NUMBER> / <BoN> dmap <EoN> . <BoN> mask <EoN> . <BoN> ny <EoN> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> ds <EoN> = <BoN> maxds <EoN> <NEWLINE> <BoN> stotal <EoN> = <NUMBER> <NEWLINE> <BoN> xi <EoN> = <BoN> x 0 <EoN> <NEWLINE> <BoN> yi <EoN> = <BoN> y 0 <EoN> <NEWLINE> <BoN> xf traj <EoN> = [ ] <NEWLINE> <BoN> yf traj <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> dmap <EoN> . <BoN> grid <EoN> . <BoN> within grid <EoN> ( <BoN> xi <EoN> , <BoN> yi <EoN> ) : <NEWLINE> <TAB> <BoN> xf traj <EoN> . <BoN> append <EoN> ( <BoN> xi <EoN> ) <NEWLINE> <BoN> yf traj <EoN> . <BoN> append <EoN> ( <BoN> yi <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> k 1 x <EoN> , <BoN> k 1 y <EoN> = <BoN> f <EoN> ( <BoN> xi <EoN> , <BoN> yi <EoN> ) <NEWLINE> <BoN> k 2 x <EoN> , <BoN> k 2 y <EoN> = <BoN> f <EoN> ( <BoN> xi <EoN> + <BoN> ds <EoN> * <BoN> k 1 x <EoN> , <NEWLINE> <BoN> yi <EoN> + <BoN> ds <EoN> * <BoN> k 1 y <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Index Error <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> ds <EoN> , <BoN> xf traj <EoN> , <BoN> yf traj <EoN> = <BoN> euler step <EoN> ( <BoN> xf traj <EoN> , <BoN> yf traj <EoN> , <BoN> dmap <EoN> , <BoN> f <EoN> ) <NEWLINE> <BoN> stotal <EoN> += <BoN> ds <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Terminate Trajectory <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> dx 1 <EoN> = <BoN> ds <EoN> * <BoN> k 1 x <EoN> <NEWLINE> <BoN> dy 1 <EoN> = <BoN> ds <EoN> * <BoN> k 1 y <EoN> <NEWLINE> <BoN> dx 2 <EoN> = <BoN> ds <EoN> * <NUMBER> * ( <BoN> k 1 x <EoN> + <BoN> k 2 x <EoN> ) <NEWLINE> <BoN> dy 2 <EoN> = <BoN> ds <EoN> * <NUMBER> * ( <BoN> k 1 y <EoN> + <BoN> k 2 y <EoN> ) <NEWLINE> <NEWLINE> <BoN> nx <EoN> , <BoN> ny <EoN> = <BoN> dmap <EoN> . <BoN> grid <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> error <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( ( ( <BoN> dx 2 <EoN> - <BoN> dx 1 <EoN> ) / <BoN> nx <EoN> ) ** <NUMBER> + ( ( <BoN> dy 2 <EoN> - <BoN> dy 1 <EoN> ) / <BoN> ny <EoN> ) ** <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> error <EoN> < <BoN> maxerror <EoN> : <NEWLINE> <TAB> <BoN> xi <EoN> += <BoN> dx 2 <EoN> <NEWLINE> <BoN> yi <EoN> += <BoN> dy 2 <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> dmap <EoN> . <BoN> update trajectory <EoN> ( <BoN> xi <EoN> , <BoN> yi <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Invalid Index Error <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stotal <EoN> + <BoN> ds <EoN> > <BoN> maxlength <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> stotal <EoN> += <BoN> ds <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> error <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> ds <EoN> = <BoN> maxds <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ds <EoN> = <BoN> min <EoN> ( <BoN> maxds <EoN> , <NUMBER> * <BoN> ds <EoN> * ( <BoN> maxerror <EoN> / <BoN> error <EoN> ) ** <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> stotal <EoN> , <BoN> xf traj <EoN> , <BoN> yf traj <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample poisson <EoN> ( <BoN> lam <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> check valid event ndims <EoN> ( <BoN> self <EoN> , <BoN> min event ndims <EoN> , <BoN> event ndims <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> event ndims <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> event ndims <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> event ndims <EoN> = <BoN> tensor util <EoN> . <BoN> constant value <EoN> ( <BoN> event ndims <EoN> ) <NEWLINE> <BoN> assertions <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> event ndims <EoN> . <BoN> dtype <EoN> . <BoN> is integer <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> event ndims <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> event ndims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> event ndims <EoN> . <BoN> shape <EoN> . <BoN> ndims <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> event ndims <EoN> . <BoN> shape <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> min event ndims <EoN> > <BoN> event ndims <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> event ndims <EoN> , <BoN> min event ndims <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> validate args <EoN> : <NEWLINE> <TAB> <BoN> assertions <EoN> += [ <NEWLINE> <BoN> check ops <EoN> . <BoN> assert greater equal <EoN> ( <BoN> event ndims <EoN> , <BoN> min event ndims <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> event ndims <EoN> . <BoN> shape <EoN> . <BoN> is fully defined <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> event ndims <EoN> . <BoN> shape <EoN> . <BoN> ndims <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> event ndims <EoN> . <BoN> shape <EoN> . <BoN> ndims <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> validate args <EoN> : <NEWLINE> <TAB> <BoN> assertions <EoN> += [ <NEWLINE> <BoN> check ops <EoN> . <BoN> assert rank <EoN> ( <BoN> event ndims <EoN> , <NUMBER> , <BoN> message <EoN> = <STRING> ) ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> assertions <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> nth power roots poly <EoN> ( <BoN> f <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> . <BoN> is multivariate <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Multivariate Polynomial Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> N <EoN> = <BoN> sympify <EoN> ( <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> N <EoN> . <BoN> is Integer <EoN> <BoN> and <EoN> <BoN> N <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> int <EoN> ( <BoN> N <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> f <EoN> . <BoN> gen <EoN> <NEWLINE> <BoN> t <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> r <EoN> = <BoN> f <EoN> . <BoN> resultant <EoN> ( <BoN> f <EoN> . <BoN> class <EoN> . <BoN> from expr <EoN> ( <BoN> x <EoN> ** <BoN> n <EoN> - <BoN> t <EoN> , <BoN> x <EoN> , <BoN> t <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> r <EoN> . <BoN> replace <EoN> ( <BoN> t <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tick bottom <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> label <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> self <EoN> . <BoN> major tick kw <EoN> : <NEWLINE> <TAB> <BoN> label <EoN> = ( <BoN> self <EoN> . <BoN> major tick kw <EoN> [ <STRING> ] <NEWLINE> <BoN> or <EoN> <BoN> self <EoN> . <BoN> major tick kw <EoN> [ <STRING> ] ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> set ticks position <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> set tick params <EoN> ( <BoN> which <EoN> = <STRING> , <BoN> labelbottom <EoN> = <BoN> label <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fsdecode <EoN> ( <BoN> filename <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> filename <EoN> , <BoN> six <EoN> . <BoN> text type <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> filename <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> filename <EoN> , <BoN> six <EoN> . <BoN> binary type <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> filename <EoN> . <BoN> decode <EoN> ( <BoN> encoding <EoN> , <BoN> errors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> filename <EoN> ) . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> eigvalsh to eps <EoN> ( <BoN> spectrum <EoN> , <BoN> cond <EoN> = <BoN> None <EoN> , <BoN> rcond <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> rcond <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> cond <EoN> = <BoN> rcond <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> cond <EoN> <BoN> in <EoN> [ <BoN> None <EoN> , - <NUMBER> ] : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> spectrum <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> factor <EoN> = { <STRING> : <NUMBER> , <STRING> : <NUMBER> } <NEWLINE> <BoN> cond <EoN> = <BoN> factor <EoN> [ <BoN> t <EoN> ] * <BoN> np <EoN> . <BoN> finfo <EoN> ( <BoN> t <EoN> ) . <BoN> eps <EoN> <NEWLINE> <UNTAB> <BoN> eps <EoN> = <BoN> cond <EoN> * <BoN> np <EoN> . <BoN> max <EoN> ( <BoN> abs <EoN> ( <BoN> spectrum <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> eps <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> row structure symbolic cholesky <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> R <EoN> , <BoN> parent <EoN> = <BoN> self <EoN> . <BoN> liupc <EoN> ( ) <NEWLINE> <BoN> inf <EoN> = <BoN> len <EoN> ( <BoN> R <EoN> ) <NEWLINE> <BoN> Lrow <EoN> = <BoN> copy <EoN> . <BoN> deepcopy <EoN> ( <BoN> R <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> rows <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> R <EoN> [ <BoN> k <EoN> ] : <NEWLINE> <TAB> <BoN> while <EoN> <BoN> j <EoN> != <BoN> inf <EoN> <BoN> and <EoN> <BoN> j <EoN> != <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> Lrow <EoN> [ <BoN> k <EoN> ] . <BoN> append <EoN> ( <BoN> j <EoN> ) <NEWLINE> <BoN> j <EoN> = <BoN> parent <EoN> [ <BoN> j <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> Lrow <EoN> [ <BoN> k <EoN> ] = <BoN> list <EoN> ( <BoN> sorted <EoN> ( <BoN> set <EoN> ( <BoN> Lrow <EoN> [ <BoN> k <EoN> ] ) ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Lrow <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> smart case <EoN> ( <BoN> pred fn pairs <EoN> , <BoN> default <EoN> = <BoN> None <EoN> , <BoN> exclusive <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> case helper <EoN> ( <NEWLINE> <BoN> smart cond <EoN> , <BoN> pred fn pairs <EoN> , <BoN> default <EoN> , <BoN> exclusive <EoN> , <BoN> name <EoN> , <NEWLINE> <BoN> allow python preds <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> literal symbol <EoN> ( <BoN> literal <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> literal <EoN> <BoN> is <EoN> <BoN> True <EoN> <BoN> or <EoN> <BoN> literal <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> literal <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> literal <EoN> . <BoN> is Symbol <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> literal <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> literal <EoN> . <BoN> is Not <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> literal symbol <EoN> ( <BoN> literal <EoN> . <BoN> args <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> ( <BoN> Attribute Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> generative <EoN> <NEWLINE> <BoN> def <EoN> <BoN> suffix with <EoN> ( <BoN> self <EoN> , * <BoN> expr <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dialect <EoN> = <BoN> kw <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> kw <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Argument Error <EoN> ( <STRING> % <NEWLINE> <STRING> . <BoN> join <EoN> ( <BoN> kw <EoN> ) ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> setup suffixes <EoN> ( <BoN> expr <EoN> , <BoN> dialect <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> minimum <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> minimum <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> roots laguerre <EoN> ( <BoN> n <EoN> , <BoN> mu <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> roots genlaguerre <EoN> ( <BoN> n <EoN> , <NUMBER> , <BoN> mu <EoN> = <BoN> mu <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cp cmp <EoN> ( <BoN> c <EoN> , <BoN> d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> zero <EoN> = <BoN> Polyn <EoN> ( <BoN> c <EoN> [ <NUMBER> ] ) . <BoN> ring <EoN> . <BoN> zero <EoN> <NEWLINE> <NEWLINE> <BoN> c 0 <EoN> = <BoN> lbp <EoN> ( <BoN> c <EoN> [ <NUMBER> ] , <BoN> zero <EoN> , <BoN> Num <EoN> ( <BoN> c <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> d 0 <EoN> = <BoN> lbp <EoN> ( <BoN> d <EoN> [ <NUMBER> ] , <BoN> zero <EoN> , <BoN> Num <EoN> ( <BoN> d <EoN> [ <NUMBER> ] ) ) <NEWLINE> <NEWLINE> <BoN> r <EoN> = <BoN> lbp cmp <EoN> ( <BoN> c 0 <EoN> , <BoN> d 0 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> == - <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> - <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> r <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> c 1 <EoN> = <BoN> lbp <EoN> ( <BoN> c <EoN> [ <NUMBER> ] , <BoN> zero <EoN> , <BoN> Num <EoN> ( <BoN> c <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> d 1 <EoN> = <BoN> lbp <EoN> ( <BoN> d <EoN> [ <NUMBER> ] , <BoN> zero <EoN> , <BoN> Num <EoN> ( <BoN> d <EoN> [ <NUMBER> ] ) ) <NEWLINE> <NEWLINE> <BoN> r <EoN> = <BoN> lbp cmp <EoN> ( <BoN> c 1 <EoN> , <BoN> d 1 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> == - <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add checkpointable dependencies <EoN> ( <BoN> self <EoN> , <BoN> checkpointable <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> split dependencies <EoN> = <BoN> split dependency <EoN> . <BoN> split dependency <EoN> ( <NEWLINE> <BoN> component names <EoN> = <BoN> self <EoN> . <BoN> param names <EoN> , <NEWLINE> <BoN> component dtypes <EoN> = ( <BoN> dtype <EoN> , ) * <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> param names <EoN> ) , <NEWLINE> <BoN> fill save buffer fn <EoN> = <BoN> self <EoN> . <BoN> checkpointable save <EoN> , <NEWLINE> <BoN> consume restore buffer fn <EoN> = <BoN> self <EoN> . <BoN> checkpointable restore <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> checkpointable track params <EoN> ( <BoN> checkpointable <EoN> , <BoN> split dependencies <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fuse selections <EoN> ( <BoN> dsk <EoN> , <BoN> head 1 <EoN> , <BoN> head 2 <EoN> , <BoN> merge <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dsk 2 <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> dsk <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> istask <EoN> ( <BoN> v <EoN> ) <BoN> and <EoN> <BoN> v <EoN> [ <NUMBER> ] == <BoN> head 1 <EoN> <BoN> and <EoN> <BoN> v <EoN> [ <NUMBER> ] <BoN> in <EoN> <BoN> dsk <EoN> <BoN> and <EoN> <NEWLINE> <BoN> istask <EoN> ( <BoN> dsk <EoN> [ <BoN> v <EoN> [ <NUMBER> ] ] ) <BoN> and <EoN> <BoN> dsk <EoN> [ <BoN> v <EoN> [ <NUMBER> ] ] [ <NUMBER> ] == <BoN> head 2 <EoN> ) : <NEWLINE> <TAB> <BoN> dsk 2 <EoN> [ <BoN> k <EoN> ] = <BoN> merge <EoN> ( <BoN> v <EoN> , <BoN> dsk <EoN> [ <BoN> v <EoN> [ <NUMBER> ] ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dsk 2 <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> dsk 2 <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> dsk 2 <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert Multi Line Equal <EoN> ( <BoN> self <EoN> , <BoN> first <EoN> , <BoN> second <EoN> , <BoN> msg <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assert Is Instance <EoN> ( <BoN> first <EoN> , <BoN> str <EoN> , <STRING> ) <NEWLINE> <BoN> self <EoN> . <BoN> assert Is Instance <EoN> ( <BoN> second <EoN> , <BoN> str <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> first <EoN> != <BoN> second <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> len <EoN> ( <BoN> first <EoN> ) > <BoN> self <EoN> . <BoN> diffThreshold <EoN> <BoN> or <EoN> <NEWLINE> <BoN> len <EoN> ( <BoN> second <EoN> ) > <BoN> self <EoN> . <BoN> diffThreshold <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> baseAssertEqual <EoN> ( <BoN> first <EoN> , <BoN> second <EoN> , <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <BoN> firstlines <EoN> = <BoN> first <EoN> . <BoN> splitlines <EoN> ( <BoN> keepends <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> secondlines <EoN> = <BoN> second <EoN> . <BoN> splitlines <EoN> ( <BoN> keepends <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> firstlines <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> first <EoN> . <BoN> strip <EoN> ( <STRING> ) == <BoN> first <EoN> : <NEWLINE> <TAB> <BoN> firstlines <EoN> = [ <BoN> first <EoN> + <STRING> ] <NEWLINE> <BoN> secondlines <EoN> = [ <BoN> second <EoN> + <STRING> ] <NEWLINE> <UNTAB> <BoN> standard Msg <EoN> = <STRING> % <BoN> common shorten repr <EoN> ( <BoN> first <EoN> , <BoN> second <EoN> ) <NEWLINE> <BoN> diff <EoN> = <STRING> + <STRING> . <BoN> join <EoN> ( <BoN> difflib <EoN> . <BoN> ndiff <EoN> ( <BoN> firstlines <EoN> , <BoN> secondlines <EoN> ) ) <NEWLINE> <BoN> standard Msg <EoN> = <BoN> self <EoN> . <BoN> truncateMessage <EoN> ( <BoN> standard Msg <EoN> , <BoN> diff <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fail <EoN> ( <BoN> self <EoN> . <BoN> formatMessage <EoN> ( <BoN> msg <EoN> , <BoN> standard Msg <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reverse seq <EoN> ( <BoN> input seq <EoN> , <BoN> lengths <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> lengths <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> reversed <EoN> ( <BoN> input seq <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> input <EoN> <BoN> in <EoN> <BoN> input seq <EoN> : <NEWLINE> <TAB> <BoN> input <EoN> . <BoN> set shape <EoN> ( <BoN> input <EoN> . <BoN> get shape <EoN> ( ) . <BoN> with rank <EoN> ( <NUMBER> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> s joined <EoN> = <BoN> array ops <EoN> . <BoN> pack <EoN> ( <BoN> input seq <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> s reversed <EoN> = <BoN> array ops <EoN> . <BoN> reverse sequence <EoN> ( <BoN> s joined <EoN> , <BoN> lengths <EoN> , <NUMBER> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> result <EoN> = <BoN> array ops <EoN> . <BoN> unpack <EoN> ( <BoN> s reversed <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> value counts <EoN> ( <BoN> self <EoN> , <BoN> dropna <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> numpy <EoN> <BoN> import <EoN> <BoN> bincount <EoN> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> <BoN> import <EoN> <BoN> Series <EoN> , <BoN> Categorical Index <EoN> <NEWLINE> <NEWLINE> <BoN> code <EoN> , <BoN> cat <EoN> = <BoN> self <EoN> . <BoN> codes <EoN> , <BoN> self <EoN> . <BoN> categories <EoN> <NEWLINE> <BoN> ncat <EoN> , <BoN> mask <EoN> = <BoN> len <EoN> ( <BoN> cat <EoN> ) , <NUMBER> <= <BoN> code <EoN> <NEWLINE> <BoN> ix <EoN> , <BoN> clean <EoN> = <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> ncat <EoN> ) , <BoN> mask <EoN> . <BoN> all <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> dropna <EoN> <BoN> or <EoN> <BoN> clean <EoN> : <NEWLINE> <TAB> <BoN> obs <EoN> = <BoN> code <EoN> <BoN> if <EoN> <BoN> clean <EoN> <BoN> else <EoN> <BoN> code <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <BoN> count <EoN> = <BoN> bincount <EoN> ( <BoN> obs <EoN> , <BoN> minlength <EoN> = <BoN> ncat <EoN> <BoN> or <EoN> <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> count <EoN> = <BoN> bincount <EoN> ( <BoN> np <EoN> . <BoN> where <EoN> ( <BoN> mask <EoN> , <BoN> code <EoN> , <BoN> ncat <EoN> ) ) <NEWLINE> <BoN> ix <EoN> = <BoN> np <EoN> . <BoN> append <EoN> ( <BoN> ix <EoN> , - <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ix <EoN> = <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> ix <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> , <NEWLINE> <BoN> fastpath <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Series <EoN> ( <BoN> count <EoN> , <BoN> index <EoN> = <BoN> Categorical Index <EoN> ( <BoN> ix <EoN> ) , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rsh <EoN> ( <BoN> data <EoN> , <BoN> points <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> data <EoN> = <BoN> ma <EoN> . <BoN> array <EoN> ( <BoN> data <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> points <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> points <EoN> = <BoN> data <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> points <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> points <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> , <BoN> ndmin <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> data <EoN> . <BoN> ndim <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Attribute Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> data <EoN> . <BoN> count <EoN> ( ) <NEWLINE> <BoN> r <EoN> = <BoN> idealfourths <EoN> ( <BoN> data <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> ) <NEWLINE> <BoN> h <EoN> = <NUMBER> * ( <BoN> r <EoN> [ - <NUMBER> ] - <BoN> r <EoN> [ <NUMBER> ] ) / <BoN> n <EoN> ** ( <NUMBER> / <NUMBER> ) <NEWLINE> <BoN> nhi <EoN> = ( <BoN> data <EoN> [ : , <BoN> None <EoN> ] <= <BoN> points <EoN> [ <BoN> None <EoN> , : ] + <BoN> h <EoN> ) . <BoN> sum <EoN> ( <NUMBER> ) <NEWLINE> <BoN> nlo <EoN> = ( <BoN> data <EoN> [ : , <BoN> None <EoN> ] < <BoN> points <EoN> [ <BoN> None <EoN> , : ] - <BoN> h <EoN> ) . <BoN> sum <EoN> ( <NUMBER> ) <NEWLINE> <BoN> return <EoN> ( <BoN> nhi <EoN> - <BoN> nlo <EoN> ) / ( <NUMBER> * <BoN> n <EoN> * <BoN> h <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> linab <EoN> ( <BoN> arg <EoN> , <BoN> symbol <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> arg <EoN> = <BoN> arg <EoN> . <BoN> expand <EoN> ( ) <NEWLINE> <BoN> ind <EoN> , <BoN> dep <EoN> = <BoN> arg <EoN> . <BoN> as independent <EoN> ( <BoN> symbol <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> arg <EoN> . <BoN> is Add <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> = <NUMBER> <NEWLINE> <BoN> a <EoN> , <BoN> x <EoN> = <BoN> ind <EoN> , <BoN> dep <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> = <BoN> ind <EoN> <NEWLINE> <BoN> a <EoN> , <BoN> x <EoN> = <BoN> separatevars <EoN> ( <BoN> dep <EoN> ) . <BoN> as independent <EoN> ( <BoN> symbol <EoN> , <BoN> as Add <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> . <BoN> could extract minus sign <EoN> ( ) : <NEWLINE> <TAB> <BoN> a <EoN> = - <BoN> a <EoN> <NEWLINE> <BoN> x <EoN> = - <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> a list <EoN> ( <BoN> label <EoN> = <BoN> None <EoN> , <BoN> kwargs <EoN> = <BoN> None <EoN> , <BoN> attributes <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> result <EoN> = [ <STRING> % <BoN> quote <EoN> ( <BoN> label <EoN> ) ] <BoN> if <EoN> <BoN> label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> else <EoN> [ ] <NEWLINE> <BoN> if <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> items <EoN> = [ <STRING> % ( <BoN> quote <EoN> ( <BoN> k <EoN> ) , <BoN> quote <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> tools <EoN> . <BoN> mapping items <EoN> ( <BoN> kwargs <EoN> ) <BoN> if <EoN> <BoN> v <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> result <EoN> . <BoN> extend <EoN> ( <BoN> items <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> attributes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> attributes <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> attributes <EoN> = <BoN> tools <EoN> . <BoN> mapping items <EoN> ( <BoN> attributes <EoN> ) <NEWLINE> <UNTAB> <BoN> items <EoN> = [ <STRING> % ( <BoN> quote <EoN> ( <BoN> k <EoN> ) , <BoN> quote <EoN> ( <BoN> v <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> attributes <EoN> <BoN> if <EoN> <BoN> v <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> result <EoN> . <BoN> extend <EoN> ( <BoN> items <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <STRING> . <BoN> join <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get op result name <EoN> ( <BoN> left <EoN> , <BoN> right <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> right <EoN> , ( <BoN> ABC Series <EoN> , <BoN> pd <EoN> . <BoN> Index <EoN> ) ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> maybe match name <EoN> ( <BoN> left <EoN> , <BoN> right <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> left <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> name <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> remove repeated comments <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> last comment <EoN> = { <STRING> : <BoN> None <EoN> } <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> gast <EoN> . <BoN> walk <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> anno <EoN> . <BoN> hasanno <EoN> ( <BoN> node <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> comment <EoN> = <BoN> anno <EoN> . <BoN> getanno <EoN> ( <BoN> node <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> comment <EoN> [ <STRING> ] == <BoN> last comment <EoN> [ <STRING> ] : <NEWLINE> <TAB> <BoN> anno <EoN> . <BoN> delanno <EoN> ( <BoN> node <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> last comment <EoN> = <BoN> comment <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> node <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> copper <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> set cmap <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> params <EoN> , <BoN> tree handle <EoN> , <BoN> stats handle <EoN> , <BoN> create op <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> params <EoN> = <BoN> params <EoN> <NEWLINE> <BoN> tensor <EoN> = <BoN> gen model ops <EoN> . <BoN> tree serialize <EoN> ( <BoN> tree handle <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> slice spec <EoN> = <STRING> <NEWLINE> <BoN> specs <EoN> = [ <BoN> saver <EoN> . <BoN> Base Saver Builder <EoN> . <BoN> Save Spec <EoN> ( <BoN> tensor <EoN> , <BoN> slice spec <EoN> , <BoN> name <EoN> ) , ] <NEWLINE> <BoN> super <EoN> ( <BoN> Tree Variable Savable <EoN> , <NEWLINE> <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> tree handle <EoN> , <BoN> specs <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> tree handle <EoN> = <BoN> tree handle <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> create op <EoN> = <BoN> create op <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> partial fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> classes <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> validate params <EoN> ( <BoN> for partial fit <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> class weight <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> lr <EoN> = <STRING> <BoN> if <EoN> <BoN> self <EoN> . <BoN> loss <EoN> == <STRING> <BoN> else <EoN> <STRING> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> partial fit <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> alpha <EoN> = <NUMBER> , <BoN> C <EoN> = <BoN> self <EoN> . <BoN> C <EoN> , <NEWLINE> <BoN> loss <EoN> = <STRING> , <BoN> learning rate <EoN> = <BoN> lr <EoN> , <BoN> max iter <EoN> = <NUMBER> , <NEWLINE> <BoN> classes <EoN> = <BoN> classes <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> , <NEWLINE> <BoN> coef init <EoN> = <BoN> None <EoN> , <BoN> intercept init <EoN> = <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> digamma <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Di Gamma <EoN> ( ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add scripts <EoN> ( <BoN> self <EoN> , * <BoN> files <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> scripts <EoN> = <BoN> self <EoN> . <BoN> paths <EoN> ( <BoN> files <EoN> ) <NEWLINE> <BoN> dist <EoN> = <BoN> self <EoN> . <BoN> get distribution <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> dist <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dist <EoN> . <BoN> scripts <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dist <EoN> . <BoN> scripts <EoN> = [ ] <NEWLINE> <UNTAB> <BoN> dist <EoN> . <BoN> scripts <EoN> . <BoN> extend <EoN> ( <BoN> scripts <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> scripts <EoN> . <BoN> extend <EoN> ( <BoN> scripts <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> download <EoN> ( <BoN> url <EoN> , <BoN> fname <EoN> = <BoN> None <EoN> , <BoN> dirname <EoN> = <BoN> None <EoN> , <BoN> overwrite <EoN> = <BoN> False <EoN> , <BoN> retries <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> assert <EoN> <BoN> retries <EoN> >= <NUMBER> , <STRING> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> fname <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> fname <EoN> = <BoN> url <EoN> . <BoN> split <EoN> ( <STRING> ) [ - <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dirname <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dirname <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> dirname <EoN> ( <BoN> fname <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fname <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> dirname <EoN> , <BoN> fname <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dirname <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> dirname <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> dirname <EoN> ) <NEWLINE> <BoN> os <EoN> . <BoN> makedirs <EoN> ( <BoN> dirname <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> <BoN> as <EoN> <BoN> exc <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> exc <EoN> . <BoN> errno <EoN> != <BoN> errno <EoN> . <BoN> EEXIS T <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> OS Error <EoN> ( <STRING> + <BoN> dirname <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> overwrite <EoN> <BoN> and <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <BoN> fname <EoN> ) : <NEWLINE> <TAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> fname <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> fname <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> retries <EoN> + <NUMBER> > <NUMBER> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> requests <EoN> . <BoN> get <EoN> ( <BoN> url <EoN> , <BoN> stream <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> r <EoN> . <BoN> status code <EoN> == <NUMBER> , <STRING> % <BoN> url <EoN> <NEWLINE> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> fname <EoN> , <STRING> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> chunk <EoN> <BoN> in <EoN> <BoN> r <EoN> . <BoN> iter content <EoN> ( <BoN> chunk size <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> chunk <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> write <EoN> ( <BoN> chunk <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> retries <EoN> -= <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> retries <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> e <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> print <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> retries <EoN> , <STRING> <BoN> if <EoN> <BoN> retries <EoN> > <NUMBER> <BoN> else <EoN> <STRING> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> url <EoN> , <BoN> fname <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> fname <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> to dense <EoN> ( <BoN> tensor <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> is sparse <EoN> ( <BoN> tensor <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> sparse tensor to dense <EoN> ( <BoN> tensor <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tensor <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nanmedian small <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> overwrite input <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> ma <EoN> . <BoN> masked array <EoN> ( <BoN> a <EoN> , <BoN> np <EoN> . <BoN> isnan <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <BoN> m <EoN> = <BoN> np <EoN> . <BoN> ma <EoN> . <BoN> median <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> overwrite input <EoN> = <BoN> overwrite input <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> np <EoN> . <BoN> count nonzero <EoN> ( <BoN> m <EoN> . <BoN> mask <EoN> . <BoN> ravel <EoN> ( ) ) ) : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> , <BoN> Runtime Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> [ ... ] = <BoN> m <EoN> . <BoN> filled <EoN> ( <BoN> np <EoN> . <BoN> nan <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> m <EoN> . <BoN> filled <EoN> ( <BoN> np <EoN> . <BoN> nan <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sosfreqz <EoN> ( <BoN> sos <EoN> , <BoN> wor N <EoN> = <BoN> None <EoN> , <BoN> whole <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> sos <EoN> , <BoN> n sections <EoN> = <BoN> validate sos <EoN> ( <BoN> sos <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n sections <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> h <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> row <EoN> <BoN> in <EoN> <BoN> sos <EoN> : <NEWLINE> <TAB> <BoN> w <EoN> , <BoN> rowh <EoN> = <BoN> freqz <EoN> ( <BoN> row <EoN> [ : <NUMBER> ] , <BoN> row <EoN> [ <NUMBER> : ] , <BoN> wor N <EoN> = <BoN> wor N <EoN> , <BoN> whole <EoN> = <BoN> whole <EoN> ) <NEWLINE> <BoN> h <EoN> *= <BoN> rowh <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> w <EoN> , <BoN> h <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> data <EoN> , <BoN> impulse response <EoN> = <BoN> None <EoN> , <BoN> filter params <EoN> = { } , <NEWLINE> <BoN> predefined filter <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert nD <EoN> ( <BoN> data <EoN> , <NUMBER> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> predefined filter <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> predefined filter <EoN> = <BoN> LPI Filter 2 D <EoN> ( <BoN> impulse response <EoN> , ** <BoN> filter params <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> predefined filter <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> assign <EoN> ( <BoN> ref <EoN> , <BoN> value <EoN> , <BoN> validate shape <EoN> = <BoN> None <EoN> , <BoN> use locking <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> ref <EoN> . <BoN> dtype <EoN> . <BoN> is ref dtype <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gen state ops <EoN> . <BoN> assign <EoN> ( <NEWLINE> <BoN> ref <EoN> , <BoN> value <EoN> , <BoN> use locking <EoN> = <BoN> use locking <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> <BoN> validate shape <EoN> = <BoN> validate shape <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ref <EoN> . <BoN> assign <EoN> ( <BoN> value <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast plus <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> astype <EoN> ( <BoN> self <EoN> , <BoN> dtype <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> self <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> copy <EoN> = <BoN> copy <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add tool <EoN> ( <BoN> self <EoN> , <BoN> tool <EoN> , <BoN> group <EoN> , <BoN> position <EoN> = - <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tool <EoN> = <BoN> self <EoN> . <BoN> toolmanager <EoN> . <BoN> get tool <EoN> ( <BoN> tool <EoN> ) <NEWLINE> <BoN> image <EoN> = <BoN> self <EoN> . <BoN> get image filename <EoN> ( <BoN> tool <EoN> . <BoN> image <EoN> ) <NEWLINE> <BoN> toggle <EoN> = <BoN> getattr <EoN> ( <BoN> tool <EoN> , <STRING> , <BoN> None <EoN> ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> add toolitem <EoN> ( <BoN> tool <EoN> . <BoN> name <EoN> , <BoN> group <EoN> , <BoN> position <EoN> , <NEWLINE> <BoN> image <EoN> , <BoN> tool <EoN> . <BoN> description <EoN> , <BoN> toggle <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> toggle <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> toolmanager <EoN> . <BoN> toolmanager connect <EoN> ( <STRING> % <BoN> tool <EoN> . <BoN> name <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> tool toggled cbk <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> tool <EoN> . <BoN> toggled <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> toggle toolitem <EoN> ( <BoN> tool <EoN> . <BoN> name <EoN> , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cudnn to tf biases <EoN> ( <BoN> self <EoN> , * <BoN> biases <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> b wi <EoN> , <BoN> b wr <EoN> , <BoN> b wh <EoN> , <BoN> b ri <EoN> , <BoN> b rr <EoN> , <BoN> b rh <EoN> = <BoN> biases <EoN> <NEWLINE> <BoN> return <EoN> ( <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> array ops <EoN> . <BoN> concat <EoN> ( [ <BoN> b wi <EoN> , <BoN> b wr <EoN> ] , <BoN> axis <EoN> = <NUMBER> ) + <BoN> array ops <EoN> . <BoN> concat <EoN> ( <NEWLINE> [ <BoN> b ri <EoN> , <BoN> b rr <EoN> ] , <BoN> axis <EoN> = <NUMBER> ) , <NEWLINE> <BoN> b wh <EoN> , <NEWLINE> <BoN> b rh <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> intersect 1 d <EoN> ( <BoN> ar 1 <EoN> , <BoN> ar 2 <EoN> , <BoN> assume unique <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> assume unique <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> ar 1 <EoN> = <BoN> unique <EoN> ( <BoN> ar 1 <EoN> ) <NEWLINE> <BoN> ar 2 <EoN> = <BoN> unique <EoN> ( <BoN> ar 2 <EoN> ) <NEWLINE> <UNTAB> <BoN> aux <EoN> = <BoN> np <EoN> . <BoN> concatenate <EoN> ( ( <BoN> ar 1 <EoN> , <BoN> ar 2 <EoN> ) ) <NEWLINE> <BoN> aux <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> aux <EoN> [ : - <NUMBER> ] [ <BoN> aux <EoN> [ <NUMBER> : ] == <BoN> aux <EoN> [ : - <NUMBER> ] ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> to numpy recarray <EoN> ( <BoN> G <EoN> , <BoN> nodelist <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> order <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = [ ( <STRING> , <BoN> float <EoN> ) ] <NEWLINE> <UNTAB> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <BoN> if <EoN> <BoN> nodelist <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> nodelist <EoN> = <BoN> list <EoN> ( <BoN> G <EoN> ) <NEWLINE> <UNTAB> <BoN> nodeset <EoN> = <BoN> set <EoN> ( <BoN> nodelist <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> nodelist <EoN> ) != <BoN> len <EoN> ( <BoN> nodeset <EoN> ) : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <BoN> nlen <EoN> = <BoN> len <EoN> ( <BoN> nodelist <EoN> ) <NEWLINE> <BoN> undirected <EoN> = <BoN> not <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) <NEWLINE> <BoN> index <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> nodelist <EoN> , <BoN> range <EoN> ( <BoN> nlen <EoN> ) ) ) <NEWLINE> <BoN> M <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> nlen <EoN> , <BoN> nlen <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> order <EoN> = <BoN> order <EoN> ) <NEWLINE> <NEWLINE> <BoN> names <EoN> = <BoN> M <EoN> . <BoN> dtype <EoN> . <BoN> names <EoN> <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> , <BoN> attrs <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> edges <EoN> ( <BoN> data <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> u <EoN> <BoN> in <EoN> <BoN> nodeset <EoN> ) <BoN> and <EoN> ( <BoN> v <EoN> <BoN> in <EoN> <BoN> nodeset <EoN> ) : <NEWLINE> <TAB> <BoN> i <EoN> , <BoN> j <EoN> = <BoN> index <EoN> [ <BoN> u <EoN> ] , <BoN> index <EoN> [ <BoN> v <EoN> ] <NEWLINE> <BoN> values <EoN> = <BoN> tuple <EoN> ( [ <BoN> attrs <EoN> [ <BoN> n <EoN> ] <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> names <EoN> ] ) <NEWLINE> <BoN> M <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] = <BoN> values <EoN> <NEWLINE> <BoN> if <EoN> <BoN> undirected <EoN> : <NEWLINE> <TAB> <BoN> M <EoN> [ <BoN> j <EoN> , <BoN> i <EoN> ] = <BoN> M <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> M <EoN> . <BoN> view <EoN> ( <BoN> np <EoN> . <BoN> recarray <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> load params <EoN> ( <BoN> self <EoN> , <BoN> fname <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> save dict <EoN> = <BoN> ndarray <EoN> . <BoN> load <EoN> ( <BoN> fname <EoN> ) <NEWLINE> <BoN> arg params <EoN> = { } <NEWLINE> <BoN> aux params <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> save dict <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> arg type <EoN> , <BoN> name <EoN> = <BoN> k <EoN> . <BoN> split <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> arg type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> arg params <EoN> [ <BoN> name <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> arg type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> aux params <EoN> [ <BoN> name <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <BoN> fname <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> set params <EoN> ( <BoN> arg params <EoN> , <BoN> aux params <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> clear covers <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> row uncovered <EoN> [ : ] = <BoN> True <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> col uncovered <EoN> [ : ] = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> toeplitz <EoN> ( <BoN> c <EoN> , <BoN> r <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> c <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> c <EoN> ) . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> c <EoN> . <BoN> conjugate <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> r <EoN> ) . <BoN> ravel <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> vals <EoN> = <BoN> np <EoN> . <BoN> concatenate <EoN> ( ( <BoN> c <EoN> [ : : - <NUMBER> ] , <BoN> r <EoN> [ <NUMBER> : ] ) ) <NEWLINE> <BoN> out shp <EoN> = <BoN> len <EoN> ( <BoN> c <EoN> ) , <BoN> len <EoN> ( <BoN> r <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> vals <EoN> . <BoN> strides <EoN> [ <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> as strided <EoN> ( <BoN> vals <EoN> [ <BoN> len <EoN> ( <BoN> c <EoN> ) - <NUMBER> : ] , <BoN> shape <EoN> = <BoN> out shp <EoN> , <BoN> strides <EoN> = ( - <BoN> n <EoN> , <BoN> n <EoN> ) ) . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> draw <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> children <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> . <BoN> draw <EoN> ( <BoN> renderer <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> bbox artist <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> , <BoN> fill <EoN> = <BoN> False <EoN> , <BoN> props <EoN> = <BoN> dict <EoN> ( <BoN> pad <EoN> = <NUMBER> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf lshift <EoN> ( <BoN> f <EoN> , <BoN> n <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> + [ <BoN> K <EoN> . <BoN> zero <EoN> ] * <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> from FF gmpy <EoN> ( <BoN> K 1 <EoN> , <BoN> a <EoN> , <BoN> K 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> . <BoN> to int <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update axisinfo <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> converter <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> info <EoN> = <BoN> self <EoN> . <BoN> converter <EoN> . <BoN> axisinfo <EoN> ( <BoN> self <EoN> . <BoN> units <EoN> , <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> info <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> info <EoN> . <BoN> majloc <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> major <EoN> . <BoN> locator <EoN> != <BoN> info <EoN> . <BoN> majloc <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> isDefault majloc <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set major locator <EoN> ( <BoN> info <EoN> . <BoN> majloc <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> isDefault majloc <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> info <EoN> . <BoN> minloc <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> minor <EoN> . <BoN> locator <EoN> != <BoN> info <EoN> . <BoN> minloc <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> isDefault minloc <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set minor locator <EoN> ( <BoN> info <EoN> . <BoN> minloc <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> isDefault minloc <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> info <EoN> . <BoN> majfmt <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> major <EoN> . <BoN> formatter <EoN> != <BoN> info <EoN> . <BoN> majfmt <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> isDefault majfmt <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set major formatter <EoN> ( <BoN> info <EoN> . <BoN> majfmt <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> isDefault majfmt <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> info <EoN> . <BoN> minfmt <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> minor <EoN> . <BoN> formatter <EoN> != <BoN> info <EoN> . <BoN> minfmt <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> isDefault minfmt <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set minor formatter <EoN> ( <BoN> info <EoN> . <BoN> minfmt <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> isDefault minfmt <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> info <EoN> . <BoN> label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> isDefault label <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set label text <EoN> ( <BoN> info <EoN> . <BoN> label <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> isDefault label <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> set default intervals <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> bode <EoN> ( <BoN> self <EoN> , <BoN> w <EoN> = <BoN> None <EoN> , <BoN> n <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> bode <EoN> ( <BoN> self <EoN> , <BoN> w <EoN> = <BoN> w <EoN> , <BoN> n <EoN> = <BoN> n <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> greedy coloring with interchange <EoN> ( <BoN> original graph <EoN> , <BoN> nodes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> original graph <EoN> ) <NEWLINE> <NEWLINE> <BoN> graph <EoN> = { <BoN> node id <EoN> : <BoN> Node <EoN> ( <BoN> node id <EoN> , <BoN> n <EoN> ) <BoN> for <EoN> <BoN> node id <EoN> <BoN> in <EoN> <BoN> original graph <EoN> } <NEWLINE> <NEWLINE> <BoN> for <EoN> ( <BoN> node 1 <EoN> , <BoN> node 2 <EoN> ) <BoN> in <EoN> <BoN> original graph <EoN> . <BoN> edges <EoN> ( ) : <NEWLINE> <TAB> <BoN> adj entry 1 <EoN> = <BoN> Adj Entry <EoN> ( <BoN> node 2 <EoN> ) <NEWLINE> <BoN> adj entry 2 <EoN> = <BoN> Adj Entry <EoN> ( <BoN> node 1 <EoN> ) <NEWLINE> <BoN> adj entry 1 <EoN> . <BoN> mate <EoN> = <BoN> adj entry 2 <EoN> <NEWLINE> <BoN> adj entry 2 <EoN> . <BoN> mate <EoN> = <BoN> adj entry 1 <EoN> <NEWLINE> <BoN> node 1 head <EoN> = <BoN> graph <EoN> [ <BoN> node 1 <EoN> ] . <BoN> adj list <EoN> <NEWLINE> <BoN> adj entry 1 <EoN> . <BoN> next <EoN> = <BoN> node 1 head <EoN> <NEWLINE> <BoN> graph <EoN> [ <BoN> node 1 <EoN> ] . <BoN> adj list <EoN> = <BoN> adj entry 1 <EoN> <NEWLINE> <BoN> node 2 head <EoN> = <BoN> graph <EoN> [ <BoN> node 2 <EoN> ] . <BoN> adj list <EoN> <NEWLINE> <BoN> adj entry 2 <EoN> . <BoN> next <EoN> = <BoN> node 2 head <EoN> <NEWLINE> <BoN> graph <EoN> [ <BoN> node 2 <EoN> ] . <BoN> adj list <EoN> = <BoN> adj entry 2 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> k <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> nodes <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> neighbors <EoN> = <BoN> graph <EoN> [ <BoN> node <EoN> ] . <BoN> iter neighbors <EoN> ( ) <NEWLINE> <BoN> col used <EoN> = { <BoN> graph <EoN> [ <BoN> adj node <EoN> . <BoN> node id <EoN> ] . <BoN> color <EoN> <BoN> for <EoN> <BoN> adj node <EoN> <BoN> in <EoN> <BoN> neighbors <EoN> } <NEWLINE> <BoN> col used <EoN> . <BoN> discard <EoN> ( - <NUMBER> ) <NEWLINE> <BoN> k 1 <EoN> = <BoN> next <EoN> ( <BoN> itertools <EoN> . <BoN> dropwhile <EoN> ( <NEWLINE> <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> <BoN> in <EoN> <BoN> col used <EoN> , <BoN> itertools <EoN> . <BoN> count <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k 1 <EoN> > <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> connected <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> visited <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> col 1 <EoN> = - <NUMBER> <NEWLINE> <BoN> col 2 <EoN> = - <NUMBER> <NEWLINE> <BoN> while <EoN> <BoN> connected <EoN> <BoN> and <EoN> <BoN> col 1 <EoN> < <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> col 1 <EoN> += <NUMBER> <NEWLINE> <BoN> neighbor cols <EoN> = ( <NEWLINE> <BoN> graph <EoN> [ <BoN> node <EoN> ] . <BoN> iter neighbors color <EoN> ( <BoN> col 1 <EoN> ) ) <NEWLINE> <BoN> col 1 adj <EoN> = [ <BoN> it <EoN> <BoN> for <EoN> <BoN> it <EoN> <BoN> in <EoN> <BoN> neighbor cols <EoN> ] <NEWLINE> <NEWLINE> <BoN> col 2 <EoN> = <BoN> col 1 <EoN> <NEWLINE> <BoN> while <EoN> <BoN> connected <EoN> <BoN> and <EoN> <BoN> col 2 <EoN> < <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> col 2 <EoN> += <NUMBER> <NEWLINE> <BoN> visited <EoN> = <BoN> set <EoN> ( <BoN> col 1 adj <EoN> ) <NEWLINE> <BoN> frontier <EoN> = <BoN> list <EoN> ( <BoN> col 1 adj <EoN> ) <NEWLINE> <BoN> i <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> <BoN> i <EoN> < <BoN> len <EoN> ( <BoN> frontier <EoN> ) : <NEWLINE> <TAB> <BoN> search node <EoN> = <BoN> frontier <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> i <EoN> += <NUMBER> <NEWLINE> <BoN> col opp <EoN> = ( <NEWLINE> <BoN> col 2 <EoN> <BoN> if <EoN> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> color <EoN> == <BoN> col 1 <EoN> <BoN> else <EoN> <BoN> col 1 <EoN> ) <NEWLINE> <BoN> neighbor cols <EoN> = ( <NEWLINE> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> iter neighbors color <EoN> ( <BoN> col opp <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> neighbor cols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> visited <EoN> . <BoN> add <EoN> ( <BoN> neighbor <EoN> ) <NEWLINE> <BoN> frontier <EoN> . <BoN> append <EoN> ( <BoN> neighbor <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> connected <EoN> = <BoN> len <EoN> ( <BoN> visited <EoN> . <BoN> intersection <EoN> ( <NEWLINE> <BoN> graph <EoN> [ <BoN> node <EoN> ] . <BoN> iter neighbors color <EoN> ( <BoN> col 2 <EoN> ) ) ) > <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> connected <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> search node <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> color <EoN> = ( <NEWLINE> <BoN> col 2 <EoN> <BoN> if <EoN> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> color <EoN> == <BoN> col 1 <EoN> <BoN> else <EoN> <BoN> col 1 <EoN> ) <NEWLINE> <BoN> col 2 adj <EoN> = <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> adj color <EoN> [ <BoN> col 2 <EoN> ] <NEWLINE> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> adj color <EoN> [ <BoN> col 2 <EoN> ] = ( <NEWLINE> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> adj color <EoN> [ <BoN> col 1 <EoN> ] ) <NEWLINE> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> adj color <EoN> [ <BoN> col 1 <EoN> ] = <BoN> col 2 adj <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> search node <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> col <EoN> = <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> color <EoN> <NEWLINE> <BoN> col opp <EoN> = <BoN> col 1 <EoN> <BoN> if <EoN> <BoN> col <EoN> == <BoN> col 2 <EoN> <BoN> else <EoN> <BoN> col 2 <EoN> <NEWLINE> <BoN> for <EoN> <BoN> adj node <EoN> <BoN> in <EoN> <BoN> graph <EoN> [ <BoN> search node <EoN> ] . <BoN> iter neighbors <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> graph <EoN> [ <BoN> adj node <EoN> . <BoN> node id <EoN> ] . <BoN> color <EoN> != <BoN> col opp <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> adj mate <EoN> = <BoN> adj node <EoN> . <BoN> mate <EoN> <NEWLINE> <BoN> graph <EoN> [ <BoN> adj node <EoN> . <BoN> node id <EoN> ] . <BoN> clear color <EoN> ( <NEWLINE> <BoN> adj mate <EoN> , <BoN> col opp <EoN> ) <NEWLINE> <BoN> graph <EoN> [ <BoN> adj node <EoN> . <BoN> node id <EoN> ] . <BoN> assign color <EoN> ( <BoN> adj mate <EoN> , <BoN> col <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> k 1 <EoN> = <BoN> col 1 <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> graph <EoN> [ <BoN> node <EoN> ] . <BoN> color <EoN> = <BoN> k 1 <EoN> <NEWLINE> <BoN> k <EoN> = <BoN> max <EoN> ( <BoN> k 1 <EoN> , <BoN> k <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> adj node <EoN> <BoN> in <EoN> <BoN> graph <EoN> [ <BoN> node <EoN> ] . <BoN> iter neighbors <EoN> ( ) : <NEWLINE> <TAB> <BoN> adj mate <EoN> = <BoN> adj node <EoN> . <BoN> mate <EoN> <NEWLINE> <BoN> graph <EoN> [ <BoN> adj node <EoN> . <BoN> node id <EoN> ] . <BoN> assign color <EoN> ( <BoN> adj mate <EoN> , <BoN> k 1 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> { <BoN> node <EoN> . <BoN> node id <EoN> : <BoN> node <EoN> . <BoN> color <EoN> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> graph <EoN> . <BoN> values <EoN> ( ) } <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mingw 32 <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> sys <EoN> . <BoN> platform <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> os <EoN> . <BoN> environ <EoN> . <BoN> get <EoN> ( <STRING> , <STRING> ) == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> os <EoN> . <BoN> environ <EoN> . <BoN> get <EoN> ( <STRING> , <STRING> ) == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> densenet 161 <EoN> ( ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> get densenet <EoN> ( <NUMBER> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save pkl <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> self <EoN> . <BoN> key pkl <EoN> , <STRING> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> pickle <EoN> . <BoN> dump <EoN> ( <BoN> self <EoN> , <BoN> f <EoN> , <BoN> protocol <EoN> = <BoN> pickle <EoN> . <BoN> HIGHEST PROTOCOL <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> : <NEWLINE> <TAB> <BoN> logger <EoN> . <BoN> warning <EoN> ( <STRING> , <NEWLINE> <BoN> self <EoN> . <BoN> keys <EoN> ) <NEWLINE> <BoN> os <EoN> . <BoN> remove <EoN> ( <BoN> self <EoN> . <BoN> key pkl <EoN> ) <NEWLINE> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> max <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> max <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logical xor <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get allsegs and allkinds <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> allsegs <EoN> = [ ] <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> filled <EoN> : <NEWLINE> <TAB> <BoN> lowers <EoN> , <BoN> uppers <EoN> = <BoN> self <EoN> . <BoN> get lowers and uppers <EoN> ( ) <NEWLINE> <BoN> allkinds <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> lower <EoN> , <BoN> upper <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> lowers <EoN> , <BoN> uppers <EoN> ) : <NEWLINE> <TAB> <BoN> segs <EoN> , <BoN> kinds <EoN> = <BoN> self <EoN> . <BoN> cpp Contour Generator <EoN> . <BoN> create filled contour <EoN> ( <NEWLINE> <BoN> lower <EoN> , <BoN> upper <EoN> ) <NEWLINE> <BoN> allsegs <EoN> . <BoN> append <EoN> ( [ <BoN> segs <EoN> ] ) <NEWLINE> <BoN> allkinds <EoN> . <BoN> append <EoN> ( [ <BoN> kinds <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> allkinds <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> level <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> levels <EoN> : <NEWLINE> <TAB> <BoN> segs <EoN> = <BoN> self <EoN> . <BoN> cpp Contour Generator <EoN> . <BoN> create contour <EoN> ( <BoN> level <EoN> ) <NEWLINE> <BoN> allsegs <EoN> . <BoN> append <EoN> ( <BoN> segs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> allsegs <EoN> , <BoN> allkinds <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> do prepare twophase <EoN> ( <BoN> self <EoN> , <BoN> connection <EoN> , <BoN> xid <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> stdin encoding <EoN> ( <BoN> encoding <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> sys <EoN> <NEWLINE> <NEWLINE> <BoN> stdin <EoN> = <BoN> sys <EoN> . <BoN> stdin <EoN> <NEWLINE> <BoN> sys <EoN> . <BoN> stdin <EoN> = <BoN> Simple Mock <EoN> ( <BoN> sys <EoN> . <BoN> stdin <EoN> , <STRING> , <BoN> encoding <EoN> ) <NEWLINE> <BoN> yield <EoN> <NEWLINE> <BoN> sys <EoN> . <BoN> stdin <EoN> = <BoN> stdin <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from cython <EoN> ( <BoN> cls <EoN> , <BoN> module <EoN> , <BoN> name <EoN> , <BoN> user data <EoN> = <BoN> None <EoN> , <BoN> signature <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> function <EoN> = <BoN> module <EoN> . <BoN> pyx capi <EoN> [ <BoN> name <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> cls <EoN> ( <BoN> function <EoN> , <BoN> user data <EoN> , <BoN> signature <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add nodes from <EoN> ( <BoN> self <EoN> , <BoN> nbunch <EoN> , ** <BoN> attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> nbunch <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> add node <EoN> ( <BoN> n <EoN> , ** <BoN> attr <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> spectral norm <EoN> ( <BoN> module <EoN> , <BoN> name <EoN> = <STRING> , <BoN> n power iterations <EoN> = <NUMBER> , <BoN> eps <EoN> = <NUMBER> , <BoN> dim <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> dim <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> module <EoN> , ( <BoN> torch <EoN> . <BoN> nn <EoN> . <BoN> Conv Transpose 1 d <EoN> , <NEWLINE> <BoN> torch <EoN> . <BoN> nn <EoN> . <BoN> Conv Transpose 2 d <EoN> , <NEWLINE> <BoN> torch <EoN> . <BoN> nn <EoN> . <BoN> Conv Transpose 3 d <EoN> ) ) : <NEWLINE> <TAB> <BoN> dim <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dim <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> Spectral Norm <EoN> . <BoN> apply <EoN> ( <BoN> module <EoN> , <BoN> name <EoN> , <BoN> n power iterations <EoN> , <BoN> dim <EoN> , <BoN> eps <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> module <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> tc <EoN> . <BoN> accepts <EoN> ( <BoN> object <EoN> , <BoN> ops <EoN> . <BoN> Tensor <EoN> , <NEWLINE> <BoN> tc <EoN> . <BoN> Union <EoN> ( <BoN> Axes <EoN> , <BoN> tc <EoN> . <BoN> Collection <EoN> ( <BoN> tc <EoN> . <BoN> Union <EoN> ( <BoN> string types <EoN> , <BoN> Axis Like <EoN> ) ) ) ) <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> tensor <EoN> , <BoN> axes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> tensor <EoN> = <BoN> tensor <EoN> <NEWLINE> <BoN> shape <EoN> = <BoN> tensor <EoN> . <BoN> get shape <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> axes <EoN> , <BoN> Axes <EoN> ) : <NEWLINE> <TAB> <BoN> unvalidated axes <EoN> = <BoN> axes <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> mutable axes <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> position <EoN> , <BoN> axis like <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> axes <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> axis like <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> shape <EoN> [ <BoN> position <EoN> ] <NEWLINE> <BoN> axis like <EoN> = ( <BoN> axis like <EoN> , <BoN> value <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> mutable axes <EoN> . <BoN> append <EoN> ( <BoN> axis like <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> unvalidated axes <EoN> = <BoN> Axes <EoN> ( <BoN> mutable axes <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> shape <EoN> ) != <BoN> len <EoN> ( <BoN> unvalidated axes <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> % ( <BoN> shape <EoN> , <BoN> unvalidated axes <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> ( <BoN> d <EoN> , <BoN> axis <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> shape <EoN> , <BoN> unvalidated axes <EoN> . <BoN> values <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> d <EoN> != <BoN> axis <EoN> . <BoN> size <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> % <NEWLINE> ( <BoN> axis <EoN> . <BoN> size <EoN> , <BoN> d <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> axes <EoN> = <BoN> unvalidated axes <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is level reference <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> get axis number <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> type <EoN> = <BoN> type <EoN> ( <BoN> self <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> key <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> is hashable <EoN> ( <BoN> key <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> axes <EoN> [ <BoN> axis <EoN> ] . <BoN> names <EoN> <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is label reference <EoN> ( <BoN> key <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get sequential train steps <EoN> ( <BoN> train steps <EoN> = <BoN> namedtuples <EoN> . <BoN> GAN Train Steps <EoN> ( <NUMBER> , <NUMBER> ) ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> sequential train steps <EoN> ( <BoN> sess <EoN> , <BoN> train ops <EoN> , <BoN> global step <EoN> , <BoN> train step kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> should stop op <EoN> , <BoN> train kwargs <EoN> = <BoN> None <EoN> , <BoN> train step kwargs <EoN> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> train step kwargs <EoN> : <NEWLINE> <TAB> <BoN> should stop op <EoN> = <BoN> train step kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> train kwargs <EoN> = <BoN> train step kwargs <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> del <EoN> <BoN> train kwargs <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> gen loss <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> train steps <EoN> . <BoN> generator train steps <EoN> ) : <NEWLINE> <TAB> <BoN> cur gen loss <EoN> , <BoN> <EoN> = <BoN> slim learning <EoN> . <BoN> train step <EoN> ( <NEWLINE> <BoN> sess <EoN> , <BoN> train ops <EoN> . <BoN> generator train op <EoN> , <BoN> global step <EoN> , <BoN> train kwargs <EoN> ) <NEWLINE> <BoN> gen loss <EoN> += <BoN> cur gen loss <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> dis loss <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> train steps <EoN> . <BoN> discriminator train steps <EoN> ) : <NEWLINE> <TAB> <BoN> cur dis loss <EoN> , <BoN> <EoN> = <BoN> slim learning <EoN> . <BoN> train step <EoN> ( <NEWLINE> <BoN> sess <EoN> , <BoN> train ops <EoN> . <BoN> discriminator train op <EoN> , <BoN> global step <EoN> , <BoN> train kwargs <EoN> ) <NEWLINE> <BoN> dis loss <EoN> += <BoN> cur dis loss <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sess <EoN> . <BoN> run <EoN> ( <BoN> train ops <EoN> . <BoN> global step inc op <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> should stop op <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> should stop <EoN> = <BoN> sess <EoN> . <BoN> run <EoN> ( <BoN> should stop op <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> should stop <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> gen loss <EoN> + <BoN> dis loss <EoN> , <BoN> should stop <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sequential train steps <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cast sparse series op <EoN> ( <BoN> left <EoN> , <BoN> right <EoN> , <BoN> opname <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> opname <EoN> = <BoN> opname <EoN> . <BoN> strip <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is integer dtype <EoN> ( <BoN> left <EoN> ) <BoN> and <EoN> <BoN> is integer dtype <EoN> ( <BoN> right <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> opname <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) <BoN> and <EoN> ( <BoN> right <EoN> . <BoN> values <EoN> == <NUMBER> ) . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> left <EoN> = <BoN> left <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> right <EoN> = <BoN> right <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> opname <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) <BoN> and <EoN> ( <BoN> left <EoN> . <BoN> values <EoN> == <NUMBER> ) . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> left <EoN> = <BoN> left <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> right <EoN> = <BoN> right <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> left <EoN> , <BoN> right <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get indices Pow <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> base <EoN> , <BoN> exp <EoN> = <BoN> expr <EoN> . <BoN> as base exp <EoN> ( ) <NEWLINE> <BoN> binds <EoN> , <BoN> bsyms <EoN> = <BoN> get indices <EoN> ( <BoN> base <EoN> ) <NEWLINE> <BoN> einds <EoN> , <BoN> esyms <EoN> = <BoN> get indices <EoN> ( <BoN> exp <EoN> ) <NEWLINE> <NEWLINE> <BoN> inds <EoN> = <BoN> binds <EoN> | <BoN> einds <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> symmetries <EoN> = { } <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> inds <EoN> , <BoN> symmetries <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lagrangian hessian x <EoN> ( <BoN> self <EoN> , <BoN> z <EoN> , <BoN> v <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> self <EoN> . <BoN> get variables <EoN> ( <BoN> z <EoN> ) <NEWLINE> <NEWLINE> <BoN> v eq <EoN> = <BoN> v <EoN> [ : <BoN> self <EoN> . <BoN> n eq <EoN> ] <NEWLINE> <NEWLINE> <BoN> v ineq <EoN> = <BoN> v <EoN> [ <BoN> self <EoN> . <BoN> n eq <EoN> : <BoN> self <EoN> . <BoN> n eq <EoN> + <BoN> self <EoN> . <BoN> n ineq <EoN> ] <NEWLINE> <BoN> lagr hess <EoN> = <BoN> self <EoN> . <BoN> lagr hess <EoN> <NEWLINE> <BoN> return <EoN> <BoN> lagr hess <EoN> ( <BoN> x <EoN> , <BoN> v eq <EoN> , <BoN> v ineq <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> is locally k edge connected <EoN> ( <BoN> G <EoN> , <BoN> s <EoN> , <BoN> t <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> k <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> G <EoN> . <BoN> degree <EoN> ( <BoN> s <EoN> ) < <BoN> k <EoN> <BoN> or <EoN> <BoN> G <EoN> . <BoN> degree <EoN> ( <BoN> t <EoN> ) < <BoN> k <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nx <EoN> . <BoN> has path <EoN> ( <BoN> G <EoN> , <BoN> s <EoN> , <BoN> t <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> localk <EoN> = <BoN> nx <EoN> . <BoN> connectivity <EoN> . <BoN> local edge connectivity <EoN> ( <BoN> G <EoN> , <BoN> s <EoN> , <BoN> t <EoN> , <BoN> cutoff <EoN> = <BoN> k <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> localk <EoN> >= <BoN> k <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reduce <EoN> ( <BoN> self <EoN> , <BoN> reduce op <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> require cross replica context extended <EoN> ( <BoN> self <EoN> . <BoN> extended <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> extended <EoN> . <BoN> reduce <EoN> ( <BoN> reduce op <EoN> , <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Mul <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> itervalues <EoN> ( <BoN> d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> iter <EoN> ( <BoN> getattr <EoN> ( <BoN> d <EoN> , <BoN> itervalues <EoN> ) ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set patchA <EoN> ( <BoN> self <EoN> , <BoN> patch A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> patch A <EoN> = <BoN> patch A <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> NoGradient <EoN> ( <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> broadcast to <EoN> ( <BoN> self <EoN> , <BoN> tensor <EoN> , <BoN> destinations <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> require cross replica context extended <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> destinations <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> broadcast to <EoN> ( <BoN> tensor <EoN> , <BoN> destinations <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is tornado coroutine <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> sys <EoN> . <BoN> modules <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> gen <EoN> = <BoN> sys <EoN> . <BoN> modules <EoN> [ <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> gen <EoN> , <STRING> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> gen <EoN> . <BoN> is coroutine function <EoN> ( <BoN> func <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get ticklabels <EoN> ( <BoN> self <EoN> , <BoN> minor <EoN> = <BoN> False <EoN> , <BoN> which <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> which <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get minorticklabels <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get majorticklabels <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> which <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get majorticklabels <EoN> ( ) + <BoN> self <EoN> . <BoN> get minorticklabels <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> which <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> minor <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get minorticklabels <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get majorticklabels <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parse <EoN> ( <BoN> self <EoN> , <BoN> argument <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> present <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> allow overwrite <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exceptions <EoN> . <BoN> Illegal Flag Value Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> , <BoN> argument <EoN> , <BoN> self <EoN> . <BoN> value <EoN> ) ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> value <EoN> = <BoN> self <EoN> . <BoN> parse <EoN> ( <BoN> argument <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> present <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get cached func code <EoN> ( <BoN> self <EoN> , <BoN> path <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> path <EoN> += [ <STRING> , ] <NEWLINE> <BoN> filename <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> self <EoN> . <BoN> location <EoN> , * <BoN> path <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> self <EoN> . <BoN> open item <EoN> ( <BoN> filename <EoN> , <STRING> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> read <EoN> ( ) . <BoN> decode <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> classify pde <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> = <BoN> None <EoN> , <BoN> dict <EoN> = <BoN> False <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> prep <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> func <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> func <EoN> . <BoN> args <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> prep <EoN> <BoN> or <EoN> <BoN> func <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prep <EoN> , <BoN> func <EoN> = <BoN> preprocess <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> func <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> func <EoN> = <BoN> func <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> eq <EoN> , <BoN> Equality <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> eq <EoN> . <BoN> rhs <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> classify pde <EoN> ( <BoN> eq <EoN> . <BoN> lhs <EoN> - <BoN> eq <EoN> . <BoN> rhs <EoN> , <BoN> func <EoN> ) <NEWLINE> <UNTAB> <BoN> eq <EoN> = <BoN> eq <EoN> . <BoN> lhs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> = <BoN> func <EoN> . <BoN> func <EoN> <NEWLINE> <BoN> x <EoN> = <BoN> func <EoN> . <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> y <EoN> = <BoN> func <EoN> . <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> fx <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> fy <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> order <EoN> = <BoN> ode order <EoN> ( <BoN> eq <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> matching hints <EoN> = { <STRING> : <BoN> order <EoN> } <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> order <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dict <EoN> : <NEWLINE> <TAB> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> matching hints <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> eq <EoN> = <BoN> expand <EoN> ( <BoN> eq <EoN> ) <NEWLINE> <NEWLINE> <BoN> a <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ] ) <NEWLINE> <BoN> b <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ] ) <NEWLINE> <BoN> c <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ] ) <NEWLINE> <BoN> d <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ] ) <NEWLINE> <BoN> e <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> ] ) <NEWLINE> <BoN> n <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> x <EoN> , <BoN> y <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> reduced eq <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> eq <EoN> . <BoN> is Add <EoN> : <NEWLINE> <TAB> <BoN> var <EoN> = <BoN> set <EoN> ( <BoN> combinations with replacement <EoN> ( ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> order <EoN> ) ) <NEWLINE> <BoN> dummyvar <EoN> = <BoN> var <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> power <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> var <EoN> : <NEWLINE> <TAB> <BoN> coeff <EoN> = <BoN> eq <EoN> . <BoN> coeff <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( * <BoN> i <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> coeff <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> match <EoN> = <BoN> coeff <EoN> . <BoN> match <EoN> ( <BoN> a <EoN> * <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ** <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> match <EoN> <BoN> and <EoN> <BoN> match <EoN> [ <BoN> a <EoN> ] : <NEWLINE> <TAB> <BoN> power <EoN> = <BoN> match <EoN> [ <BoN> n <EoN> ] <NEWLINE> <BoN> dummyvar <EoN> . <BoN> remove <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> dummyvar <EoN> . <BoN> remove <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> dummyvar <EoN> : <NEWLINE> <TAB> <BoN> coeff <EoN> = <BoN> eq <EoN> . <BoN> coeff <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) . <BoN> diff <EoN> ( * <BoN> i <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> coeff <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> match <EoN> = <BoN> coeff <EoN> . <BoN> match <EoN> ( <BoN> a <EoN> * <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ** <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> match <EoN> <BoN> and <EoN> <BoN> match <EoN> [ <BoN> a <EoN> ] <BoN> and <EoN> <BoN> match <EoN> [ <BoN> n <EoN> ] < <BoN> power <EoN> : <NEWLINE> <TAB> <BoN> power <EoN> = <BoN> match <EoN> [ <BoN> n <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> power <EoN> : <NEWLINE> <TAB> <BoN> den <EoN> = <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ** <BoN> power <EoN> <NEWLINE> <BoN> reduced eq <EoN> = <BoN> Add <EoN> ( * [ <BoN> arg <EoN> / <BoN> den <EoN> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> eq <EoN> . <BoN> args <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> reduced eq <EoN> : <NEWLINE> <TAB> <BoN> reduced eq <EoN> = <BoN> eq <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> order <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> reduced eq <EoN> = <BoN> collect <EoN> ( <BoN> reduced eq <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <BoN> r <EoN> = <BoN> reduced eq <EoN> . <BoN> match <EoN> ( <BoN> b <EoN> * <BoN> fx <EoN> + <BoN> c <EoN> * <BoN> fy <EoN> + <BoN> d <EoN> * <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) + <BoN> e <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> r <EoN> [ <BoN> e <EoN> ] : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> r <EoN> . <BoN> update <EoN> ( { <STRING> : <BoN> b <EoN> , <STRING> : <BoN> c <EoN> , <STRING> : <BoN> d <EoN> } ) <NEWLINE> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> r <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> r <EoN> [ <BoN> b <EoN> ] ** <NUMBER> + <BoN> r <EoN> [ <BoN> c <EoN> ] ** <NUMBER> != <NUMBER> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> r <EoN> . <BoN> update <EoN> ( { <STRING> : <BoN> b <EoN> , <STRING> : <BoN> c <EoN> , <STRING> : <BoN> d <EoN> , <STRING> : <BoN> e <EoN> } ) <NEWLINE> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> r <EoN> <NEWLINE> <BoN> matching hints <EoN> [ <NEWLINE> <STRING> ] = <BoN> r <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> ] ) <NEWLINE> <BoN> c <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> ] ) <NEWLINE> <BoN> d <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> fx <EoN> , <BoN> fy <EoN> ] ) <NEWLINE> <BoN> r <EoN> = <BoN> reduced eq <EoN> . <BoN> match <EoN> ( <BoN> b <EoN> * <BoN> fx <EoN> + <BoN> c <EoN> * <BoN> fy <EoN> + <BoN> d <EoN> * <BoN> f <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) + <BoN> e <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> . <BoN> update <EoN> ( { <STRING> : <BoN> b <EoN> , <STRING> : <BoN> c <EoN> , <STRING> : <BoN> d <EoN> , <STRING> : <BoN> e <EoN> } ) <NEWLINE> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> r <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> retlist <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> allhints <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> matching hints <EoN> : <NEWLINE> <TAB> <BoN> retlist <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> dict <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> None <EoN> <NEWLINE> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> tuple <EoN> ( <BoN> retlist <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> allhints <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> matching hints <EoN> : <NEWLINE> <TAB> <BoN> matching hints <EoN> [ <STRING> ] = <BoN> i <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> matching hints <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> retlist <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> generative <EoN> <NEWLINE> <BoN> def <EoN> <BoN> group by <EoN> ( <BoN> self <EoN> , * <BoN> clauses <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> append group by <EoN> ( * <BoN> clauses <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> histogramdd <EoN> ( <BoN> sample <EoN> , <BoN> bins <EoN> = <NUMBER> , <BoN> range <EoN> = <BoN> None <EoN> , <BoN> normed <EoN> = <BoN> False <EoN> , <BoN> weights <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> N <EoN> , <BoN> D <EoN> = <BoN> sample <EoN> . <BoN> shape <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Attribute Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> sample <EoN> = <BoN> atleast 2 d <EoN> ( <BoN> sample <EoN> ) . <BoN> T <EoN> <NEWLINE> <BoN> N <EoN> , <BoN> D <EoN> = <BoN> sample <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> nbin <EoN> = <BoN> empty <EoN> ( <BoN> D <EoN> , <BoN> int <EoN> ) <NEWLINE> <BoN> edges <EoN> = <BoN> D <EoN> * [ <BoN> None <EoN> ] <NEWLINE> <BoN> dedges <EoN> = <BoN> D <EoN> * [ <BoN> None <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> weights <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> weights <EoN> = <BoN> asarray <EoN> ( <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> M <EoN> = <BoN> len <EoN> ( <BoN> bins <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> M <EoN> != <BoN> D <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> bins <EoN> = <BoN> D <EoN> * [ <BoN> bins <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> range <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> N <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> smin <EoN> = <BoN> zeros <EoN> ( <BoN> D <EoN> ) <NEWLINE> <BoN> smax <EoN> = <BoN> ones <EoN> ( <BoN> D <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> smin <EoN> = <BoN> atleast 1 d <EoN> ( <BoN> array <EoN> ( <BoN> sample <EoN> . <BoN> min <EoN> ( <NUMBER> ) , <BoN> float <EoN> ) ) <NEWLINE> <BoN> smax <EoN> = <BoN> atleast 1 d <EoN> ( <BoN> array <EoN> ( <BoN> sample <EoN> . <BoN> max <EoN> ( <NUMBER> ) , <BoN> float <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> np <EoN> . <BoN> isfinite <EoN> ( <BoN> range <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> smin <EoN> = <BoN> zeros <EoN> ( <BoN> D <EoN> ) <NEWLINE> <BoN> smax <EoN> = <BoN> zeros <EoN> ( <BoN> D <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> D <EoN> ) : <NEWLINE> <TAB> <BoN> smin <EoN> [ <BoN> i <EoN> ] , <BoN> smax <EoN> [ <BoN> i <EoN> ] = <BoN> range <EoN> [ <BoN> i <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> len <EoN> ( <BoN> smin <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> smin <EoN> [ <BoN> i <EoN> ] == <BoN> smax <EoN> [ <BoN> i <EoN> ] : <NEWLINE> <TAB> <BoN> smin <EoN> [ <BoN> i <EoN> ] = <BoN> smin <EoN> [ <BoN> i <EoN> ] - <NUMBER> <NEWLINE> <BoN> smax <EoN> [ <BoN> i <EoN> ] = <BoN> smax <EoN> [ <BoN> i <EoN> ] + <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> issubdtype <EoN> ( <BoN> sample <EoN> . <BoN> dtype <EoN> , <BoN> np <EoN> . <BoN> inexact <EoN> ) : <NEWLINE> <TAB> <BoN> edge dt <EoN> = <BoN> sample <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> edge dt <EoN> = <BoN> float <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> D <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isscalar <EoN> ( <BoN> bins <EoN> [ <BoN> i <EoN> ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> bins <EoN> [ <BoN> i <EoN> ] < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> nbin <EoN> [ <BoN> i <EoN> ] = <BoN> bins <EoN> [ <BoN> i <EoN> ] + <NUMBER> <NEWLINE> <BoN> edges <EoN> [ <BoN> i <EoN> ] = <BoN> linspace <EoN> ( <BoN> smin <EoN> [ <BoN> i <EoN> ] , <BoN> smax <EoN> [ <BoN> i <EoN> ] , <BoN> nbin <EoN> [ <BoN> i <EoN> ] - <NUMBER> , <BoN> dtype <EoN> = <BoN> edge dt <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> edges <EoN> [ <BoN> i <EoN> ] = <BoN> asarray <EoN> ( <BoN> bins <EoN> [ <BoN> i <EoN> ] , <BoN> edge dt <EoN> ) <NEWLINE> <BoN> nbin <EoN> [ <BoN> i <EoN> ] = <BoN> len <EoN> ( <BoN> edges <EoN> [ <BoN> i <EoN> ] ) + <NUMBER> <NEWLINE> <UNTAB> <BoN> dedges <EoN> [ <BoN> i <EoN> ] = <BoN> diff <EoN> ( <BoN> edges <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> dedges <EoN> [ <BoN> i <EoN> ] ) <= <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> nbin <EoN> = <BoN> asarray <EoN> ( <BoN> nbin <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> N <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> nbin <EoN> - <NUMBER> ) , <BoN> edges <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> Ncount <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> D <EoN> ) : <NEWLINE> <TAB> <BoN> Ncount <EoN> [ <BoN> i <EoN> ] = <BoN> digitize <EoN> ( <BoN> sample <EoN> [ : , <BoN> i <EoN> ] , <BoN> edges <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> D <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> mindiff <EoN> = <BoN> dedges <EoN> [ <BoN> i <EoN> ] . <BoN> min <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> isinf <EoN> ( <BoN> mindiff <EoN> ) : <NEWLINE> <TAB> <BoN> decimal <EoN> = <BoN> int <EoN> ( - <BoN> log 10 <EoN> ( <BoN> mindiff <EoN> ) ) + <NUMBER> <NEWLINE> <NEWLINE> <BoN> not smaller than edge <EoN> = ( <BoN> sample <EoN> [ : , <BoN> i <EoN> ] >= <BoN> edges <EoN> [ <BoN> i <EoN> ] [ - <NUMBER> ] ) <NEWLINE> <BoN> on edge <EoN> = ( <BoN> around <EoN> ( <BoN> sample <EoN> [ : , <BoN> i <EoN> ] , <BoN> decimal <EoN> ) == <NEWLINE> <BoN> around <EoN> ( <BoN> edges <EoN> [ <BoN> i <EoN> ] [ - <NUMBER> ] , <BoN> decimal <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> Ncount <EoN> [ <BoN> i <EoN> ] [ <BoN> nonzero <EoN> ( <BoN> on edge <EoN> & <BoN> not smaller than edge <EoN> ) [ <NUMBER> ] ] -= <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> hist <EoN> = <BoN> zeros <EoN> ( <BoN> nbin <EoN> , <BoN> float <EoN> ) . <BoN> reshape <EoN> ( - <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ni <EoN> = <BoN> nbin <EoN> . <BoN> argsort <EoN> ( ) <NEWLINE> <BoN> xy <EoN> = <BoN> zeros <EoN> ( <BoN> N <EoN> , <BoN> int <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <NUMBER> , <BoN> D <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> xy <EoN> += <BoN> Ncount <EoN> [ <BoN> ni <EoN> [ <BoN> i <EoN> ] ] * <BoN> nbin <EoN> [ <BoN> ni <EoN> [ <BoN> i <EoN> + <NUMBER> : ] ] . <BoN> prod <EoN> ( ) <NEWLINE> <UNTAB> <BoN> xy <EoN> += <BoN> Ncount <EoN> [ <BoN> ni <EoN> [ - <NUMBER> ] ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> xy <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> zeros <EoN> ( <BoN> nbin <EoN> - <NUMBER> , <BoN> int <EoN> ) , <BoN> edges <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> flatcount <EoN> = <BoN> bincount <EoN> ( <BoN> xy <EoN> , <BoN> weights <EoN> ) <NEWLINE> <BoN> a <EoN> = <BoN> arange <EoN> ( <BoN> len <EoN> ( <BoN> flatcount <EoN> ) ) <NEWLINE> <BoN> hist <EoN> [ <BoN> a <EoN> ] = <BoN> flatcount <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> hist <EoN> = <BoN> hist <EoN> . <BoN> reshape <EoN> ( <BoN> sort <EoN> ( <BoN> nbin <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> nbin <EoN> . <BoN> size <EoN> ) : <NEWLINE> <TAB> <BoN> j <EoN> = <BoN> ni <EoN> . <BoN> argsort <EoN> ( ) [ <BoN> i <EoN> ] <NEWLINE> <BoN> hist <EoN> = <BoN> hist <EoN> . <BoN> swapaxes <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> ) <NEWLINE> <BoN> ni <EoN> [ <BoN> i <EoN> ] , <BoN> ni <EoN> [ <BoN> j <EoN> ] = <BoN> ni <EoN> [ <BoN> j <EoN> ] , <BoN> ni <EoN> [ <BoN> i <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> core <EoN> = <BoN> D <EoN> * [ <BoN> slice <EoN> ( <NUMBER> , - <NUMBER> ) ] <NEWLINE> <BoN> hist <EoN> = <BoN> hist <EoN> [ <BoN> core <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> normed <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> hist <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> arange <EoN> ( <BoN> D <EoN> ) : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> ones <EoN> ( <BoN> D <EoN> , <BoN> int <EoN> ) <NEWLINE> <BoN> shape <EoN> [ <BoN> i <EoN> ] = <BoN> nbin <EoN> [ <BoN> i <EoN> ] - <NUMBER> <NEWLINE> <BoN> hist <EoN> = <BoN> hist <EoN> / <BoN> dedges <EoN> [ <BoN> i <EoN> ] . <BoN> reshape <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> hist <EoN> /= <BoN> s <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> hist <EoN> . <BoN> shape <EoN> != <BoN> nbin <EoN> - <NUMBER> ) . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> hist <EoN> , <BoN> edges <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> register option <EoN> ( <BoN> key <EoN> , <BoN> defval <EoN> , <BoN> doc <EoN> = <STRING> , <BoN> validator <EoN> = <BoN> None <EoN> , <BoN> cb <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> tokenize <EoN> <NEWLINE> <BoN> import <EoN> <BoN> keyword <EoN> <NEWLINE> <BoN> key <EoN> = <BoN> key <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> registered options <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Option Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> key <EoN> = <BoN> key <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> reserved keys <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Option Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> key <EoN> = <BoN> key <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> validator <EoN> : <NEWLINE> <TAB> <BoN> validator <EoN> ( <BoN> defval <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> path <EoN> = <BoN> key <EoN> . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> path <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> bool <EoN> ( <BoN> re <EoN> . <BoN> match <EoN> ( <STRING> + <BoN> tokenize <EoN> . <BoN> Name <EoN> + <STRING> , <BoN> k <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> k <EoN> = <BoN> k <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> keyword <EoN> . <BoN> iskeyword <EoN> ( <BoN> k <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> k <EoN> = <BoN> k <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> cursor <EoN> = <BoN> global config <EoN> <NEWLINE> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> p <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> path <EoN> [ : - <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> cursor <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Option Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> option <EoN> = <STRING> . <BoN> join <EoN> ( <BoN> path <EoN> [ : <BoN> i <EoN> ] ) ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> p <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> cursor <EoN> : <NEWLINE> <TAB> <BoN> cursor <EoN> [ <BoN> p <EoN> ] = { } <NEWLINE> <UNTAB> <BoN> cursor <EoN> = <BoN> cursor <EoN> [ <BoN> p <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> cursor <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Option Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> option <EoN> = <STRING> . <BoN> join <EoN> ( <BoN> path <EoN> [ : - <NUMBER> ] ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> cursor <EoN> [ <BoN> path <EoN> [ - <NUMBER> ] ] = <BoN> defval <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> registered options <EoN> [ <BoN> key <EoN> ] = <BoN> Registered Option <EoN> ( <BoN> key <EoN> = <BoN> key <EoN> , <BoN> defval <EoN> = <BoN> defval <EoN> , <NEWLINE> <BoN> doc <EoN> = <BoN> doc <EoN> , <BoN> validator <EoN> = <BoN> validator <EoN> , <NEWLINE> <BoN> cb <EoN> = <BoN> cb <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exit <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> . <BoN> rcmod <EoN> <BoN> import <EoN> <BoN> set palette <EoN> <NEWLINE> <BoN> set palette <EoN> ( <BoN> self <EoN> . <BoN> orig palette <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> debug print <EoN> ( <BoN> self <EoN> , <BoN> msg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> distutils <EoN> . <BoN> debug <EoN> <BoN> import <EoN> <BoN> DEBU G <EoN> <NEWLINE> <BoN> if <EoN> <BoN> DEBU G <EoN> : <NEWLINE> <TAB> <BoN> print <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <BoN> sys <EoN> . <BoN> stdout <EoN> . <BoN> flush <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abc <EoN> . <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> save <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set configuration from sharded input tensors <EoN> ( <BoN> self <EoN> , <BoN> input tensors <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> frozen <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> tuple shapes <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> number of shards <EoN> = <BoN> len <EoN> ( <BoN> input tensors <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> set number of shards <EoN> ( <BoN> number of shards <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> input tensors <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> t <EoN> ) != <BoN> self <EoN> . <BoN> number of tuple elements <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % ( <NEWLINE> <BoN> str <EoN> ( <BoN> input tensors <EoN> ) , <BoN> self <EoN> . <BoN> number of tuple elements <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> sharded shapes <EoN> = [ [ <BoN> t <EoN> [ <BoN> i <EoN> ] . <BoN> shape <EoN> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> input tensors <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> self <EoN> . <BoN> number of tuple elements <EoN> ) ] <NEWLINE> <NEWLINE> <BoN> unsharded shapes <EoN> = [ <NEWLINE> <BoN> policy <EoN> . <BoN> get unsharded shape <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> for <EoN> ( <BoN> policy <EoN> , <BoN> s <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> sharding policies <EoN> , <BoN> sharded shapes <EoN> ) <NEWLINE> ] <NEWLINE> <BoN> self <EoN> . <BoN> set tuple shapes <EoN> ( <BoN> unsharded shapes <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <NUMBER> , <BoN> self <EoN> . <BoN> number of shards <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> ( <BoN> t 1 <EoN> , <BoN> t 2 <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> input tensors <EoN> [ <NUMBER> ] , <BoN> input tensors <EoN> [ <BoN> i <EoN> ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> t 1 <EoN> . <BoN> dtype <EoN> != <BoN> t 2 <EoN> . <BoN> dtype <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> str <EoN> ( <BoN> input tensors <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> set tuple types <EoN> ( [ <BoN> t <EoN> . <BoN> dtype <EoN> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> input tensors <EoN> [ <NUMBER> ] ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> scan <EoN> ( <BoN> initial state <EoN> , <BoN> scan func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> apply fn <EoN> ( <BoN> dataset <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ScanDataset <EoN> ( <BoN> dataset <EoN> , <BoN> initial state <EoN> , <BoN> scan func <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> apply fn <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add n <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> Manager <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> . <BoN> managers <EoN> <BoN> import <EoN> <BoN> Sync Manager <EoN> <NEWLINE> <BoN> m <EoN> = <BoN> Sync Manager <EoN> ( <BoN> ctx <EoN> = <BoN> self <EoN> . <BoN> get context <EoN> ( ) ) <NEWLINE> <BoN> m <EoN> . <BoN> start <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> m <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> start trajectory <EoN> ( <BoN> self <EoN> , <BoN> xm <EoN> , <BoN> ym <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> traj <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> update trajectory <EoN> ( <BoN> xm <EoN> , <BoN> ym <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logical and eager fallback <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> x <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> x <EoN> , <BoN> dtypes <EoN> . <BoN> bool <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> y <EoN> , <BoN> dtypes <EoN> . <BoN> bool <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> x <EoN> , <BoN> y <EoN> ] <NEWLINE> <BoN> attrs <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> adjust contrast <EoN> ( <BoN> images <EoN> , <BoN> contrast factor <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> None <EoN> , <STRING> , <NEWLINE> [ <BoN> images <EoN> , <BoN> contrast factor <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> images <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> images <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> orig dtype <EoN> = <BoN> images <EoN> . <BoN> dtype <EoN> <NEWLINE> <BoN> flt images <EoN> = <BoN> convert image dtype <EoN> ( <BoN> images <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <NEWLINE> <BoN> adjusted <EoN> = <BoN> gen image ops <EoN> . <BoN> adjust contrastv 2 <EoN> ( <NEWLINE> <BoN> flt images <EoN> , <BoN> contrast factor <EoN> = <BoN> contrast factor <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> convert image dtype <EoN> ( <BoN> adjusted <EoN> , <BoN> orig dtype <EoN> , <BoN> saturate <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from float <EoN> ( <BoN> x <EoN> , <BoN> prec <EoN> = <NUMBER> , <BoN> rnd <EoN> = <BoN> round fast <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> != <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fnan <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> m <EoN> , <BoN> e <EoN> = <BoN> math <EoN> . <BoN> frexp <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> == <BoN> math float inf <EoN> : <BoN> return <EoN> <BoN> finf <EoN> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> == - <BoN> math float inf <EoN> : <BoN> return <EoN> <BoN> fninf <EoN> <NEWLINE> <BoN> return <EoN> <BoN> fnan <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> == <BoN> math float inf <EoN> : <BoN> return <EoN> <BoN> finf <EoN> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> == - <BoN> math float inf <EoN> : <BoN> return <EoN> <BoN> fninf <EoN> <NEWLINE> <BoN> return <EoN> <BoN> from man exp <EoN> ( <BoN> int <EoN> ( <BoN> m <EoN> * ( <NUMBER> << <NUMBER> ) ) , <BoN> e <EoN> - <NUMBER> , <BoN> prec <EoN> , <BoN> rnd <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> split batch beams <EoN> ( <BoN> self <EoN> , <BoN> t <EoN> , <BoN> s <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> ops <EoN> . <BoN> Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( <BoN> tensor util <EoN> . <BoN> constant value <EoN> ( <BoN> s <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <BoN> t shape <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> reshaped t <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <NEWLINE> <BoN> t <EoN> , <NEWLINE> <BoN> array ops <EoN> . <BoN> concat <EoN> ( ( [ <BoN> self <EoN> . <BoN> batch size <EoN> , <BoN> self <EoN> . <BoN> beam width <EoN> ] , <BoN> t shape <EoN> [ <NUMBER> : ] ) , <NEWLINE> <NUMBER> ) ) <NEWLINE> <BoN> static batch size <EoN> = <BoN> tensor util <EoN> . <BoN> constant value <EoN> ( <BoN> self <EoN> . <BoN> batch size <EoN> ) <NEWLINE> <BoN> expected reshaped shape <EoN> = <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ( <NEWLINE> [ <BoN> static batch size <EoN> , <BoN> self <EoN> . <BoN> beam width <EoN> ] ) . <BoN> concatenate <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> reshaped t <EoN> . <BoN> shape <EoN> . <BoN> is compatible with <EoN> ( <BoN> expected reshaped shape <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> reshaped t <EoN> . <BoN> shape <EoN> , <BoN> expected reshaped shape <EoN> ) ) <NEWLINE> <UNTAB> <BoN> reshaped t <EoN> . <BoN> set shape <EoN> ( <BoN> expected reshaped shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> reshaped t <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tensor jacobian product <EoN> ( <BoN> fun <EoN> , <BoN> argnum <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> vector dot fun <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <BoN> args <EoN> , <BoN> vector <EoN> = <BoN> args <EoN> [ : - <NUMBER> ] , <BoN> args <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> tensordot <EoN> ( <BoN> vector <EoN> , <BoN> fun <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) , <BoN> axes <EoN> = <BoN> np <EoN> . <BoN> ndim <EoN> ( <BoN> vector <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> jacobian <EoN> ( <BoN> vector dot fun <EoN> , <BoN> argnum <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> primitive <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> terms <EoN> = [ ] <NEWLINE> <BoN> inf <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> , <BoN> m <EoN> = <BoN> a <EoN> . <BoN> as coeff Mul <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> c <EoN> . <BoN> is Rational <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <BoN> m <EoN> = <BoN> a <EoN> <NEWLINE> <UNTAB> <BoN> inf <EoN> = <BoN> inf <EoN> <BoN> or <EoN> <BoN> m <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Complex Infinity <EoN> <NEWLINE> <BoN> terms <EoN> . <BoN> append <EoN> ( ( <BoN> c <EoN> . <BoN> p <EoN> , <BoN> c <EoN> . <BoN> q <EoN> , <BoN> m <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> inf <EoN> : <NEWLINE> <TAB> <BoN> ngcd <EoN> = <BoN> reduce <EoN> ( <BoN> igcd <EoN> , [ <BoN> t <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> terms <EoN> ] , <NUMBER> ) <NEWLINE> <BoN> dlcm <EoN> = <BoN> reduce <EoN> ( <BoN> ilcm <EoN> , [ <BoN> t <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> terms <EoN> ] , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ngcd <EoN> = <BoN> reduce <EoN> ( <BoN> igcd <EoN> , [ <BoN> t <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> terms <EoN> <BoN> if <EoN> <BoN> t <EoN> [ <NUMBER> ] ] , <NUMBER> ) <NEWLINE> <BoN> dlcm <EoN> = <BoN> reduce <EoN> ( <BoN> ilcm <EoN> , [ <BoN> t <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> terms <EoN> <BoN> if <EoN> <BoN> t <EoN> [ <NUMBER> ] ] , <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ngcd <EoN> == <BoN> dlcm <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> One <EoN> , <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> inf <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> p <EoN> , <BoN> q <EoN> , <BoN> term <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> terms <EoN> ) : <NEWLINE> <TAB> <BoN> terms <EoN> [ <BoN> i <EoN> ] = <BoN> keep coeff <EoN> ( <BoN> Rational <EoN> ( ( <BoN> p <EoN> // <BoN> ngcd <EoN> ) * ( <BoN> dlcm <EoN> // <BoN> q <EoN> ) ) , <BoN> term <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> p <EoN> , <BoN> q <EoN> , <BoN> term <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> terms <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> q <EoN> : <NEWLINE> <TAB> <BoN> terms <EoN> [ <BoN> i <EoN> ] = <BoN> keep coeff <EoN> ( <BoN> Rational <EoN> ( ( <BoN> p <EoN> // <BoN> ngcd <EoN> ) * ( <BoN> dlcm <EoN> // <BoN> q <EoN> ) ) , <BoN> term <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> terms <EoN> [ <BoN> i <EoN> ] = <BoN> keep coeff <EoN> ( <BoN> Rational <EoN> ( <BoN> p <EoN> , <BoN> q <EoN> ) , <BoN> term <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> terms <EoN> [ <NUMBER> ] . <BoN> is Number <EoN> <BoN> or <EoN> <BoN> terms <EoN> [ <NUMBER> ] <BoN> is <EoN> <BoN> S <EoN> . <BoN> Complex Infinity <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> terms <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> addsort <EoN> ( <BoN> terms <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> c <EoN> : <NEWLINE> <TAB> <BoN> terms <EoN> . <BoN> insert <EoN> ( <NUMBER> , <BoN> c <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Rational <EoN> ( <BoN> ngcd <EoN> , <BoN> dlcm <EoN> ) , <BoN> self <EoN> . <BoN> new rawargs <EoN> ( * <BoN> terms <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> trigger tool <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> toolmanager <EoN> . <BoN> trigger tool <EoN> ( <BoN> name <EoN> , <BoN> sender <EoN> = <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add edge <EoN> ( <BoN> self <EoN> , <BoN> u of edge <EoN> , <BoN> v of edge <EoN> , ** <BoN> attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> u <EoN> , <BoN> v <EoN> = <BoN> u of edge <EoN> , <BoN> v of edge <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> u <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> succ <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> succ <EoN> [ <BoN> u <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> pred <EoN> [ <BoN> u <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> node <EoN> [ <BoN> u <EoN> ] = { } <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> succ <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> succ <EoN> [ <BoN> v <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> pred <EoN> [ <BoN> v <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> node <EoN> [ <BoN> v <EoN> ] = { } <NEWLINE> <NEWLINE> <UNTAB> <BoN> datadict <EoN> = <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> u <EoN> ] . <BoN> get <EoN> ( <BoN> v <EoN> , <BoN> self <EoN> . <BoN> edge attr dict factory <EoN> ( ) ) <NEWLINE> <BoN> datadict <EoN> . <BoN> update <EoN> ( <BoN> attr <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> succ <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] = <BoN> datadict <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> pred <EoN> [ <BoN> v <EoN> ] [ <BoN> u <EoN> ] = <BoN> datadict <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> onenorm matrix power nnm <EoN> ( <BoN> A <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> int <EoN> ( <BoN> p <EoN> ) != <BoN> p <EoN> <BoN> or <EoN> <BoN> p <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> int <EoN> ( <BoN> p <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> A <EoN> . <BoN> shape <EoN> ) != <NUMBER> <BoN> or <EoN> <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] != <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> v <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( ( <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] , <NUMBER> ) , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> M <EoN> = <BoN> A <EoN> . <BoN> T <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> p <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> M <EoN> . <BoN> dot <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> max <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shape array <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> shape array <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fast destroy <EoN> ( <BoN> self <EoN> , <BoN> app <EoN> , <BoN> reason <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dm <EoN> = <BoN> getattr <EoN> ( <BoN> app <EoN> . <BoN> op <EoN> , <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dm <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> inputs <EoN> = <BoN> set <EoN> ( <BoN> itertools <EoN> . <BoN> chain <EoN> . <BoN> from iterable <EoN> ( <BoN> dm <EoN> . <BoN> values <EoN> ( ) ) ) <NEWLINE> <BoN> for <EoN> <BoN> inp idx <EoN> <BoN> in <EoN> <BoN> inputs <EoN> : <NEWLINE> <TAB> <BoN> inp <EoN> = <BoN> app <EoN> . <BoN> inputs <EoN> [ <BoN> inp idx <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> getattr <EoN> ( <BoN> inp <EoN> . <BoN> tag <EoN> , <STRING> , <BoN> False <EoN> ) <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> inp <EoN> , <BoN> graph <EoN> . <BoN> Constant <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fail validate <EoN> [ <BoN> app <EoN> ] = <BoN> Inconsistency Error <EoN> ( <NEWLINE> <STRING> % <NEWLINE> <BoN> inp <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> inp <EoN> . <BoN> clients <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fail validate <EoN> [ <BoN> app <EoN> ] = <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Inconsistency Error <EoN> ( <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> reason <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> inp <EoN> . <BoN> owner <EoN> : <NEWLINE> <TAB> <BoN> app 2 <EoN> = <BoN> inp <EoN> . <BoN> owner <EoN> <NEWLINE> <BoN> inp idx 2 <EoN> = <BoN> app 2 <EoN> . <BoN> outputs <EoN> . <BoN> index <EoN> ( <BoN> inp <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> getattr <EoN> ( <BoN> app 2 <EoN> . <BoN> op <EoN> , <STRING> , { } ) <NEWLINE> <BoN> d <EoN> = <BoN> getattr <EoN> ( <BoN> app 2 <EoN> . <BoN> op <EoN> , <STRING> , { } ) <NEWLINE> <BoN> if <EoN> <BoN> v <EoN> : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> v <EoN> . <BoN> get <EoN> ( <BoN> inp idx 2 <EoN> , [ ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> v <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fail validate <EoN> [ <BoN> app <EoN> ] = <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Inconsistency Error <EoN> ( <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> reason <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> d <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> d <EoN> . <BoN> get <EoN> ( <BoN> inp idx 2 <EoN> , [ ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> d <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fail validate <EoN> [ <BoN> app <EoN> ] = <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> Inconsistency Error <EoN> ( <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> reason <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> solve discrete are <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> q <EoN> , <BoN> r <EoN> , <BoN> e <EoN> = <BoN> None <EoN> , <BoN> s <EoN> = <BoN> None <EoN> , <BoN> balanced <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> q <EoN> , <BoN> r <EoN> , <BoN> e <EoN> , <BoN> s <EoN> , <BoN> m <EoN> , <BoN> n <EoN> , <BoN> r or c <EoN> , <BoN> gen are <EoN> = <BoN> are validate args <EoN> ( <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> q <EoN> , <BoN> r <EoN> , <BoN> e <EoN> , <BoN> s <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> H <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <NUMBER> * <BoN> m <EoN> + <BoN> n <EoN> , <NUMBER> * <BoN> m <EoN> + <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> r or c <EoN> ) <NEWLINE> <BoN> H <EoN> [ : <BoN> m <EoN> , : <BoN> m <EoN> ] = <BoN> a <EoN> <NEWLINE> <BoN> H <EoN> [ : <BoN> m <EoN> , <NUMBER> * <BoN> m <EoN> : ] = <BoN> b <EoN> <NEWLINE> <BoN> H <EoN> [ <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> , : <BoN> m <EoN> ] = - <BoN> q <EoN> <NEWLINE> <BoN> H <EoN> [ <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> , <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> ] = <BoN> np <EoN> . <BoN> eye <EoN> ( <BoN> m <EoN> ) <BoN> if <EoN> <BoN> e <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> e <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> <NEWLINE> <BoN> H <EoN> [ <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> , <NUMBER> * <BoN> m <EoN> : ] = <NUMBER> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> - <BoN> s <EoN> <NEWLINE> <BoN> H <EoN> [ <NUMBER> * <BoN> m <EoN> : , : <BoN> m <EoN> ] = <NUMBER> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> s <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> <NEWLINE> <BoN> H <EoN> [ <NUMBER> * <BoN> m <EoN> : , <NUMBER> * <BoN> m <EoN> : ] = <BoN> r <EoN> <NEWLINE> <NEWLINE> <BoN> J <EoN> = <BoN> np <EoN> . <BoN> zeros like <EoN> ( <BoN> H <EoN> , <BoN> dtype <EoN> = <BoN> r or c <EoN> ) <NEWLINE> <BoN> J <EoN> [ : <BoN> m <EoN> , : <BoN> m <EoN> ] = <BoN> np <EoN> . <BoN> eye <EoN> ( <BoN> m <EoN> ) <BoN> if <EoN> <BoN> e <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> e <EoN> <NEWLINE> <BoN> J <EoN> [ <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> , <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> ] = <BoN> a <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> <NEWLINE> <BoN> J <EoN> [ <NUMBER> * <BoN> m <EoN> : , <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> ] = - <BoN> b <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> balanced <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> M <EoN> = <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> H <EoN> ) + <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> J <EoN> ) <NEWLINE> <BoN> M <EoN> [ <BoN> np <EoN> . <BoN> diag indices from <EoN> ( <BoN> M <EoN> ) ] = <NUMBER> <NEWLINE> <BoN> <EoN> , ( <BoN> sca <EoN> , <BoN> <EoN> ) = <BoN> matrix balance <EoN> ( <BoN> M <EoN> , <BoN> separate <EoN> = <NUMBER> , <BoN> permute <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> sca <EoN> , <BoN> np <EoN> . <BoN> ones like <EoN> ( <BoN> sca <EoN> ) ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> sca <EoN> = <BoN> np <EoN> . <BoN> log 2 <EoN> ( <BoN> sca <EoN> ) <NEWLINE> <NEWLINE> <BoN> s <EoN> = <BoN> np <EoN> . <BoN> round <EoN> ( ( <BoN> sca <EoN> [ <BoN> m <EoN> : <NUMBER> * <BoN> m <EoN> ] - <BoN> sca <EoN> [ : <BoN> m <EoN> ] ) / <NUMBER> ) <NEWLINE> <BoN> sca <EoN> = <NUMBER> ** <BoN> np <EoN> . <BoN> r <EoN> [ <BoN> s <EoN> , - <BoN> s <EoN> , <BoN> sca <EoN> [ <NUMBER> * <BoN> m <EoN> : ] ] <NEWLINE> <NEWLINE> <BoN> elwisescale <EoN> = <BoN> sca <EoN> [ : , <BoN> None <EoN> ] * <BoN> np <EoN> . <BoN> reciprocal <EoN> ( <BoN> sca <EoN> ) <NEWLINE> <BoN> H <EoN> *= <BoN> elwisescale <EoN> <NEWLINE> <BoN> J <EoN> *= <BoN> elwisescale <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> q of qr <EoN> , <BoN> <EoN> = <BoN> qr <EoN> ( <BoN> H <EoN> [ : , - <BoN> n <EoN> : ] ) <NEWLINE> <BoN> H <EoN> = <BoN> q of qr <EoN> [ : , <BoN> n <EoN> : ] . <BoN> conj <EoN> ( ) . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> H <EoN> [ : , : <NUMBER> * <BoN> m <EoN> ] ) <NEWLINE> <BoN> J <EoN> = <BoN> q of qr <EoN> [ : , <BoN> n <EoN> : ] . <BoN> conj <EoN> ( ) . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> J <EoN> [ : , : <NUMBER> * <BoN> m <EoN> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> out str <EoN> = <STRING> <BoN> if <EoN> <BoN> r or c <EoN> == <BoN> float <EoN> <BoN> else <EoN> <STRING> <NEWLINE> <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> <EoN> , <BoN> u <EoN> = <BoN> ordqz <EoN> ( <BoN> H <EoN> , <BoN> J <EoN> , <BoN> sort <EoN> = <STRING> , <NEWLINE> <BoN> overwrite a <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> overwrite b <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> check finite <EoN> = <BoN> False <EoN> , <NEWLINE> <BoN> output <EoN> = <BoN> out str <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> e <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> u <EoN> , <BoN> <EoN> = <BoN> qr <EoN> ( <BoN> np <EoN> . <BoN> vstack <EoN> ( ( <BoN> e <EoN> . <BoN> dot <EoN> ( <BoN> u <EoN> [ : <BoN> m <EoN> , : <BoN> m <EoN> ] ) , <BoN> u <EoN> [ <BoN> m <EoN> : , : <BoN> m <EoN> ] ) ) ) <NEWLINE> <UNTAB> <BoN> u 00 <EoN> = <BoN> u <EoN> [ : <BoN> m <EoN> , : <BoN> m <EoN> ] <NEWLINE> <BoN> u 10 <EoN> = <BoN> u <EoN> [ <BoN> m <EoN> : , : <BoN> m <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> up <EoN> , <BoN> ul <EoN> , <BoN> uu <EoN> = <BoN> lu <EoN> ( <BoN> u 00 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <NUMBER> / <BoN> cond <EoN> ( <BoN> uu <EoN> ) < <BoN> np <EoN> . <BoN> spacing <EoN> ( <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Lin Alg Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> solve triangular <EoN> ( <BoN> ul <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> , <NEWLINE> <BoN> solve triangular <EoN> ( <BoN> uu <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> , <NEWLINE> <BoN> u 10 <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> , <NEWLINE> <BoN> lower <EoN> = <BoN> True <EoN> ) , <NEWLINE> <BoN> unit diagonal <EoN> = <BoN> True <EoN> , <NEWLINE> ) . <BoN> conj <EoN> ( ) . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> up <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> balanced <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> *= <BoN> sca <EoN> [ : <BoN> m <EoN> , <BoN> None <EoN> ] * <BoN> sca <EoN> [ : <BoN> m <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> u sym <EoN> = <BoN> u 00 <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> u 10 <EoN> ) <NEWLINE> <BoN> n u sym <EoN> = <BoN> norm <EoN> ( <BoN> u sym <EoN> , <NUMBER> ) <NEWLINE> <BoN> u sym <EoN> = <BoN> u sym <EoN> - <BoN> u sym <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> <NEWLINE> <BoN> sym threshold <EoN> = <BoN> np <EoN> . <BoN> max <EoN> ( [ <BoN> np <EoN> . <BoN> spacing <EoN> ( <NUMBER> ) , <NUMBER> * <BoN> n u sym <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> norm <EoN> ( <BoN> u sym <EoN> , <NUMBER> ) > <BoN> sym threshold <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Lin Alg Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> x <EoN> + <BoN> x <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> ) / <NUMBER> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> inv <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> inv eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> find localzeros <EoN> ( <BoN> cls <EoN> , <BoN> values <EoN> , ** <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> localzeros <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> values <EoN> : <NEWLINE> <TAB> <BoN> is newzero <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> localzeros <EoN> = <BoN> list <EoN> ( <BoN> localzeros <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> z <EoN> <BoN> in <EoN> <BoN> localzeros <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> id <EoN> ( <BoN> v <EoN> ) == <BoN> id <EoN> ( <BoN> z <EoN> ) : <NEWLINE> <TAB> <BoN> is newzero <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> con <EoN> = <BoN> cls <EoN> . <BoN> is connected <EoN> ( <BoN> v <EoN> , <BoN> z <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> con <EoN> : <NEWLINE> <TAB> <BoN> is newzero <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> con <EoN> <BoN> is <EoN> <BoN> True <EoN> <BoN> or <EoN> <BoN> con <EoN> == <BoN> cls <EoN> : <NEWLINE> <TAB> <BoN> localzeros <EoN> . <BoN> remove <EoN> ( <BoN> z <EoN> ) <NEWLINE> <BoN> localzeros <EoN> . <BoN> update <EoN> ( [ <BoN> v <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> is newzero <EoN> : <NEWLINE> <TAB> <BoN> localzeros <EoN> . <BoN> update <EoN> ( [ <BoN> v <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> localzeros <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> exp <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> exp eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> exp <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> exp <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> box iou <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> format <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> lhs <EoN> , <BoN> rhs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> lhs <EoN> , <BoN> ND Array <EoN> ) <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> rhs <EoN> , <BoN> ND Array <EoN> ) <BoN> and <EoN> <BoN> lhs <EoN> . <BoN> shape <EoN> == <BoN> rhs <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ufunc helper <EoN> ( <NEWLINE> <BoN> lhs <EoN> , <NEWLINE> <BoN> rhs <EoN> , <NEWLINE> <BoN> op <EoN> . <BoN> elemwise add <EoN> , <NEWLINE> <BoN> operator <EoN> . <BoN> add <EoN> , <NEWLINE> <BoN> internal <EoN> . <BoN> plus scalar <EoN> , <NEWLINE> <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ufunc helper <EoN> ( <NEWLINE> <BoN> lhs <EoN> , <NEWLINE> <BoN> rhs <EoN> , <NEWLINE> <BoN> op <EoN> . <BoN> broadcast add <EoN> , <NEWLINE> <BoN> operator <EoN> . <BoN> add <EoN> , <NEWLINE> <BoN> internal <EoN> . <BoN> plus scalar <EoN> , <NEWLINE> <BoN> None <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max len seq <EoN> ( <BoN> nbits <EoN> , <BoN> state <EoN> = <BoN> None <EoN> , <BoN> length <EoN> = <BoN> None <EoN> , <BoN> taps <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> taps <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> nbits <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> mls taps <EoN> : <NEWLINE> <TAB> <BoN> known taps <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> list <EoN> ( <BoN> mls taps <EoN> . <BoN> keys <EoN> ( ) ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> % ( <BoN> known taps <EoN> . <BoN> min <EoN> ( ) , <BoN> known taps <EoN> . <BoN> max <EoN> ( ) ) ) <NEWLINE> <UNTAB> <BoN> taps <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> mls taps <EoN> [ <BoN> nbits <EoN> ] , <BoN> np <EoN> . <BoN> intp <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> taps <EoN> = <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> taps <EoN> , <BoN> np <EoN> . <BoN> intp <EoN> ) ) [ : : - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> taps <EoN> < <NUMBER> ) <BoN> or <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> taps <EoN> > <BoN> nbits <EoN> ) <BoN> or <EoN> <BoN> taps <EoN> . <BoN> size <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> taps <EoN> = <BoN> np <EoN> . <BoN> ascontiguousarray <EoN> ( <BoN> taps <EoN> ) <NEWLINE> <UNTAB> <BoN> n max <EoN> = ( <NUMBER> ** <BoN> nbits <EoN> ) - <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> length <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> length <EoN> = <BoN> n max <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> length <EoN> = <BoN> int <EoN> ( <BoN> length <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> length <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> state <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> state <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( <BoN> nbits <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 8 <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> state <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> state <EoN> , <BoN> dtype <EoN> = <BoN> bool <EoN> , <BoN> order <EoN> = <STRING> ) . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> int 8 <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> state <EoN> . <BoN> ndim <EoN> != <NUMBER> <BoN> or <EoN> <BoN> state <EoN> . <BoN> size <EoN> != <BoN> nbits <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> state <EoN> == <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> seq <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> length <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 8 <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <BoN> state <EoN> = <BoN> max len seq inner <EoN> ( <BoN> taps <EoN> , <BoN> state <EoN> , <BoN> nbits <EoN> , <BoN> length <EoN> , <BoN> seq <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> seq <EoN> , <BoN> state <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parse <EoN> ( <BoN> self <EoN> , <BoN> file <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> empty re <EoN> = <BoN> re <EoN> . <BoN> compile <EoN> ( <STRING> ) <NEWLINE> <BoN> word re <EoN> = <BoN> re <EoN> . <BoN> compile <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <BoN> effects re <EoN> = <BoN> re <EoN> . <BoN> compile <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <BoN> lines <EoN> = ( <BoN> line <EoN> . <BoN> strip <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> line <EoN> <BoN> in <EoN> <BoN> file <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> empty re <EoN> . <BoN> match <EoN> ( <BoN> line <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> line <EoN> <BoN> in <EoN> <BoN> lines <EoN> : <NEWLINE> <TAB> <BoN> effects <EoN> , <BoN> encoding <EoN> , <BoN> filename <EoN> = <STRING> , <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <BoN> words <EoN> = <BoN> word re <EoN> . <BoN> finditer <EoN> ( <BoN> line <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> w <EoN> = <BoN> next <EoN> ( <BoN> words <EoN> ) <NEWLINE> <BoN> texname <EoN> = <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <NEWLINE> <BoN> w <EoN> = <BoN> next <EoN> ( <BoN> words <EoN> ) <NEWLINE> <BoN> psname <EoN> = <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> words <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> eff <EoN> = <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> eff <EoN> : <NEWLINE> <TAB> <BoN> effects <EoN> = <BoN> eff <EoN> <NEWLINE> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> enc <EoN> = ( <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <NEWLINE> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) ) <NEWLINE> <BoN> if <EoN> <BoN> enc <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> encoding <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> debug <EoN> ( <STRING> , <NEWLINE> <BoN> texname <EoN> , <BoN> psname <EoN> ) <NEWLINE> <UNTAB> <BoN> encoding <EoN> = <BoN> enc <EoN> <NEWLINE> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> filename <EoN> = <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> w <EoN> . <BoN> group <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> effects dict <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> match <EoN> <BoN> in <EoN> <BoN> effects re <EoN> . <BoN> finditer <EoN> ( <BoN> effects <EoN> ) : <NEWLINE> <TAB> <BoN> slant <EoN> = <BoN> match <EoN> . <BoN> group <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> slant <EoN> : <NEWLINE> <TAB> <BoN> effects dict <EoN> [ <STRING> ] = <BoN> float <EoN> ( <BoN> slant <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> effects dict <EoN> [ <STRING> ] = <BoN> float <EoN> ( <BoN> match <EoN> . <BoN> group <EoN> ( <STRING> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> font <EoN> [ <BoN> texname <EoN> ] = <BoN> Ps Font <EoN> ( <NEWLINE> <BoN> texname <EoN> = <BoN> texname <EoN> , <BoN> psname <EoN> = <BoN> psname <EoN> , <BoN> effects <EoN> = <BoN> effects dict <EoN> , <NEWLINE> <BoN> encoding <EoN> = <BoN> encoding <EoN> , <BoN> filename <EoN> = <BoN> filename <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set position <EoN> ( <BoN> self <EoN> , <BoN> xy <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> set x <EoN> ( <BoN> xy <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> self <EoN> . <BoN> set y <EoN> ( <BoN> xy <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> log cdf <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> call log cdf <EoN> ( <BoN> value <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> f oneway <EoN> ( * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> args <EoN> = [ <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> arg <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <NEWLINE> <BoN> num groups <EoN> = <BoN> len <EoN> ( <BoN> args <EoN> ) <NEWLINE> <BoN> alldata <EoN> = <BoN> np <EoN> . <BoN> concatenate <EoN> ( <BoN> args <EoN> ) <NEWLINE> <BoN> bign <EoN> = <BoN> len <EoN> ( <BoN> alldata <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> offset <EoN> = <BoN> alldata <EoN> . <BoN> mean <EoN> ( ) <NEWLINE> <BoN> alldata <EoN> -= <BoN> offset <EoN> <NEWLINE> <NEWLINE> <BoN> sstot <EoN> = <BoN> sum of squares <EoN> ( <BoN> alldata <EoN> ) - ( <BoN> square of sums <EoN> ( <BoN> alldata <EoN> ) / <BoN> float <EoN> ( <BoN> bign <EoN> ) ) <NEWLINE> <BoN> ssbn <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> ssbn <EoN> += <BoN> square of sums <EoN> ( <BoN> a <EoN> - <BoN> offset <EoN> ) / <BoN> float <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> ssbn <EoN> -= ( <BoN> square of sums <EoN> ( <BoN> alldata <EoN> ) / <BoN> float <EoN> ( <BoN> bign <EoN> ) ) <NEWLINE> <BoN> sswn <EoN> = <BoN> sstot <EoN> - <BoN> ssbn <EoN> <NEWLINE> <BoN> dfbn <EoN> = <BoN> num groups <EoN> - <NUMBER> <NEWLINE> <BoN> dfwn <EoN> = <BoN> bign <EoN> - <BoN> num groups <EoN> <NEWLINE> <BoN> msb <EoN> = <BoN> ssbn <EoN> / <BoN> float <EoN> ( <BoN> dfbn <EoN> ) <NEWLINE> <BoN> msw <EoN> = <BoN> sswn <EoN> / <BoN> float <EoN> ( <BoN> dfwn <EoN> ) <NEWLINE> <BoN> f <EoN> = <BoN> msb <EoN> / <BoN> msw <EoN> <NEWLINE> <NEWLINE> <BoN> prob <EoN> = <BoN> special <EoN> . <BoN> fdtrc <EoN> ( <BoN> dfbn <EoN> , <BoN> dfwn <EoN> , <BoN> f <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> F onewayResult <EoN> ( <BoN> f <EoN> , <BoN> prob <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ellip harm <EoN> ( <BoN> h 2 <EoN> , <BoN> k 2 <EoN> , <BoN> n <EoN> , <BoN> p <EoN> , <BoN> s <EoN> , <BoN> signm <EoN> = <NUMBER> , <BoN> signn <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> ellip harm <EoN> ( <BoN> h 2 <EoN> , <BoN> k 2 <EoN> , <BoN> n <EoN> , <BoN> p <EoN> , <BoN> s <EoN> , <BoN> signm <EoN> , <BoN> signn <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set fillstyle <EoN> ( <BoN> self <EoN> , <BoN> fs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> marker <EoN> . <BoN> set fillstyle <EoN> ( <BoN> fs <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is positive <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> domain <EoN> . <BoN> is positive <EoN> ( <BoN> a <EoN> . <BoN> L C <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> finish <EoN> ( <BoN> self <EoN> , <BoN> state <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> fit X <EoN> = <BoN> check array <EoN> ( <BoN> X <EoN> , <BoN> accept sparse <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> hash functions <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> trees <EoN> = [ ] <NEWLINE> <BoN> self <EoN> . <BoN> original indices <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> rng <EoN> = <BoN> check random state <EoN> ( <BoN> self <EoN> . <BoN> random state <EoN> ) <NEWLINE> <BoN> int max <EoN> = <BoN> np <EoN> . <BoN> iinfo <EoN> ( <BoN> np <EoN> . <BoN> int 32 <EoN> ) . <BoN> max <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> n estimators <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> hasher <EoN> = <BoN> Gaussian Random Projection Hash <EoN> ( <BoN> MAX HASH SIZE <EoN> , <NEWLINE> <BoN> rng <EoN> . <BoN> randint <EoN> ( <NUMBER> , <BoN> int max <EoN> ) ) <NEWLINE> <BoN> hashes <EoN> = <BoN> hasher <EoN> . <BoN> fit transform <EoN> ( <BoN> self <EoN> . <BoN> fit X <EoN> ) [ : , <NUMBER> ] <NEWLINE> <BoN> original index <EoN> = <BoN> np <EoN> . <BoN> argsort <EoN> ( <BoN> hashes <EoN> ) <NEWLINE> <BoN> bin hashes <EoN> = <BoN> hashes <EoN> [ <BoN> original index <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> original indices <EoN> . <BoN> append <EoN> ( <BoN> original index <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> trees <EoN> . <BoN> append <EoN> ( <BoN> bin hashes <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> hash functions <EoN> . <BoN> append <EoN> ( <BoN> hasher <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> generate masks <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random poisson <EoN> ( <BoN> lam <EoN> = <BoN> Null <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> ctx <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read cz lsm event list <EoN> ( <BoN> fh <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> count <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <STRING> , <BoN> fh <EoN> . <BoN> read <EoN> ( <NUMBER> ) ) [ <NUMBER> ] <NEWLINE> <BoN> events <EoN> = [ ] <NEWLINE> <BoN> while <EoN> <BoN> count <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> esize <EoN> , <BoN> etime <EoN> , <BoN> etype <EoN> = <BoN> struct <EoN> . <BoN> unpack <EoN> ( <STRING> , <BoN> fh <EoN> . <BoN> read <EoN> ( <NUMBER> ) ) <NEWLINE> <BoN> etext <EoN> = <BoN> stripnull <EoN> ( <BoN> fh <EoN> . <BoN> read <EoN> ( <BoN> esize <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> events <EoN> . <BoN> append <EoN> ( ( <BoN> etime <EoN> , <BoN> etype <EoN> , <BoN> etext <EoN> ) ) <NEWLINE> <BoN> count <EoN> -= <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> events <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> plot parametric <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> args <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> sympify <EoN> , <BoN> args <EoN> ) ) <NEWLINE> <BoN> show <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <BoN> series <EoN> = [ ] <NEWLINE> <BoN> plot expr <EoN> = <BoN> check arguments <EoN> ( <BoN> args <EoN> , <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> series <EoN> = [ <BoN> Parametric 2 D Line Series <EoN> ( * <BoN> arg <EoN> , ** <BoN> kwargs <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> plot expr <EoN> ] <NEWLINE> <BoN> plots <EoN> = <BoN> Plot <EoN> ( * <BoN> series <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> show <EoN> : <NEWLINE> <TAB> <BoN> plots <EoN> . <BoN> show <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> plots <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> subs <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> containers <EoN> <BoN> import <EoN> <BoN> Dict <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> utilities <EoN> <BoN> import <EoN> <BoN> default sort key <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> Dummy <EoN> , <BoN> Symbol <EoN> <NEWLINE> <NEWLINE> <BoN> unordered <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> sequence <EoN> = <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> sequence <EoN> , <BoN> set <EoN> ) : <NEWLINE> <TAB> <BoN> unordered <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> sequence <EoN> , ( <BoN> Dict <EoN> , <BoN> Mapping <EoN> ) ) : <NEWLINE> <TAB> <BoN> unordered <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> sequence <EoN> = <BoN> sequence <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> iterable <EoN> ( <BoN> sequence <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> utilities <EoN> . <BoN> misc <EoN> <BoN> import <EoN> <BoN> filldedent <EoN> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> filldedent <EoN> ( <STRING> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> sequence <EoN> = [ <BoN> args <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> sequence <EoN> = <BoN> list <EoN> ( <BoN> sequence <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> sequence <EoN> ) ) : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> list <EoN> ( <BoN> sequence <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> , <BoN> si <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> si <EoN> = <BoN> sympify <EoN> ( <BoN> si <EoN> , <BoN> strict <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Sympify Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> si <EoN> ) <BoN> is <EoN> <BoN> str <EoN> : <NEWLINE> <TAB> <BoN> si <EoN> = <BoN> Symbol <EoN> ( <BoN> si <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> sequence <EoN> [ <BoN> i <EoN> ] = <BoN> None <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> s <EoN> [ <BoN> j <EoN> ] = <BoN> si <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sequence <EoN> [ <BoN> i <EoN> ] = <BoN> None <EoN> <BoN> if <EoN> <BoN> aresame <EoN> ( * <BoN> s <EoN> ) <BoN> else <EoN> <BoN> tuple <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> sequence <EoN> = <BoN> list <EoN> ( <BoN> filter <EoN> ( <BoN> None <EoN> , <BoN> sequence <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> unordered <EoN> : <NEWLINE> <TAB> <BoN> sequence <EoN> = <BoN> dict <EoN> ( <BoN> sequence <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> k <EoN> . <BoN> is Atom <EoN> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> sequence <EoN> ) : <NEWLINE> <TAB> <BoN> d <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> o <EoN> , <BoN> n <EoN> <BoN> in <EoN> <BoN> sequence <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> ops <EoN> = <BoN> o <EoN> . <BoN> count ops <EoN> ( ) , <BoN> len <EoN> ( <BoN> o <EoN> . <BoN> args <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> ops <EoN> = ( <NUMBER> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> d <EoN> . <BoN> setdefault <EoN> ( <BoN> ops <EoN> , [ ] ) . <BoN> append <EoN> ( ( <BoN> o <EoN> , <BoN> n <EoN> ) ) <NEWLINE> <UNTAB> <BoN> newseq <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> d <EoN> . <BoN> keys <EoN> ( ) , <BoN> reverse <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> newseq <EoN> . <BoN> extend <EoN> ( <NEWLINE> <BoN> sorted <EoN> ( [ <BoN> v <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> d <EoN> [ <BoN> k <EoN> ] ] , <BoN> key <EoN> = <BoN> default sort key <EoN> ) ) <NEWLINE> <UNTAB> <BoN> sequence <EoN> = [ ( <BoN> k <EoN> , <BoN> sequence <EoN> [ <BoN> k <EoN> ] ) <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> newseq <EoN> ] <NEWLINE> <BoN> del <EoN> <BoN> newseq <EoN> , <BoN> d <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sequence <EoN> = <BoN> sorted <EoN> ( [ ( <BoN> k <EoN> , <BoN> v <EoN> ) <BoN> for <EoN> ( <BoN> k <EoN> , <BoN> v <EoN> ) <BoN> in <EoN> <BoN> sequence <EoN> . <BoN> items <EoN> ( ) ] , <NEWLINE> <BoN> key <EoN> = <BoN> default sort key <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> reps <EoN> = { } <NEWLINE> <BoN> rv <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> True <EoN> <NEWLINE> <BoN> m <EoN> = <BoN> Dummy <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> old <EoN> , <BoN> new <EoN> <BoN> in <EoN> <BoN> sequence <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> Dummy <EoN> ( <BoN> commutative <EoN> = <BoN> new <EoN> . <BoN> is commutative <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> rv <EoN> = <BoN> rv <EoN> . <BoN> subs <EoN> ( <BoN> old <EoN> , <BoN> d <EoN> * <BoN> m <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> rv <EoN> , <BoN> Basic <EoN> ) : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> reps <EoN> [ <BoN> d <EoN> ] = <BoN> new <EoN> <NEWLINE> <UNTAB> <BoN> reps <EoN> [ <BoN> m <EoN> ] = <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <BoN> return <EoN> <BoN> rv <EoN> . <BoN> xreplace <EoN> ( <BoN> reps <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> rv <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> for <EoN> <BoN> old <EoN> , <BoN> new <EoN> <BoN> in <EoN> <BoN> sequence <EoN> : <NEWLINE> <TAB> <BoN> rv <EoN> = <BoN> rv <EoN> . <BoN> subs <EoN> ( <BoN> old <EoN> , <BoN> new <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> rv <EoN> , <BoN> Basic <EoN> ) : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sparse reindex <EoN> ( <BoN> self <EoN> , <BoN> new index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> new index <EoN> , <BoN> splib <EoN> . <BoN> Sparse Index <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> block <EoN> = <BoN> self <EoN> . <BoN> block <EoN> . <BoN> sparse reindex <EoN> ( <BoN> new index <EoN> ) <NEWLINE> <BoN> new data <EoN> = <BoN> Single Block Manager <EoN> ( <BoN> block <EoN> , <BoN> self <EoN> . <BoN> index <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> new data <EoN> , <BoN> index <EoN> = <BoN> self <EoN> . <BoN> index <EoN> , <NEWLINE> <BoN> sparse index <EoN> = <BoN> new index <EoN> , <NEWLINE> <BoN> fill value <EoN> = <BoN> self <EoN> . <BoN> fill value <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> seconds <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> s <EoN> / <BoN> SEC PER DAY <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is isosceles <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> has dups <EoN> ( <BoN> s <EoN> . <BoN> length <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> sides <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> categories <EoN> = <BoN> self <EoN> . <BoN> categories <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> fit <EoN> ( <BoN> X <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get ticks position <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> majt <EoN> = <BoN> self <EoN> . <BoN> major Ticks <EoN> [ <NUMBER> ] <NEWLINE> <BoN> m T <EoN> = <BoN> self <EoN> . <BoN> minor Ticks <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> major Top <EoN> = ( ( <BoN> not <EoN> <BoN> majt <EoN> . <BoN> tick 1 On <EoN> ) <BoN> and <EoN> <BoN> majt <EoN> . <BoN> tick 2 On <EoN> <BoN> and <EoN> <NEWLINE> ( <BoN> not <EoN> <BoN> majt <EoN> . <BoN> label 1 On <EoN> ) <BoN> and <EoN> <BoN> majt <EoN> . <BoN> label 2 On <EoN> ) <NEWLINE> <BoN> minor Top <EoN> = ( ( <BoN> not <EoN> <BoN> m T <EoN> . <BoN> tick 1 On <EoN> ) <BoN> and <EoN> <BoN> m T <EoN> . <BoN> tick 2 On <EoN> <BoN> and <EoN> <NEWLINE> ( <BoN> not <EoN> <BoN> m T <EoN> . <BoN> label 1 On <EoN> ) <BoN> and <EoN> <BoN> m T <EoN> . <BoN> label 2 On <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> major Top <EoN> <BoN> and <EoN> <BoN> minor Top <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> Major Bottom <EoN> = ( <BoN> majt <EoN> . <BoN> tick 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> majt <EoN> . <BoN> tick 2 On <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> majt <EoN> . <BoN> label 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> majt <EoN> . <BoN> label 2 On <EoN> ) ) <NEWLINE> <BoN> Minor Bottom <EoN> = ( <BoN> m T <EoN> . <BoN> tick 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> m T <EoN> . <BoN> tick 2 On <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> m T <EoN> . <BoN> label 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> m T <EoN> . <BoN> label 2 On <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> Major Bottom <EoN> <BoN> and <EoN> <BoN> Minor Bottom <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> major Default <EoN> = ( <BoN> majt <EoN> . <BoN> tick 1 On <EoN> <BoN> and <EoN> <BoN> majt <EoN> . <BoN> tick 2 On <EoN> <BoN> and <EoN> <NEWLINE> <BoN> majt <EoN> . <BoN> label 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> majt <EoN> . <BoN> label 2 On <EoN> ) ) <NEWLINE> <BoN> minor Default <EoN> = ( <BoN> m T <EoN> . <BoN> tick 1 On <EoN> <BoN> and <EoN> <BoN> m T <EoN> . <BoN> tick 2 On <EoN> <BoN> and <EoN> <NEWLINE> <BoN> m T <EoN> . <BoN> label 1 On <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> m T <EoN> . <BoN> label 2 On <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> major Default <EoN> <BoN> and <EoN> <BoN> minor Default <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <STRING> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ndim <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dims <EoN> = <BoN> x <EoN> . <BoN> get shape <EoN> ( ) . <BoN> dims <EoN> <NEWLINE> <BoN> if <EoN> <BoN> dims <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> dims <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> zip <EoN> ( <BoN> datasets <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Zip Dataset <EoN> ( <BoN> datasets <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> spalde <EoN> ( <BoN> x <EoN> , <BoN> tck <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> tck <EoN> , <BoN> B Spline <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> impl <EoN> . <BoN> spalde <EoN> ( <BoN> x <EoN> , <BoN> tck <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> calc extra info <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> info <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <NEWLINE> <TAB> <BoN> opt <EoN> = <BoN> self <EoN> . <BoN> cp <EoN> . <BoN> get <EoN> ( <BoN> self <EoN> . <BoN> section <EoN> , <BoN> key <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> opt <EoN> : <NEWLINE> <TAB> <BoN> tmp <EoN> = { <BoN> key <EoN> : [ <BoN> opt <EoN> ] } <NEWLINE> <BoN> dict append <EoN> ( <BoN> info <EoN> , ** <BoN> tmp <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> info <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> axes <EoN> , <BoN> pickradius <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> artist <EoN> . <BoN> Artist <EoN> . <BoN> init <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> set figure <EoN> ( <BoN> axes <EoN> . <BoN> figure <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> isDefault label <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> axes <EoN> = <BoN> axes <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> major <EoN> = <BoN> Ticker <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> minor <EoN> = <BoN> Ticker <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> callbacks <EoN> = <BoN> cbook <EoN> . <BoN> Callback Registry <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> autolabelpos <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> smart bounds <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> label <EoN> = <BoN> self <EoN> . <BoN> get label <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> labelpad <EoN> = <BoN> rc Params <EoN> [ <STRING> ] <NEWLINE> <BoN> self <EoN> . <BoN> offset Text <EoN> = <BoN> self <EoN> . <BoN> get offset text <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> pickradius <EoN> = <BoN> pickradius <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> major tick kw <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> minor tick kw <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> cla <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> set scale <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> as float array <EoN> ( <BoN> x <EoN> , <BoN> check finite <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> ascontiguousarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> dtyp <EoN> = <BoN> get dtype <EoN> ( <BoN> x <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> x <EoN> . <BoN> astype <EoN> ( <BoN> dtyp <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> check finite <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> isfinite <EoN> ( <BoN> x <EoN> ) . <BoN> all <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rvs <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> discrete <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> rndm <EoN> = <BoN> kwds <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> args <EoN> , <BoN> loc <EoN> , <BoN> scale <EoN> , <BoN> size <EoN> = <BoN> self <EoN> . <BoN> parse args rvs <EoN> ( * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) <NEWLINE> <BoN> cond <EoN> = <BoN> logical and <EoN> ( <BoN> self <EoN> . <BoN> argcheck <EoN> ( * <BoN> args <EoN> ) , ( <BoN> scale <EoN> >= <NUMBER> ) ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> cond <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> scale <EoN> == <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> loc <EoN> * <BoN> ones <EoN> ( <BoN> size <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rndm <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> random state saved <EoN> = <BoN> self <EoN> . <BoN> random state <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> random state <EoN> = <BoN> check random state <EoN> ( <BoN> rndm <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> size <EoN> = <BoN> size <EoN> <NEWLINE> <BoN> vals <EoN> = <BoN> self <EoN> . <BoN> rvs <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <NEWLINE> <BoN> vals <EoN> = <BoN> vals <EoN> * <BoN> scale <EoN> + <BoN> loc <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> rndm <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> random state <EoN> = <BoN> random state saved <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> discrete <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> size <EoN> == ( ) : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> int <EoN> ( <BoN> vals <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> vals <EoN> . <BoN> astype <EoN> ( <BoN> int <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> vals <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> count ops <EoN> ( <BoN> self <EoN> , <BoN> visual <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> . <BoN> function <EoN> <BoN> import <EoN> <BoN> count ops <EoN> <NEWLINE> <BoN> return <EoN> <BoN> count ops <EoN> ( <BoN> self <EoN> , <BoN> visual <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> concatenate <EoN> ( <BoN> inputs <EoN> , <BoN> axis <EoN> = - <NUMBER> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Concatenate <EoN> ( <BoN> axis <EoN> = <BoN> axis <EoN> , ** <BoN> kwargs <EoN> ) ( <BoN> inputs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> op time <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> rval <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> self <EoN> . <BoN> apply time <EoN> ) : <NEWLINE> <TAB> <BoN> rval <EoN> . <BoN> setdefault <EoN> ( <BoN> node <EoN> . <BoN> op <EoN> , <NUMBER> ) <NEWLINE> <BoN> rval <EoN> [ <BoN> node <EoN> . <BoN> op <EoN> ] += <BoN> t <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rval <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get consuming ops <EoN> ( <BoN> ts <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ts <EoN> = <BoN> make list of t <EoN> ( <BoN> ts <EoN> , <BoN> allow graph <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> ops <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> ts <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> op <EoN> <BoN> in <EoN> <BoN> t <EoN> . <BoN> consumers <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> op <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> ops <EoN> : <NEWLINE> <TAB> <BoN> ops <EoN> . <BoN> append <EoN> ( <BoN> op <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> ops <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> khatri rao <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> value in bounds <EoN> ( <BoN> self <EoN> , <BoN> val <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> valstep <EoN> : <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> np <EoN> . <BoN> round <EoN> ( ( <BoN> val <EoN> - <BoN> self <EoN> . <BoN> valmin <EoN> ) / <BoN> self <EoN> . <BoN> valstep <EoN> ) * <BoN> self <EoN> . <BoN> valstep <EoN> <NEWLINE> <BoN> val <EoN> += <BoN> self <EoN> . <BoN> valmin <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> val <EoN> <= <BoN> self <EoN> . <BoN> valmin <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> closedmin <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> val <EoN> = <BoN> self <EoN> . <BoN> valmin <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> val <EoN> >= <BoN> self <EoN> . <BoN> valmax <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> closedmax <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> val <EoN> = <BoN> self <EoN> . <BoN> valmax <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> slidermin <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> val <EoN> <= <BoN> self <EoN> . <BoN> slidermin <EoN> . <BoN> val <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> closedmin <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> val <EoN> = <BoN> self <EoN> . <BoN> slidermin <EoN> . <BoN> val <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> slidermax <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> val <EoN> >= <BoN> self <EoN> . <BoN> slidermax <EoN> . <BoN> val <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> closedmax <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> val <EoN> = <BoN> self <EoN> . <BoN> slidermax <EoN> . <BoN> val <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> val <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> volume <EoN> ( <BoN> G <EoN> , <BoN> S <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> degree <EoN> = <BoN> G <EoN> . <BoN> out degree <EoN> <BoN> if <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) <BoN> else <EoN> <BoN> G <EoN> . <BoN> degree <EoN> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <BoN> d <EoN> <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> degree <EoN> ( <BoN> S <EoN> , <BoN> weight <EoN> = <BoN> weight <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mathml <EoN> ( <BoN> expr <EoN> , <BoN> printer <EoN> = <STRING> , ** <BoN> settings <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> printer <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Math ML Presentation Printer <EoN> ( <BoN> settings <EoN> ) . <BoN> doprint <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Math ML Content Printer <EoN> ( <BoN> settings <EoN> ) . <BoN> doprint <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reblock 2 x 2 <EoN> ( <BoN> B <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> B <EoN> , <BoN> Block Matrix <EoN> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> d <EoN> > <NUMBER> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> B <EoN> . <BoN> blocks <EoN> . <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> B <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> B M <EoN> = <BoN> Block Matrix <EoN> <NEWLINE> <BoN> return <EoN> <BoN> B M <EoN> ( [ [ <BoN> B <EoN> . <BoN> blocks <EoN> [ <NUMBER> , <NUMBER> ] , <BoN> B M <EoN> ( <BoN> B <EoN> . <BoN> blocks <EoN> [ <NUMBER> , <NUMBER> : ] ) ] , <NEWLINE> [ <BoN> B M <EoN> ( <BoN> B <EoN> . <BoN> blocks <EoN> [ <NUMBER> : , <NUMBER> ] ) , <BoN> B M <EoN> ( <BoN> B <EoN> . <BoN> blocks <EoN> [ <NUMBER> : , <NUMBER> : ] ) ] ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lcm <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> gmpy lcm <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> toposort <EoN> ( <BoN> prereqs d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> seq <EoN> = [ ] <NEWLINE> <BoN> done <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> postreqs d <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> , <BoN> prereqs <EoN> <BoN> in <EoN> <BoN> iteritems <EoN> ( <BoN> prereqs d <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> prereq <EoN> <BoN> in <EoN> <BoN> prereqs <EoN> : <NEWLINE> <TAB> <BoN> postreqs d <EoN> . <BoN> setdefault <EoN> ( <BoN> prereq <EoN> , <BoN> set <EoN> ( ) ) . <BoN> add <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> next <EoN> = <BoN> set <EoN> ( [ <BoN> k <EoN> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> prereqs d <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> prereqs d <EoN> [ <BoN> k <EoN> ] ] ) <NEWLINE> <BoN> while <EoN> <BoN> next <EoN> : <NEWLINE> <TAB> <BoN> bases <EoN> = <BoN> next <EoN> <NEWLINE> <BoN> next <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> bases <EoN> : <NEWLINE> <TAB> <BoN> done <EoN> . <BoN> add <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> seq <EoN> . <BoN> append <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> bases <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> postreq <EoN> <BoN> in <EoN> <BoN> postreqs d <EoN> . <BoN> get <EoN> ( <BoN> x <EoN> , [ ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> prereqs d <EoN> [ <BoN> postreq <EoN> ] . <BoN> difference <EoN> ( <BoN> done <EoN> ) : <NEWLINE> <TAB> <BoN> next <EoN> . <BoN> add <EoN> ( <BoN> postreq <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> prereqs d <EoN> ) != <BoN> len <EoN> ( <BoN> seq <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> seq <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as unicode <EoN> ( <BoN> rstring <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> rstring <EoN> . <BoN> encode <EoN> ( <STRING> , <STRING> ) . <BoN> decode <EoN> ( <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> backward <EoN> ( <BoN> self <EoN> , <BoN> out grads <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> binded <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> params initialized <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> exec group <EoN> . <BoN> backward <EoN> ( <BoN> out grads <EoN> = <BoN> out grads <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> check format <EoN> ( <BoN> self <EoN> , <BoN> full check <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MXND Array Sync Check Format <EoN> ( <BoN> self <EoN> . <BoN> handle <EoN> , <BoN> ctypes <EoN> . <BoN> c bool <EoN> ( <BoN> full check <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get edgecolor <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> patch <EoN> . <BoN> get edgecolor <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set canvas size <EoN> ( <BoN> self <EoN> , <BoN> w <EoN> , <BoN> h <EoN> , <BoN> d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> width <EoN> , <BoN> self <EoN> . <BoN> height <EoN> , <BoN> self <EoN> . <BoN> depth <EoN> = <BoN> np <EoN> . <BoN> ceil <EoN> ( [ <BoN> w <EoN> , <BoN> h <EoN> , <BoN> d <EoN> ] ) <NEWLINE> <BoN> self <EoN> . <BoN> mathtext backend <EoN> . <BoN> set canvas size <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> width <EoN> , <BoN> self <EoN> . <BoN> height <EoN> , <BoN> self <EoN> . <BoN> depth <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> process figure for rasterizing <EoN> ( <BoN> fig <EoN> , <BoN> bbox inches restore <EoN> , <BoN> fixed dpi <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> bbox inches <EoN> , <BoN> restore bbox <EoN> = <BoN> bbox inches restore <EoN> <NEWLINE> <BoN> restore bbox <EoN> ( ) <NEWLINE> <BoN> r <EoN> = <BoN> adjust bbox <EoN> ( <BoN> fig <EoN> , <BoN> bbox inches <EoN> , <BoN> fixed dpi <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> bbox inches <EoN> , <BoN> r <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> tile <EoN> ( <BoN> input <EoN> , <BoN> multiples <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> input <EoN> , <BoN> multiples <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tile eager fallback <EoN> ( <NEWLINE> <BoN> input <EoN> , <BoN> multiples <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> tile <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> multiples <EoN> = <BoN> multiples <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> multiples <EoN> = <BoN> multiples <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> tile <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> multiples <EoN> = <BoN> multiples <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf sub <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gf neg <EoN> ( <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> df <EoN> = <BoN> gf degree <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> dg <EoN> = <BoN> gf degree <EoN> ( <BoN> g <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> df <EoN> == <BoN> dg <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gf strip <EoN> ( [ ( <BoN> a <EoN> - <BoN> b <EoN> ) % <BoN> p <EoN> <BoN> for <EoN> <BoN> a <EoN> , <BoN> b <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> ) ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> k <EoN> = <BoN> abs <EoN> ( <BoN> df <EoN> - <BoN> dg <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> df <EoN> > <BoN> dg <EoN> : <NEWLINE> <TAB> <BoN> h <EoN> , <BoN> f <EoN> = <BoN> f <EoN> [ : <BoN> k <EoN> ] , <BoN> f <EoN> [ <BoN> k <EoN> : ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> h <EoN> , <BoN> g <EoN> = <BoN> gf neg <EoN> ( <BoN> g <EoN> [ : <BoN> k <EoN> ] , <BoN> p <EoN> , <BoN> K <EoN> ) , <BoN> g <EoN> [ <BoN> k <EoN> : ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> h <EoN> + [ ( <BoN> a <EoN> - <BoN> b <EoN> ) % <BoN> p <EoN> <BoN> for <EoN> <BoN> a <EoN> , <BoN> b <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf sqf part <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> <EoN> , <BoN> sqf <EoN> = <BoN> gf sqf list <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> g <EoN> = [ <BoN> K <EoN> . <BoN> one <EoN> ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> f <EoN> , <BoN> <EoN> <BoN> in <EoN> <BoN> sqf <EoN> : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> gf mul <EoN> ( <BoN> g <EoN> , <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> g <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> texts to sequences generator <EoN> ( <BoN> self <EoN> , <BoN> texts <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> num words <EoN> = <BoN> self <EoN> . <BoN> num words <EoN> <NEWLINE> <BoN> oov token index <EoN> = <BoN> self <EoN> . <BoN> word index <EoN> . <BoN> get <EoN> ( <BoN> self <EoN> . <BoN> oov token <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> text <EoN> <BoN> in <EoN> <BoN> texts <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> char level <EoN> <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> text <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> lower <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> text <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> text <EoN> = [ <BoN> text elem <EoN> . <BoN> lower <EoN> ( ) <BoN> for <EoN> <BoN> text elem <EoN> <BoN> in <EoN> <BoN> text <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> text <EoN> = <BoN> text <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> seq <EoN> = <BoN> text <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> seq <EoN> = <BoN> text to word sequence <EoN> ( <BoN> text <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> filters <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> lower <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> split <EoN> ) <NEWLINE> <UNTAB> <BoN> vect <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> seq <EoN> : <NEWLINE> <TAB> <BoN> i <EoN> = <BoN> self <EoN> . <BoN> word index <EoN> . <BoN> get <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> num words <EoN> <BoN> and <EoN> <BoN> i <EoN> >= <BoN> num words <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> oov token index <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> vect <EoN> . <BoN> append <EoN> ( <BoN> oov token index <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> vect <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> oov token <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> vect <EoN> . <BoN> append <EoN> ( <BoN> oov token index <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> yield <EoN> <BoN> vect <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> repr <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> , <NEWLINE> <BoN> repr <EoN> ( <BoN> self <EoN> . <BoN> A <EoN> ) , <NEWLINE> <BoN> repr <EoN> ( <BoN> self <EoN> . <BoN> B <EoN> ) , <NEWLINE> <BoN> repr <EoN> ( <BoN> self <EoN> . <BoN> C <EoN> ) , <NEWLINE> <BoN> repr <EoN> ( <BoN> self <EoN> . <BoN> D <EoN> ) , <NEWLINE> <BoN> repr <EoN> ( <BoN> self <EoN> . <BoN> dt <EoN> ) , <NEWLINE> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> update dim sizes <EoN> ( <BoN> dim sizes <EoN> , <BoN> arg <EoN> , <BoN> core dims <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> core dims <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> num core dims <EoN> = <BoN> len <EoN> ( <BoN> core dims <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> arg <EoN> . <BoN> ndim <EoN> < <BoN> num core dims <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> arg <EoN> . <BoN> ndim <EoN> , <BoN> core dims <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> core shape <EoN> = <BoN> arg <EoN> . <BoN> shape <EoN> [ - <BoN> num core dims <EoN> : ] <NEWLINE> <BoN> for <EoN> <BoN> dim <EoN> , <BoN> size <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> core dims <EoN> , <BoN> core shape <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dim <EoN> <BoN> in <EoN> <BoN> dim sizes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> size <EoN> != <BoN> dim sizes <EoN> [ <BoN> dim <EoN> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> % ( <BoN> dim <EoN> , <BoN> size <EoN> , <BoN> dim sizes <EoN> [ <BoN> dim <EoN> ] ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dim sizes <EoN> [ <BoN> dim <EoN> ] = <BoN> size <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> new epoch <EoN> ( <BoN> self <EoN> , <BoN> auto <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> auto <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> use auto new epoch <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> use auto new epoch <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> epoch <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> argmax <EoN> ( <BoN> self <EoN> , <BoN> dim <EoN> = <BoN> None <EoN> , <BoN> keepdim <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> argmax <EoN> ( <BoN> self <EoN> , <BoN> dim <EoN> , <BoN> keepdim <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
