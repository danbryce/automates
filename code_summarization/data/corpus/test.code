<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> color list to matrix and cmap <EoN> ( <BoN> colors <EoN> , <BoN> ind <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> issubclass <EoN> ( <BoN> type <EoN> ( <BoN> x <EoN> ) , <BoN> list <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> colors <EoN> ) : <NEWLINE> <TAB> <BoN> all colors <EoN> = <BoN> set <EoN> ( <BoN> itertools <EoN> . <BoN> chain <EoN> ( * <BoN> colors <EoN> ) ) <NEWLINE> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> colors <EoN> ) <NEWLINE> <BoN> m <EoN> = <BoN> len <EoN> ( <BoN> colors <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> all colors <EoN> = <BoN> set <EoN> ( <BoN> colors <EoN> ) <NEWLINE> <BoN> n <EoN> = <NUMBER> <NEWLINE> <BoN> m <EoN> = <BoN> len <EoN> ( <BoN> colors <EoN> ) <NEWLINE> <BoN> colors <EoN> = [ <BoN> colors <EoN> ] <NEWLINE> <UNTAB> <BoN> color to value <EoN> = <BoN> dict <EoN> ( ( <BoN> col <EoN> , <BoN> i <EoN> ) <BoN> for <EoN> <BoN> i <EoN> , <BoN> col <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> all colors <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> matrix <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> color to value <EoN> [ <BoN> c <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> color <EoN> <BoN> in <EoN> <BoN> colors <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> color <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> shape <EoN> = ( <BoN> n <EoN> , <BoN> m <EoN> ) <NEWLINE> <BoN> matrix <EoN> = <BoN> matrix <EoN> . <BoN> reshape <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <BoN> matrix <EoN> = <BoN> matrix <EoN> [ : , <BoN> ind <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> matrix <EoN> = <BoN> matrix <EoN> . <BoN> T <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> cmap <EoN> = <BoN> mpl <EoN> . <BoN> colors <EoN> . <BoN> Listed Colormap <EoN> ( <BoN> all colors <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> matrix <EoN> , <BoN> cmap <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make regex <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> can be regex <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> type <EoN> ( <BoN> obj <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> re <EoN> . <BoN> compile <EoN> ( <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> obj <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> invalidate <EoN> ( <BoN> self <EoN> , <BoN> exception <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> invalidated <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Resource Closed Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> connection is valid <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> connection <EoN> . <BoN> invalidate <EoN> ( <BoN> exception <EoN> ) <NEWLINE> <UNTAB> <BoN> del <EoN> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> connection <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> invalid <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> write summary results <EoN> ( <BoN> output dir <EoN> , <BoN> eval results <EoN> , <BoN> current global step <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> current global step <EoN> , <NEWLINE> <BoN> eval results to str <EoN> ( <BoN> eval results <EoN> ) ) <NEWLINE> <BoN> summary writer <EoN> = <BoN> get summary writer <EoN> ( <BoN> output dir <EoN> ) <NEWLINE> <BoN> summary <EoN> = <BoN> summary pb 2 <EoN> . <BoN> Summary <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> eval results <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> eval results <EoN> [ <BoN> key <EoN> ] <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> value <EoN> = <BoN> summary <EoN> . <BoN> value <EoN> . <BoN> add <EoN> ( ) <NEWLINE> <BoN> value <EoN> . <BoN> tag <EoN> = <BoN> key <EoN> <NEWLINE> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> eval results <EoN> [ <BoN> key <EoN> ] , <BoN> np <EoN> . <BoN> float 32 <EoN> ) <BoN> or <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> eval results <EoN> [ <BoN> key <EoN> ] , <BoN> float <EoN> ) ) : <NEWLINE> <TAB> <BoN> value <EoN> . <BoN> simple value <EoN> = <BoN> float <EoN> ( <BoN> eval results <EoN> [ <BoN> key <EoN> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> logging <EoN> . <BoN> warn <EoN> ( <STRING> , <NEWLINE> <BoN> key <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> summary writer <EoN> . <BoN> add summary <EoN> ( <BoN> summary <EoN> , <BoN> current global step <EoN> ) <NEWLINE> <BoN> summary writer <EoN> . <BoN> flush <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> is train <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> curr execgrp <EoN> . <BoN> forward <EoN> ( <BoN> is train <EoN> = <BoN> is train <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get partial string timestamp match key <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> labels <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> labels <EoN> , <BoN> Multi Index <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) <BoN> and <EoN> <BoN> labels <EoN> . <BoN> levels <EoN> [ <NUMBER> ] . <BoN> is all dates <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> tuple <EoN> ( [ <BoN> key <EoN> ] + [ <BoN> slice <EoN> ( <BoN> None <EoN> ) ] * ( <BoN> len <EoN> ( <BoN> labels <EoN> . <BoN> levels <EoN> ) - <NUMBER> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> new key <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> component <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> component <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) <BoN> and <EoN> <BoN> labels <EoN> . <BoN> levels <EoN> [ <BoN> i <EoN> ] . <BoN> is all dates <EoN> : <NEWLINE> <TAB> <BoN> new key <EoN> . <BoN> append <EoN> ( <BoN> slice <EoN> ( <BoN> component <EoN> , <BoN> component <EoN> , <BoN> None <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new key <EoN> . <BoN> append <EoN> ( <BoN> component <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> key <EoN> = <BoN> tuple <EoN> ( <BoN> new key <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> key <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> lock <EoN> = <BoN> threading <EoN> . <BoN> R Lock <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> group lock <EoN> = <BoN> lock util <EoN> . <BoN> Group Lock <EoN> ( <BoN> num groups <EoN> = <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> nodes by id <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> next id counter <EoN> = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> nodes by name <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> version <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> names in use <EoN> = { } <NEWLINE> <BoN> self <EoN> . <BoN> stack state is thread local <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> thread local <EoN> = <BoN> threading <EoN> . <BoN> local <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> graph device function stack <EoN> = <BoN> traceable stack <EoN> . <BoN> Traceable Stack <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> default original op <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> control flow context <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> graph control dependencies stack <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> collections <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> seed <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> attr scope map <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> op to kernel label map <EoN> = { } <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> gradient override map <EoN> = { } <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> finalized <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> functions <EoN> = <BoN> collections <EoN> . <BoN> Ordered Dict <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> graph def versions <EoN> = <BoN> versions pb 2 <EoN> . <BoN> Version Def <EoN> ( <NEWLINE> <BoN> producer <EoN> = <BoN> versions <EoN> . <BoN> GRAPH DEF VERSION <EoN> , <NEWLINE> <BoN> min consumer <EoN> = <BoN> versions <EoN> . <BoN> GRAPH DEF VERSION MIN CONSUMER <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> building function <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> graph colocation stack <EoN> = <BoN> traceable stack <EoN> . <BoN> Traceable Stack <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> unfeedable tensors <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> unfetchable ops <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> handle feeders <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> handle readers <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> handle movers <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> handle deleters <EoN> = { } <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> graph key <EoN> = <STRING> % ( <BoN> uid <EoN> ( ) , ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> last loss reduction <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> container <EoN> = <STRING> <NEWLINE> <BoN> self <EoN> . <BoN> registered ops <EoN> = <BoN> op def registry <EoN> . <BoN> get registered ops <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> scoped c graph <EoN> = <BoN> c api util <EoN> . <BoN> Scoped TF Graph <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> c api <EoN> . <BoN> Set Require Shape Inference Fns <EoN> ( <BoN> self <EoN> . <BoN> c graph <EoN> , <BoN> False <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> tf 2 <EoN> . <BoN> enabled <EoN> ( ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> switch to thread local <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> py random state <EoN> ( <NUMBER> ) <NEWLINE> <BoN> def <EoN> <BoN> random powerlaw tree sequence <EoN> ( <BoN> n <EoN> , <BoN> gamma <EoN> = <NUMBER> , <BoN> seed <EoN> = <BoN> None <EoN> , <BoN> tries <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> z <EoN> = <BoN> nx <EoN> . <BoN> utils <EoN> . <BoN> powerlaw sequence <EoN> ( <BoN> n <EoN> , <BoN> exponent <EoN> = <BoN> gamma <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> ) <NEWLINE> <NEWLINE> <BoN> zseq <EoN> = [ <BoN> min <EoN> ( <BoN> n <EoN> , <BoN> max <EoN> ( <BoN> int <EoN> ( <BoN> round <EoN> ( <BoN> s <EoN> ) ) , <NUMBER> ) ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> z <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> z <EoN> = <BoN> nx <EoN> . <BoN> utils <EoN> . <BoN> powerlaw sequence <EoN> ( <BoN> tries <EoN> , <BoN> exponent <EoN> = <BoN> gamma <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> ) <NEWLINE> <NEWLINE> <BoN> swap <EoN> = [ <BoN> min <EoN> ( <BoN> n <EoN> , <BoN> max <EoN> ( <BoN> int <EoN> ( <BoN> round <EoN> ( <BoN> s <EoN> ) ) , <NUMBER> ) ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> z <EoN> ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> deg <EoN> <BoN> in <EoN> <BoN> swap <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <NUMBER> * <BoN> n <EoN> - <BoN> sum <EoN> ( <BoN> zseq <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> zseq <EoN> <NEWLINE> <UNTAB> <BoN> index <EoN> = <BoN> seed <EoN> . <BoN> randint <EoN> ( <NUMBER> , <BoN> n <EoN> - <NUMBER> ) <NEWLINE> <BoN> zseq <EoN> [ <BoN> index <EoN> ] = <BoN> swap <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> tries <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> issubclass <EoN> ( <BoN> arg 1 <EoN> , <BoN> arg 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> issubclass <EoN> ( <BoN> arg 1 <EoN> , <BoN> arg 2 <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Leaky Re L U <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> gamma <EoN> = <BoN> None <EoN> , <BoN> act type <EoN> = <BoN> Null <EoN> , <BoN> slope <EoN> = <BoN> Null <EoN> , <BoN> lower bound <EoN> = <BoN> Null <EoN> , <BoN> upper bound <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get counterexample <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> G <EoN> = <BoN> nx <EoN> . <BoN> Graph <EoN> ( <BoN> G <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> check planarity <EoN> ( <BoN> G <EoN> ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Exception <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> subgraph <EoN> = <BoN> nx <EoN> . <BoN> Graph <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> <BoN> in <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> nbrs <EoN> = <BoN> list <EoN> ( <BoN> G <EoN> [ <BoN> u <EoN> ] ) <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> nbrs <EoN> : <NEWLINE> <TAB> <BoN> G <EoN> . <BoN> remove edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> check planarity <EoN> ( <BoN> G <EoN> ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> G <EoN> . <BoN> add edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> subgraph <EoN> . <BoN> add edge <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> subgraph <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> import model <EoN> ( <BoN> model file <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> graph <EoN> = <BoN> Graph Proto <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> onnx <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <STRING> <NEWLINE> + <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> model proto <EoN> = <BoN> onnx <EoN> . <BoN> load <EoN> ( <BoN> model file <EoN> ) <NEWLINE> <BoN> sym <EoN> , <BoN> arg params <EoN> , <BoN> aux params <EoN> = <BoN> graph <EoN> . <BoN> from onnx <EoN> ( <BoN> model proto <EoN> . <BoN> graph <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> sym <EoN> , <BoN> arg params <EoN> , <BoN> aux params <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> unregularized loss <EoN> ( <BoN> self <EoN> , <BoN> examples <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assertSpecified <EoN> ( [ <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> ] , <BoN> examples <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> assertList <EoN> ( [ <STRING> , <STRING> ] , <BoN> examples <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> predictions <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> linear predictions <EoN> ( <BoN> examples <EoN> ) , <BoN> dtypes <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> labels <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <NEWLINE> <BoN> internal convert to tensor <EoN> ( <BoN> examples <EoN> [ <STRING> ] ) , <NEWLINE> <BoN> dtypes <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <BoN> weights <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <NEWLINE> <BoN> internal convert to tensor <EoN> ( <BoN> examples <EoN> [ <STRING> ] ) , <NEWLINE> <BoN> dtypes <EoN> . <BoN> float 64 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <NEWLINE> <BoN> sigmoid cross entropy with logits <EoN> ( <BoN> labels <EoN> = <BoN> labels <EoN> , <NEWLINE> <BoN> logits <EoN> = <BoN> predictions <EoN> ) , <NEWLINE> <BoN> weights <EoN> ) ) / <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <NEWLINE> <BoN> log poisson loss <EoN> ( <BoN> targets <EoN> = <BoN> labels <EoN> , <BoN> log input <EoN> = <BoN> predictions <EoN> ) , <NEWLINE> <BoN> weights <EoN> ) ) / <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> all ones <EoN> = <BoN> array ops <EoN> . <BoN> ones like <EoN> ( <BoN> predictions <EoN> ) <NEWLINE> <BoN> adjusted labels <EoN> = <BoN> math ops <EoN> . <BoN> subtract <EoN> ( <NUMBER> * <BoN> labels <EoN> , <BoN> all ones <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> error <EoN> = <BoN> nn ops <EoN> . <BoN> relu <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> subtract <EoN> ( <BoN> all ones <EoN> , <NEWLINE> <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <BoN> adjusted labels <EoN> , <BoN> predictions <EoN> ) ) ) <NEWLINE> <BoN> weighted error <EoN> = <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <BoN> error <EoN> , <BoN> weights <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> weighted error <EoN> ) / <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <NEWLINE> <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> err <EoN> = <BoN> math ops <EoN> . <BoN> subtract <EoN> ( <BoN> labels <EoN> , <BoN> predictions <EoN> ) <NEWLINE> <NEWLINE> <BoN> weighted squared err <EoN> = <BoN> math ops <EoN> . <BoN> multiply <EoN> ( <BoN> math ops <EoN> . <BoN> square <EoN> ( <BoN> err <EoN> ) , <BoN> weights <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> weighted squared err <EoN> ) / <NEWLINE> ( <NUMBER> * <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> weights <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eigenvects <EoN> ( <BoN> self <EoN> , <BoN> error when incomplete <EoN> = <BoN> True <EoN> , <BoN> iszerofunc <EoN> = <BoN> iszero <EoN> , ** <BoN> flags <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> matrices <EoN> <BoN> import <EoN> <BoN> eye <EoN> <NEWLINE> <NEWLINE> <BoN> simplify <EoN> = <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> simplify <EoN> , <BoN> Function Type <EoN> ) : <NEWLINE> <TAB> <BoN> simpfunc <EoN> = <BoN> simplify <EoN> <BoN> if <EoN> <BoN> simplify <EoN> <BoN> else <EoN> <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> primitive <EoN> = <BoN> flags <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> False <EoN> ) <NEWLINE> <BoN> chop <EoN> = <BoN> flags <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <BoN> flags <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <BoN> mat <EoN> = <BoN> self <EoN> <NEWLINE> <NEWLINE> <BoN> has floats <EoN> = <BoN> any <EoN> ( <BoN> v <EoN> . <BoN> has <EoN> ( <BoN> Float <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> self <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> has floats <EoN> : <NEWLINE> <TAB> <BoN> mat <EoN> = <BoN> mat <EoN> . <BoN> applyfunc <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> nsimplify <EoN> ( <BoN> x <EoN> , <BoN> rational <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> eigenspace <EoN> ( <BoN> eigenval <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> m <EoN> = <BoN> mat <EoN> - <BoN> self <EoN> . <BoN> eye <EoN> ( <BoN> mat <EoN> . <BoN> rows <EoN> ) * <BoN> eigenval <EoN> <NEWLINE> <BoN> ret <EoN> = <BoN> m <EoN> . <BoN> nullspace <EoN> ( <BoN> iszerofunc <EoN> = <BoN> iszerofunc <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> ret <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> simplify <EoN> : <NEWLINE> <TAB> <BoN> ret <EoN> = <BoN> m <EoN> . <BoN> nullspace <EoN> ( <BoN> iszerofunc <EoN> = <BoN> iszerofunc <EoN> , <BoN> simplify <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> ret <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> % <BoN> eigenval <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> eigenvals <EoN> = <BoN> mat <EoN> . <BoN> eigenvals <EoN> ( <BoN> rational <EoN> = <BoN> False <EoN> , <NEWLINE> <BoN> error when incomplete <EoN> = <BoN> error when incomplete <EoN> , <NEWLINE> ** <BoN> flags <EoN> ) <NEWLINE> <BoN> ret <EoN> = [ ( <BoN> val <EoN> , <BoN> mult <EoN> , <BoN> eigenspace <EoN> ( <BoN> val <EoN> ) ) <BoN> for <EoN> <BoN> val <EoN> , <BoN> mult <EoN> <BoN> in <EoN> <NEWLINE> <BoN> sorted <EoN> ( <BoN> eigenvals <EoN> . <BoN> items <EoN> ( ) , <BoN> key <EoN> = <BoN> default sort key <EoN> ) ] <NEWLINE> <BoN> if <EoN> <BoN> primitive <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> def <EoN> <BoN> denom clean <EoN> ( <BoN> l <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> gcd <EoN> <NEWLINE> <BoN> return <EoN> [ ( <BoN> v <EoN> / <BoN> gcd <EoN> ( <BoN> list <EoN> ( <BoN> v <EoN> ) ) ) . <BoN> applyfunc <EoN> ( <BoN> simpfunc <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> l <EoN> ] <NEWLINE> <UNTAB> <BoN> ret <EoN> = [ ( <BoN> val <EoN> , <BoN> mult <EoN> , <BoN> denom clean <EoN> ( <BoN> es <EoN> ) ) <BoN> for <EoN> <BoN> val <EoN> , <BoN> mult <EoN> , <BoN> es <EoN> <BoN> in <EoN> <BoN> ret <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> has floats <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> ret <EoN> = [ ( <BoN> val <EoN> . <BoN> evalf <EoN> ( <BoN> chop <EoN> = <BoN> chop <EoN> ) , <BoN> mult <EoN> , [ <BoN> v <EoN> . <BoN> evalf <EoN> ( <BoN> chop <EoN> = <BoN> chop <EoN> ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> es <EoN> ] ) <BoN> for <EoN> <BoN> val <EoN> , <BoN> mult <EoN> , <BoN> es <EoN> <BoN> in <EoN> <BoN> ret <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> external values <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> . <BoN> astype <EoN> ( <STRING> ) . <BoN> values <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> relu <EoN> ( <BoN> x <EoN> , <BoN> alpha <EoN> = <NUMBER> , <BoN> max value <EoN> = <BoN> None <EoN> , <BoN> threshold <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> alpha <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> max value <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> threshold <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nn <EoN> . <BoN> leaky relu <EoN> ( <BoN> x <EoN> , <BoN> alpha <EoN> = <BoN> alpha <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> threshold <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> negative part <EoN> = <BoN> nn <EoN> . <BoN> relu <EoN> ( - <BoN> x <EoN> + <BoN> threshold <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> negative part <EoN> = <BoN> nn <EoN> . <BoN> relu <EoN> ( - <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> clip max <EoN> = <BoN> max value <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> threshold <EoN> != <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> x <EoN> * <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> math ops <EoN> . <BoN> greater <EoN> ( <BoN> x <EoN> , <BoN> threshold <EoN> ) , <BoN> floatx <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> max value <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> nn <EoN> . <BoN> relu 6 <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> clip max <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> nn <EoN> . <BoN> relu <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> clip max <EoN> : <NEWLINE> <TAB> <BoN> max value <EoN> = <BoN> to tensor <EoN> ( <BoN> max value <EoN> , <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> zero <EoN> = <BoN> to tensor <EoN> ( <NUMBER> , <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> clip ops <EoN> . <BoN> clip by value <EoN> ( <BoN> x <EoN> , <BoN> zero <EoN> , <BoN> max value <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> alpha <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> alpha <EoN> = <BoN> to tensor <EoN> ( <BoN> alpha <EoN> , <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> x <EoN> -= <BoN> alpha <EoN> * <BoN> negative part <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> centroid <EoN> ( <BoN> image <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> M <EoN> = <BoN> moments central <EoN> ( <BoN> image <EoN> , <BoN> center <EoN> = ( <NUMBER> , ) * <BoN> image <EoN> . <BoN> ndim <EoN> , <BoN> order <EoN> = <NUMBER> ) <NEWLINE> <BoN> center <EoN> = ( <BoN> M <EoN> [ <BoN> tuple <EoN> ( <BoN> np <EoN> . <BoN> eye <EoN> ( <BoN> image <EoN> . <BoN> ndim <EoN> , <BoN> dtype <EoN> = <BoN> int <EoN> ) ) ] <NEWLINE> <NEWLINE> / <BoN> M <EoN> [ ( <NUMBER> , ) * <BoN> image <EoN> . <BoN> ndim <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> center <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cbrt <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> is dtype <EoN> ( <BoN> cls <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> dtype <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> startswith <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> dtype <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> cls <EoN> . <BoN> parse dtype strict <EoN> ( <BoN> dtype <EoN> ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> super <EoN> ( <BoN> Period Dtype <EoN> , <BoN> cls <EoN> ) . <BoN> is dtype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> logpdf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <BoN> condlist <EoN> = [ <BoN> np <EoN> . <BoN> logical and <EoN> ( <BoN> h <EoN> != <NUMBER> , <BoN> k <EoN> != <NUMBER> ) , <NEWLINE> <BoN> np <EoN> . <BoN> logical and <EoN> ( <BoN> h <EoN> == <NUMBER> , <BoN> k <EoN> != <NUMBER> ) , <NEWLINE> <BoN> np <EoN> . <BoN> logical and <EoN> ( <BoN> h <EoN> != <NUMBER> , <BoN> k <EoN> == <NUMBER> ) , <NEWLINE> <BoN> np <EoN> . <BoN> logical and <EoN> ( <BoN> h <EoN> == <NUMBER> , <BoN> k <EoN> == <NUMBER> ) ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> f 0 <EoN> ( <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <BoN> sc <EoN> . <BoN> xlog 1 py <EoN> ( <NUMBER> / <BoN> k <EoN> - <NUMBER> , - <BoN> k <EoN> * <BoN> x <EoN> ) + <NEWLINE> <BoN> sc <EoN> . <BoN> xlog 1 py <EoN> ( <NUMBER> / <BoN> h <EoN> - <NUMBER> , - <BoN> h <EoN> * ( <NUMBER> - <BoN> k <EoN> * <BoN> x <EoN> ) ** ( <NUMBER> / <BoN> k <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> f 1 <EoN> ( <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sc <EoN> . <BoN> xlog 1 py <EoN> ( <NUMBER> / <BoN> k <EoN> - <NUMBER> , - <BoN> k <EoN> * <BoN> x <EoN> ) - ( <NUMBER> - <BoN> k <EoN> * <BoN> x <EoN> ) ** ( <NUMBER> / <BoN> k <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> f 2 <EoN> ( <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> - <BoN> x <EoN> + <BoN> sc <EoN> . <BoN> xlog 1 py <EoN> ( <NUMBER> / <BoN> h <EoN> - <NUMBER> , - <BoN> h <EoN> * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> x <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> f 3 <EoN> ( <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> - <BoN> x <EoN> - <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> lazyselect <EoN> ( <BoN> condlist <EoN> , <NEWLINE> [ <BoN> f 0 <EoN> , <BoN> f 1 <EoN> , <BoN> f 2 <EoN> , <BoN> f 3 <EoN> ] , <NEWLINE> [ <BoN> x <EoN> , <BoN> h <EoN> , <BoN> k <EoN> ] , <NEWLINE> <BoN> default <EoN> = <BoN> np <EoN> . <BoN> nan <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get alpha <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> alpha <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> almost equal <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> rtol <EoN> = <BoN> None <EoN> , <BoN> atol <EoN> = <BoN> None <EoN> , <BoN> equal nan <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> allclose <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> rtol <EoN> = <BoN> get rtol <EoN> ( <BoN> rtol <EoN> ) , <BoN> atol <EoN> = <BoN> get atol <EoN> ( <BoN> atol <EoN> ) , <BoN> equal nan <EoN> = <BoN> equal nan <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eq <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> equal <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> nested <EoN> ( * <BoN> managers <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> exits <EoN> = [ ] <NEWLINE> <BoN> vars <EoN> = [ ] <NEWLINE> <BoN> exc <EoN> = ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> mgr <EoN> <BoN> in <EoN> <BoN> managers <EoN> : <NEWLINE> <TAB> <BoN> exit <EoN> = <BoN> mgr <EoN> . <BoN> exit <EoN> <NEWLINE> <BoN> enter <EoN> = <BoN> mgr <EoN> . <BoN> enter <EoN> <NEWLINE> <BoN> vars <EoN> . <BoN> append <EoN> ( <BoN> enter <EoN> ( ) ) <NEWLINE> <BoN> exits <EoN> . <BoN> append <EoN> ( <BoN> exit <EoN> ) <NEWLINE> <UNTAB> <BoN> yield <EoN> <BoN> vars <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> exc <EoN> = <BoN> sys <EoN> . <BoN> exc info <EoN> ( ) <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> while <EoN> <BoN> exits <EoN> : <NEWLINE> <TAB> <BoN> exit <EoN> = <BoN> exits <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> exit <EoN> ( * <BoN> exc <EoN> ) : <NEWLINE> <TAB> <BoN> exc <EoN> = ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> exc <EoN> = <BoN> sys <EoN> . <BoN> exc info <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> exc <EoN> != ( <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> reraise <EoN> ( <BoN> exc <EoN> [ <NUMBER> ] , <BoN> exc <EoN> [ <NUMBER> ] , <BoN> exc <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get items to delete <EoN> ( <BoN> self <EoN> , <BoN> bytes limit <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> bytes limit <EoN> , <BoN> basestring <EoN> ) : <NEWLINE> <TAB> <BoN> bytes limit <EoN> = <BoN> memstr to bytes <EoN> ( <BoN> bytes limit <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> items <EoN> = <BoN> self <EoN> . <BoN> get items <EoN> ( ) <NEWLINE> <BoN> size <EoN> = <BoN> sum <EoN> ( <BoN> item <EoN> . <BoN> size <EoN> <BoN> for <EoN> <BoN> item <EoN> <BoN> in <EoN> <BoN> items <EoN> ) <NEWLINE> <NEWLINE> <BoN> to delete size <EoN> = <BoN> size <EoN> - <BoN> bytes limit <EoN> <NEWLINE> <BoN> if <EoN> <BoN> to delete size <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> items <EoN> . <BoN> sort <EoN> ( <BoN> key <EoN> = <BoN> operator <EoN> . <BoN> attrgetter <EoN> ( <STRING> ) ) <NEWLINE> <NEWLINE> <BoN> items to delete <EoN> = [ ] <NEWLINE> <BoN> size so far <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> item <EoN> <BoN> in <EoN> <BoN> items <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> size so far <EoN> > <BoN> to delete size <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> items to delete <EoN> . <BoN> append <EoN> ( <BoN> item <EoN> ) <NEWLINE> <BoN> size so far <EoN> += <BoN> item <EoN> . <BoN> size <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> items to delete <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> len guards <EoN> ( <BoN> M <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> int <EoN> ( <BoN> M <EoN> ) != <BoN> M <EoN> <BoN> or <EoN> <BoN> M <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> M <EoN> <= <NUMBER> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit on texts <EoN> ( <BoN> self <EoN> , <BoN> texts <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> text <EoN> <BoN> in <EoN> <BoN> texts <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> document count <EoN> += <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> char level <EoN> <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> text <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> lower <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> text <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> text <EoN> = [ <BoN> text elem <EoN> . <BoN> lower <EoN> ( ) <BoN> for <EoN> <BoN> text elem <EoN> <BoN> in <EoN> <BoN> text <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> text <EoN> = <BoN> text <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> seq <EoN> = <BoN> text <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> seq <EoN> = <BoN> text to word sequence <EoN> ( <BoN> text <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> filters <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> lower <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> split <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> seq <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> word counts <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> word counts <EoN> [ <BoN> w <EoN> ] += <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> word counts <EoN> [ <BoN> w <EoN> ] = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> w <EoN> <BoN> in <EoN> <BoN> set <EoN> ( <BoN> seq <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> word docs <EoN> [ <BoN> w <EoN> ] += <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> wcounts <EoN> = <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> word counts <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <BoN> wcounts <EoN> . <BoN> sort <EoN> ( <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> [ <NUMBER> ] , <BoN> reverse <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> oov token <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sorted voc <EoN> = [ ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sorted voc <EoN> = [ <BoN> self <EoN> . <BoN> oov token <EoN> ] <NEWLINE> <UNTAB> <BoN> sorted voc <EoN> . <BoN> extend <EoN> ( <BoN> wc <EoN> [ <NUMBER> ] <BoN> for <EoN> <BoN> wc <EoN> <BoN> in <EoN> <BoN> wcounts <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> word index <EoN> = <BoN> dict <EoN> ( <NEWLINE> <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> sorted voc <EoN> , <BoN> list <EoN> ( <BoN> range <EoN> ( <NUMBER> , <BoN> len <EoN> ( <BoN> sorted voc <EoN> ) + <NUMBER> ) ) ) ) ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> index word <EoN> = <BoN> dict <EoN> ( ( <BoN> c <EoN> , <BoN> w <EoN> ) <BoN> for <EoN> <BoN> w <EoN> , <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> word index <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> w <EoN> , <BoN> c <EoN> <BoN> in <EoN> <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> word docs <EoN> . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> index docs <EoN> [ <BoN> self <EoN> . <BoN> word index <EoN> [ <BoN> w <EoN> ] ] = <BoN> c <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parallel plane <EoN> ( <BoN> self <EoN> , <BoN> pt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> self <EoN> . <BoN> normal vector <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Plane <EoN> ( <BoN> pt <EoN> , <BoN> normal vector <EoN> = <BoN> a <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get name <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> get font <EoN> ( <BoN> findfont <EoN> ( <BoN> self <EoN> ) ) . <BoN> family name <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> typecode <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> typecode <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is distance regular <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> intersection array <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> draw bounding boxes <EoN> ( <BoN> images <EoN> , <BoN> boxes <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> images <EoN> , <NEWLINE> <BoN> boxes <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> draw bounding boxes eager fallback <EoN> ( <NEWLINE> <BoN> images <EoN> , <BoN> boxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> draw bounding boxes <EoN> , <BoN> images <EoN> = <BoN> images <EoN> , <BoN> boxes <EoN> = <BoN> boxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> images <EoN> = <BoN> images <EoN> , <BoN> boxes <EoN> = <BoN> boxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> draw bounding boxes <EoN> , <BoN> images <EoN> = <BoN> images <EoN> , <BoN> boxes <EoN> = <BoN> boxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> issctype <EoN> ( <BoN> rep <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> rep <EoN> , ( <BoN> type <EoN> , <BoN> dtype <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> obj 2 sctype <EoN> ( <BoN> rep <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> res <EoN> <BoN> and <EoN> <BoN> res <EoN> != <BoN> object <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <BoN> date <EoN> = <BoN> None <EoN> , <BoN> instructions <EoN> = <STRING> ) <NEWLINE> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> to int 32 <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> cast <EoN> ( <BoN> x <EoN> , <BoN> dtypes <EoN> . <BoN> int 32 <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> copy ops <EoN> ( <BoN> self <EoN> , <BoN> info <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sorted ops <EoN> = <BoN> sorted <EoN> ( <BoN> info <EoN> . <BoN> sgv <EoN> . <BoN> ops <EoN> , <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> op <EoN> : <BoN> op <EoN> . <BoN> id <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> op <EoN> <BoN> in <EoN> <BoN> sorted ops <EoN> : <NEWLINE> <TAB> <BoN> new inputs <EoN> = [ <BoN> self <EoN> . <BoN> transformed t <EoN> ( <BoN> info <EoN> , <BoN> t <EoN> , <BoN> op <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> op <EoN> . <BoN> inputs <EoN> ] <NEWLINE> <BoN> op <EoN> , <BoN> op outputs <EoN> = <BoN> self <EoN> . <BoN> transform op handler <EoN> ( <BoN> info <EoN> , <BoN> op <EoN> , <BoN> new inputs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> op <EoN> <BoN> is <EoN> <BoN> op <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> info <EoN> . <BoN> transformed ops <EoN> [ <BoN> op <EoN> ] = <BoN> op <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> assign collections handler <EoN> ( <BoN> info <EoN> , <BoN> op <EoN> , <BoN> op <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> op output <EoN> , <BoN> op output <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> op <EoN> . <BoN> outputs <EoN> , <BoN> op outputs <EoN> ) : <NEWLINE> <TAB> <BoN> info <EoN> . <BoN> transformed ts <EoN> [ <BoN> op output <EoN> ] = <BoN> op output <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> assign collections handler <EoN> ( <BoN> info <EoN> , <BoN> op output <EoN> , <BoN> op output <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> node def <EoN> , <BoN> op <EoN> , <BoN> message <EoN> , <BoN> error code <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Op Error <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> node def <EoN> = <BoN> node def <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> op <EoN> = <BoN> op <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> message <EoN> = <BoN> message <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> error code <EoN> = <BoN> error code <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> structurally equal <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Kronecker Product <EoN> ) <NEWLINE> <BoN> and <EoN> <BoN> self <EoN> . <BoN> shape <EoN> == <BoN> other <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> args <EoN> ) == <BoN> len <EoN> ( <BoN> other <EoN> . <BoN> args <EoN> ) <NEWLINE> <BoN> and <EoN> <BoN> all <EoN> ( <BoN> a <EoN> . <BoN> shape <EoN> == <BoN> b <EoN> . <BoN> shape <EoN> <BoN> for <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> args <EoN> , <BoN> other <EoN> . <BoN> args <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> attracting components <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> scc <EoN> = <BoN> list <EoN> ( <BoN> nx <EoN> . <BoN> strongly connected components <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <BoN> c G <EoN> = <BoN> nx <EoN> . <BoN> condensation <EoN> ( <BoN> G <EoN> , <BoN> scc <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> c G <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> c G <EoN> . <BoN> out degree <EoN> ( <BoN> n <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> scc <EoN> [ <BoN> n <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> limit range for scale <EoN> ( <BoN> self <EoN> , <BoN> vmin <EoN> , <BoN> vmax <EoN> , <BoN> minpos <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> vmin <EoN> , <BoN> vmax <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> seq id <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> global <EoN> <BoN> layoutboxobjnum <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <STRING> % ( <BoN> next <EoN> ( <BoN> layoutboxobjnum <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform labels <EoN> ( <BoN> self <EoN> , <BoN> mode <EoN> , <BoN> labels <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> ( <BoN> mode <EoN> == <BoN> model fn <EoN> . <BoN> Mode Keys <EoN> . <BoN> INFE R <EoN> ) <BoN> or <EoN> ( <BoN> labels <EoN> <BoN> is <EoN> <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> labels tensor <EoN> = <BoN> to labels tensor <EoN> ( <BoN> labels <EoN> , <BoN> self <EoN> . <BoN> label name <EoN> ) <NEWLINE> <BoN> check no sparse tensor <EoN> ( <BoN> labels tensor <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> labels tensor <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> test gxx support <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> code <EoN> = <NEWLINE> <BoN> default openmp <EoN> = <BoN> GCC compiler <EoN> . <BoN> try compile tmp <EoN> ( <NEWLINE> <BoN> src code <EoN> = <BoN> code <EoN> , <NEWLINE> <BoN> tmp prefix <EoN> = <STRING> , <NEWLINE> <BoN> flags <EoN> = [ <STRING> ] , <NEWLINE> <BoN> try run <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> default openmp <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> empty cache <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> initialized <EoN> : <NEWLINE> <TAB> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> cuda emptyCache <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> embed id <EoN> . <BoN> embed id <EoN> ( <BoN> x <EoN> , <BoN> self <EoN> . <BoN> W <EoN> , <BoN> ignore label <EoN> = <BoN> self <EoN> . <BoN> ignore label <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> abspath <EoN> ( <BoN> self <EoN> , <BoN> path <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Data Source <EoN> . <BoN> abspath <EoN> ( <BoN> self <EoN> , <BoN> self <EoN> . <BoN> fullpath <EoN> ( <BoN> path <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> polyadd <EoN> ( <BoN> c 1 <EoN> , <BoN> c 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> [ <BoN> c 1 <EoN> , <BoN> c 2 <EoN> ] = <BoN> pu <EoN> . <BoN> as series <EoN> ( [ <BoN> c 1 <EoN> , <BoN> c 2 <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> c 1 <EoN> ) > <BoN> len <EoN> ( <BoN> c 2 <EoN> ) : <NEWLINE> <TAB> <BoN> c 1 <EoN> [ : <BoN> c 2 <EoN> . <BoN> size <EoN> ] += <BoN> c 2 <EoN> <NEWLINE> <BoN> ret <EoN> = <BoN> c 1 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> c 2 <EoN> [ : <BoN> c 1 <EoN> . <BoN> size <EoN> ] += <BoN> c 1 <EoN> <NEWLINE> <BoN> ret <EoN> = <BoN> c 2 <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> pu <EoN> . <BoN> trimseq <EoN> ( <BoN> ret <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set thetagrids <EoN> ( <BoN> self <EoN> , <BoN> angles <EoN> , <BoN> labels <EoN> = <BoN> None <EoN> , <BoN> fmt <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> angles <EoN> = <BoN> self <EoN> . <BoN> convert yunits <EoN> ( <BoN> angles <EoN> ) <NEWLINE> <BoN> angles <EoN> = <BoN> np <EoN> . <BoN> deg 2 rad <EoN> ( <BoN> angles <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> set xticks <EoN> ( <BoN> angles <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> labels <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set xticklabels <EoN> ( <BoN> labels <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> fmt <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> xaxis <EoN> . <BoN> set major formatter <EoN> ( <BoN> mticker <EoN> . <BoN> Format Str Formatter <EoN> ( <BoN> fmt <EoN> ) ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> xaxis <EoN> . <BoN> get ticklabels <EoN> ( ) : <NEWLINE> <TAB> <BoN> t <EoN> . <BoN> update <EoN> ( <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> xaxis <EoN> . <BoN> get ticklines <EoN> ( ) , <BoN> self <EoN> . <BoN> xaxis <EoN> . <BoN> get ticklabels <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hermvander 2 d <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> deg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ideg <EoN> = [ <BoN> int <EoN> ( <BoN> d <EoN> ) <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> deg <EoN> ] <NEWLINE> <BoN> is valid <EoN> = [ <BoN> id <EoN> == <BoN> d <EoN> <BoN> and <EoN> <BoN> id <EoN> >= <NUMBER> <BoN> for <EoN> <BoN> id <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> ideg <EoN> , <BoN> deg <EoN> ) ] <NEWLINE> <BoN> if <EoN> <BoN> is valid <EoN> != [ <NUMBER> , <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> degx <EoN> , <BoN> degy <EoN> = <BoN> ideg <EoN> <NEWLINE> <BoN> x <EoN> , <BoN> y <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> copy <EoN> = <NUMBER> ) + <NUMBER> <NEWLINE> <NEWLINE> <BoN> vx <EoN> = <BoN> hermvander <EoN> ( <BoN> x <EoN> , <BoN> degx <EoN> ) <NEWLINE> <BoN> vy <EoN> = <BoN> hermvander <EoN> ( <BoN> y <EoN> , <BoN> degy <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> vx <EoN> [ ... , <BoN> None <EoN> ] * <BoN> vy <EoN> [ ... , <BoN> None <EoN> , : ] <NEWLINE> <BoN> return <EoN> <BoN> v <EoN> . <BoN> reshape <EoN> ( <BoN> v <EoN> . <BoN> shape <EoN> [ : - <NUMBER> ] + ( - <NUMBER> , ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> linalg gemm <EoN> ( <BoN> A <EoN> = <BoN> None <EoN> , <BoN> B <EoN> = <BoN> None <EoN> , <BoN> C <EoN> = <BoN> None <EoN> , <BoN> transpose a <EoN> = <BoN> Null <EoN> , <BoN> transpose b <EoN> = <BoN> Null <EoN> , <BoN> alpha <EoN> = <BoN> Null <EoN> , <BoN> beta <EoN> = <BoN> Null <EoN> , <BoN> axis <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> preprocess conv 1 d input <EoN> ( <BoN> x <EoN> , <BoN> data format <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> dtype <EoN> ( <BoN> x <EoN> ) == <STRING> <BoN> and <EoN> <NEWLINE> <BoN> Strict Version <EoN> ( <BoN> tf <EoN> . <BoN> version <EoN> . <BoN> split <EoN> ( <STRING> ) [ <NUMBER> ] ) < <BoN> Strict Version <EoN> ( <STRING> ) ) : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> tf <EoN> . <BoN> cast <EoN> ( <BoN> x <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> tf data format <EoN> = <STRING> <NEWLINE> <BoN> if <EoN> <BoN> data format <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> has nchw support <EoN> ( ) : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> tf <EoN> . <BoN> transpose <EoN> ( <BoN> x <EoN> , ( <NUMBER> , <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> tf data format <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> , <BoN> tf data format <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> hash <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> hashtype <EoN> ( <BoN> self <EoN> ) ^ <BoN> hash <EoN> ( <BoN> self <EoN> . <BoN> dtype <EoN> ) ^ <BoN> hash <EoN> ( <BoN> self <EoN> . <BoN> broadcastable <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as numer denom <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> exp <EoN> = <BoN> self <EoN> . <BoN> exp <EoN> <NEWLINE> <BoN> neg exp <EoN> = <BoN> exp <EoN> . <BoN> is negative <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> neg exp <EoN> <BoN> and <EoN> <BoN> not <EoN> ( - <BoN> exp <EoN> ) . <BoN> is negative <EoN> : <NEWLINE> <TAB> <BoN> neg exp <EoN> = <BoN> coeff isneg <EoN> ( <BoN> exp <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> neg exp <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> One <EoN> , <BoN> self <EoN> . <BoN> func <EoN> ( - <BoN> exp <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> , <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reset <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> jnp zeros <EoN> ( <BoN> n <EoN> , <BoN> nt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> jnyn zeros <EoN> ( <BoN> n <EoN> , <BoN> nt <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> gauss <EoN> ( <BoN> self <EoN> , <BoN> mu <EoN> , <BoN> sigma <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> random <EoN> = <BoN> self <EoN> . <BoN> random <EoN> <NEWLINE> <BoN> z <EoN> = <BoN> self <EoN> . <BoN> gauss next <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> gauss next <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> z <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x 2 pi <EoN> = <BoN> random <EoN> ( ) * <BoN> TWOP I <EoN> <NEWLINE> <BoN> g 2 rad <EoN> = <BoN> sqrt <EoN> ( - <NUMBER> * <BoN> log <EoN> ( <NUMBER> - <BoN> random <EoN> ( ) ) ) <NEWLINE> <BoN> z <EoN> = <BoN> cos <EoN> ( <BoN> x 2 pi <EoN> ) * <BoN> g 2 rad <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> gauss next <EoN> = <BoN> sin <EoN> ( <BoN> x 2 pi <EoN> ) * <BoN> g 2 rad <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> mu <EoN> + <BoN> z <EoN> * <BoN> sigma <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to sympy <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Sym Py Rational <EoN> ( <BoN> int <EoN> ( <BoN> gmpy numer <EoN> ( <BoN> a <EoN> ) ) , <NEWLINE> <BoN> int <EoN> ( <BoN> gmpy denom <EoN> ( <BoN> a <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set fontfamily <EoN> ( <BoN> self <EoN> , <BoN> fontname <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> fontproperties <EoN> . <BoN> set family <EoN> ( <BoN> fontname <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tocomplex <EoN> ( <BoN> arr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> issubclass <EoN> ( <BoN> arr <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , ( <BoN> nt <EoN> . <BoN> single <EoN> , <BoN> nt <EoN> . <BoN> byte <EoN> , <BoN> nt <EoN> . <BoN> short <EoN> , <BoN> nt <EoN> . <BoN> ubyte <EoN> , <NEWLINE> <BoN> nt <EoN> . <BoN> ushort <EoN> , <BoN> nt <EoN> . <BoN> csingle <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr <EoN> . <BoN> astype <EoN> ( <BoN> nt <EoN> . <BoN> csingle <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr <EoN> . <BoN> astype <EoN> ( <BoN> nt <EoN> . <BoN> cdouble <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> return std <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y mean <EoN> = <BoN> self <EoN> . <BoN> decision function <EoN> ( <BoN> X <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> return std <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> y mean <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> normalize <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> = ( <BoN> X <EoN> - <BoN> self <EoN> . <BoN> X offset <EoN> ) / <BoN> self <EoN> . <BoN> X scale <EoN> <NEWLINE> <UNTAB> <BoN> X <EoN> = <BoN> X <EoN> [ : , <BoN> self <EoN> . <BoN> lambda <EoN> < <BoN> self <EoN> . <BoN> threshold lambda <EoN> ] <NEWLINE> <BoN> sigmas squared data <EoN> = ( <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> X <EoN> , <BoN> self <EoN> . <BoN> sigma <EoN> ) * <BoN> X <EoN> ) . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> y std <EoN> = <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> sigmas squared data <EoN> + ( <NUMBER> / <BoN> self <EoN> . <BoN> alpha <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> y mean <EoN> , <BoN> y std <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from pretrained <EoN> ( <BoN> cls <EoN> , <BoN> embeddings <EoN> , <BoN> freeze <EoN> = <BoN> True <EoN> , <BoN> sparse <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> embeddings <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> , <STRING> <NEWLINE> <BoN> rows <EoN> , <BoN> cols <EoN> = <BoN> embeddings <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> embedding <EoN> = <BoN> cls <EoN> ( <NEWLINE> <BoN> num embeddings <EoN> = <BoN> rows <EoN> , <NEWLINE> <BoN> embedding dim <EoN> = <BoN> cols <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> embeddings <EoN> , <NEWLINE> <BoN> sparse <EoN> = <BoN> sparse <EoN> , <NEWLINE> ) <NEWLINE> <BoN> embedding <EoN> . <BoN> weight <EoN> . <BoN> requires grad <EoN> = <BoN> not <EoN> <BoN> freeze <EoN> <NEWLINE> <BoN> return <EoN> <BoN> embedding <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> primal name <EoN> ( <BoN> func <EoN> , <BoN> wrt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> func <EoN> , <BoN> types <EoN> . <BoN> Function Type <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <BoN> func <EoN> ) <NEWLINE> <UNTAB> <BoN> varnames <EoN> = <BoN> six <EoN> . <BoN> get function code <EoN> ( <BoN> func <EoN> ) . <BoN> co varnames <EoN> <NEWLINE> <BoN> return <EoN> <BoN> PRIMAL NAME <EoN> . <BoN> format <EoN> ( <BoN> func <EoN> . <BoN> name <EoN> , <STRING> . <BoN> join <EoN> ( <BoN> varnames <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> wrt <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hardshrink <EoN> ( <BoN> input <EoN> , <BoN> lambd <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> hardshrink <EoN> ( <BoN> input <EoN> , <BoN> lambd <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> run post hooks <EoN> ( <BoN> self <EoN> , <BoN> return arrays <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> hook <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inputs hooks <EoN> : <NEWLINE> <TAB> ( <BoN> ind <EoN> , <BoN> unique ind <EoN> ) = <BoN> hook <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> in list <EoN> [ <BoN> ind <EoN> ] = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> hook <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> outputs hooks <EoN> : <NEWLINE> <TAB> ( <BoN> ind <EoN> , <BoN> unique ind <EoN> ) = <BoN> hook <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> out list <EoN> [ <BoN> ind <EoN> ] = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> hook <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> return hooks <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> ( <BoN> ret index <EoN> , <BoN> unique list index <EoN> ) = <BoN> hook <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> need copy <EoN> = <BoN> self <EoN> . <BoN> array infos <EoN> [ <BoN> unique list index <EoN> ] . <BoN> retain <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> need copy <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> unique arrays <EoN> [ <BoN> unique list index <EoN> ] [ ... ] = <BoN> return arrays <EoN> [ <BoN> ret index <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> unique arrays <EoN> [ <BoN> unique list index <EoN> ] = <BoN> return arrays <EoN> [ <BoN> ret index <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is bytes like <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> obj <EoN> + <STRING> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> join <EoN> ( <BoN> sep <EoN> , <BoN> seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> to string or unicode array <EoN> ( <NEWLINE> <BoN> vec string <EoN> ( <BoN> sep <EoN> , <BoN> object <EoN> , <STRING> , ( <BoN> seq <EoN> , ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> indexer at time <EoN> ( <BoN> self <EoN> , <BoN> time <EoN> , <BoN> asof <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> dateutil <EoN> . <BoN> parser <EoN> <BoN> import <EoN> <BoN> parse <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> asof <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> time <EoN> , <BoN> compat <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> time <EoN> = <BoN> parse <EoN> ( <BoN> time <EoN> ) . <BoN> time <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> time <EoN> . <BoN> tzinfo <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> time micros <EoN> = <BoN> self <EoN> . <BoN> get time micros <EoN> ( ) <NEWLINE> <BoN> micros <EoN> = <BoN> time to micros <EoN> ( <BoN> time <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> micros <EoN> == <BoN> time micros <EoN> ) . <BoN> nonzero <EoN> ( ) [ <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get parallels <EoN> ( <BoN> bezier 2 <EoN> , <BoN> width <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> c 1 x <EoN> , <BoN> c 1 y <EoN> = <BoN> bezier 2 <EoN> [ <NUMBER> ] <NEWLINE> <BoN> cmx <EoN> , <BoN> cmy <EoN> = <BoN> bezier 2 <EoN> [ <NUMBER> ] <NEWLINE> <BoN> c 2 x <EoN> , <BoN> c 2 y <EoN> = <BoN> bezier 2 <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> parallel test <EoN> = <BoN> check if parallel <EoN> ( <BoN> c 1 x <EoN> - <BoN> cmx <EoN> , <BoN> c 1 y <EoN> - <BoN> cmy <EoN> , <NEWLINE> <BoN> cmx <EoN> - <BoN> c 2 x <EoN> , <BoN> cmy <EoN> - <BoN> c 2 y <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> parallel test <EoN> == - <NUMBER> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <BoN> cos t 1 <EoN> , <BoN> sin t 1 <EoN> = <BoN> get cos sin <EoN> ( <BoN> c 1 x <EoN> , <BoN> c 1 y <EoN> , <BoN> c 2 x <EoN> , <BoN> c 2 y <EoN> ) <NEWLINE> <BoN> cos t 2 <EoN> , <BoN> sin t 2 <EoN> = <BoN> cos t 1 <EoN> , <BoN> sin t 1 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> cos t 1 <EoN> , <BoN> sin t 1 <EoN> = <BoN> get cos sin <EoN> ( <BoN> c 1 x <EoN> , <BoN> c 1 y <EoN> , <BoN> cmx <EoN> , <BoN> cmy <EoN> ) <NEWLINE> <BoN> cos t 2 <EoN> , <BoN> sin t 2 <EoN> = <BoN> get cos sin <EoN> ( <BoN> cmx <EoN> , <BoN> cmy <EoN> , <BoN> c 2 x <EoN> , <BoN> c 2 y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> c 1 x left <EoN> , <BoN> c 1 y left <EoN> , <BoN> c 1 x right <EoN> , <BoN> c 1 y right <EoN> = ( <NEWLINE> <BoN> get normal points <EoN> ( <BoN> c 1 x <EoN> , <BoN> c 1 y <EoN> , <BoN> cos t 1 <EoN> , <BoN> sin t 1 <EoN> , <BoN> width <EoN> ) <NEWLINE> ) <NEWLINE> <BoN> c 2 x left <EoN> , <BoN> c 2 y left <EoN> , <BoN> c 2 x right <EoN> , <BoN> c 2 y right <EoN> = ( <NEWLINE> <BoN> get normal points <EoN> ( <BoN> c 2 x <EoN> , <BoN> c 2 y <EoN> , <BoN> cos t 2 <EoN> , <BoN> sin t 2 <EoN> , <BoN> width <EoN> ) <NEWLINE> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> parallel test <EoN> != <NUMBER> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> cmx left <EoN> , <BoN> cmy left <EoN> = ( <NEWLINE> <NUMBER> * ( <BoN> c 1 x left <EoN> + <BoN> c 2 x left <EoN> ) , <NUMBER> * ( <BoN> c 1 y left <EoN> + <BoN> c 2 y left <EoN> ) <NEWLINE> ) <NEWLINE> <BoN> cmx right <EoN> , <BoN> cmy right <EoN> = ( <NEWLINE> <NUMBER> * ( <BoN> c 1 x right <EoN> + <BoN> c 2 x right <EoN> ) , <NUMBER> * ( <BoN> c 1 y right <EoN> + <BoN> c 2 y right <EoN> ) <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cmx left <EoN> , <BoN> cmy left <EoN> = <BoN> get intersection <EoN> ( <BoN> c 1 x left <EoN> , <BoN> c 1 y left <EoN> , <BoN> cos t 1 <EoN> , <NEWLINE> <BoN> sin t 1 <EoN> , <BoN> c 2 x left <EoN> , <BoN> c 2 y left <EoN> , <NEWLINE> <BoN> cos t 2 <EoN> , <BoN> sin t 2 <EoN> ) <NEWLINE> <NEWLINE> <BoN> cmx right <EoN> , <BoN> cmy right <EoN> = <BoN> get intersection <EoN> ( <BoN> c 1 x right <EoN> , <BoN> c 1 y right <EoN> , <BoN> cos t 1 <EoN> , <NEWLINE> <BoN> sin t 1 <EoN> , <BoN> c 2 x right <EoN> , <BoN> c 2 y right <EoN> , <NEWLINE> <BoN> cos t 2 <EoN> , <BoN> sin t 2 <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> path left <EoN> = [ ( <BoN> c 1 x left <EoN> , <BoN> c 1 y left <EoN> ) , <NEWLINE> ( <BoN> cmx left <EoN> , <BoN> cmy left <EoN> ) , <NEWLINE> ( <BoN> c 2 x left <EoN> , <BoN> c 2 y left <EoN> ) ] <NEWLINE> <BoN> path right <EoN> = [ ( <BoN> c 1 x right <EoN> , <BoN> c 1 y right <EoN> ) , <NEWLINE> ( <BoN> cmx right <EoN> , <BoN> cmy right <EoN> ) , <NEWLINE> ( <BoN> c 2 x right <EoN> , <BoN> c 2 y right <EoN> ) ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> path left <EoN> , <BoN> path right <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get params <EoN> ( <BoN> self <EoN> , <BoN> deep <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> out <EoN> = <BoN> dict <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> get param names <EoN> ( ) : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> getattr <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> deep <EoN> <BoN> and <EoN> <BoN> hasattr <EoN> ( <BoN> value <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> deep items <EoN> = <BoN> value <EoN> . <BoN> get params <EoN> ( ) . <BoN> items <EoN> ( ) <NEWLINE> <BoN> out <EoN> . <BoN> update <EoN> ( ( <BoN> key <EoN> + <STRING> + <BoN> k <EoN> , <BoN> val <EoN> ) <BoN> for <EoN> <BoN> k <EoN> , <BoN> val <EoN> <BoN> in <EoN> <BoN> deep items <EoN> ) <NEWLINE> <UNTAB> <BoN> out <EoN> [ <BoN> key <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read image <EoN> ( <BoN> self <EoN> , <BoN> fname <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> self <EoN> . <BoN> path root <EoN> , <BoN> fname <EoN> ) , <STRING> ) <BoN> as <EoN> <BoN> fin <EoN> : <NEWLINE> <TAB> <BoN> img <EoN> = <BoN> fin <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> img <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to sympy <EoN> ( <BoN> self <EoN> , <BoN> element <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Float <EoN> ( <BoN> element <EoN> , <BoN> self <EoN> . <BoN> dps <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> unquote plus <EoN> ( <BoN> string <EoN> , <BoN> encoding <EoN> = <STRING> , <BoN> errors <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> string <EoN> = <BoN> string <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> unquote <EoN> ( <BoN> string <EoN> , <BoN> encoding <EoN> , <BoN> errors <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to undirected <EoN> ( <BoN> self <EoN> , <BoN> as view <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> graph class <EoN> = <BoN> self <EoN> . <BoN> to undirected class <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> as view <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nx <EoN> . <BoN> graphviews <EoN> . <BoN> generic graph view <EoN> ( <BoN> self <EoN> , <BoN> graph class <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> G <EoN> = <BoN> graph class <EoN> ( ) <NEWLINE> <BoN> G <EoN> . <BoN> graph <EoN> . <BoN> update <EoN> ( <BoN> deepcopy <EoN> ( <BoN> self <EoN> . <BoN> graph <EoN> ) ) <NEWLINE> <BoN> G <EoN> . <BoN> add nodes from <EoN> ( ( <BoN> n <EoN> , <BoN> deepcopy <EoN> ( <BoN> d <EoN> ) ) <BoN> for <EoN> <BoN> n <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> node <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <BoN> G <EoN> . <BoN> add edges from <EoN> ( ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> deepcopy <EoN> ( <BoN> d <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> u <EoN> , <BoN> nbrs <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> adj <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> nbrs <EoN> . <BoN> items <EoN> ( ) ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get fignums <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sorted <EoN> ( <BoN> pylab helpers <EoN> . <BoN> Gcf <EoN> . <BoN> figs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> context <EoN> = <BoN> util <EoN> . <BoN> threading <EoN> . <BoN> local <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> engines <EoN> = { } <NEWLINE> <BoN> super <EoN> ( <BoN> Thread Local Meta Data <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> option image nocomposite <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fsencode <EoN> ( <BoN> filename <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> filename <EoN> = <BoN> fspath <EoN> ( <BoN> filename <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> filename <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> filename <EoN> . <BoN> encode <EoN> ( <BoN> encoding <EoN> , <BoN> errors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> filename <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cohen kappa score <EoN> ( <BoN> y 1 <EoN> , <BoN> y 2 <EoN> , <BoN> labels <EoN> = <BoN> None <EoN> , <BoN> weights <EoN> = <BoN> None <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> confusion <EoN> = <BoN> confusion matrix <EoN> ( <BoN> y 1 <EoN> , <BoN> y 2 <EoN> , <BoN> labels <EoN> = <BoN> labels <EoN> , <NEWLINE> <BoN> sample weight <EoN> = <BoN> sample weight <EoN> ) <NEWLINE> <BoN> n classes <EoN> = <BoN> confusion <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> sum 0 <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> confusion <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> sum 1 <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> confusion <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> expected <EoN> = <BoN> np <EoN> . <BoN> outer <EoN> ( <BoN> sum 0 <EoN> , <BoN> sum 1 <EoN> ) / <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> sum 0 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> weights <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> w mat <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( [ <BoN> n classes <EoN> , <BoN> n classes <EoN> ] , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int <EoN> ) <NEWLINE> <BoN> w mat <EoN> . <BoN> flat <EoN> [ : : <BoN> n classes <EoN> + <NUMBER> ] = <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> weights <EoN> == <STRING> <BoN> or <EoN> <BoN> weights <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> w mat <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( [ <BoN> n classes <EoN> , <BoN> n classes <EoN> ] , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int <EoN> ) <NEWLINE> <BoN> w mat <EoN> += <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> n classes <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> weights <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> w mat <EoN> = <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> w mat <EoN> - <BoN> w mat <EoN> . <BoN> T <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> w mat <EoN> = ( <BoN> w mat <EoN> - <BoN> w mat <EoN> . <BoN> T <EoN> ) ** <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> w mat <EoN> * <BoN> confusion <EoN> ) / <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> w mat <EoN> * <BoN> expected <EoN> ) <NEWLINE> <BoN> return <EoN> <NUMBER> - <BoN> k <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as coefficients dict <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> d <EoN> = <BoN> defaultdict <EoN> ( <BoN> list <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> ai <EoN> <BoN> in <EoN> <BoN> a <EoN> . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> , <BoN> m <EoN> = <BoN> ai <EoN> . <BoN> as coeff Mul <EoN> ( ) <NEWLINE> <BoN> d <EoN> [ <BoN> m <EoN> ] . <BoN> append <EoN> ( <BoN> c <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> d <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> v <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> [ <BoN> k <EoN> ] = <BoN> Add <EoN> ( * <BoN> v <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> di <EoN> = <BoN> defaultdict <EoN> ( <BoN> int <EoN> ) <NEWLINE> <BoN> di <EoN> . <BoN> update <EoN> ( <BoN> d <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> di <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> abs rel err <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> abs err <EoN> = <BoN> abs <EoN> ( <BoN> a <EoN> - <BoN> b <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> rel err <EoN> = <BoN> abs err <EoN> / <BoN> np <EoN> . <BoN> maximum <EoN> ( <BoN> abs <EoN> ( <BoN> a <EoN> ) + <BoN> abs <EoN> ( <BoN> b <EoN> ) , [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> abs err <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> abs err <EoN> ) <NEWLINE> <BoN> rel err <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> rel err <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> abs err <EoN> , <BoN> rel err <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save and write assets <EoN> ( <BoN> self <EoN> , <BoN> assets collection to add <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> asset filename map <EoN> = <BoN> maybe save assets <EoN> ( <BoN> add asset to collection <EoN> , <NEWLINE> <BoN> assets collection to add <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> asset filename map <EoN> : <NEWLINE> <TAB> <BoN> tf logging <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> copy assets to destination dir <EoN> ( <BoN> asset filename map <EoN> , <BoN> self <EoN> . <BoN> export dir <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update func argset <EoN> ( <BoN> self <EoN> , <BoN> func i <EoN> , <BoN> new argset <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new args <EoN> = <BoN> Ordered Set <EoN> ( <BoN> new argset <EoN> ) <NEWLINE> <BoN> old args <EoN> = <BoN> self <EoN> . <BoN> func to argset <EoN> [ <BoN> func i <EoN> ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> deleted arg <EoN> <BoN> in <EoN> <BoN> old args <EoN> - <BoN> new args <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> arg to funcset <EoN> [ <BoN> deleted arg <EoN> ] . <BoN> remove <EoN> ( <BoN> func i <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> added arg <EoN> <BoN> in <EoN> <BoN> new args <EoN> - <BoN> old args <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> arg to funcset <EoN> [ <BoN> added arg <EoN> ] . <BoN> add <EoN> ( <BoN> func i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> func to argset <EoN> [ <BoN> func i <EoN> ] . <BoN> clear <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> func to argset <EoN> [ <BoN> func i <EoN> ] . <BoN> update <EoN> ( <BoN> new args <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> expm multiply <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> , <BoN> start <EoN> = <BoN> None <EoN> , <BoN> stop <EoN> = <BoN> None <EoN> , <BoN> num <EoN> = <BoN> None <EoN> , <BoN> endpoint <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> all <EoN> ( <BoN> arg <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> ( <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> num <EoN> , <BoN> endpoint <EoN> ) ) : <NEWLINE> <TAB> <BoN> X <EoN> = <BoN> expm multiply simple <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> , <BoN> status <EoN> = <BoN> expm multiply interval <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> , <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> num <EoN> , <BoN> endpoint <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> X <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> scatter minus scalar <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> scalar <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reset group selection <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> group selection <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> group selection <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> reset cache <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> enter <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> . <BoN> rcmod <EoN> <BoN> import <EoN> <BoN> set palette <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> orig palette <EoN> = <BoN> color palette <EoN> ( ) <NEWLINE> <BoN> set palette <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> recv bytes into <EoN> ( <BoN> self <EoN> , <BoN> buf <EoN> , <BoN> offset <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> check closed <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> check readable <EoN> ( ) <NEWLINE> <BoN> with <EoN> <BoN> memoryview <EoN> ( <BoN> buf <EoN> ) <BoN> as <EoN> <BoN> m <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> itemsize <EoN> = <BoN> m <EoN> . <BoN> itemsize <EoN> <NEWLINE> <BoN> bytesize <EoN> = <BoN> itemsize <EoN> * <BoN> len <EoN> ( <BoN> m <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> offset <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> offset <EoN> > <BoN> bytesize <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> recv bytes <EoN> ( ) <NEWLINE> <BoN> size <EoN> = <BoN> result <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> bytesize <EoN> < <BoN> offset <EoN> + <BoN> size <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Buffer Too Short <EoN> ( <BoN> result <EoN> . <BoN> getvalue <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> result <EoN> . <BoN> seek <EoN> ( <NUMBER> ) <NEWLINE> <BoN> result <EoN> . <BoN> readinto <EoN> ( <BoN> m <EoN> [ <BoN> offset <EoN> // <BoN> itemsize <EoN> : <NEWLINE> ( <BoN> offset <EoN> + <BoN> size <EoN> ) // <BoN> itemsize <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> size <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> qsize <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> self <EoN> . <BoN> mutex <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> qsize <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> invert yaxis <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> set ylim <EoN> ( <BoN> self <EoN> . <BoN> get ylim <EoN> ( ) [ : : - <NUMBER> ] , <BoN> auto <EoN> = <BoN> None <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> factorplot <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> msg <EoN> = ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> ) <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> ) <NEWLINE> <BoN> msg <EoN> = ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> , <BoN> User Warning <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> kwargs <EoN> . <BoN> setdefault <EoN> ( <STRING> , <STRING> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> catplot <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> verify and get subgroup size <EoN> ( <BoN> self <EoN> , <BoN> group assignment <EoN> , <BoN> num shards <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> group assignment <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> isinstance <EoN> ( <BoN> group assignment <EoN> , <BoN> list <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> all <EoN> ( <BoN> isinstance <EoN> ( <BoN> i <EoN> , <BoN> list <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> group assignment <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> group assignment <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> replica ids <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> g <EoN> <BoN> in <EoN> <BoN> group assignment <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> replica ids <EoN> . <BoN> add <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> set <EoN> ( <BoN> range <EoN> ( <BoN> num shards <EoN> ) ) != <BoN> replica ids <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> num shards <EoN> , <BoN> group assignment <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> subgroup size list <EoN> = [ <BoN> len <EoN> ( <BoN> group <EoN> ) <BoN> for <EoN> <BoN> group <EoN> <BoN> in <EoN> <BoN> group assignment <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> all <EoN> ( <BoN> subgroup size list <EoN> [ <NUMBER> ] == <BoN> size <EoN> <BoN> for <EoN> <BoN> size <EoN> <BoN> in <EoN> <BoN> subgroup size list <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> subgroup size list <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> group assignment <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save file <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> String I O <EoN> <BoN> as <EoN> <BoN> pystring I O <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> io <EoN> <BoN> as <EoN> <BoN> pystring I O <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> obj <EoN> , <STRING> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> obj <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> obj <EoN> <BoN> is <EoN> <BoN> sys <EoN> . <BoN> stdout <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> save reduce <EoN> ( <BoN> getattr <EoN> , ( <BoN> sys <EoN> , <STRING> ) , <BoN> obj <EoN> = <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> obj <EoN> <BoN> is <EoN> <BoN> sys <EoN> . <BoN> stderr <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> save reduce <EoN> ( <BoN> getattr <EoN> , ( <BoN> sys <EoN> , <STRING> ) , <BoN> obj <EoN> = <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> obj <EoN> <BoN> is <EoN> <BoN> sys <EoN> . <BoN> stdin <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> obj <EoN> . <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> obj <EoN> , <STRING> ) <BoN> and <EoN> <BoN> obj <EoN> . <BoN> isatty <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> obj <EoN> . <BoN> mode <EoN> <BoN> and <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> obj <EoN> . <BoN> mode <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> % <BoN> obj <EoN> . <BoN> mode <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> name <EoN> = <BoN> obj <EoN> . <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> retval <EoN> = <BoN> pystring I O <EoN> . <BoN> String I O <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> curloc <EoN> = <BoN> obj <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> obj <EoN> . <BoN> seek <EoN> ( <NUMBER> ) <NEWLINE> <BoN> contents <EoN> = <BoN> obj <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <BoN> obj <EoN> . <BoN> seek <EoN> ( <BoN> curloc <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> IO Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> pickle <EoN> . <BoN> Pickling Error <EoN> ( <STRING> % <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> retval <EoN> . <BoN> write <EoN> ( <BoN> contents <EoN> ) <NEWLINE> <BoN> retval <EoN> . <BoN> seek <EoN> ( <BoN> curloc <EoN> ) <NEWLINE> <NEWLINE> <BoN> retval <EoN> . <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> save <EoN> ( <BoN> retval <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> memoize <EoN> ( <BoN> obj <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> Substitution <EoN> ( <BoN> name <EoN> = <STRING> ) <NEWLINE> @ <BoN> Appender <EoN> ( <BoN> doc template <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> sem <EoN> ( <BoN> self <EoN> , <BoN> ddof <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> std <EoN> ( <BoN> ddof <EoN> = <BoN> ddof <EoN> ) / <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> self <EoN> . <BoN> count <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> partition <EoN> ( <BoN> self <EoN> , <BoN> sep <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> asarray <EoN> ( <BoN> partition <EoN> ( <BoN> self <EoN> , <BoN> sep <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set data <EoN> ( <BoN> self <EoN> , <BoN> A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cm <EoN> . <BoN> Scalar Mappable <EoN> . <BoN> set array <EoN> ( <BoN> self <EoN> , <NEWLINE> <BoN> cbook <EoN> . <BoN> safe masked invalid <EoN> ( <BoN> A <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> model variables <EoN> ( <BoN> scope <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> ops <EoN> . <BoN> get collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> MODEL VARIABLES <EoN> , <BoN> scope <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> softsign <EoN> ( <BoN> features <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> features <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> softsign eager fallback <EoN> ( <NEWLINE> <BoN> features <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> softsign <EoN> , <BoN> features <EoN> = <BoN> features <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> features <EoN> = <BoN> features <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> softsign <EoN> , <BoN> features <EoN> = <BoN> features <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from ordinalf <EoN> ( <BoN> x <EoN> , <BoN> tz <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> tz <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> tz <EoN> = <BoN> get rc timezone <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ix <EoN> , <BoN> remainder <EoN> = <BoN> divmod <EoN> ( <BoN> x <EoN> , <NUMBER> ) <NEWLINE> <BoN> ix <EoN> = <BoN> int <EoN> ( <BoN> ix <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ix <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> ix <EoN> ) ) <NEWLINE> <UNTAB> <BoN> dt <EoN> = <BoN> datetime <EoN> . <BoN> datetime <EoN> . <BoN> fromordinal <EoN> ( <BoN> ix <EoN> ) . <BoN> replace <EoN> ( <BoN> tzinfo <EoN> = <BoN> UT C <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> musec prec <EoN> = <NUMBER> <NEWLINE> <BoN> remainder musec <EoN> = <BoN> int <EoN> ( <BoN> round <EoN> ( <BoN> remainder <EoN> * <BoN> MUSECONDS PER DAY <EoN> / <BoN> musec prec <EoN> ) <NEWLINE> * <BoN> musec prec <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> < <NUMBER> * <NUMBER> : <NEWLINE> <TAB> <BoN> remainder musec <EoN> = <BoN> int <EoN> ( <BoN> round <EoN> ( <BoN> remainder <EoN> * <BoN> MUSECONDS PER DAY <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> dt <EoN> += <BoN> datetime <EoN> . <BoN> timedelta <EoN> ( <BoN> microseconds <EoN> = <BoN> remainder musec <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dt <EoN> . <BoN> astimezone <EoN> ( <BoN> tz <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arctan 2 <EoN> ( <BoN> x 1 <EoN> , <BoN> x 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Arctan 2 <EoN> ( ) . <BoN> apply <EoN> ( ( <BoN> x 1 <EoN> , <BoN> x 2 <EoN> ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add callback <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> oid <EoN> = <BoN> self <EoN> . <BoN> oid <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> propobservers <EoN> [ <BoN> oid <EoN> ] = <BoN> func <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> oid <EoN> += <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> oid <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> cos <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cos eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> cos <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> cos <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> nav stack <EoN> . <BoN> clear <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> set history buttons <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to period <EoN> ( <BoN> self <EoN> , <BoN> freq <EoN> = <BoN> None <EoN> , <BoN> copy <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new values <EoN> = <BoN> self <EoN> . <BoN> values <EoN> <NEWLINE> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> new values <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> new index <EoN> = <BoN> self <EoN> . <BoN> index <EoN> . <BoN> to period <EoN> ( <BoN> freq <EoN> = <BoN> freq <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> new values <EoN> , <NEWLINE> <BoN> index <EoN> = <BoN> new index <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reverse <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> directed <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> H <EoN> = <BoN> self <EoN> . <BoN> class <EoN> ( <BoN> strict <EoN> = <BoN> self <EoN> . <BoN> strict <EoN> , <BoN> directed <EoN> = <BoN> True <EoN> , <BoN> name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> H <EoN> . <BoN> graph attr <EoN> . <BoN> update <EoN> ( <BoN> self <EoN> . <BoN> graph attr <EoN> ) <NEWLINE> <BoN> H <EoN> . <BoN> node attr <EoN> . <BoN> update <EoN> ( <BoN> self <EoN> . <BoN> node attr <EoN> ) <NEWLINE> <BoN> H <EoN> . <BoN> edge attr <EoN> . <BoN> update <EoN> ( <BoN> self <EoN> . <BoN> edge attr <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> nodes <EoN> ( ) : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> add node <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> new n <EoN> = <BoN> Node <EoN> ( <BoN> H <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> new n <EoN> . <BoN> attr <EoN> . <BoN> update <EoN> ( <BoN> n <EoN> . <BoN> attr <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> edges <EoN> ( ) : <NEWLINE> <TAB> ( <BoN> u <EoN> , <BoN> v <EoN> ) = <BoN> e <EoN> <NEWLINE> <BoN> H <EoN> . <BoN> add edge <EoN> ( <BoN> v <EoN> , <BoN> u <EoN> ) <NEWLINE> <BoN> uv <EoN> = <BoN> H <EoN> . <BoN> get edge <EoN> ( <BoN> v <EoN> , <BoN> u <EoN> ) <NEWLINE> <BoN> uv <EoN> . <BoN> attr <EoN> . <BoN> update <EoN> ( <BoN> e <EoN> . <BoN> attr <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> H <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> searchsorted <EoN> ( <BoN> self <EoN> , <BoN> v <EoN> , <BoN> side <EoN> = <STRING> , <BoN> sorter <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> super <EoN> ( <BoN> Frozen ND Array <EoN> , <BoN> self <EoN> ) . <BoN> searchsorted <EoN> ( <NEWLINE> <BoN> v <EoN> , <BoN> side <EoN> = <BoN> side <EoN> , <BoN> sorter <EoN> = <BoN> sorter <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> raw open <EoN> ( <BoN> self <EoN> , <BoN> flags <EoN> , <BoN> mode <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> closed <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> raise closed <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> accessor <EoN> . <BoN> open <EoN> ( <BoN> self <EoN> , <BoN> flags <EoN> , <BoN> mode <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init saver <EoN> ( <BoN> self <EoN> , <BoN> saver <EoN> = <BoN> USE DEFAULT <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> saver <EoN> <BoN> is <EoN> <BoN> Supervisor <EoN> . <BoN> USE DEFAULT <EoN> : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> self <EoN> . <BoN> get first op from collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> saver <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> variables <EoN> . <BoN> global variables <EoN> ( ) : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> saver mod <EoN> . <BoN> Saver <EoN> ( ) <NEWLINE> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> , <BoN> saver <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> saver <EoN> = <BoN> saver <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pdf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> exp <EoN> ( <BoN> self <EoN> . <BoN> logpdf <EoN> ( <BoN> x <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> convert to fill <EoN> ( <BoN> cls <EoN> , <BoN> fill dict <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> from <EoN> <BoN> openpyxl <EoN> . <BoN> styles <EoN> <BoN> import <EoN> <BoN> Pattern Fill <EoN> , <BoN> Gradient Fill <EoN> <NEWLINE> <NEWLINE> <BoN> pattern fill key map <EoN> = { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> } <NEWLINE> <NEWLINE> <BoN> gradient fill key map <EoN> = { <NEWLINE> <STRING> : <STRING> , <NEWLINE> } <NEWLINE> <NEWLINE> <BoN> pfill kwargs <EoN> = { } <NEWLINE> <BoN> gfill kwargs <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> fill dict <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> pk <EoN> = <BoN> gk <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> pattern fill key map <EoN> : <NEWLINE> <TAB> <BoN> pk <EoN> = <BoN> pattern fill key map <EoN> [ <BoN> k <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> gradient fill key map <EoN> : <NEWLINE> <TAB> <BoN> gk <EoN> = <BoN> gradient fill key map <EoN> [ <BoN> k <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> pk <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> cls <EoN> . <BoN> convert to color <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> gk <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> cls <EoN> . <BoN> convert to stop <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> pk <EoN> : <NEWLINE> <TAB> <BoN> pfill kwargs <EoN> [ <BoN> pk <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> gk <EoN> : <NEWLINE> <TAB> <BoN> gfill kwargs <EoN> [ <BoN> gk <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pfill kwargs <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <BoN> gfill kwargs <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Pattern Fill <EoN> ( ** <BoN> pfill kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Gradient Fill <EoN> ( ** <BoN> gfill kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pprint setters rest <EoN> ( <BoN> self <EoN> , <BoN> prop <EoN> = <BoN> None <EoN> , <BoN> leadingspace <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> leadingspace <EoN> : <NEWLINE> <TAB> <BoN> pad <EoN> = <STRING> * <BoN> leadingspace <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pad <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> prop <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> accepts <EoN> = <BoN> self <EoN> . <BoN> get valid values <EoN> ( <BoN> prop <EoN> ) <NEWLINE> <BoN> return <EoN> <STRING> % ( <BoN> pad <EoN> , <BoN> prop <EoN> , <BoN> accepts <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> attrs <EoN> = <BoN> self <EoN> . <BoN> get setters and targets <EoN> ( ) <NEWLINE> <BoN> attrs <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> lines <EoN> = [ ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> names <EoN> = [ <BoN> self <EoN> . <BoN> aliased name rest <EoN> ( <BoN> prop <EoN> , <BoN> target <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> prop <EoN> , <BoN> target <EoN> <BoN> in <EoN> <BoN> attrs <EoN> ] <NEWLINE> <BoN> accepts <EoN> = [ <BoN> self <EoN> . <BoN> get valid values <EoN> ( <BoN> prop <EoN> ) <BoN> for <EoN> <BoN> prop <EoN> , <BoN> target <EoN> <BoN> in <EoN> <BoN> attrs <EoN> ] <NEWLINE> <NEWLINE> <BoN> col 0 len <EoN> = <BoN> max <EoN> ( <BoN> len <EoN> ( <BoN> n <EoN> ) <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> names <EoN> ) <NEWLINE> <BoN> col 1 len <EoN> = <BoN> max <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> accepts <EoN> ) <NEWLINE> <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <STRING> ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> pad <EoN> + <STRING> ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> pad <EoN> + <STRING> ) <NEWLINE> <BoN> pad <EoN> += <STRING> <NEWLINE> <NEWLINE> <BoN> table formatstr <EoN> = <BoN> pad <EoN> + <STRING> * <BoN> col 0 len <EoN> + <STRING> + <STRING> * <BoN> col 1 len <EoN> <NEWLINE> <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <STRING> ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> table formatstr <EoN> ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> pad <EoN> + <STRING> . <BoN> ljust <EoN> ( <BoN> col 0 len <EoN> + <NUMBER> ) + <NEWLINE> <STRING> . <BoN> ljust <EoN> ( <BoN> col 1 len <EoN> ) ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> table formatstr <EoN> ) <NEWLINE> <NEWLINE> <BoN> lines <EoN> . <BoN> extend <EoN> ( [ <BoN> pad <EoN> + <BoN> n <EoN> . <BoN> ljust <EoN> ( <BoN> col 0 len <EoN> + <NUMBER> ) + <BoN> a <EoN> . <BoN> ljust <EoN> ( <BoN> col 1 len <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> , <BoN> a <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> names <EoN> , <BoN> accepts <EoN> ) ] ) <NEWLINE> <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <BoN> table formatstr <EoN> ) <NEWLINE> <BoN> lines <EoN> . <BoN> append <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> lines <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> neg <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> operate <EoN> ( <BoN> neg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cdf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> any none <EoN> ( * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> arg <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> entropy lower bound <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> self <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <BoN> values <EoN> = [ <BoN> self <EoN> . <BoN> cat <EoN> . <BoN> logits <EoN> ] ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> self <EoN> . <BoN> assertions <EoN> ) : <NEWLINE> <TAB> <BoN> distribution entropies <EoN> = [ <BoN> d <EoN> . <BoN> entropy <EoN> ( ) <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> components <EoN> ] <NEWLINE> <BoN> cat probs <EoN> = <BoN> self <EoN> . <BoN> cat probs <EoN> ( <BoN> log probs <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> partial entropies <EoN> = [ <NEWLINE> <BoN> c p <EoN> * <BoN> m <EoN> <BoN> for <EoN> ( <BoN> c p <EoN> , <BoN> m <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> cat probs <EoN> , <BoN> distribution entropies <EoN> ) <NEWLINE> ] <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> add n <EoN> ( <BoN> partial entropies <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> with metaclass <EoN> ( <BoN> meta <EoN> , * <BoN> bases <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> meta <EoN> ( <STRING> , <BoN> bases <EoN> , { } ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set figure <EoN> ( <BoN> self <EoN> , <BoN> fig <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> martist <EoN> . <BoN> Artist <EoN> . <BoN> set figure <EoN> ( <BoN> self <EoN> , <BoN> fig <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> get children <EoN> ( ) : <NEWLINE> <TAB> <BoN> c <EoN> . <BoN> set figure <EoN> ( <BoN> fig <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> simplify variable coeff <EoN> ( <BoN> sol <EoN> , <BoN> syms <EoN> , <BoN> func <EoN> , <BoN> funcarg <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> eta <EoN> = <BoN> Symbol <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> syms <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> sym <EoN> = <BoN> syms <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <BoN> final <EoN> = <BoN> sol <EoN> . <BoN> subs <EoN> ( <BoN> sym <EoN> , <BoN> func <EoN> ( <BoN> funcarg <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fname <EoN> = <BoN> func <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> sym <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> syms <EoN> ) : <NEWLINE> <TAB> <BoN> tempfun <EoN> = <BoN> Function <EoN> ( <BoN> fname <EoN> + <BoN> str <EoN> ( <BoN> key <EoN> ) ) <NEWLINE> <BoN> final <EoN> = <BoN> sol <EoN> . <BoN> subs <EoN> ( <BoN> sym <EoN> , <BoN> func <EoN> ( <BoN> funcarg <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> simplify <EoN> ( <BoN> final <EoN> . <BoN> subs <EoN> ( <BoN> eta <EoN> , <BoN> funcarg <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> decimal to Rational prec <EoN> ( <BoN> dec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dec <EoN> . <BoN> is finite <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> dec <EoN> ) <NEWLINE> <UNTAB> <BoN> s <EoN> , <BoN> d <EoN> , <BoN> e <EoN> = <BoN> dec <EoN> . <BoN> as tuple <EoN> ( ) <NEWLINE> <BoN> prec <EoN> = <BoN> len <EoN> ( <BoN> d <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> e <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> rv <EoN> = <BoN> Integer <EoN> ( <BoN> int <EoN> ( <BoN> dec <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = ( - <NUMBER> ) ** <BoN> s <EoN> <NEWLINE> <BoN> d <EoN> = <BoN> sum <EoN> ( [ <BoN> di <EoN> * <NUMBER> ** <BoN> i <EoN> <BoN> for <EoN> <BoN> i <EoN> , <BoN> di <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> reversed <EoN> ( <BoN> d <EoN> ) ) ] ) <NEWLINE> <BoN> rv <EoN> = <BoN> Rational <EoN> ( <BoN> s <EoN> * <BoN> d <EoN> , <NUMBER> ** - <BoN> e <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> , <BoN> prec <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> flattop <EoN> ( <BoN> M <EoN> , <BoN> sym <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = [ <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> general cosine <EoN> ( <BoN> M <EoN> , <BoN> a <EoN> , <BoN> sym <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> integrate gaussian <EoN> ( <BoN> self <EoN> , <BoN> mean <EoN> , <BoN> cov <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mean <EoN> = <BoN> atleast 1 d <EoN> ( <BoN> squeeze <EoN> ( <BoN> mean <EoN> ) ) <NEWLINE> <BoN> cov <EoN> = <BoN> atleast 2 d <EoN> ( <BoN> cov <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> mean <EoN> . <BoN> shape <EoN> != ( <BoN> self <EoN> . <BoN> d <EoN> , ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> d <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> cov <EoN> . <BoN> shape <EoN> != ( <BoN> self <EoN> . <BoN> d <EoN> , <BoN> self <EoN> . <BoN> d <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> d <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> mean <EoN> = <BoN> mean <EoN> [ : , <BoN> newaxis <EoN> ] <NEWLINE> <NEWLINE> <BoN> sum cov <EoN> = <BoN> self <EoN> . <BoN> covariance <EoN> + <BoN> cov <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sum cov chol <EoN> = <BoN> linalg <EoN> . <BoN> cho factor <EoN> ( <BoN> sum cov <EoN> ) <NEWLINE> <NEWLINE> <BoN> diff <EoN> = <BoN> self <EoN> . <BoN> dataset <EoN> - <BoN> mean <EoN> <NEWLINE> <BoN> tdiff <EoN> = <BoN> linalg <EoN> . <BoN> cho solve <EoN> ( <BoN> sum cov chol <EoN> , <BoN> diff <EoN> ) <NEWLINE> <NEWLINE> <BoN> sqrt det <EoN> = <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> np <EoN> . <BoN> diagonal <EoN> ( <BoN> sum cov chol <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> norm const <EoN> = <BoN> power <EoN> ( <NUMBER> * <BoN> pi <EoN> , <BoN> sum cov <EoN> . <BoN> shape <EoN> [ <NUMBER> ] / <NUMBER> ) * <BoN> sqrt det <EoN> <NEWLINE> <NEWLINE> <BoN> energies <EoN> = <BoN> sum <EoN> ( <BoN> diff <EoN> * <BoN> tdiff <EoN> , <BoN> axis <EoN> = <NUMBER> ) / <NUMBER> <NEWLINE> <BoN> result <EoN> = <BoN> sum <EoN> ( <BoN> exp <EoN> ( - <BoN> energies <EoN> ) , <BoN> axis <EoN> = <NUMBER> ) / <BoN> norm const <EoN> / <BoN> self <EoN> . <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> equal <EoN> ( <BoN> x 1 <EoN> , <BoN> x 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> compare chararrays <EoN> ( <BoN> x 1 <EoN> , <BoN> x 2 <EoN> , <STRING> , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> correlate 2 d <EoN> ( <BoN> in 1 <EoN> , <BoN> in 2 <EoN> , <BoN> mode <EoN> = <STRING> , <BoN> boundary <EoN> = <STRING> , <BoN> fillvalue <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> in 1 <EoN> = <BoN> asarray <EoN> ( <BoN> in 1 <EoN> ) <NEWLINE> <BoN> in 2 <EoN> = <BoN> asarray <EoN> ( <BoN> in 2 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> in 1 <EoN> . <BoN> ndim <EoN> == <BoN> in 2 <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> swapped inputs <EoN> = <BoN> inputs swap needed <EoN> ( <BoN> mode <EoN> , <BoN> in 1 <EoN> . <BoN> shape <EoN> , <BoN> in 2 <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> swapped inputs <EoN> : <NEWLINE> <TAB> <BoN> in 1 <EoN> , <BoN> in 2 <EoN> = <BoN> in 2 <EoN> , <BoN> in 1 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> val <EoN> = <BoN> valfrommode <EoN> ( <BoN> mode <EoN> ) <NEWLINE> <BoN> bval <EoN> = <BoN> bvalfromboundary <EoN> ( <BoN> boundary <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> sigtools <EoN> . <BoN> convolve 2 d <EoN> ( <BoN> in 1 <EoN> , <BoN> in 2 <EoN> . <BoN> conj <EoN> ( ) , <NUMBER> , <BoN> val <EoN> , <BoN> bval <EoN> , <BoN> fillvalue <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> swapped inputs <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> out <EoN> [ : : - <NUMBER> , : : - <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> create location <EoN> ( <BoN> self <EoN> , <BoN> location <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> binary crossentropy <EoN> ( <BoN> target <EoN> , <BoN> output <EoN> , <BoN> from logits <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> from logits <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> epsilon <EoN> = <BoN> to tensor <EoN> ( <BoN> epsilon <EoN> ( ) , <BoN> output <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> ) <NEWLINE> <BoN> output <EoN> = <BoN> clip ops <EoN> . <BoN> clip by value <EoN> ( <BoN> output <EoN> , <BoN> epsilon <EoN> , <NUMBER> - <BoN> epsilon <EoN> ) <NEWLINE> <BoN> output <EoN> = <BoN> math ops <EoN> . <BoN> log <EoN> ( <BoN> output <EoN> / ( <NUMBER> - <BoN> output <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> nn <EoN> . <BoN> sigmoid cross entropy with logits <EoN> ( <BoN> labels <EoN> = <BoN> target <EoN> , <BoN> logits <EoN> = <BoN> output <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> allresults <EoN> ( <BoN> tree <EoN> , <BoN> leaf <EoN> = <BoN> yieldify <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> treeapply <EoN> ( <BoN> tree <EoN> , { <BoN> list <EoN> : <BoN> branch <EoN> . <BoN> multiplex <EoN> , <BoN> tuple <EoN> : <BoN> branch <EoN> . <BoN> chain <EoN> } , <NEWLINE> <BoN> leaf <EoN> = <BoN> leaf <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fix pooling <EoN> ( <BoN> pool type <EoN> , <BoN> inputs <EoN> , <BoN> new attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> stride <EoN> = <BoN> new attr <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> kernel <EoN> = <BoN> new attr <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> padding <EoN> = <BoN> new attr <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stride <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> stride <EoN> = ( <NUMBER> , ) * <BoN> len <EoN> ( <BoN> kernel <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> padding <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> padding <EoN> = ( <NUMBER> , ) * <BoN> len <EoN> ( <BoN> kernel <EoN> ) * <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> kernel <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> dummy axis <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> padding <EoN> = ( <NUMBER> , <BoN> padding <EoN> [ <NUMBER> ] , <NUMBER> , <BoN> padding <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> pad width <EoN> = ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) + <BoN> pad sequence fix <EoN> ( <BoN> padding <EoN> , <BoN> kernel dim <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> curr sym <EoN> = <BoN> symbol <EoN> . <BoN> expand dims <EoN> ( <BoN> inputs <EoN> [ <NUMBER> ] , <BoN> axis <EoN> = <BoN> dummy axis <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new pad op <EoN> = <BoN> symbol <EoN> . <BoN> pad <EoN> ( <BoN> curr sym <EoN> , <BoN> mode <EoN> = <STRING> , <BoN> pad width <EoN> = <BoN> pad width <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new pad op <EoN> = <BoN> symbol <EoN> . <BoN> split <EoN> ( <BoN> new pad op <EoN> , <BoN> axis <EoN> = <BoN> dummy axis <EoN> , <BoN> num outputs <EoN> = <NUMBER> , <BoN> squeeze axis <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> pad width <EoN> = ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) + <BoN> pad sequence fix <EoN> ( <BoN> padding <EoN> , <BoN> kernel dim <EoN> = <BoN> len <EoN> ( <BoN> kernel <EoN> ) ) <NEWLINE> <BoN> curr sym <EoN> = <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> pool type <EoN> == <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> new pad op <EoN> = <BoN> symbol <EoN> . <BoN> pad <EoN> ( <BoN> curr sym <EoN> , <BoN> mode <EoN> = <STRING> , <BoN> pad width <EoN> = <BoN> pad width <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> new pad op <EoN> = <BoN> symbol <EoN> . <BoN> pad <EoN> ( <BoN> curr sym <EoN> , <BoN> mode <EoN> = <STRING> , <BoN> pad width <EoN> = <BoN> pad width <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> new pooling op <EoN> = <BoN> symbol <EoN> . <BoN> Pooling <EoN> ( <BoN> new pad op <EoN> , <BoN> pool type <EoN> = <BoN> pool type <EoN> , <BoN> stride <EoN> = <BoN> stride <EoN> , <BoN> kernel <EoN> = <BoN> kernel <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> new pooling op <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gca <EoN> ( ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> gcf <EoN> ( ) . <BoN> gca <EoN> ( ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> udivisors <EoN> ( <BoN> n <EoN> , <BoN> generator <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> n <EoN> = <BoN> as int <EoN> ( <BoN> abs <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> isprime <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ <NUMBER> , <BoN> n <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <BoN> rv <EoN> = <BoN> udivisors <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> generator <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sorted <EoN> ( <BoN> rv <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rv <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get eval ops <EoN> ( <BoN> self <EoN> , <BoN> features <EoN> , <BoN> labels <EoN> , <BoN> metrics <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> model fn ops <EoN> = <BoN> self <EoN> . <BoN> call model fn <EoN> ( <BoN> features <EoN> , <BoN> labels <EoN> , <NEWLINE> <BoN> model fn lib <EoN> . <BoN> Mode Keys <EoN> . <BoN> EVA L <EoN> , <BoN> metrics <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> metric key <EoN> . <BoN> Metric Key <EoN> . <BoN> LOS S <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> model fn ops <EoN> . <BoN> eval metric ops <EoN> : <NEWLINE> <TAB> <BoN> model fn ops <EoN> . <BoN> eval metric ops <EoN> [ <BoN> metric key <EoN> . <BoN> Metric Key <EoN> . <BoN> LOS S <EoN> ] = ( <NEWLINE> <BoN> metrics lib <EoN> . <BoN> mean <EoN> ( <BoN> model fn ops <EoN> . <BoN> loss <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> model fn ops <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get ring <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> polys <EoN> . <BoN> domains <EoN> <BoN> import <EoN> <BoN> Python Integer Ring <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Python Integer Ring <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get autoscaley on <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> autoscaleYon <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> variables initializer <EoN> ( <BoN> var list <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> var list <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * [ <BoN> v <EoN> . <BoN> initializer <EoN> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> var list <EoN> ] , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> control flow ops <EoN> . <BoN> no op <EoN> ( <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> find matching indices <EoN> ( <BoN> tree <EoN> , <BoN> bin X <EoN> , <BoN> left mask <EoN> , <BoN> right mask <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> left index <EoN> = <BoN> np <EoN> . <BoN> searchsorted <EoN> ( <BoN> tree <EoN> , <BoN> bin X <EoN> & <BoN> left mask <EoN> ) <NEWLINE> <BoN> right index <EoN> = <BoN> np <EoN> . <BoN> searchsorted <EoN> ( <BoN> tree <EoN> , <BoN> bin X <EoN> | <BoN> right mask <EoN> , <NEWLINE> <BoN> side <EoN> = <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> left index <EoN> , <BoN> right index <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mp sgd update <EoN> ( <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> grad <EoN> = <BoN> None <EoN> , <BoN> weight 32 <EoN> = <BoN> None <EoN> , <BoN> lr <EoN> = <BoN> Null <EoN> , <BoN> wd <EoN> = <BoN> Null <EoN> , <BoN> rescale grad <EoN> = <BoN> Null <EoN> , <BoN> clip gradient <EoN> = <BoN> Null <EoN> , <BoN> lazy update <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add hook <EoN> ( <BoN> self <EoN> , <BoN> hook <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> hook <EoN> , <BoN> function hook <EoN> . <BoN> Function Hook <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> hook <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> hooks <EoN> = <BoN> self <EoN> . <BoN> local function hooks <EoN> <NEWLINE> <BoN> if <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> hooks <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> % <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> hooks <EoN> [ <BoN> name <EoN> ] = <BoN> hook <EoN> <NEWLINE> <BoN> hook <EoN> . <BoN> added <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> minimum rooted branching <EoN> ( <BoN> D <EoN> , <BoN> root <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> rooted <EoN> = <BoN> D <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> rooted <EoN> . <BoN> remove edges from <EoN> ( [ ( <BoN> u <EoN> , <BoN> root <EoN> ) <BoN> for <EoN> <BoN> u <EoN> <BoN> in <EoN> <BoN> D <EoN> . <BoN> predecessors <EoN> ( <BoN> root <EoN> ) ] ) <NEWLINE> <NEWLINE> <BoN> A <EoN> = <BoN> nx <EoN> . <BoN> minimum spanning arborescence <EoN> ( <BoN> rooted <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> A <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> njoin <EoN> ( * <BoN> path <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> paths <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> path <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is sequence <EoN> ( <BoN> p <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> paths <EoN> . <BoN> append <EoN> ( <BoN> njoin <EoN> ( * <BoN> p <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> is string <EoN> ( <BoN> p <EoN> ) <NEWLINE> <BoN> paths <EoN> . <BoN> append <EoN> ( <BoN> p <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> path <EoN> = <BoN> paths <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> path <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> joined <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> joined <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( * <BoN> path <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> sep <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> joined <EoN> = <BoN> joined <EoN> . <BoN> replace <EoN> ( <STRING> , <BoN> os <EoN> . <BoN> path <EoN> . <BoN> sep <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> minrelpath <EoN> ( <BoN> joined <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> iqr percentile <EoN> ( <BoN> x <EoN> , <BoN> q <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> interpolation <EoN> = <STRING> , <BoN> keepdims <EoN> = <BoN> False <EoN> , <BoN> contains nan <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> contains nan <EoN> <BoN> and <EoN> <BoN> Numpy Version <EoN> ( <BoN> np <EoN> . <BoN> version <EoN> ) < <STRING> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <STRING> <STRING> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> msg <EoN> , <BoN> Runtime Warning <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> percentile <EoN> ( <BoN> x <EoN> , <BoN> q <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> keepdims <EoN> = <BoN> keepdims <EoN> , <NEWLINE> <BoN> interpolation <EoN> = <BoN> interpolation <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> interpolation <EoN> != <STRING> <BoN> or <EoN> <BoN> keepdims <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> Runtime Warning <EoN> ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> original size <EoN> = <BoN> len <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> axis <EoN> ) % <BoN> x <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> original size <EoN> > <BoN> axis <EoN> . <BoN> size <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> . <BoN> size <EoN> == <BoN> x <EoN> . <BoN> ndim <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> axis <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> axis <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> ax <EoN> <BoN> in <EoN> <BoN> axis <EoN> [ : : - <NUMBER> ] : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> rollaxis <EoN> ( <BoN> x <EoN> , <BoN> ax <EoN> , <BoN> x <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> x <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> [ : - <BoN> axis <EoN> . <BoN> size <EoN> ] + <NEWLINE> ( <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> [ - <BoN> axis <EoN> . <BoN> size <EoN> : ] ) , ) ) <NEWLINE> <BoN> axis <EoN> = - <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> percentile <EoN> ( <BoN> x <EoN> , <BoN> q <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> convert units <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x 0 <EoN> = <BoN> self <EoN> . <BoN> convert xunits <EoN> ( <BoN> self <EoN> . <BoN> x 0 <EoN> ) <NEWLINE> <BoN> y 0 <EoN> = <BoN> self <EoN> . <BoN> convert yunits <EoN> ( <BoN> self <EoN> . <BoN> y 0 <EoN> ) <NEWLINE> <BoN> x 1 <EoN> = <BoN> self <EoN> . <BoN> convert xunits <EoN> ( <BoN> self <EoN> . <BoN> x 1 <EoN> ) <NEWLINE> <BoN> y 1 <EoN> = <BoN> self <EoN> . <BoN> convert yunits <EoN> ( <BoN> self <EoN> . <BoN> y 1 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> x 0 <EoN> , <BoN> y 0 <EoN> , <BoN> x 1 <EoN> , <BoN> y 1 <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> minutes <EoN> ( <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> m <EoN> / <BoN> MINUTES PER DAY <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arctan <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> gcd <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Factors <EoN> ) : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> Factors <EoN> ( <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> other <EoN> . <BoN> is zero <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Factors <EoN> ( <BoN> self <EoN> . <BoN> factors <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> factors <EoN> = { } <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> factor <EoN> , <BoN> exp <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> factors <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> factor <EoN> , <BoN> exp <EoN> = <BoN> sympify <EoN> ( <BoN> factor <EoN> ) , <BoN> sympify <EoN> ( <BoN> exp <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> factor <EoN> <BoN> in <EoN> <BoN> other <EoN> . <BoN> factors <EoN> : <NEWLINE> <TAB> <BoN> lt <EoN> = ( <BoN> exp <EoN> - <BoN> other <EoN> . <BoN> factors <EoN> [ <BoN> factor <EoN> ] ) . <BoN> is negative <EoN> <NEWLINE> <BoN> if <EoN> <BoN> lt <EoN> == <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> factors <EoN> [ <BoN> factor <EoN> ] = <BoN> exp <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> lt <EoN> == <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> factors <EoN> [ <BoN> factor <EoN> ] = <BoN> other <EoN> . <BoN> factors <EoN> [ <BoN> factor <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> Factors <EoN> ( <BoN> factors <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get frame result type <EoN> ( <BoN> result <EoN> , <BoN> objs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> . <BoN> blocks <EoN> <BoN> and <EoN> <BoN> all <EoN> ( <BoN> b <EoN> . <BoN> is sparse <EoN> <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> result <EoN> . <BoN> blocks <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> sparse <EoN> . <BoN> api <EoN> <BoN> import <EoN> <BoN> Sparse Data Frame <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Sparse Data Frame <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> next <EoN> ( <BoN> obj <EoN> <BoN> for <EoN> <BoN> obj <EoN> <BoN> in <EoN> <BoN> objs <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <NEWLINE> <BoN> ABC Sparse Data Frame <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> rfloordiv <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set linewidth <EoN> ( <BoN> self <EoN> , <BoN> lw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> lw <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> lw <EoN> = <BoN> mpl <EoN> . <BoN> rc Params <EoN> [ <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> lw <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> lw <EoN> = <BoN> mpl <EoN> . <BoN> rc Params <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> us lw <EoN> = <BoN> np <EoN> . <BoN> atleast 1 d <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> lw <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> linewidths <EoN> , <BoN> self <EoN> . <BoN> linestyles <EoN> = <BoN> self <EoN> . <BoN> bcast lwls <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> us lw <EoN> , <BoN> self <EoN> . <BoN> us linestyles <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lesser equal <EoN> ( <BoN> lhs <EoN> , <BoN> rhs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> ufunc helper <EoN> ( <NEWLINE> <BoN> lhs <EoN> , <NEWLINE> <BoN> rhs <EoN> , <NEWLINE> <BoN> op <EoN> . <BoN> broadcast lesser equal <EoN> , <NEWLINE> <BoN> lambda <EoN> <BoN> x <EoN> , <BoN> y <EoN> : <NUMBER> <BoN> if <EoN> <BoN> x <EoN> <= <BoN> y <EoN> <BoN> else <EoN> <NUMBER> , <NEWLINE> <BoN> internal <EoN> . <BoN> lesser equal scalar <EoN> , <NEWLINE> <BoN> internal <EoN> . <BoN> greater equal scalar <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> belongs to set <EoN> ( <BoN> self <EoN> , <BoN> node <EoN> , <BoN> set nodes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> rep <EoN> = <BoN> set nodes <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> ( <BoN> rep <EoN> . <BoN> op <EoN> . <BoN> as while <EoN> != <BoN> node <EoN> . <BoN> op <EoN> . <BoN> as while <EoN> <BoN> or <EoN> <NEWLINE> <BoN> node <EoN> . <BoN> op <EoN> . <BoN> truncate gradient <EoN> != <BoN> rep <EoN> . <BoN> op <EoN> . <BoN> truncate gradient <EoN> <BoN> or <EoN> <NEWLINE> <BoN> node <EoN> . <BoN> op <EoN> . <BoN> mode <EoN> != <BoN> rep <EoN> . <BoN> op <EoN> . <BoN> mode <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> nsteps <EoN> = <BoN> node <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> nsteps <EoN> = <BoN> int <EoN> ( <BoN> get scalar constant value <EoN> ( <BoN> nsteps <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> tensor <EoN> . <BoN> Not Scalar Constant Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> rep nsteps <EoN> = <BoN> rep <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> rep nsteps <EoN> = <BoN> int <EoN> ( <BoN> get scalar constant value <EoN> ( <BoN> rep nsteps <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> tensor <EoN> . <BoN> Not Scalar Constant Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> nsteps <EoN> != <BoN> rep nsteps <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> nd <EoN> <BoN> in <EoN> <BoN> set nodes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> gof <EoN> . <BoN> graph <EoN> . <BoN> is in ancestors <EoN> ( <BoN> node <EoN> , <BoN> nd <EoN> ) <BoN> or <EoN> <BoN> gof <EoN> . <BoN> graph <EoN> . <BoN> is in ancestors <EoN> ( <BoN> nd <EoN> , <BoN> node <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> node <EoN> . <BoN> op <EoN> . <BoN> as while <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> cond <EoN> = <BoN> node <EoN> . <BoN> op <EoN> . <BoN> outputs <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> rep cond <EoN> = <BoN> rep <EoN> . <BoN> op <EoN> . <BoN> outputs <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> scan utils <EoN> . <BoN> equal computations <EoN> ( [ <BoN> cond <EoN> ] , [ <BoN> rep cond <EoN> ] , <NEWLINE> <BoN> node <EoN> . <BoN> op <EoN> . <BoN> inputs <EoN> , <NEWLINE> <BoN> rep <EoN> . <BoN> op <EoN> . <BoN> inputs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> preprocess roots <EoN> ( <BoN> poly <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> coeff <EoN> = <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <NEWLINE> <BoN> poly func <EoN> = <BoN> poly <EoN> . <BoN> func <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> clear denoms <EoN> ( <BoN> convert <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Domain Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> coeff <EoN> , <BoN> poly <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> primitive <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> retract <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> poly <EoN> . <BoN> get domain <EoN> ( ) . <BoN> is Poly <EoN> <BoN> and <EoN> <BoN> all <EoN> ( <BoN> c <EoN> . <BoN> is term <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> poly <EoN> . <BoN> rep <EoN> . <BoN> coeffs <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> inject <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> strips <EoN> = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> poly <EoN> . <BoN> monoms <EoN> ( ) ) ) <NEWLINE> <BoN> gens <EoN> = <BoN> list <EoN> ( <BoN> poly <EoN> . <BoN> gens <EoN> [ <NUMBER> : ] ) <NEWLINE> <NEWLINE> <BoN> base <EoN> , <BoN> strips <EoN> = <BoN> strips <EoN> [ <NUMBER> ] , <BoN> strips <EoN> [ <NUMBER> : ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> gen <EoN> , <BoN> strip <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> list <EoN> ( <BoN> gens <EoN> ) , <BoN> strips <EoN> ) : <NEWLINE> <TAB> <BoN> reverse <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> strip <EoN> [ <NUMBER> ] < <BoN> strip <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> strip <EoN> = <BoN> reversed <EoN> ( <BoN> strip <EoN> ) <NEWLINE> <BoN> reverse <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> ratio <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> , <BoN> b <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> base <EoN> , <BoN> strip <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> a <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> a <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> b <EoN> % <BoN> a <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ratio <EoN> = <BoN> b <EoN> // <BoN> a <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> ratio <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ratio <EoN> = <BoN> ratio <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ratio <EoN> != <BoN> ratio <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> reverse <EoN> : <NEWLINE> <TAB> <BoN> ratio <EoN> = - <BoN> ratio <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> eval <EoN> ( <BoN> gen <EoN> , <NUMBER> ) <NEWLINE> <BoN> coeff <EoN> *= <BoN> gen <EoN> ** ( - <BoN> ratio <EoN> ) <NEWLINE> <BoN> gens <EoN> . <BoN> remove <EoN> ( <BoN> gen <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> eject <EoN> ( * <BoN> gens <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> poly <EoN> . <BoN> is univariate <EoN> <BoN> and <EoN> <BoN> poly <EoN> . <BoN> get domain <EoN> ( ) . <BoN> is ZZ <EoN> : <NEWLINE> <TAB> <BoN> basis <EoN> = <BoN> integer basis <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> basis <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> poly <EoN> . <BoN> degree <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> func <EoN> ( <BoN> k <EoN> , <BoN> coeff <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> coeff <EoN> // <BoN> basis <EoN> ** ( <BoN> n <EoN> - <BoN> k <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> poly <EoN> = <BoN> poly <EoN> . <BoN> termwise <EoN> ( <BoN> func <EoN> ) <NEWLINE> <BoN> coeff <EoN> *= <BoN> basis <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> poly <EoN> , <BoN> poly func <EoN> ) : <NEWLINE> <TAB> <BoN> poly <EoN> = <BoN> poly func <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> coeff <EoN> , <BoN> poly <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ode order <EoN> ( <BoN> expr <EoN> , <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> func <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> expr <EoN> . <BoN> match <EoN> ( <BoN> a <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> expr <EoN> , <BoN> Derivative <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expr <EoN> . <BoN> args <EoN> [ <NUMBER> ] == <BoN> func <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> expr <EoN> . <BoN> variables <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> order <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> expr <EoN> . <BoN> args <EoN> [ <NUMBER> ] . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> order <EoN> = <BoN> max <EoN> ( <BoN> order <EoN> , <BoN> ode order <EoN> ( <BoN> arg <EoN> , <BoN> func <EoN> ) + <BoN> len <EoN> ( <BoN> expr <EoN> . <BoN> variables <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> order <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> order <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> expr <EoN> . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> order <EoN> = <BoN> max <EoN> ( <BoN> order <EoN> , <BoN> ode order <EoN> ( <BoN> arg <EoN> , <BoN> func <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> order <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> close <EoN> ( <BoN> self <EoN> , <BoN> cancel pending enqueues <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> % <BoN> self <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> queue ref <EoN> . <BoN> dtype <EoN> == <BoN> dtypes <EoN> . <BoN> resource <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gen data flow ops <EoN> . <BoN> queue close v 2 <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> queue ref <EoN> , <NEWLINE> <BoN> cancel pending enqueues <EoN> = <BoN> cancel pending enqueues <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gen data flow ops <EoN> . <BoN> queue close <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> queue ref <EoN> , <NEWLINE> <BoN> cancel pending enqueues <EoN> = <BoN> cancel pending enqueues <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get clients 2 <EoN> ( <BoN> node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> l <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> , <BoN> i <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> outputs <EoN> [ <NUMBER> ] . <BoN> clients <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> c <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> c <EoN> . <BoN> outputs <EoN> : <NEWLINE> <TAB> <BoN> l <EoN> . <BoN> extend <EoN> ( [ <BoN> cc <EoN> <BoN> for <EoN> <BoN> cc <EoN> , <BoN> ii <EoN> <BoN> in <EoN> <BoN> var <EoN> . <BoN> clients <EoN> <BoN> if <EoN> <BoN> cc <EoN> != <STRING> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> l <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> logpdf <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> mean <EoN> = <BoN> None <EoN> , <BoN> rowcov <EoN> = <NUMBER> , <BoN> colcov <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dims <EoN> , <BoN> mean <EoN> , <BoN> rowcov <EoN> , <BoN> colcov <EoN> = <BoN> self <EoN> . <BoN> process parameters <EoN> ( <BoN> mean <EoN> , <BoN> rowcov <EoN> , <NEWLINE> <BoN> colcov <EoN> ) <NEWLINE> <BoN> X <EoN> = <BoN> self <EoN> . <BoN> process quantiles <EoN> ( <BoN> X <EoN> , <BoN> dims <EoN> ) <NEWLINE> <BoN> rowpsd <EoN> = <BoN> PSD <EoN> ( <BoN> rowcov <EoN> , <BoN> allow singular <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> colpsd <EoN> = <BoN> PSD <EoN> ( <BoN> colcov <EoN> , <BoN> allow singular <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> self <EoN> . <BoN> logpdf <EoN> ( <BoN> dims <EoN> , <BoN> X <EoN> , <BoN> mean <EoN> , <BoN> rowpsd <EoN> . <BoN> U <EoN> , <BoN> rowpsd <EoN> . <BoN> log pdet <EoN> , <BoN> colpsd <EoN> . <BoN> U <EoN> , <NEWLINE> <BoN> colpsd <EoN> . <BoN> log pdet <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> squeeze output <EoN> ( <BoN> out <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> muly <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p 1 <EoN> = <BoN> poly from expr <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> n <EoN> = <BoN> degree <EoN> ( <BoN> p 1 <EoN> ) <NEWLINE> <BoN> a <EoN> = [ <BoN> c <EoN> * <BoN> x <EoN> ** <BoN> i <EoN> * <BoN> y <EoN> ** ( <BoN> n <EoN> - <BoN> i <EoN> ) <BoN> for <EoN> ( <BoN> i <EoN> , ) , <BoN> c <EoN> <BoN> in <EoN> <BoN> p 1 <EoN> . <BoN> terms <EoN> ( ) ] <NEWLINE> <BoN> return <EoN> <BoN> Add <EoN> ( * <BoN> a <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> loop <EoN> ( <BoN> coord <EoN> , <BoN> timer interval secs <EoN> , <BoN> target <EoN> , <BoN> args <EoN> = <BoN> None <EoN> , <BoN> kwargs <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> looper <EoN> = <BoN> Looper Thread <EoN> ( <BoN> coord <EoN> , <BoN> timer interval secs <EoN> , <BoN> target <EoN> = <BoN> target <EoN> , <BoN> args <EoN> = <BoN> args <EoN> , <NEWLINE> <BoN> kwargs <EoN> = <BoN> kwargs <EoN> ) <NEWLINE> <BoN> looper <EoN> . <BoN> start <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> looper <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gaussian kl divergence <EoN> ( <BoN> mean <EoN> , <BoN> ln var <EoN> , <BoN> reduce <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> reduce <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> reduce <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> var <EoN> = <BoN> exponential <EoN> . <BoN> exp <EoN> ( <BoN> ln var <EoN> ) <NEWLINE> <BoN> mean square <EoN> = <BoN> mean <EoN> * <BoN> mean <EoN> <NEWLINE> <BoN> loss <EoN> = ( <BoN> mean square <EoN> + <BoN> var <EoN> - <BoN> ln var <EoN> - <NUMBER> ) * <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> reduce <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sum <EoN> . <BoN> sum <EoN> ( <BoN> loss <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> loss <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> window <EoN> ( <BoN> self <EoN> , <BoN> size <EoN> , <BoN> shift <EoN> = <BoN> None <EoN> , <BoN> stride <EoN> = <NUMBER> , <BoN> drop remainder <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> shift <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shift <EoN> = <BoN> size <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Window Dataset <EoN> ( <BoN> self <EoN> , <BoN> size <EoN> , <BoN> shift <EoN> , <BoN> stride <EoN> , <BoN> drop remainder <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> begin twophase <EoN> ( <BoN> self <EoN> , <BoN> xid <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> branch from <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> branch from <EoN> . <BoN> begin twophase <EoN> ( <BoN> xid <EoN> = <BoN> xid <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> transaction <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Invalid Request Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> xid <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> xid <EoN> = <BoN> self <EoN> . <BoN> engine <EoN> . <BoN> dialect <EoN> . <BoN> create xid <EoN> ( ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> transaction <EoN> = <BoN> Two Phase Transaction <EoN> ( <BoN> self <EoN> , <BoN> xid <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> transaction <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> row swap <EoN> ( <BoN> self <EoN> , <BoN> i <EoN> , <BoN> j <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> > <BoN> j <EoN> : <NEWLINE> <TAB> <BoN> i <EoN> , <BoN> j <EoN> = <BoN> j <EoN> , <BoN> i <EoN> <NEWLINE> <UNTAB> <BoN> rows <EoN> = <BoN> self <EoN> . <BoN> row list <EoN> ( ) <NEWLINE> <BoN> temp <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> ii <EoN> , <BoN> jj <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> rows <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ii <EoN> == <BoN> i <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> smat <EoN> . <BoN> pop <EoN> ( ( <BoN> ii <EoN> , <BoN> jj <EoN> ) ) <NEWLINE> <BoN> temp <EoN> . <BoN> append <EoN> ( ( <BoN> jj <EoN> , <BoN> v <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ii <EoN> == <BoN> j <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> smat <EoN> . <BoN> pop <EoN> ( ( <BoN> ii <EoN> , <BoN> jj <EoN> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> smat <EoN> [ <BoN> i <EoN> , <BoN> jj <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ii <EoN> > <BoN> j <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> temp <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> smat <EoN> [ <BoN> j <EoN> , <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate format <EoN> ( <BoN> self <EoN> , <BoN> format <EoN> , <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> = <BoN> kwargs <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> FORMAT MAP <EoN> [ <BoN> format <EoN> . <BoN> lower <EoN> ( ) ] <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> format <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> kwargs <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> getfullargspec <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> inspect <EoN> . <BoN> getfullargspec <EoN> ( <BoN> func <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> arg spec <EoN> = <BoN> inspect <EoN> . <BoN> getargspec <EoN> ( <BoN> func <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> full argspec type <EoN> ( <BoN> args <EoN> = <BoN> arg spec <EoN> . <BoN> args <EoN> , <NEWLINE> <BoN> varargs <EoN> = <BoN> arg spec <EoN> . <BoN> varargs <EoN> , <NEWLINE> <BoN> varkw <EoN> = <BoN> arg spec <EoN> . <BoN> keywords <EoN> , <NEWLINE> <BoN> defaults <EoN> = <BoN> arg spec <EoN> . <BoN> defaults <EoN> , <NEWLINE> <BoN> kwonlyargs <EoN> = [ ] , <NEWLINE> <BoN> kwonlydefaults <EoN> = <BoN> None <EoN> , <NEWLINE> <BoN> annotations <EoN> = { } ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> load data <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dirname <EoN> = <STRING> <NEWLINE> <BoN> origin <EoN> = <STRING> <NEWLINE> <BoN> path <EoN> = <BoN> get file <EoN> ( <BoN> dirname <EoN> , <BoN> origin <EoN> = <BoN> origin <EoN> , <BoN> untar <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> num train samples <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> x train <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> num train samples <EoN> , <NUMBER> , <NUMBER> , <NUMBER> ) , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <BoN> y train <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( <BoN> num train samples <EoN> , ) , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> fpath <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> path <EoN> , <STRING> + <BoN> str <EoN> ( <BoN> i <EoN> ) ) <NEWLINE> ( <BoN> x train <EoN> [ ( <BoN> i <EoN> - <NUMBER> ) * <NUMBER> : <BoN> i <EoN> * <NUMBER> , : , : , : ] , <NEWLINE> <BoN> y train <EoN> [ ( <BoN> i <EoN> - <NUMBER> ) * <NUMBER> : <BoN> i <EoN> * <NUMBER> ] ) = <BoN> load batch <EoN> ( <BoN> fpath <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> fpath <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> path <EoN> , <STRING> ) <NEWLINE> <BoN> x test <EoN> , <BoN> y test <EoN> = <BoN> load batch <EoN> ( <BoN> fpath <EoN> ) <NEWLINE> <NEWLINE> <BoN> y train <EoN> = <BoN> np <EoN> . <BoN> reshape <EoN> ( <BoN> y train <EoN> , ( <BoN> len <EoN> ( <BoN> y train <EoN> ) , <NUMBER> ) ) <NEWLINE> <BoN> y test <EoN> = <BoN> np <EoN> . <BoN> reshape <EoN> ( <BoN> y test <EoN> , ( <BoN> len <EoN> ( <BoN> y test <EoN> ) , <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> K <EoN> . <BoN> image data format <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> x train <EoN> = <BoN> x train <EoN> . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> x test <EoN> = <BoN> x test <EoN> . <BoN> transpose <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> x train <EoN> , <BoN> y train <EoN> ) , ( <BoN> x test <EoN> , <BoN> y test <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverted <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load label <EoN> ( <BoN> batch <EoN> , <BoN> targets <EoN> , <BoN> major axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> batch <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> new batch <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> targets <EoN> ) ) : <NEWLINE> <TAB> <BoN> new batch <EoN> . <BoN> append <EoN> ( [ <BoN> b <EoN> . <BoN> label <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> batch <EoN> ] ) <NEWLINE> <UNTAB> <BoN> new targets <EoN> = [ [ <BoN> dst <EoN> <BoN> for <EoN> <BoN> <EoN> , <BoN> dst <EoN> <BoN> in <EoN> <BoN> d target <EoN> ] <BoN> for <EoN> <BoN> d target <EoN> <BoN> in <EoN> <BoN> targets <EoN> ] <NEWLINE> <BoN> load general <EoN> ( <BoN> new batch <EoN> , <BoN> new targets <EoN> , <BoN> major axis <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> load general <EoN> ( <BoN> batch <EoN> . <BoN> label <EoN> , <BoN> targets <EoN> , <BoN> major axis <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> linear 2 eq order 2 type 4 <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> t <EoN> , <BoN> r <EoN> , <BoN> eq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> C 1 <EoN> , <BoN> C 2 <EoN> , <BoN> C 3 <EoN> , <BoN> C 4 <EoN> = <BoN> get numbered constants <EoN> ( <BoN> eq <EoN> , <BoN> num <EoN> = <NUMBER> ) <NEWLINE> <BoN> k <EoN> = <BoN> Symbol <EoN> ( <STRING> ) <NEWLINE> <BoN> Ra <EoN> , <BoN> Ca <EoN> , <BoN> Rb <EoN> , <BoN> Cb <EoN> = <BoN> symbols <EoN> ( <STRING> ) <NEWLINE> <BoN> a 1 <EoN> = <BoN> r <EoN> [ <STRING> ] ; <BoN> a 2 <EoN> = <BoN> r <EoN> [ <STRING> ] <NEWLINE> <BoN> b 1 <EoN> = <BoN> r <EoN> [ <STRING> ] ; <BoN> b 2 <EoN> = <BoN> r <EoN> [ <STRING> ] <NEWLINE> <BoN> c 1 <EoN> = <BoN> r <EoN> [ <STRING> ] ; <BoN> c 2 <EoN> = <BoN> r <EoN> [ <STRING> ] <NEWLINE> <BoN> d 1 <EoN> = <BoN> r <EoN> [ <STRING> ] ; <BoN> d 2 <EoN> = <BoN> r <EoN> [ <STRING> ] <NEWLINE> <BoN> k 1 <EoN> = <BoN> r <EoN> [ <STRING> ] . <BoN> expand <EoN> ( ) . <BoN> as independent <EoN> ( <BoN> t <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> k 2 <EoN> = <BoN> r <EoN> [ <STRING> ] . <BoN> expand <EoN> ( ) . <BoN> as independent <EoN> ( <BoN> t <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> ew 1 <EoN> = <BoN> r <EoN> [ <STRING> ] . <BoN> expand <EoN> ( ) . <BoN> as independent <EoN> ( <BoN> t <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> ew 2 <EoN> = <BoN> powdenest <EoN> ( <BoN> ew 1 <EoN> ) . <BoN> as base exp <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> ew 3 <EoN> = <BoN> collect <EoN> ( <BoN> ew 2 <EoN> , <BoN> t <EoN> ) . <BoN> coeff <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> w <EoN> = <BoN> cancel <EoN> ( <BoN> ew 3 <EoN> / <BoN> I <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> peq 1 <EoN> = ( - <BoN> w <EoN> ** <NUMBER> + <BoN> c 1 <EoN> ) * <BoN> Ra <EoN> - <BoN> a 1 <EoN> * <BoN> w <EoN> * <BoN> Ca <EoN> + <BoN> d 1 <EoN> * <BoN> Rb <EoN> - <BoN> b 1 <EoN> * <BoN> w <EoN> * <BoN> Cb <EoN> - <BoN> k 1 <EoN> <NEWLINE> <BoN> peq 2 <EoN> = <BoN> a 1 <EoN> * <BoN> w <EoN> * <BoN> Ra <EoN> + ( - <BoN> w <EoN> ** <NUMBER> + <BoN> c 1 <EoN> ) * <BoN> Ca <EoN> + <BoN> b 1 <EoN> * <BoN> w <EoN> * <BoN> Rb <EoN> + <BoN> d 1 <EoN> * <BoN> Cb <EoN> <NEWLINE> <BoN> peq 3 <EoN> = <BoN> c 2 <EoN> * <BoN> Ra <EoN> - <BoN> a 2 <EoN> * <BoN> w <EoN> * <BoN> Ca <EoN> + ( - <BoN> w <EoN> ** <NUMBER> + <BoN> d 2 <EoN> ) * <BoN> Rb <EoN> - <BoN> b 2 <EoN> * <BoN> w <EoN> * <BoN> Cb <EoN> - <BoN> k 2 <EoN> <NEWLINE> <BoN> peq 4 <EoN> = <BoN> a 2 <EoN> * <BoN> w <EoN> * <BoN> Ra <EoN> + <BoN> c 2 <EoN> * <BoN> Ca <EoN> + <BoN> b 2 <EoN> * <BoN> w <EoN> * <BoN> Rb <EoN> + ( - <BoN> w <EoN> ** <NUMBER> + <BoN> d 2 <EoN> ) * <BoN> Cb <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> psol <EoN> = <BoN> solve <EoN> ( [ <BoN> peq 1 <EoN> , <BoN> peq 2 <EoN> , <BoN> peq 3 <EoN> , <BoN> peq 4 <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> chareq <EoN> = ( <BoN> k <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k <EoN> + <BoN> c 1 <EoN> ) * ( <BoN> k <EoN> ** <NUMBER> + <BoN> b 2 <EoN> * <BoN> k <EoN> + <BoN> d 2 <EoN> ) - ( <BoN> b 1 <EoN> * <BoN> k <EoN> + <BoN> d 1 <EoN> ) * ( <BoN> a 2 <EoN> * <BoN> k <EoN> + <BoN> c 2 <EoN> ) <NEWLINE> [ <BoN> k 1 <EoN> , <BoN> k 2 <EoN> , <BoN> k 3 <EoN> , <BoN> k 4 <EoN> ] = <BoN> roots quartic <EoN> ( <BoN> Poly <EoN> ( <BoN> chareq <EoN> ) ) <NEWLINE> <BoN> sol 1 <EoN> = - <BoN> C 1 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 1 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 1 <EoN> * <BoN> t <EoN> ) - <BoN> C 2 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 2 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 2 <EoN> * <BoN> t <EoN> ) - <BoN> C 3 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 3 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 3 <EoN> * <BoN> t <EoN> ) - <BoN> C 4 <EoN> * ( <BoN> b 1 <EoN> * <BoN> k 4 <EoN> + <BoN> d 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 4 <EoN> * <BoN> t <EoN> ) + ( <BoN> Ra <EoN> + <BoN> I <EoN> * <BoN> Ca <EoN> ) * <BoN> exp <EoN> ( <BoN> I <EoN> * <BoN> w <EoN> * <BoN> t <EoN> ) <NEWLINE> <NEWLINE> <BoN> a 1 <EoN> = ( <BoN> a 1 <EoN> - <NUMBER> ) <NEWLINE> <BoN> sol 2 <EoN> = <BoN> C 1 <EoN> * ( <BoN> k 1 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 1 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 1 <EoN> * <BoN> t <EoN> ) + <BoN> C 2 <EoN> * ( <BoN> k 2 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 2 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 2 <EoN> * <BoN> t <EoN> ) + <BoN> C 3 <EoN> * ( <BoN> k 3 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 3 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 3 <EoN> * <BoN> t <EoN> ) + <BoN> C 4 <EoN> * ( <BoN> k 4 <EoN> ** <NUMBER> + <BoN> a 1 <EoN> * <BoN> k 4 <EoN> + <BoN> c 1 <EoN> ) * <BoN> exp <EoN> ( <BoN> k 4 <EoN> * <BoN> t <EoN> ) + ( <BoN> Rb <EoN> + <BoN> I <EoN> * <BoN> Cb <EoN> ) * <BoN> exp <EoN> ( <BoN> I <EoN> * <BoN> w <EoN> * <BoN> t <EoN> ) <NEWLINE> <BoN> return <EoN> [ <BoN> Eq <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> sol 1 <EoN> ) , <BoN> Eq <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> sol 2 <EoN> ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save <EoN> ( <BoN> self <EoN> , <BoN> filepath <EoN> , <BoN> overwrite <EoN> = <BoN> True <EoN> , <BoN> include optimizer <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is graph network <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <BoN> from <EoN> . . <BoN> models <EoN> <BoN> import <EoN> <BoN> save model <EoN> <NEWLINE> <BoN> save model <EoN> ( <BoN> self <EoN> , <BoN> filepath <EoN> , <BoN> overwrite <EoN> , <BoN> include optimizer <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lbp key <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <BoN> sig key <EoN> ( <BoN> Sign <EoN> ( <BoN> f <EoN> ) , <BoN> Polyn <EoN> ( <BoN> f <EoN> ) . <BoN> ring <EoN> . <BoN> order <EoN> ) , - <BoN> Num <EoN> ( <BoN> f <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> recast to symbols <EoN> ( <BoN> eqs <EoN> , <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> iterable <EoN> ( <BoN> eqs <EoN> ) <BoN> and <EoN> <BoN> iterable <EoN> ( <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> new symbols <EoN> = <BoN> list <EoN> ( <BoN> symbols <EoN> ) <NEWLINE> <BoN> swap sym <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> s <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> Symbol <EoN> ) <BoN> and <EoN> <BoN> s <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> swap sym <EoN> : <NEWLINE> <TAB> <BoN> swap sym <EoN> [ <BoN> s <EoN> ] = <BoN> Dummy <EoN> ( <STRING> % <BoN> i <EoN> ) <NEWLINE> <BoN> new symbols <EoN> [ <BoN> i <EoN> ] = <BoN> swap sym <EoN> [ <BoN> s <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> new f <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> eqs <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> new f <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> . <BoN> subs <EoN> ( <BoN> swap sym <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> new f <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> swap sym <EoN> = { <BoN> v <EoN> : <BoN> k <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> swap sym <EoN> . <BoN> items <EoN> ( ) } <NEWLINE> <BoN> return <EoN> <BoN> new f <EoN> , <BoN> new symbols <EoN> , <BoN> swap sym <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> shape from header <EoN> ( <BoN> self <EoN> , <BoN> hdr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mclass <EoN> = <BoN> hdr <EoN> . <BoN> mclass <EoN> <NEWLINE> <BoN> if <EoN> <BoN> mclass <EoN> == <BoN> mxFULL CLASS <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> tuple <EoN> ( <BoN> map <EoN> ( <BoN> int <EoN> , <BoN> hdr <EoN> . <BoN> dims <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> mclass <EoN> == <BoN> mxCHAR CLASS <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> tuple <EoN> ( <BoN> map <EoN> ( <BoN> int <EoN> , <BoN> hdr <EoN> . <BoN> dims <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> chars as strings <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> shape <EoN> [ : - <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> mclass <EoN> == <BoN> mxSPARSE CLASS <EoN> : <NEWLINE> <TAB> <BoN> dt <EoN> = <BoN> hdr <EoN> . <BoN> dtype <EoN> <NEWLINE> <BoN> dims <EoN> = <BoN> hdr <EoN> . <BoN> dims <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> len <EoN> ( <BoN> dims <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> dims <EoN> [ <NUMBER> ] >= <NUMBER> <BoN> and <EoN> <BoN> dims <EoN> [ <NUMBER> ] >= <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> mat stream <EoN> . <BoN> seek <EoN> ( <BoN> dt <EoN> . <BoN> itemsize <EoN> * ( <BoN> dims <EoN> [ <NUMBER> ] - <NUMBER> ) , <NUMBER> ) <NEWLINE> <BoN> rows <EoN> = <BoN> np <EoN> . <BoN> ndarray <EoN> ( <BoN> shape <EoN> = ( <NUMBER> , ) , <BoN> dtype <EoN> = <BoN> dt <EoN> , <NEWLINE> <BoN> buffer <EoN> = <BoN> self <EoN> . <BoN> mat stream <EoN> . <BoN> read <EoN> ( <BoN> dt <EoN> . <BoN> itemsize <EoN> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> mat stream <EoN> . <BoN> seek <EoN> ( <BoN> dt <EoN> . <BoN> itemsize <EoN> * ( <BoN> dims <EoN> [ <NUMBER> ] - <NUMBER> ) , <NUMBER> ) <NEWLINE> <BoN> cols <EoN> = <BoN> np <EoN> . <BoN> ndarray <EoN> ( <BoN> shape <EoN> = ( <NUMBER> , ) , <BoN> dtype <EoN> = <BoN> dt <EoN> , <NEWLINE> <BoN> buffer <EoN> = <BoN> self <EoN> . <BoN> mat stream <EoN> . <BoN> read <EoN> ( <BoN> dt <EoN> . <BoN> itemsize <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> shape <EoN> = ( <BoN> int <EoN> ( <BoN> rows <EoN> ) , <BoN> int <EoN> ( <BoN> cols <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> mclass <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> squeeze me <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> tuple <EoN> ( [ <BoN> x <EoN> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> shape <EoN> <BoN> if <EoN> <BoN> x <EoN> != <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> shape <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get rc timezone <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> s <EoN> = <BoN> matplotlib <EoN> . <BoN> rc Params <EoN> [ <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> s <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> UT C <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dateutil <EoN> . <BoN> tz <EoN> . <BoN> gettz <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> in transaction <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> root <EoN> . <BoN> transaction <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get filename queue <EoN> ( <BoN> self <EoN> , <BoN> epoch limit <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> epoch limiter <EoN> = <BoN> variable scope <EoN> . <BoN> variable <EoN> ( <NEWLINE> <BoN> initial value <EoN> = <BoN> constant op <EoN> . <BoN> constant <EoN> ( <NUMBER> , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) , <NEWLINE> <BoN> name <EoN> = <STRING> , <NEWLINE> <BoN> trainable <EoN> = <BoN> False <EoN> , <NEWLINE> <BoN> collections <EoN> = [ <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> LOCAL VARIABLES <EoN> ] ) <NEWLINE> <BoN> filenames tensor <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <NEWLINE> <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> self <EoN> . <BoN> filenames <EoN> ) , [ - <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> conditional count up to <EoN> = <BoN> control flow ops <EoN> . <BoN> cond <EoN> ( <NEWLINE> <BoN> state ops <EoN> . <BoN> is variable initialized <EoN> ( <BoN> epoch limiter <EoN> ) , <NEWLINE> <BoN> lambda <EoN> : <BoN> epoch limiter <EoN> . <BoN> count up to <EoN> ( <BoN> epoch limit <EoN> ) , <NEWLINE> <BoN> lambda <EoN> : <BoN> constant op <EoN> . <BoN> constant <EoN> ( <NUMBER> , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) ) <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> conditional count up to <EoN> ] ) : <NEWLINE> <TAB> <BoN> filenames tensor <EoN> = <BoN> array ops <EoN> . <BoN> identity <EoN> ( <BoN> filenames tensor <EoN> ) <NEWLINE> <UNTAB> <BoN> filename queue <EoN> = <BoN> input lib <EoN> . <BoN> string input producer <EoN> ( <NEWLINE> <BoN> filenames tensor <EoN> , <BoN> shuffle <EoN> = <BoN> False <EoN> , <BoN> capacity <EoN> = <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> filename queue <EoN> , <BoN> epoch limiter <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set tensor <EoN> ( <BoN> self <EoN> , <BoN> tensor index <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> interpreter <EoN> . <BoN> Set Tensor <EoN> ( <BoN> tensor index <EoN> , <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> divmod <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> floor div <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) , <BoN> mod check <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sub <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> + - <BoN> other <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fragment 3 1 <EoN> ( <BoN> norm info <EoN> , <BoN> n 0 <EoN> , <BoN> tol <EoN> , <BoN> m max <EoN> = <NUMBER> , <BoN> ell <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> ell <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> best m <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> best s <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> condition 3 13 <EoN> ( <BoN> norm info <EoN> . <BoN> onenorm <EoN> ( ) , <BoN> n 0 <EoN> , <BoN> m max <EoN> , <BoN> ell <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> m <EoN> , <BoN> theta <EoN> <BoN> in <EoN> <BoN> theta <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> ceil <EoN> ( <BoN> norm info <EoN> . <BoN> onenorm <EoN> ( ) / <BoN> theta <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> best m <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> m <EoN> * <BoN> s <EoN> < <BoN> best m <EoN> * <BoN> best s <EoN> : <NEWLINE> <TAB> <BoN> best m <EoN> = <BoN> m <EoN> <NEWLINE> <BoN> best s <EoN> = <BoN> s <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> compute p max <EoN> ( <BoN> m max <EoN> ) + <NUMBER> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> m <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> p <EoN> * ( <BoN> p <EoN> - <NUMBER> ) - <NUMBER> , <BoN> m max <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> m <EoN> <BoN> in <EoN> <BoN> theta <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> compute cost div m <EoN> ( <BoN> m <EoN> , <BoN> p <EoN> , <BoN> norm info <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> best m <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> m <EoN> * <BoN> s <EoN> < <BoN> best m <EoN> * <BoN> best s <EoN> : <NEWLINE> <TAB> <BoN> best m <EoN> = <BoN> m <EoN> <NEWLINE> <BoN> best s <EoN> = <BoN> s <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> best s <EoN> = <BoN> max <EoN> ( <BoN> best s <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> best m <EoN> , <BoN> best s <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> plot marginals <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> False <EoN> <NEWLINE> <BoN> plt <EoN> . <BoN> sca <EoN> ( <BoN> self <EoN> . <BoN> ax marg x <EoN> ) <NEWLINE> <BoN> func <EoN> ( <BoN> self <EoN> . <BoN> x <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> True <EoN> <NEWLINE> <BoN> plt <EoN> . <BoN> sca <EoN> ( <BoN> self <EoN> . <BoN> ax marg y <EoN> ) <NEWLINE> <BoN> func <EoN> ( <BoN> self <EoN> . <BoN> y <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> flatten <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> flatten <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> convert colorspace <EoN> ( <BoN> arr <EoN> , <BoN> fromspace <EoN> , <BoN> tospace <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fromdict <EoN> = { <STRING> : <BoN> lambda <EoN> <BoN> im <EoN> : <BoN> im <EoN> , <STRING> : <BoN> hsv 2 rgb <EoN> , <STRING> : <BoN> rgbcie 2 rgb <EoN> , <NEWLINE> <STRING> : <BoN> xyz 2 rgb <EoN> , <STRING> : <BoN> yuv 2 rgb <EoN> , <STRING> : <BoN> yiq 2 rgb <EoN> , <NEWLINE> <STRING> : <BoN> ypbpr 2 rgb <EoN> , <STRING> : <BoN> ycbcr 2 rgb <EoN> , <STRING> : <BoN> ydbdr 2 rgb <EoN> } <NEWLINE> <BoN> todict <EoN> = { <STRING> : <BoN> lambda <EoN> <BoN> im <EoN> : <BoN> im <EoN> , <STRING> : <BoN> rgb 2 hsv <EoN> , <STRING> : <BoN> rgb 2 rgbcie <EoN> , <NEWLINE> <STRING> : <BoN> rgb 2 xyz <EoN> , <STRING> : <BoN> rgb 2 yuv <EoN> , <STRING> : <BoN> rgb 2 yiq <EoN> , <NEWLINE> <STRING> : <BoN> rgb 2 ypbpr <EoN> , <STRING> : <BoN> rgb 2 ycbcr <EoN> , <STRING> : <BoN> rgb 2 ydbdr <EoN> } <NEWLINE> <NEWLINE> <BoN> fromspace <EoN> = <BoN> fromspace <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> tospace <EoN> = <BoN> tospace <EoN> . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> fromspace <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> fromdict <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> . <BoN> format <EoN> ( <BoN> fromdict <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tospace <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> todict <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> . <BoN> format <EoN> ( <BoN> todict <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> todict <EoN> [ <BoN> tospace <EoN> ] ( <BoN> fromdict <EoN> [ <BoN> fromspace <EoN> ] ( <BoN> arr <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> exception matches <EoN> ( <BoN> self <EoN> , <BoN> exc type <EoN> , <BoN> exc value <EoN> , <BoN> trace back <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> issubclass <EoN> ( <BoN> exc type <EoN> , <BoN> self <EoN> . <BoN> exception <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> regexp <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> val <EoN> = <BoN> str <EoN> ( <BoN> exc value <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> regexp <EoN> . <BoN> search <EoN> ( <BoN> val <EoN> ) : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> pat <EoN> = <BoN> self <EoN> . <BoN> regexp <EoN> . <BoN> pattern <EoN> , <BoN> val <EoN> = <BoN> val <EoN> ) <NEWLINE> <BoN> e <EoN> = <BoN> Assertion Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <BoN> raise with traceback <EoN> ( <BoN> e <EoN> , <BoN> trace back <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> disable v 2 tensorshape <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> global <EoN> <BoN> TENSORSHAPE V 2 OVERRIDE <EoN> , <BoN> Tensor Shape <EoN> <NEWLINE> <BoN> TENSORSHAPE V 2 OVERRIDE <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> Tensor Shape <EoN> = <BoN> Tensor Shape V 1 <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> adjoint <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval adjoint <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> merge eval <EoN> ( <BoN> self <EoN> , <BoN> all model fn ops <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> predictions <EoN> = { } <NEWLINE> <BoN> metrics <EoN> = { } <NEWLINE> <BoN> losses <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> head <EoN> , <BoN> m <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> heads <EoN> , <BoN> all model fn ops <EoN> ) : <NEWLINE> <TAB> <BoN> losses <EoN> . <BoN> append <EoN> ( <BoN> m <EoN> . <BoN> loss <EoN> ) <NEWLINE> <BoN> head name <EoN> = <BoN> head <EoN> . <BoN> head name <EoN> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> m <EoN> . <BoN> predictions <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> predictions <EoN> [ ( <BoN> head name <EoN> , <BoN> k <EoN> ) ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> m <EoN> . <BoN> eval metric ops <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> metrics <EoN> [ <BoN> k <EoN> ] = <BoN> v <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> loss <EoN> = <BoN> self <EoN> . <BoN> loss merger <EoN> ( <BoN> losses <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> model fn <EoN> . <BoN> Model Fn Ops <EoN> ( <NEWLINE> <BoN> mode <EoN> = <BoN> model fn <EoN> . <BoN> Mode Keys <EoN> . <BoN> EVA L <EoN> , <NEWLINE> <BoN> predictions <EoN> = <BoN> predictions <EoN> , <NEWLINE> <BoN> loss <EoN> = <BoN> loss <EoN> , <NEWLINE> <BoN> eval metric ops <EoN> = <BoN> metrics <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> adjust location <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> bounds <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> low <EoN> , <BoN> high <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> view Lim <EoN> . <BoN> intervaly <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> low <EoN> , <BoN> high <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> view Lim <EoN> . <BoN> intervalx <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <BoN> self <EoN> . <BoN> spine type <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> smart bounds <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> viewlim low <EoN> , <BoN> viewlim high <EoN> = <BoN> sorted <EoN> ( [ <BoN> low <EoN> , <BoN> high <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> datalim low <EoN> , <BoN> datalim high <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> data Lim <EoN> . <BoN> intervaly <EoN> <NEWLINE> <BoN> ticks <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get yticks <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> datalim low <EoN> , <BoN> datalim high <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> data Lim <EoN> . <BoN> intervalx <EoN> <NEWLINE> <BoN> ticks <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get xticks <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ticks <EoN> = <BoN> np <EoN> . <BoN> sort <EoN> ( <BoN> ticks <EoN> ) <NEWLINE> <BoN> datalim low <EoN> , <BoN> datalim high <EoN> = <BoN> sorted <EoN> ( [ <BoN> datalim low <EoN> , <BoN> datalim high <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> datalim low <EoN> < <BoN> viewlim low <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> low <EoN> = <BoN> viewlim low <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> cond <EoN> = ( <BoN> ticks <EoN> <= <BoN> datalim low <EoN> ) & ( <BoN> ticks <EoN> >= <BoN> viewlim low <EoN> ) <NEWLINE> <BoN> tickvals <EoN> = <BoN> ticks <EoN> [ <BoN> cond <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tickvals <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> low <EoN> = <BoN> tickvals <EoN> [ - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> low <EoN> = <BoN> datalim low <EoN> <NEWLINE> <UNTAB> <BoN> low <EoN> = <BoN> max <EoN> ( <BoN> low <EoN> , <BoN> viewlim low <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> datalim high <EoN> > <BoN> viewlim high <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> high <EoN> = <BoN> viewlim high <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> cond <EoN> = ( <BoN> ticks <EoN> >= <BoN> datalim high <EoN> ) & ( <BoN> ticks <EoN> <= <BoN> viewlim high <EoN> ) <NEWLINE> <BoN> tickvals <EoN> = <BoN> ticks <EoN> [ <BoN> cond <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tickvals <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> high <EoN> = <BoN> tickvals <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> high <EoN> = <BoN> datalim high <EoN> <NEWLINE> <UNTAB> <BoN> high <EoN> = <BoN> min <EoN> ( <BoN> high <EoN> , <BoN> viewlim high <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> low <EoN> , <BoN> high <EoN> = <BoN> self <EoN> . <BoN> bounds <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> patch type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> direction <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get theta direction <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> direction <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> offset <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get theta offset <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> offset <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> low <EoN> = <BoN> low <EoN> * <BoN> direction <EoN> + <BoN> offset <EoN> <NEWLINE> <BoN> high <EoN> = <BoN> high <EoN> * <BoN> direction <EoN> + <BoN> offset <EoN> <NEWLINE> <BoN> if <EoN> <BoN> low <EoN> > <BoN> high <EoN> : <NEWLINE> <TAB> <BoN> low <EoN> , <BoN> high <EoN> = <BoN> high <EoN> , <BoN> low <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> path <EoN> = <BoN> mpath <EoN> . <BoN> Path <EoN> . <BoN> arc <EoN> ( <BoN> np <EoN> . <BoN> rad 2 deg <EoN> ( <BoN> low <EoN> ) , <BoN> np <EoN> . <BoN> rad 2 deg <EoN> ( <BoN> high <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> rmin <EoN> , <BoN> rmax <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> view Lim <EoN> . <BoN> intervaly <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> rorigin <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get rorigin <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> rorigin <EoN> = <BoN> rmin <EoN> <NEWLINE> <UNTAB> <BoN> scaled diameter <EoN> = ( <BoN> rmin <EoN> - <BoN> rorigin <EoN> ) / ( <BoN> rmax <EoN> - <BoN> rorigin <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> height <EoN> = <BoN> scaled diameter <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> width <EoN> = <BoN> scaled diameter <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <BoN> self <EoN> . <BoN> spine type <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> v 1 <EoN> = <BoN> self <EoN> . <BoN> path <EoN> . <BoN> vertices <EoN> <NEWLINE> <BoN> assert <EoN> <BoN> v 1 <EoN> . <BoN> shape <EoN> == ( <NUMBER> , <NUMBER> ) , <STRING> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> v 1 <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> low <EoN> <NEWLINE> <BoN> v 1 <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> high <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> spine type <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> v 1 <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> low <EoN> <NEWLINE> <BoN> v 1 <EoN> [ <NUMBER> , <NUMBER> ] = <BoN> high <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <BoN> self <EoN> . <BoN> spine type <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform select for nested joins <EoN> ( <BoN> self <EoN> , <BoN> select <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cloned <EoN> = { } <NEWLINE> <BoN> column translate <EoN> = [ { } ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> visit <EoN> ( <BoN> element <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> element <EoN> <BoN> in <EoN> <BoN> column translate <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> column translate <EoN> [ - <NUMBER> ] [ <BoN> element <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> element <EoN> <BoN> in <EoN> <BoN> cloned <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cloned <EoN> [ <BoN> element <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> newelem <EoN> = <BoN> cloned <EoN> [ <BoN> element <EoN> ] = <BoN> element <EoN> . <BoN> clone <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> newelem <EoN> . <BoN> is selectable <EoN> <BoN> and <EoN> <BoN> newelem <EoN> . <BoN> is join <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> newelem <EoN> . <BoN> right <EoN> , <BoN> selectable <EoN> . <BoN> From Grouping <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> newelem <EoN> . <BoN> reset exported <EoN> ( ) <NEWLINE> <BoN> newelem <EoN> . <BoN> left <EoN> = <BoN> visit <EoN> ( <BoN> newelem <EoN> . <BoN> left <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <BoN> right <EoN> = <BoN> visit <EoN> ( <BoN> newelem <EoN> . <BoN> right <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <BoN> selectable <EoN> = <BoN> selectable <EoN> . <BoN> Select <EoN> ( <NEWLINE> [ <BoN> right <EoN> . <BoN> element <EoN> ] , <NEWLINE> <BoN> use labels <EoN> = <BoN> True <EoN> ) . <BoN> alias <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> selectable <EoN> . <BoN> c <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> . <BoN> key label <EoN> = <BoN> c <EoN> . <BoN> key <EoN> <NEWLINE> <BoN> c <EoN> . <BoN> label <EoN> = <BoN> c <EoN> . <BoN> name <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> translate dict <EoN> = <BoN> dict <EoN> ( <NEWLINE> <BoN> zip <EoN> ( <BoN> newelem <EoN> . <BoN> right <EoN> . <BoN> element <EoN> . <BoN> c <EoN> , <BoN> selectable <EoN> . <BoN> c <EoN> ) <NEWLINE> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> translate dict <EoN> [ <BoN> right <EoN> . <BoN> element <EoN> . <BoN> left <EoN> ] = <BoN> selectable <EoN> <NEWLINE> <BoN> translate dict <EoN> [ <BoN> right <EoN> . <BoN> element <EoN> . <BoN> right <EoN> ] = <BoN> selectable <EoN> <NEWLINE> <BoN> translate dict <EoN> [ <BoN> newelem <EoN> . <BoN> right <EoN> . <BoN> element <EoN> . <BoN> left <EoN> ] = <BoN> selectable <EoN> <NEWLINE> <BoN> translate dict <EoN> [ <BoN> newelem <EoN> . <BoN> right <EoN> . <BoN> element <EoN> . <BoN> right <EoN> ] = <BoN> selectable <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> list <EoN> ( <BoN> column translate <EoN> [ - <NUMBER> ] . <BoN> items <EoN> ( ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> translate dict <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> column translate <EoN> [ - <NUMBER> ] [ <BoN> k <EoN> ] = <BoN> translate dict <EoN> [ <BoN> v <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> column translate <EoN> [ - <NUMBER> ] . <BoN> update <EoN> ( <BoN> translate dict <EoN> ) <NEWLINE> <NEWLINE> <BoN> newelem <EoN> . <BoN> right <EoN> = <BoN> selectable <EoN> <NEWLINE> <NEWLINE> <BoN> newelem <EoN> . <BoN> onclause <EoN> = <BoN> visit <EoN> ( <BoN> newelem <EoN> . <BoN> onclause <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> newelem <EoN> . <BoN> is from container <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> kw <EoN> [ <STRING> ] = <STRING> <NEWLINE> <BoN> newelem <EoN> . <BoN> copy internals <EoN> ( <BoN> clone <EoN> = <BoN> visit <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> newelem <EoN> . <BoN> is selectable <EoN> <BoN> and <EoN> <BoN> newelem <EoN> . <BoN> is select <EoN> : <NEWLINE> <TAB> <BoN> barrier select <EoN> = <BoN> kw <EoN> . <BoN> get <EoN> ( <STRING> , <BoN> None <EoN> ) == <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> barrier select <EoN> : <NEWLINE> <TAB> <BoN> column translate <EoN> . <BoN> append <EoN> ( { } ) <NEWLINE> <UNTAB> <BoN> kw <EoN> [ <STRING> ] = <STRING> <NEWLINE> <BoN> newelem <EoN> . <BoN> copy internals <EoN> ( <BoN> clone <EoN> = <BoN> visit <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> barrier select <EoN> : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> column translate <EoN> [ - <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> newelem <EoN> . <BoN> copy internals <EoN> ( <BoN> clone <EoN> = <BoN> visit <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> newelem <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> visit <EoN> ( <BoN> select <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set command options <EoN> ( <BoN> self <EoN> , <BoN> command obj <EoN> , <BoN> option dict <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> command name <EoN> = <BoN> command obj <EoN> . <BoN> get command name <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> option dict <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> option dict <EoN> = <BoN> self <EoN> . <BoN> get option dict <EoN> ( <BoN> command name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> DEBU G <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> announce <EoN> ( <STRING> % <BoN> command name <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> ( <BoN> option <EoN> , ( <BoN> source <EoN> , <BoN> value <EoN> ) ) <BoN> in <EoN> <BoN> option dict <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> DEBU G <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> announce <EoN> ( <STRING> % ( <BoN> option <EoN> , <BoN> value <EoN> , <NEWLINE> <BoN> source <EoN> ) ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> bool opts <EoN> = [ <BoN> translate longopt <EoN> ( <BoN> o <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> o <EoN> <BoN> in <EoN> <BoN> command obj <EoN> . <BoN> boolean options <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> bool opts <EoN> = [ ] <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> neg opt <EoN> = <BoN> command obj <EoN> . <BoN> negative opt <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> neg opt <EoN> = { } <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> is string <EoN> = <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> str <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> option <EoN> <BoN> in <EoN> <BoN> neg opt <EoN> <BoN> and <EoN> <BoN> is string <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> command obj <EoN> , <BoN> neg opt <EoN> [ <BoN> option <EoN> ] , <BoN> not <EoN> <BoN> strtobool <EoN> ( <BoN> value <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> option <EoN> <BoN> in <EoN> <BoN> bool opts <EoN> <BoN> and <EoN> <BoN> is string <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> command obj <EoN> , <BoN> option <EoN> , <BoN> strtobool <EoN> ( <BoN> value <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> command obj <EoN> , <BoN> option <EoN> ) : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> command obj <EoN> , <BoN> option <EoN> , <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Distutils Option Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> % ( <BoN> source <EoN> , <BoN> command name <EoN> , <BoN> option <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> <BoN> as <EoN> <BoN> msg <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Distutils Option Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> src <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> random <EoN> . <BoN> random <EoN> ( ) < <BoN> self <EoN> . <BoN> p <EoN> : <NEWLINE> <TAB> <BoN> src <EoN> = <BoN> nd <EoN> . <BoN> dot <EoN> ( <BoN> src <EoN> , <BoN> self <EoN> . <BoN> mat <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> src <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> roots chebyt <EoN> ( <BoN> n <EoN> , <BoN> mu <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> m <EoN> = <BoN> int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> <BoN> or <EoN> <BoN> n <EoN> != <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> ufuncs <EoN> . <BoN> sinpi <EoN> ( <BoN> np <EoN> . <BoN> arange <EoN> ( - <BoN> m <EoN> + <NUMBER> , <BoN> m <EoN> , <NUMBER> ) / ( <NUMBER> * <BoN> m <EoN> ) ) <NEWLINE> <BoN> w <EoN> = <BoN> np <EoN> . <BoN> full like <EoN> ( <BoN> x <EoN> , <BoN> pi <EoN> / <BoN> m <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> mu <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> , <BoN> w <EoN> , <BoN> pi <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> , <BoN> w <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf factor sqf <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> , <BoN> method <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> lc <EoN> , <BoN> f <EoN> = <BoN> gf monic <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> gf degree <EoN> ( <BoN> f <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lc <EoN> , [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> method <EoN> = <BoN> method <EoN> <BoN> or <EoN> <BoN> query <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> factors <EoN> = <BoN> factor methods <EoN> [ <BoN> method <EoN> ] ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> factors <EoN> = <BoN> gf zassenhaus <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> lc <EoN> , <BoN> factors <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> kl divergence <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> self <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> kl divergence <EoN> ( <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> generative <EoN> <NEWLINE> @ <BoN> util <EoN> . <BoN> deprecated <EoN> ( <STRING> , <NEWLINE> <BoN> message <EoN> = <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> autocommit <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> execution options <EoN> = <BoN> self <EoN> . <BoN> execution options <EoN> . <BoN> union <EoN> ( { <STRING> : <BoN> True <EoN> } ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> solve linear <EoN> ( <BoN> lhs <EoN> , <BoN> rhs <EoN> = <NUMBER> , <BoN> symbols <EoN> = [ ] , <BoN> exclude <EoN> = [ ] ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> lhs <EoN> , <BoN> Equality <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> rhs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> filldedent <EoN> ( <STRING> % <BoN> rhs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> rhs <EoN> = <BoN> lhs <EoN> . <BoN> rhs <EoN> <NEWLINE> <BoN> lhs <EoN> = <BoN> lhs <EoN> . <BoN> lhs <EoN> <NEWLINE> <UNTAB> <BoN> dens <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> eq <EoN> = <BoN> lhs <EoN> - <BoN> rhs <EoN> <NEWLINE> <BoN> n <EoN> , <BoN> d <EoN> = <BoN> eq <EoN> . <BoN> as numer denom <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> , <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> free <EoN> = <BoN> n <EoN> . <BoN> free symbols <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> symbols <EoN> = <BoN> free <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> bad <EoN> = [ <BoN> s <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> symbols <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> s <EoN> . <BoN> is Symbol <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> bad <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> bad <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> bad <EoN> = <BoN> bad <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> symbols <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> eg <EoN> = <STRING> % ( <BoN> eq <EoN> , <BoN> symbols <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> eg <EoN> = <STRING> % ( <BoN> eq <EoN> , <BoN> list <EoN> ( <BoN> symbols <EoN> ) ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> filldedent <EoN> ( <STRING> % ( <BoN> bad <EoN> , <BoN> eg <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> symbols <EoN> = <BoN> free <EoN> . <BoN> intersection <EoN> ( <BoN> symbols <EoN> ) <NEWLINE> <UNTAB> <BoN> symbols <EoN> = <BoN> symbols <EoN> . <BoN> difference <EoN> ( <BoN> exclude <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> , <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <UNTAB> <BoN> dfree <EoN> = <BoN> d <EoN> . <BoN> free symbols <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> derivs <EoN> = <BoN> defaultdict <EoN> ( <BoN> list <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> der <EoN> <BoN> in <EoN> <BoN> n <EoN> . <BoN> atoms <EoN> ( <BoN> Derivative <EoN> ) : <NEWLINE> <TAB> <BoN> csym <EoN> = <BoN> der <EoN> . <BoN> free symbols <EoN> & <BoN> symbols <EoN> <NEWLINE> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> csym <EoN> : <NEWLINE> <TAB> <BoN> derivs <EoN> [ <BoN> c <EoN> ] . <BoN> append <EoN> ( <BoN> der <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> all zero <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> for <EoN> <BoN> xi <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> symbols <EoN> , <BoN> key <EoN> = <BoN> default sort key <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> derivs <EoN> [ <BoN> xi <EoN> ] , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> derivs <EoN> [ <BoN> xi <EoN> ] = { <BoN> der <EoN> : <BoN> der <EoN> . <BoN> doit <EoN> ( ) <BoN> for <EoN> <BoN> der <EoN> <BoN> in <EoN> <BoN> derivs <EoN> [ <BoN> xi <EoN> ] } <NEWLINE> <UNTAB> <BoN> newn <EoN> = <BoN> n <EoN> . <BoN> subs <EoN> ( <BoN> derivs <EoN> [ <BoN> xi <EoN> ] ) <NEWLINE> <BoN> dnewn dxi <EoN> = <BoN> newn <EoN> . <BoN> diff <EoN> ( <BoN> xi <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> free <EoN> = <BoN> dnewn dxi <EoN> . <BoN> free symbols <EoN> <NEWLINE> <BoN> if <EoN> <BoN> dnewn dxi <EoN> <BoN> and <EoN> ( <BoN> not <EoN> <BoN> free <EoN> <BoN> or <EoN> <BoN> any <EoN> ( <BoN> dnewn dxi <EoN> . <BoN> diff <EoN> ( <BoN> s <EoN> ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> free <EoN> ) ) : <NEWLINE> <TAB> <BoN> all zero <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> dnewn dxi <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Na N <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> xi <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> dnewn dxi <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> vi <EoN> = - <NUMBER> / <BoN> dnewn dxi <EoN> * ( <BoN> newn <EoN> . <BoN> subs <EoN> ( <BoN> xi <EoN> , <NUMBER> ) ) <NEWLINE> <BoN> if <EoN> <BoN> dens <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dens <EoN> = <BoN> simple dens <EoN> ( <BoN> eq <EoN> , <BoN> symbols <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> any <EoN> ( <BoN> checksol <EoN> ( <BoN> di <EoN> , { <BoN> xi <EoN> : <BoN> vi <EoN> } , <BoN> minimal <EoN> = <BoN> True <EoN> ) <BoN> is <EoN> <BoN> True <EoN> <NEWLINE> <BoN> for <EoN> <BoN> di <EoN> <BoN> in <EoN> <BoN> dens <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> irep <EoN> = [ ( <BoN> i <EoN> , <BoN> i <EoN> . <BoN> doit <EoN> ( ) ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> vi <EoN> . <BoN> atoms <EoN> ( <BoN> Integral <EoN> ) <BoN> if <EoN> <NEWLINE> <BoN> i <EoN> . <BoN> function <EoN> . <BoN> is number <EoN> ] <NEWLINE> <NEWLINE> <BoN> vi <EoN> = <BoN> expand mul <EoN> ( <BoN> vi <EoN> . <BoN> subs <EoN> ( <BoN> irep <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> xi <EoN> , <BoN> vi <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> all zero <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> , <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> . <BoN> is Symbol <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> , <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> n <EoN> , <BoN> d <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> step <EoN> ( <BoN> self <EoN> , <BoN> X 0 <EoN> = <BoN> None <EoN> , <BoN> T <EoN> = <BoN> None <EoN> , <BoN> N <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> step <EoN> ( <BoN> self <EoN> , <BoN> X 0 <EoN> = <BoN> X 0 <EoN> , <BoN> T <EoN> = <BoN> T <EoN> , <BoN> N <EoN> = <BoN> N <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> apply <EoN> ( <BoN> self <EoN> , <BoN> fn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> cld <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> children <EoN> . <BoN> values <EoN> ( ) : <NEWLINE> <TAB> <BoN> cld <EoN> . <BoN> apply <EoN> ( <BoN> fn <EoN> ) <NEWLINE> <UNTAB> <BoN> fn <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getattribute <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> value <EoN> = <BoN> super <EoN> ( <BoN> Numpy State <EoN> , <BoN> self <EoN> ) . <BoN> getattribute <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> value <EoN> , <BoN> NumpyWrapper <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> value <EoN> . <BoN> array <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> starmap <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> , <BoN> iterable <EoN> , <BoN> chunksize <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> map async <EoN> ( <BoN> func <EoN> , <BoN> iterable <EoN> , <BoN> starmapstar <EoN> , <BoN> chunksize <EoN> ) . <BoN> get <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> ensure constraint <EoN> ( <BoN> self <EoN> , <BoN> trial <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> index <EoN> <BoN> in <EoN> <BoN> np <EoN> . <BoN> where <EoN> ( ( <BoN> trial <EoN> < <NUMBER> ) | ( <BoN> trial <EoN> > <NUMBER> ) ) [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> trial <EoN> [ <BoN> index <EoN> ] = <BoN> self <EoN> . <BoN> random number generator <EoN> . <BoN> rand <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf irred p ben or <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n <EoN> = <BoN> gf degree <EoN> ( <BoN> f <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> <EoN> , <BoN> f <EoN> = <BoN> gf monic <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> H <EoN> = <BoN> h <EoN> = <BoN> gf pow mod <EoN> ( [ <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> ] , <BoN> p <EoN> , <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> // <NUMBER> ) : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> gf sub <EoN> ( <BoN> h <EoN> , [ <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> ] , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> gf gcd <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) == [ <BoN> K <EoN> . <BoN> one <EoN> ] : <NEWLINE> <TAB> <BoN> h <EoN> = <BoN> gf compose mod <EoN> ( <BoN> h <EoN> , <BoN> H <EoN> , <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> b <EoN> = <BoN> gf frobenius monomial base <EoN> ( <BoN> f <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> H <EoN> = <BoN> h <EoN> = <BoN> gf frobenius map <EoN> ( [ <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> ] , <BoN> f <EoN> , <BoN> b <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> // <NUMBER> ) : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> gf sub <EoN> ( <BoN> h <EoN> , [ <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> ] , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> gf gcd <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) == [ <BoN> K <EoN> . <BoN> one <EoN> ] : <NEWLINE> <TAB> <BoN> h <EoN> = <BoN> gf frobenius map <EoN> ( <BoN> h <EoN> , <BoN> f <EoN> , <BoN> b <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> draw spectral <EoN> ( <BoN> G <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> draw <EoN> ( <BoN> G <EoN> , <BoN> spectral layout <EoN> ( <BoN> G <EoN> ) , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> degree <EoN> ( <BoN> f <EoN> , <BoN> j <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> j <EoN> , <BoN> int <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dmp degree in <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> j <EoN> , <BoN> f <EoN> . <BoN> lev <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> j <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> data <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert nD <EoN> ( <BoN> data <EoN> , <NUMBER> , <STRING> ) <NEWLINE> <BoN> F <EoN> , <BoN> G <EoN> = <BoN> self <EoN> . <BoN> prepare <EoN> ( <BoN> data <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> dual <EoN> . <BoN> ifftn <EoN> ( <BoN> F <EoN> * <BoN> G <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> centre <EoN> ( <BoN> out <EoN> , <BoN> data <EoN> . <BoN> shape <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get window extent <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> w <EoN> , <BoN> h <EoN> , <BoN> xd <EoN> , <BoN> yd <EoN> = <BoN> self <EoN> . <BoN> get extent <EoN> ( <BoN> renderer <EoN> ) <NEWLINE> <BoN> ox <EoN> , <BoN> oy <EoN> = <BoN> self <EoN> . <BoN> get offset <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> mtransforms <EoN> . <BoN> Bbox <EoN> . <BoN> from bounds <EoN> ( <BoN> ox <EoN> - <BoN> xd <EoN> , <BoN> oy <EoN> - <BoN> yd <EoN> , <BoN> w <EoN> , <BoN> h <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from params <EoN> ( <BoN> cls <EoN> , <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> result <EoN> = <BoN> cls <EoN> ( ) <NEWLINE> <BoN> result <EoN> . <BoN> params <EoN> = <BoN> params <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> central crop <EoN> ( <BoN> image <EoN> , <BoN> central fraction <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> None <EoN> , <STRING> , [ <BoN> image <EoN> ] ) : <NEWLINE> <TAB> <BoN> image <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> image <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> central fraction <EoN> <= <NUMBER> <BoN> or <EoN> <BoN> central fraction <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> central fraction <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> image <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> AssertAtLeast 3 DImage <EoN> ( <BoN> image <EoN> ) <NEWLINE> <BoN> rank <EoN> = <BoN> image <EoN> . <BoN> get shape <EoN> ( ) . <BoN> ndims <EoN> <NEWLINE> <BoN> if <EoN> <BoN> rank <EoN> != <NUMBER> <BoN> and <EoN> <BoN> rank <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> rank <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> get dim <EoN> ( <BoN> tensor <EoN> , <BoN> idx <EoN> ) : <NEWLINE> <TAB> <BoN> static shape <EoN> = <BoN> tensor <EoN> . <BoN> get shape <EoN> ( ) . <BoN> dims <EoN> [ <BoN> idx <EoN> ] . <BoN> value <EoN> <NEWLINE> <BoN> if <EoN> <BoN> static shape <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> static shape <EoN> , <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> tensor <EoN> ) [ <BoN> idx <EoN> ] , <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rank <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> img h <EoN> , <BoN> dynamic h <EoN> = <BoN> get dim <EoN> ( <BoN> image <EoN> , <NUMBER> ) <NEWLINE> <BoN> img w <EoN> , <BoN> dynamic w <EoN> = <BoN> get dim <EoN> ( <BoN> image <EoN> , <NUMBER> ) <NEWLINE> <BoN> img d <EoN> = <BoN> image <EoN> . <BoN> get shape <EoN> ( ) [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> img bs <EoN> = <BoN> image <EoN> . <BoN> get shape <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> img h <EoN> , <BoN> dynamic h <EoN> = <BoN> get dim <EoN> ( <BoN> image <EoN> , <NUMBER> ) <NEWLINE> <BoN> img w <EoN> , <BoN> dynamic w <EoN> = <BoN> get dim <EoN> ( <BoN> image <EoN> , <NUMBER> ) <NEWLINE> <BoN> img d <EoN> = <BoN> image <EoN> . <BoN> get shape <EoN> ( ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dynamic h <EoN> : <NEWLINE> <TAB> <BoN> img hd <EoN> = <BoN> math ops <EoN> . <BoN> to double <EoN> ( <BoN> img h <EoN> ) <NEWLINE> <BoN> bbox h start <EoN> = <BoN> math ops <EoN> . <BoN> to int 32 <EoN> ( ( <BoN> img hd <EoN> - <BoN> img hd <EoN> * <BoN> central fraction <EoN> ) / <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> img hd <EoN> = <BoN> float <EoN> ( <BoN> img h <EoN> ) <NEWLINE> <BoN> bbox h start <EoN> = <BoN> int <EoN> ( ( <BoN> img hd <EoN> - <BoN> img hd <EoN> * <BoN> central fraction <EoN> ) / <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dynamic w <EoN> : <NEWLINE> <TAB> <BoN> img wd <EoN> = <BoN> math ops <EoN> . <BoN> to double <EoN> ( <BoN> img w <EoN> ) <NEWLINE> <BoN> bbox w start <EoN> = <BoN> math ops <EoN> . <BoN> to int 32 <EoN> ( ( <BoN> img wd <EoN> - <BoN> img wd <EoN> * <BoN> central fraction <EoN> ) / <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> img wd <EoN> = <BoN> float <EoN> ( <BoN> img w <EoN> ) <NEWLINE> <BoN> bbox w start <EoN> = <BoN> int <EoN> ( ( <BoN> img wd <EoN> - <BoN> img wd <EoN> * <BoN> central fraction <EoN> ) / <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> bbox h size <EoN> = <BoN> img h <EoN> - <BoN> bbox h start <EoN> * <NUMBER> <NEWLINE> <BoN> bbox w size <EoN> = <BoN> img w <EoN> - <BoN> bbox w start <EoN> * <NUMBER> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> rank <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> bbox begin <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <BoN> bbox h start <EoN> , <BoN> bbox w start <EoN> , <NUMBER> ] ) <NEWLINE> <BoN> bbox size <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <BoN> bbox h size <EoN> , <BoN> bbox w size <EoN> , - <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> bbox begin <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <NUMBER> , <BoN> bbox h start <EoN> , <BoN> bbox w start <EoN> , <NUMBER> ] ) <NEWLINE> <BoN> bbox size <EoN> = <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ - <NUMBER> , <BoN> bbox h size <EoN> , <BoN> bbox w size <EoN> , - <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> image <EoN> = <BoN> array ops <EoN> . <BoN> slice <EoN> ( <BoN> image <EoN> , <BoN> bbox begin <EoN> , <BoN> bbox size <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> rank <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> image <EoN> . <BoN> set shape <EoN> ( [ <NEWLINE> <BoN> None <EoN> <BoN> if <EoN> <BoN> dynamic h <EoN> <BoN> else <EoN> <BoN> bbox h size <EoN> , <NEWLINE> <BoN> None <EoN> <BoN> if <EoN> <BoN> dynamic w <EoN> <BoN> else <EoN> <BoN> bbox w size <EoN> , <NEWLINE> <BoN> img d <EoN> <NEWLINE> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> image <EoN> . <BoN> set shape <EoN> ( [ <NEWLINE> <BoN> img bs <EoN> , <NEWLINE> <BoN> None <EoN> <BoN> if <EoN> <BoN> dynamic h <EoN> <BoN> else <EoN> <BoN> bbox h size <EoN> , <NEWLINE> <BoN> None <EoN> <BoN> if <EoN> <BoN> dynamic w <EoN> <BoN> else <EoN> <BoN> bbox w size <EoN> , <NEWLINE> <BoN> img d <EoN> <NEWLINE> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> image <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sparse mask <EoN> ( <BoN> a <EoN> , <BoN> mask indices <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> a <EoN> , <BoN> mask indices <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> indices <EoN> = <BoN> a <EoN> . <BoN> indices <EoN> <NEWLINE> <BoN> out indices <EoN> , <BoN> to gather <EoN> = <BoN> setdiff 1 d <EoN> ( <BoN> indices <EoN> , <BoN> mask indices <EoN> ) <NEWLINE> <BoN> out values <EoN> = <BoN> gather <EoN> ( <BoN> a <EoN> . <BoN> values <EoN> , <BoN> to gather <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ops <EoN> . <BoN> Indexed Slices <EoN> ( <BoN> out values <EoN> , <BoN> out indices <EoN> , <BoN> a <EoN> . <BoN> dense shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bidiag matmul <EoN> ( <BoN> matrix <EoN> , <BoN> alpha <EoN> , <BoN> beta <EoN> , <BoN> adjoint b <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <BoN> alpha <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> alpha <EoN> , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> adjoint b <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> beta <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> beta <EoN> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> matrix <EoN> [ : , : - <NUMBER> ] * <BoN> alpha <EoN> + <BoN> matrix <EoN> [ : , <NUMBER> : ] * <BoN> beta <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> beta <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> beta <EoN> [ : - <NUMBER> ] , <NUMBER> ) <NEWLINE> <BoN> shape <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> matrix <EoN> ) <NEWLINE> <BoN> zero column <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <NEWLINE> <BoN> array ops <EoN> . <BoN> zeros <EoN> ( <NEWLINE> <BoN> shape <EoN> [ : <NUMBER> ] , <BoN> dtype <EoN> = <BoN> matrix <EoN> . <BoN> dtype <EoN> ) , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> matrix <EoN> * <BoN> alpha <EoN> + <BoN> array ops <EoN> . <BoN> concat <EoN> ( <NEWLINE> [ <BoN> zero column <EoN> , <BoN> matrix <EoN> [ : , : - <NUMBER> ] * <BoN> beta <EoN> ] , <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> count by layer type <EoN> ( <BoN> self <EoN> , <BoN> type name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> num <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> layer <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> layers <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> layer <EoN> , <BoN> link <EoN> . <BoN> Link <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> layer <EoN> . <BoN> class <EoN> . <BoN> name <EoN> == <BoN> type name <EoN> : <NEWLINE> <TAB> <BoN> num <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> layer <EoN> . <BoN> name <EoN> == <BoN> type name <EoN> : <NEWLINE> <TAB> <BoN> num <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> num <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set params <EoN> ( <BoN> self <EoN> , <BoN> base <EoN> = <BoN> None <EoN> , <BoN> offset <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> base <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> base <EoN> = <BoN> base <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> offset <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> offset <EoN> = <BoN> offset <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nanprod <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <BoN> Null <EoN> , <BoN> keepdims <EoN> = <BoN> Null <EoN> , <BoN> exclude <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> create xml dom element <EoN> ( <BoN> self <EoN> , <BoN> doc <EoN> , <BoN> module name <EoN> , <BoN> is key <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> element <EoN> = <BoN> doc <EoN> . <BoN> create Element <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> is key <EoN> : <NEWLINE> <TAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <BoN> doc <EoN> , <STRING> , <STRING> ) ) <NEWLINE> <UNTAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> module name <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <BoN> doc <EoN> , <STRING> , <BoN> self <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> short name <EoN> : <NEWLINE> <TAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> self <EoN> . <BoN> short name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> help <EoN> : <NEWLINE> <TAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> self <EoN> . <BoN> help <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> serializer <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> . <BoN> default <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> default <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> default serialized <EoN> = <BoN> self <EoN> . <BoN> serializer <EoN> . <BoN> serialize <EoN> ( <BoN> self <EoN> . <BoN> default <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> default serialized <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> default serialized <EoN> = <BoN> self <EoN> . <BoN> default <EoN> <NEWLINE> <UNTAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> default serialized <EoN> ) ) <NEWLINE> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> self <EoN> . <BoN> value <EoN> ) ) <NEWLINE> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> helpers <EoN> . <BoN> create xml dom element <EoN> ( <NEWLINE> <BoN> doc <EoN> , <STRING> , <BoN> self <EoN> . <BoN> flag type <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> extra xml dom elements <EoN> ( <BoN> doc <EoN> ) : <NEWLINE> <TAB> <BoN> element <EoN> . <BoN> append Child <EoN> ( <BoN> e <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> element <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate data columns <EoN> ( <BoN> self <EoN> , <BoN> data columns <EoN> , <BoN> min itemsize <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> non index axes <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> axis <EoN> , <BoN> axis labels <EoN> = <BoN> self <EoN> . <BoN> non index axes <EoN> [ <NUMBER> ] <NEWLINE> <BoN> info <EoN> = <BoN> self <EoN> . <BoN> info <EoN> . <BoN> get <EoN> ( <BoN> axis <EoN> , <BoN> dict <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> info <EoN> . <BoN> get <EoN> ( <STRING> ) == <STRING> <BoN> and <EoN> <BoN> data columns <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> axis <EoN> , <BoN> data columns <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> data columns <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> data columns <EoN> = <BoN> list <EoN> ( <BoN> axis labels <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> data columns <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data columns <EoN> = [ ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> min itemsize <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> existing data columns <EoN> = <BoN> set <EoN> ( <BoN> data columns <EoN> ) <NEWLINE> <BoN> data columns <EoN> . <BoN> extend <EoN> ( [ <NEWLINE> <BoN> k <EoN> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> min itemsize <EoN> . <BoN> keys <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> != <STRING> <BoN> and <EoN> <BoN> k <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> existing data columns <EoN> <NEWLINE> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> [ <BoN> c <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> data columns <EoN> <BoN> if <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> axis labels <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> add loss <EoN> ( <BoN> loss <EoN> , <BoN> loss collection <EoN> = <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> LOSSE S <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> loss collection <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> loss collection <EoN> , <BoN> loss <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is alive <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> initialized <EoN> , <STRING> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is stopped <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> started <EoN> . <BoN> is set <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> wait for tstate lock <EoN> ( <BoN> False <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is stopped <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predictions <EoN> ( <BoN> self <EoN> , <BoN> examples <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assertSpecified <EoN> ( <NEWLINE> [ <STRING> , <STRING> , <STRING> ] , <BoN> examples <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> assertList <EoN> ( [ <STRING> , <STRING> ] , <BoN> examples <EoN> ) <NEWLINE> <NEWLINE> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> linear predictions <EoN> ( <BoN> examples <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> with <EoN> <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> math ops <EoN> . <BoN> sigmoid <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> with <EoN> <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> math ops <EoN> . <BoN> exp <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> elemwise mul <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> class <EoN> <BoN> Byte Processor <EoN> ( <BoN> object <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> @ <BoN> deprecated <EoN> ( <BoN> None <EoN> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> max document length <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> max document length <EoN> = <BoN> max document length <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> fit transform <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> transform <EoN> ( <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> reverse <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> data <EoN> <BoN> in <EoN> <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> document <EoN> = <BoN> np <EoN> . <BoN> trim zeros <EoN> ( <BoN> data <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> int 8 <EoN> ) , <BoN> trim <EoN> = <STRING> ) . <BoN> tostring <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> document <EoN> . <BoN> decode <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Unicode Decode Error <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <STRING> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> def <EoN> <BoN> transform <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> six <EoN> . <BoN> P Y 3 <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> buffer or memoryview <EoN> = <BoN> memoryview <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> buffer or memoryview <EoN> = <BoN> buffer <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> document <EoN> <BoN> in <EoN> <BoN> x <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> document <EoN> , <BoN> six <EoN> . <BoN> text type <EoN> ) : <NEWLINE> <TAB> <BoN> document <EoN> = <BoN> document <EoN> . <BoN> encode <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> document mv <EoN> = <BoN> buffer or memoryview <EoN> ( <BoN> document <EoN> ) <NEWLINE> <BoN> buff <EoN> = <BoN> np <EoN> . <BoN> frombuffer <EoN> ( <BoN> document mv <EoN> [ : <BoN> self <EoN> . <BoN> max document length <EoN> ] , <NEWLINE> <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> uint 8 <EoN> ) <NEWLINE> <BoN> yield <EoN> <BoN> np <EoN> . <BoN> pad <EoN> ( <BoN> buff <EoN> , ( <NUMBER> , <BoN> self <EoN> . <BoN> max document length <EoN> - <BoN> len <EoN> ( <BoN> buff <EoN> ) ) , <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update position xytext <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> , <BoN> xy pixel <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> set transform <EoN> ( <BoN> self <EoN> . <BoN> get xy transform <EoN> ( <BoN> renderer <EoN> , <BoN> self <EoN> . <BoN> anncoords <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> ox 0 <EoN> , <BoN> oy 0 <EoN> = <BoN> self <EoN> . <BoN> get xy display <EoN> ( ) <NEWLINE> <BoN> ox 1 <EoN> , <BoN> oy 1 <EoN> = <BoN> xy pixel <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> arrowprops <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x 0 <EoN> , <BoN> y 0 <EoN> = <BoN> xy pixel <EoN> <NEWLINE> <BoN> l <EoN> , <BoN> b <EoN> , <BoN> w <EoN> , <BoN> h <EoN> = <BoN> Text <EoN> . <BoN> get window extent <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) . <BoN> bounds <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> l <EoN> + <BoN> w <EoN> <NEWLINE> <BoN> t <EoN> = <BoN> b <EoN> + <BoN> h <EoN> <NEWLINE> <BoN> xc <EoN> = <NUMBER> * ( <BoN> l <EoN> + <BoN> r <EoN> ) <NEWLINE> <BoN> yc <EoN> = <NUMBER> * ( <BoN> b <EoN> + <BoN> t <EoN> ) <NEWLINE> <NEWLINE> <BoN> d <EoN> = <BoN> self <EoN> . <BoN> arrowprops <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> ms <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> self <EoN> . <BoN> get size <EoN> ( ) ) <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set mutation scale <EoN> ( <BoN> ms <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> d <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> shrink <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> width <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> headwidth <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> frac <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> frac <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> headlength <EoN> = <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> stylekw <EoN> = <BoN> dict <EoN> ( <BoN> head length <EoN> = <BoN> headlength <EoN> / <BoN> ms <EoN> , <NEWLINE> <BoN> head width <EoN> = <BoN> headwidth <EoN> / <BoN> ms <EoN> , <NEWLINE> <BoN> tail width <EoN> = <BoN> width <EoN> / <BoN> ms <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set arrowstyle <EoN> ( <STRING> , ** <BoN> stylekw <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> xpos <EoN> = ( ( <BoN> l <EoN> , <NUMBER> ) , ( <BoN> xc <EoN> , <NUMBER> ) , ( <BoN> r <EoN> , <NUMBER> ) ) <NEWLINE> <BoN> ypos <EoN> = ( ( <BoN> b <EoN> , <NUMBER> ) , ( <BoN> yc <EoN> , <NUMBER> ) , ( <BoN> t <EoN> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> <EoN> , ( <BoN> x <EoN> , <BoN> relposx <EoN> ) = <BoN> min <EoN> ( ( <BoN> abs <EoN> ( <BoN> val <EoN> [ <NUMBER> ] - <BoN> x 0 <EoN> ) , <BoN> val <EoN> ) <BoN> for <EoN> <BoN> val <EoN> <BoN> in <EoN> <BoN> xpos <EoN> ) <NEWLINE> <BoN> <EoN> , ( <BoN> y <EoN> , <BoN> relposy <EoN> ) = <BoN> min <EoN> ( ( <BoN> abs <EoN> ( <BoN> val <EoN> [ <NUMBER> ] - <BoN> y 0 <EoN> ) , <BoN> val <EoN> ) <BoN> for <EoN> <BoN> val <EoN> <BoN> in <EoN> <BoN> ypos <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> arrow relpos <EoN> = ( <BoN> relposx <EoN> , <BoN> relposy <EoN> ) <NEWLINE> <NEWLINE> <BoN> r <EoN> = <BoN> np <EoN> . <BoN> hypot <EoN> ( ( <BoN> y <EoN> - <BoN> y 0 <EoN> ) , ( <BoN> x <EoN> - <BoN> x 0 <EoN> ) ) <NEWLINE> <BoN> shrink pts <EoN> = <BoN> shrink <EoN> * <BoN> r <EoN> / <BoN> renderer <EoN> . <BoN> points to pixels <EoN> ( <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> shrink A <EoN> = <BoN> shrink pts <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> shrink B <EoN> = <BoN> shrink pts <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> relpos <EoN> = <BoN> self <EoN> . <BoN> arrow relpos <EoN> <NEWLINE> <BoN> bbox <EoN> = <BoN> Text <EoN> . <BoN> get window extent <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) <NEWLINE> <BoN> ox 0 <EoN> = <BoN> bbox <EoN> . <BoN> x 0 <EoN> + <BoN> bbox <EoN> . <BoN> width <EoN> * <BoN> relpos <EoN> [ <NUMBER> ] <NEWLINE> <BoN> oy 0 <EoN> = <BoN> bbox <EoN> . <BoN> y 0 <EoN> + <BoN> bbox <EoN> . <BoN> height <EoN> * <BoN> relpos <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set positions <EoN> ( ( <BoN> ox 0 <EoN> , <BoN> oy 0 <EoN> ) , ( <BoN> ox 1 <EoN> , <BoN> oy 1 <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> d <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set patchA <EoN> ( <BoN> d <EoN> . <BoN> pop <EoN> ( <STRING> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> bbox patch <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set patchA <EoN> ( <BoN> self <EoN> . <BoN> bbox patch <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pad <EoN> = <BoN> renderer <EoN> . <BoN> points to pixels <EoN> ( <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> get text <EoN> ( ) == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set patchA <EoN> ( <BoN> None <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> bbox <EoN> = <BoN> Text <EoN> . <BoN> get window extent <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) <NEWLINE> <BoN> l <EoN> , <BoN> b <EoN> , <BoN> w <EoN> , <BoN> h <EoN> = <BoN> bbox <EoN> . <BoN> bounds <EoN> <NEWLINE> <BoN> l <EoN> -= <BoN> pad <EoN> / <NUMBER> <NEWLINE> <BoN> b <EoN> -= <BoN> pad <EoN> / <NUMBER> <NEWLINE> <BoN> w <EoN> += <BoN> pad <EoN> <NEWLINE> <BoN> h <EoN> += <BoN> pad <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> Rectangle <EoN> ( <BoN> xy <EoN> = ( <BoN> l <EoN> , <BoN> b <EoN> ) , <NEWLINE> <BoN> width <EoN> = <BoN> w <EoN> , <NEWLINE> <BoN> height <EoN> = <BoN> h <EoN> , <NEWLINE> ) <NEWLINE> <BoN> r <EoN> . <BoN> set transform <EoN> ( <BoN> Identity Transform <EoN> ( ) ) <NEWLINE> <BoN> r <EoN> . <BoN> set clip on <EoN> ( <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> arrow patch <EoN> . <BoN> set patchA <EoN> ( <BoN> r <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> winter <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> set cmap <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set default <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> default unparsed <EoN> = <BoN> value <EoN> <NEWLINE> <BoN> if <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> default <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> default <EoN> = <BoN> self <EoN> . <BoN> parse <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> default as str <EoN> = <BoN> self <EoN> . <BoN> get parsed value as string <EoN> ( <BoN> self <EoN> . <BoN> default <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> using default value <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> value <EoN> = <BoN> self <EoN> . <BoN> default <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cdf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> N <EoN> = <NUMBER> / ( <BoN> m <EoN> / <BoN> beta <EoN> / ( <BoN> m <EoN> - <NUMBER> ) * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) + <BoN> norm pdf C <EoN> * <BoN> norm cdf <EoN> ( <BoN> beta <EoN> ) ) <NEWLINE> <BoN> rhs <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> : ( <BoN> m <EoN> / <BoN> beta <EoN> ) * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) / ( <BoN> m <EoN> - <NUMBER> ) + <BoN> norm pdf C <EoN> * ( <BoN> norm cdf <EoN> ( <BoN> x <EoN> ) - <BoN> norm cdf <EoN> ( - <BoN> beta <EoN> ) ) <NEWLINE> <BoN> lhs <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> : ( <BoN> m <EoN> / <BoN> beta <EoN> ) ** <BoN> m <EoN> * <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> beta <EoN> ** <NUMBER> / <NUMBER> ) * ( <BoN> m <EoN> / <BoN> beta <EoN> - <BoN> beta <EoN> - <BoN> x <EoN> ) ** ( - <BoN> m <EoN> + <NUMBER> ) / ( <BoN> m <EoN> - <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> N <EoN> * <BoN> lazywhere <EoN> ( <BoN> np <EoN> . <BoN> atleast 1 d <EoN> ( <BoN> x <EoN> > - <BoN> beta <EoN> ) , ( <BoN> x <EoN> , <BoN> beta <EoN> , <BoN> m <EoN> ) , <BoN> f <EoN> = <BoN> rhs <EoN> , <BoN> f 2 <EoN> = <BoN> lhs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> maybe rotate dims <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> rotate right <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> needs rotation const <EoN> = <BoN> tensor util <EoN> . <BoN> constant value <EoN> ( <BoN> self <EoN> . <BoN> needs rotation <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> needs rotation const <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> needs rotation const <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> ndims <EoN> = <BoN> array ops <EoN> . <BoN> rank <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> n <EoN> = ( <BoN> ndims <EoN> - <BoN> self <EoN> . <BoN> rotate ndims <EoN> ) <BoN> if <EoN> <BoN> rotate right <EoN> <BoN> else <EoN> <BoN> self <EoN> . <BoN> rotate ndims <EoN> <NEWLINE> <BoN> return <EoN> <BoN> array ops <EoN> . <BoN> transpose <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> concat vectors <EoN> ( <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> n <EoN> , <BoN> ndims <EoN> ) , <BoN> math ops <EoN> . <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is simple path <EoN> ( <BoN> G <EoN> , <BoN> nodes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> nodes <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> nodes <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nodes <EoN> [ <NUMBER> ] <BoN> in <EoN> <BoN> G <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> len <EoN> ( <BoN> set <EoN> ( <BoN> nodes <EoN> ) ) == <BoN> len <EoN> ( <BoN> nodes <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> all <EoN> ( <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> [ <BoN> u <EoN> ] <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> pairwise <EoN> ( <BoN> nodes <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> estimate smallest singular value <EoN> ( <BoN> U <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> U <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> U <EoN> ) <NEWLINE> <BoN> m <EoN> , <BoN> n <EoN> = <BoN> U <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> != <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> w <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> wp <EoN> = ( <NUMBER> - <BoN> p <EoN> [ <BoN> k <EoN> ] ) / <BoN> U <EoN> . <BoN> T <EoN> [ <BoN> k <EoN> , <BoN> k <EoN> ] <NEWLINE> <BoN> wm <EoN> = ( - <NUMBER> - <BoN> p <EoN> [ <BoN> k <EoN> ] ) / <BoN> U <EoN> . <BoN> T <EoN> [ <BoN> k <EoN> , <BoN> k <EoN> ] <NEWLINE> <BoN> pp <EoN> = <BoN> p <EoN> [ <BoN> k <EoN> + <NUMBER> : ] + <BoN> U <EoN> . <BoN> T <EoN> [ <BoN> k <EoN> + <NUMBER> : , <BoN> k <EoN> ] * <BoN> wp <EoN> <NEWLINE> <BoN> pm <EoN> = <BoN> p <EoN> [ <BoN> k <EoN> + <NUMBER> : ] + <BoN> U <EoN> . <BoN> T <EoN> [ <BoN> k <EoN> + <NUMBER> : , <BoN> k <EoN> ] * <BoN> wm <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> wp <EoN> ) + <BoN> norm <EoN> ( <BoN> pp <EoN> , <NUMBER> ) >= <BoN> abs <EoN> ( <BoN> wm <EoN> ) + <BoN> norm <EoN> ( <BoN> pm <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> w <EoN> [ <BoN> k <EoN> ] = <BoN> wp <EoN> <NEWLINE> <BoN> p <EoN> [ <BoN> k <EoN> + <NUMBER> : ] = <BoN> pp <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> w <EoN> [ <BoN> k <EoN> ] = <BoN> wm <EoN> <NEWLINE> <BoN> p <EoN> [ <BoN> k <EoN> + <NUMBER> : ] = <BoN> pm <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> v <EoN> = <BoN> solve triangular <EoN> ( <BoN> U <EoN> , <BoN> w <EoN> ) <NEWLINE> <NEWLINE> <BoN> v norm <EoN> = <BoN> norm <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> w norm <EoN> = <BoN> norm <EoN> ( <BoN> w <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> s min <EoN> = <BoN> w norm <EoN> / <BoN> v norm <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> z min <EoN> = <BoN> v <EoN> / <BoN> v norm <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> s min <EoN> , <BoN> z min <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> register buffer <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> tensor <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> name <EoN> , <BoN> torch <EoN> . <BoN> six <EoN> . <BoN> string classes <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> torch <EoN> . <BoN> typename <EoN> ( <BoN> name <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) <BoN> and <EoN> <BoN> name <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> buffers <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> tensor <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> tensor <EoN> , <BoN> torch <EoN> . <BoN> Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> torch <EoN> . <BoN> typename <EoN> ( <BoN> tensor <EoN> ) , <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> buffers <EoN> [ <BoN> name <EoN> ] = <BoN> tensor <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> str encode <EoN> ( <BoN> arr <EoN> , <BoN> encoding <EoN> , <BoN> errors <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> encoding <EoN> <BoN> in <EoN> <BoN> cpython optimized encoders <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> encode <EoN> ( <BoN> encoding <EoN> , <BoN> errors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> encoder <EoN> = <BoN> codecs <EoN> . <BoN> getencoder <EoN> ( <BoN> encoding <EoN> ) <NEWLINE> <BoN> f <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> encoder <EoN> ( <BoN> x <EoN> , <BoN> errors <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> na map <EoN> ( <BoN> f <EoN> , <BoN> arr <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> map offdiag <EoN> ( <BoN> self <EoN> , <BoN> func <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> map lower <EoN> ( <BoN> func <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> map upper <EoN> ( <BoN> func <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> docstring <EoN> . <BoN> dedent interpd <EoN> <NEWLINE> <BoN> def <EoN> <BoN> gca <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ckey <EoN> , <BoN> cax <EoN> = <BoN> self <EoN> . <BoN> axstack <EoN> . <BoN> current key axes <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> cax <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cax <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> projection class <EoN> , <BoN> <EoN> , <BoN> key <EoN> = <BoN> process projection requirements <EoN> ( <NEWLINE> <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ckey <EoN> = <BoN> ckey <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> key <EoN> = <BoN> key <EoN> [ <NUMBER> : ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> == <BoN> ckey <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> cax <EoN> , <BoN> projection class <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cax <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> add subplot <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> consolidate <EoN> ( <BoN> self <EoN> , <BoN> inplace <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> inplace <EoN> = <BoN> validate bool kwarg <EoN> ( <BoN> inplace <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> inplace <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> consolidate inplace <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> lambda <EoN> : <BoN> self <EoN> . <BoN> data <EoN> . <BoN> consolidate <EoN> ( ) <NEWLINE> <BoN> cons data <EoN> = <BoN> self <EoN> . <BoN> protect consolidate <EoN> ( <BoN> f <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> cons data <EoN> ) . <BoN> finalize <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> set defaults <EoN> ( <BoN> options <EoN> , ** <BoN> defaults <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> options <EoN> : <NEWLINE> <TAB> <BoN> options <EoN> = <BoN> dict <EoN> ( <BoN> options <EoN> ) <NEWLINE> <BoN> options <EoN> [ <STRING> ] = <BoN> defaults <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> options <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> colors <EoN> , <BoN> name <EoN> = <STRING> , <BoN> N <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> monochrome <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> N <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> colors <EoN> = <BoN> colors <EoN> <NEWLINE> <BoN> N <EoN> = <BoN> len <EoN> ( <BoN> colors <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> colors <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> colors <EoN> = [ <BoN> colors <EoN> ] * <BoN> N <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> monochrome <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> cbook <EoN> . <BoN> iterable <EoN> ( <BoN> colors <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> colors <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> monochrome <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> colors <EoN> = <BoN> list <EoN> ( <NEWLINE> <BoN> itertools <EoN> . <BoN> islice <EoN> ( <BoN> itertools <EoN> . <BoN> cycle <EoN> ( <BoN> colors <EoN> ) , <BoN> N <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> gray <EoN> = <BoN> float <EoN> ( <BoN> colors <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> colors <EoN> = [ <BoN> gray <EoN> ] * <BoN> N <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> monochrome <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> Colormap <EoN> . <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> N <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> relu <EoN> ( <BoN> input <EoN> , <BoN> inplace <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> inplace <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> relu <EoN> ( <BoN> input <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> relu <EoN> ( <BoN> input <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dstack <EoN> ( <BoN> tup <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> nx <EoN> . <BoN> concatenate <EoN> ( [ <BoN> atleast 3 d <EoN> ( <BoN> m <EoN> ) <BoN> for <EoN> <BoN> m <EoN> <BoN> in <EoN> <BoN> tup <EoN> ] , <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> checkpoint path <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Deformable Convolution <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> offset <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> bias <EoN> = <BoN> None <EoN> , <BoN> kernel <EoN> = <BoN> Null <EoN> , <BoN> stride <EoN> = <BoN> Null <EoN> , <BoN> dilate <EoN> = <BoN> Null <EoN> , <BoN> pad <EoN> = <BoN> Null <EoN> , <BoN> num filter <EoN> = <BoN> Null <EoN> , <BoN> num group <EoN> = <BoN> Null <EoN> , <BoN> num deformable group <EoN> = <BoN> Null <EoN> , <BoN> workspace <EoN> = <BoN> Null <EoN> , <BoN> no bias <EoN> = <BoN> Null <EoN> , <BoN> layout <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get solid joinstyle <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> solidjoinstyle <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> disjoint union all <EoN> ( <BoN> graphs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> graphs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> graphs <EoN> = <BoN> iter <EoN> ( <BoN> graphs <EoN> ) <NEWLINE> <BoN> U <EoN> = <BoN> next <EoN> ( <BoN> graphs <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> H <EoN> <BoN> in <EoN> <BoN> graphs <EoN> : <NEWLINE> <TAB> <BoN> U <EoN> = <BoN> nx <EoN> . <BoN> disjoint union <EoN> ( <BoN> U <EoN> , <BoN> H <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> U <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> r 2 score <EoN> ( <BoN> pred <EoN> , <BoN> true <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> , <BoN> multioutput <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> R 2 score <EoN> ( <BoN> sample weight <EoN> = <BoN> sample weight <EoN> , <NEWLINE> <BoN> multioutput <EoN> = <BoN> multioutput <EoN> ) ( <BoN> pred <EoN> , <BoN> true <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> piecewise constant <EoN> ( <BoN> x <EoN> , <BoN> boundaries <EoN> , <BoN> values <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> decayed lr <EoN> = <BoN> learning rate decay v 2 <EoN> . <BoN> piecewise constant <EoN> ( <BoN> x <EoN> , <BoN> boundaries <EoN> , <BoN> values <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> decayed lr <EoN> = <BoN> decayed lr <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> decayed lr <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> uniform <EoN> ( <BoN> random state <EoN> , <BoN> size <EoN> = <BoN> None <EoN> , <BoN> low <EoN> = <NUMBER> , <BoN> high <EoN> = <NUMBER> , <BoN> ndim <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> low <EoN> = <BoN> tensor <EoN> . <BoN> as tensor variable <EoN> ( <BoN> low <EoN> ) <NEWLINE> <BoN> high <EoN> = <BoN> tensor <EoN> . <BoN> as tensor variable <EoN> ( <BoN> high <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> tensor <EoN> . <BoN> scal <EoN> . <BoN> upcast <EoN> ( <BoN> theano <EoN> . <BoN> config <EoN> . <BoN> float X <EoN> , <BoN> low <EoN> . <BoN> dtype <EoN> , <BoN> high <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> ndim <EoN> , <BoN> size <EoN> , <BoN> bcast <EoN> = <BoN> infer ndim bcast <EoN> ( <BoN> ndim <EoN> , <BoN> size <EoN> , <BoN> low <EoN> , <BoN> high <EoN> ) <NEWLINE> <BoN> op <EoN> = <BoN> Random Function <EoN> ( <STRING> , <NEWLINE> <BoN> tensor <EoN> . <BoN> Tensor Type <EoN> ( <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> broadcastable <EoN> = <BoN> bcast <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> ( <BoN> random state <EoN> , <BoN> size <EoN> , <BoN> low <EoN> , <BoN> high <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> add numeric methods binary <EoN> ( <BoN> cls <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cls <EoN> . <BoN> add <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> add <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> radd <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> radd <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> sub <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> sub <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rsub <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rsub <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> mul <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> mul <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rmul <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rmul <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rpow <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rpow <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> pow <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> pow <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> mod <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> mod <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> floordiv <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> floordiv <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rfloordiv <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rfloordiv <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> truediv <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> truediv <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rtruediv <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rtruediv <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> compat <EoN> . <BoN> P Y 3 <EoN> : <NEWLINE> <TAB> <BoN> cls <EoN> . <BoN> div <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> operator <EoN> . <BoN> div <EoN> , <BoN> cls <EoN> ) <NEWLINE> <BoN> cls <EoN> . <BoN> rdiv <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> ops <EoN> . <BoN> rdiv <EoN> , <BoN> cls <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> cls <EoN> . <BoN> divmod <EoN> = <BoN> make arithmetic op <EoN> ( <BoN> divmod <EoN> , <BoN> cls <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> library option <EoN> ( <BoN> self <EoN> , <BoN> lib <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sturm <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> . <BoN> lev <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> f <EoN> . <BoN> per <EoN> , <BoN> dup sturm <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <BoN> f <EoN> . <BoN> dom <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> src <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> random <EoN> . <BoN> random <EoN> ( ) < <BoN> self <EoN> . <BoN> p <EoN> : <NEWLINE> <TAB> <BoN> src <EoN> = <BoN> nd <EoN> . <BoN> flip <EoN> ( <BoN> src <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> src <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> should wrap creator <EoN> ( <BoN> self <EoN> , <BoN> creator <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> argspec <EoN> = <BoN> util <EoN> . <BoN> get callable argspec <EoN> ( <BoN> self <EoN> . <BoN> creator <EoN> , <BoN> no self <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lambda <EoN> <BoN> crec <EoN> : <BoN> creator <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> defaulted <EoN> = <BoN> argspec <EoN> [ <NUMBER> ] <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> argspec <EoN> [ <NUMBER> ] ) <BoN> or <EoN> <NUMBER> <NEWLINE> <BoN> positionals <EoN> = <BoN> len <EoN> ( <BoN> argspec <EoN> [ <NUMBER> ] ) - <BoN> defaulted <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> argspec <EoN> [ <NUMBER> ] , <BoN> argspec <EoN> [ <NUMBER> ] ) == ( [ <STRING> ] , ( <BoN> None <EoN> , ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> creator <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> positionals <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> creator <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lambda <EoN> <BoN> crec <EoN> : <BoN> creator <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> Sparse Frame Fixed <EoN> , <BoN> self <EoN> ) . <BoN> write <EoN> ( <BoN> obj <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> name <EoN> , <BoN> ss <EoN> <BoN> in <EoN> <BoN> compat <EoN> . <BoN> iteritems <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <BoN> key <EoN> = <STRING> % <BoN> name <EoN> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> group <EoN> . <BoN> v children <EoN> : <NEWLINE> <TAB> <BoN> node <EoN> = <BoN> self <EoN> . <BoN> handle <EoN> . <BoN> create group <EoN> ( <BoN> self <EoN> . <BoN> group <EoN> , <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> node <EoN> = <BoN> getattr <EoN> ( <BoN> self <EoN> . <BoN> group <EoN> , <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> s <EoN> = <BoN> Sparse Series Fixed <EoN> ( <BoN> self <EoN> . <BoN> parent <EoN> , <BoN> node <EoN> ) <NEWLINE> <BoN> s <EoN> . <BoN> write <EoN> ( <BoN> ss <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> attrs <EoN> . <BoN> default fill value <EoN> = <BoN> obj <EoN> . <BoN> default fill value <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> attrs <EoN> . <BoN> default kind <EoN> = <BoN> obj <EoN> . <BoN> default kind <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> write index <EoN> ( <STRING> , <BoN> obj <EoN> . <BoN> columns <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get indices or sections <EoN> ( <BoN> indices or sections <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ios <EoN> = <BoN> indices or sections <EoN> <NEWLINE> <BoN> is seq <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> ios <EoN> , <BoN> numpy <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ios <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> != <STRING> <BoN> and <EoN> <BoN> ios <EoN> . <BoN> size <EoN> > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ios <EoN> . <BoN> ndim <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> is seq <EoN> = <BoN> ios <EoN> . <BoN> ndim <EoN> != <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> ios <EoN> , <BoN> collections abc <EoN> . <BoN> Sequence <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> ios <EoN> = <BoN> list <EoN> ( <BoN> ios <EoN> ) <NEWLINE> <BoN> is seq <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> indices or sections <EoN> , <BoN> six <EoN> . <BoN> integer types <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> type <EoN> ( <BoN> indices or sections <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> is seq <EoN> <BoN> and <EoN> <BoN> chainer <EoN> . <BoN> is debug <EoN> ( ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> p <EoN> , <BoN> n <EoN> <BoN> in <EoN> <BoN> six <EoN> . <BoN> moves <EoN> . <BoN> zip <EoN> ( <BoN> ios <EoN> , <BoN> ios <EoN> [ <NUMBER> : ] ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p <EoN> > <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> is seq <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ios <EoN> , <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> , <BoN> ios <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> list gpus <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> re <EoN> = <STRING> <NEWLINE> <BoN> nvidia smi <EoN> = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> for <EoN> <BoN> cmd <EoN> <BoN> in <EoN> <BoN> nvidia smi <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> re <EoN> = <BoN> subprocess <EoN> . <BoN> check output <EoN> ( [ <BoN> cmd <EoN> , <STRING> ] , <BoN> universal newlines <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> OS Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( [ <BoN> i <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> re <EoN> . <BoN> split <EoN> ( <STRING> ) <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> i <EoN> ] ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> tree is initialized op <EoN> ( <BoN> tree handle <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <NEWLINE> <BoN> tree handle <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tree is initialized op eager fallback <EoN> ( <NEWLINE> <BoN> tree handle <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> tree is initialized op <EoN> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> tree is initialized op <EoN> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> repr categories info <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> category strs <EoN> = <BoN> self <EoN> . <BoN> repr categories <EoN> ( ) <NEWLINE> <BoN> dtype <EoN> = <BoN> getattr <EoN> ( <BoN> self <EoN> . <BoN> categories <EoN> , <STRING> , <NEWLINE> <BoN> str <EoN> ( <BoN> self <EoN> . <BoN> categories <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> levheader <EoN> = <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> length <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> categories <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> width <EoN> , <BoN> height <EoN> = <BoN> get terminal size <EoN> ( ) <NEWLINE> <BoN> max width <EoN> = <BoN> get option <EoN> ( <STRING> ) <BoN> or <EoN> <BoN> width <EoN> <NEWLINE> <BoN> if <EoN> <BoN> com <EoN> . <BoN> in ipython frontend <EoN> ( ) : <NEWLINE> <NEWLINE> <TAB> <BoN> max width <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> levstring <EoN> = <STRING> <NEWLINE> <BoN> start <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> cur col len <EoN> = <BoN> len <EoN> ( <BoN> levheader <EoN> ) <NEWLINE> <BoN> sep len <EoN> , <BoN> sep <EoN> = ( <NUMBER> , <STRING> ) <BoN> if <EoN> <BoN> self <EoN> . <BoN> ordered <EoN> <BoN> else <EoN> ( <NUMBER> , <STRING> ) <NEWLINE> <BoN> linesep <EoN> = <BoN> sep <EoN> . <BoN> rstrip <EoN> ( ) + <STRING> <NEWLINE> <BoN> for <EoN> <BoN> val <EoN> <BoN> in <EoN> <BoN> category strs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> max width <EoN> != <NUMBER> <BoN> and <EoN> <BoN> cur col len <EoN> + <BoN> sep len <EoN> + <BoN> len <EoN> ( <BoN> val <EoN> ) > <BoN> max width <EoN> : <NEWLINE> <TAB> <BoN> levstring <EoN> += <BoN> linesep <EoN> + ( <STRING> * ( <BoN> len <EoN> ( <BoN> levheader <EoN> ) + <NUMBER> ) ) <NEWLINE> <BoN> cur col len <EoN> = <BoN> len <EoN> ( <BoN> levheader <EoN> ) + <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> start <EoN> : <NEWLINE> <TAB> <BoN> levstring <EoN> += <BoN> sep <EoN> <NEWLINE> <BoN> cur col len <EoN> += <BoN> len <EoN> ( <BoN> val <EoN> ) <NEWLINE> <UNTAB> <BoN> levstring <EoN> += <BoN> val <EoN> <NEWLINE> <BoN> start <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> levheader <EoN> + <STRING> + <BoN> levstring <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) + <STRING> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make int array <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> array <EoN> . <BoN> array <EoN> ( <BoN> str <EoN> ( <STRING> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set weights <EoN> ( <BoN> self <EoN> , <BoN> weights <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> params <EoN> = <BoN> self <EoN> . <BoN> weights <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> params <EoN> ) != <BoN> len <EoN> ( <BoN> weights <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> + <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> len <EoN> ( <BoN> weights <EoN> ) ) + <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> len <EoN> ( <BoN> params <EoN> ) ) + <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> weights <EoN> ) [ : <NUMBER> ] + <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> params <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> weight value tuples <EoN> = [ ] <NEWLINE> <BoN> param values <EoN> = <BoN> K <EoN> . <BoN> batch get value <EoN> ( <BoN> params <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> pv <EoN> , <BoN> p <EoN> , <BoN> w <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> param values <EoN> , <BoN> params <EoN> , <BoN> weights <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> pv <EoN> . <BoN> shape <EoN> != <BoN> w <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> pv <EoN> . <BoN> shape <EoN> ) + <NEWLINE> <STRING> <NEWLINE> <STRING> + <BoN> str <EoN> ( <BoN> w <EoN> . <BoN> shape <EoN> ) ) <NEWLINE> <UNTAB> <BoN> weight value tuples <EoN> . <BoN> append <EoN> ( ( <BoN> p <EoN> , <BoN> w <EoN> ) ) <NEWLINE> <UNTAB> <BoN> K <EoN> . <BoN> batch set value <EoN> ( <BoN> weight value tuples <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> fit <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> transform <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check is fitted <EoN> ( <BoN> self <EoN> , <STRING> , <STRING> ) <NEWLINE> <BoN> X <EoN> = <BoN> check array <EoN> ( <BoN> X <EoN> , <BoN> accept sparse <EoN> = ( <STRING> , <STRING> ) , <BoN> copy <EoN> = <BoN> self <EoN> . <BoN> copy <EoN> , <NEWLINE> <BoN> estimator <EoN> = <BoN> self <EoN> , <BoN> dtype <EoN> = <BoN> FLOAT DTYPES <EoN> , <NEWLINE> <BoN> force all finite <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sparse <EoN> . <BoN> issparse <EoN> ( <BoN> X <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> with scaling <EoN> : <NEWLINE> <TAB> <BoN> inplace column scale <EoN> ( <BoN> X <EoN> , <NUMBER> / <BoN> self <EoN> . <BoN> scale <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> with centering <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> -= <BoN> self <EoN> . <BoN> center <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> with scaling <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> /= <BoN> self <EoN> . <BoN> scale <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> X <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set options <EoN> ( <BoN> self <EoN> , ** <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> , <BoN> value <EoN> <BoN> in <EoN> <BoN> options <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> options <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> options <EoN> [ <BoN> key <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <BoN> key <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> solve triangulated <EoN> ( <BoN> polys <EoN> , * <BoN> gens <EoN> , ** <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> = <BoN> groebner <EoN> ( <BoN> polys <EoN> , <BoN> gens <EoN> , <BoN> polys <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> G <EoN> = <BoN> list <EoN> ( <BoN> reversed <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> domain <EoN> = <BoN> args <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> domain <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> g <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <BoN> G <EoN> [ <BoN> i <EoN> ] = <BoN> g <EoN> . <BoN> set domain <EoN> ( <BoN> domain <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> f <EoN> , <BoN> G <EoN> = <BoN> G <EoN> [ <NUMBER> ] . <BoN> ltrim <EoN> ( - <NUMBER> ) , <BoN> G <EoN> [ <NUMBER> : ] <NEWLINE> <BoN> dom <EoN> = <BoN> f <EoN> . <BoN> get domain <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> zeros <EoN> = <BoN> f <EoN> . <BoN> ground roots <EoN> ( ) <NEWLINE> <BoN> solutions <EoN> = <BoN> set <EoN> ( [ ] ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> zero <EoN> <BoN> in <EoN> <BoN> zeros <EoN> : <NEWLINE> <TAB> <BoN> solutions <EoN> . <BoN> add <EoN> ( ( ( <BoN> zero <EoN> , ) , <BoN> dom <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> var seq <EoN> = <BoN> reversed <EoN> ( <BoN> gens <EoN> [ : - <NUMBER> ] ) <NEWLINE> <BoN> vars seq <EoN> = <BoN> postfixes <EoN> ( <BoN> gens <EoN> [ <NUMBER> : ] ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> var <EoN> , <BoN> vars <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> var seq <EoN> , <BoN> vars seq <EoN> ) : <NEWLINE> <TAB> <BoN> solutions <EoN> = <BoN> set <EoN> ( [ ] ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> values <EoN> , <BoN> dom <EoN> <BoN> in <EoN> <BoN> solutions <EoN> : <NEWLINE> <TAB> <BoN> H <EoN> , <BoN> mapping <EoN> = [ ] , <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> vars <EoN> , <BoN> values <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> g <EoN> <BoN> in <EoN> <BoN> G <EoN> : <NEWLINE> <TAB> <BoN> vars <EoN> = ( <BoN> var <EoN> , ) + <BoN> vars <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> g <EoN> . <BoN> has only gens <EoN> ( * <BoN> vars <EoN> ) <BoN> and <EoN> <BoN> g <EoN> . <BoN> degree <EoN> ( <BoN> var <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> h <EoN> = <BoN> g <EoN> . <BoN> ltrim <EoN> ( <BoN> var <EoN> ) . <BoN> eval <EoN> ( <BoN> dict <EoN> ( <BoN> mapping <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> g <EoN> . <BoN> degree <EoN> ( <BoN> var <EoN> ) == <BoN> h <EoN> . <BoN> degree <EoN> ( ) : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> append <EoN> ( <BoN> h <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> p <EoN> = <BoN> min <EoN> ( <BoN> H <EoN> , <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> h <EoN> : <BoN> h <EoN> . <BoN> degree <EoN> ( ) ) <NEWLINE> <BoN> zeros <EoN> = <BoN> p <EoN> . <BoN> ground roots <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> zero <EoN> <BoN> in <EoN> <BoN> zeros <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> zero <EoN> . <BoN> is Rational <EoN> : <NEWLINE> <TAB> <BoN> dom zero <EoN> = <BoN> dom <EoN> . <BoN> algebraic field <EoN> ( <BoN> zero <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dom zero <EoN> = <BoN> dom <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> solutions <EoN> . <BoN> add <EoN> ( ( ( <BoN> zero <EoN> , ) + <BoN> values <EoN> , <BoN> dom zero <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> solutions <EoN> = <BoN> solutions <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> solutions <EoN> = <BoN> list <EoN> ( <BoN> solutions <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , ( <BoN> solution <EoN> , <BoN> <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> solutions <EoN> ) : <NEWLINE> <TAB> <BoN> solutions <EoN> [ <BoN> i <EoN> ] = <BoN> solution <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sorted <EoN> ( <BoN> solutions <EoN> , <BoN> key <EoN> = <BoN> default sort key <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sanitize index <EoN> ( <BoN> data <EoN> , <BoN> index <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> index <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> data <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> data <EoN> ) != <BoN> len <EoN> ( <BoN> index <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> data <EoN> , <BoN> ABC Index Class <EoN> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> data <EoN> , ( <BoN> Period Index <EoN> , <BoN> Datetime Index <EoN> ) ) : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> data <EoN> . <BoN> values <EoN> <NEWLINE> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> data <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> data <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> data <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> sanitize array <EoN> ( <BoN> data <EoN> , <BoN> index <EoN> , <BoN> copy <EoN> = <BoN> copy <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> data <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> squeezenet 1 1 <EoN> ( ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> get squeezenet <EoN> ( <STRING> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> piecewise <EoN> ( <BoN> x <EoN> , <BoN> condlist <EoN> , <BoN> funclist <EoN> , * <BoN> args <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> asanyarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> n 2 <EoN> = <BoN> len <EoN> ( <BoN> funclist <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isscalar <EoN> ( <BoN> condlist <EoN> ) <BoN> or <EoN> ( <NEWLINE> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> condlist <EoN> [ <NUMBER> ] , ( <BoN> list <EoN> , <BoN> ndarray <EoN> ) ) <BoN> and <EoN> <BoN> x <EoN> . <BoN> ndim <EoN> != <NUMBER> ) : <NEWLINE> <TAB> <BoN> condlist <EoN> = [ <BoN> condlist <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> condlist <EoN> = <BoN> array <EoN> ( <BoN> condlist <EoN> , <BoN> dtype <EoN> = <BoN> bool <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> condlist <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <BoN> n 2 <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> condelse <EoN> = ~ <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> condlist <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> keepdims <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> condlist <EoN> = <BoN> np <EoN> . <BoN> concatenate <EoN> ( [ <BoN> condlist <EoN> , <BoN> condelse <EoN> ] , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> n <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> n <EoN> != <BoN> n 2 <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> n <EoN> , <BoN> n <EoN> , <BoN> n <EoN> + <NUMBER> ) <NEWLINE> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> zeros <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> , <BoN> x <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> item <EoN> = <BoN> funclist <EoN> [ <BoN> k <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> item <EoN> , <BoN> collections <EoN> . <BoN> Callable <EoN> ) : <NEWLINE> <TAB> <BoN> y <EoN> [ <BoN> condlist <EoN> [ <BoN> k <EoN> ] ] = <BoN> item <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> x <EoN> [ <BoN> condlist <EoN> [ <BoN> k <EoN> ] ] <NEWLINE> <BoN> if <EoN> <BoN> vals <EoN> . <BoN> size <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> y <EoN> [ <BoN> condlist <EoN> [ <BoN> k <EoN> ] ] = <BoN> item <EoN> ( <BoN> vals <EoN> , * <BoN> args <EoN> , ** <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> out degree centrality <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> G <EoN> ) <= <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> { <BoN> n <EoN> : <NUMBER> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> G <EoN> } <NEWLINE> <NEWLINE> <UNTAB> <BoN> s <EoN> = <NUMBER> / ( <BoN> len <EoN> ( <BoN> G <EoN> ) - <NUMBER> ) <NEWLINE> <BoN> centrality <EoN> = { <BoN> n <EoN> : <BoN> d <EoN> * <BoN> s <EoN> <BoN> for <EoN> <BoN> n <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> out degree <EoN> ( ) } <NEWLINE> <BoN> return <EoN> <BoN> centrality <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ell <EoN> ( <BoN> A <EoN> , <BoN> m <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> A <EoN> . <BoN> shape <EoN> ) != <NUMBER> <BoN> or <EoN> <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] != <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> p <EoN> = <NUMBER> * <BoN> m <EoN> + <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> choose 2 p p <EoN> = <BoN> scipy <EoN> . <BoN> special <EoN> . <BoN> comb <EoN> ( <NUMBER> * <BoN> p <EoN> , <BoN> p <EoN> , <BoN> exact <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> abs c recip <EoN> = <BoN> float <EoN> ( <BoN> choose 2 p p <EoN> * <BoN> math <EoN> . <BoN> factorial <EoN> ( <NUMBER> * <BoN> p <EoN> + <NUMBER> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> u <EoN> = <NUMBER> ** - <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> A abs onenorm <EoN> = <BoN> onenorm matrix power nnm <EoN> ( <BoN> abs <EoN> ( <BoN> A <EoN> ) , <BoN> p <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> A abs onenorm <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> alpha <EoN> = <BoN> A abs onenorm <EoN> / ( <BoN> onenorm <EoN> ( <BoN> A <EoN> ) * <BoN> abs c recip <EoN> ) <NEWLINE> <BoN> log 2 alpha div u <EoN> = <BoN> np <EoN> . <BoN> log 2 <EoN> ( <BoN> alpha <EoN> / <BoN> u <EoN> ) <NEWLINE> <BoN> value <EoN> = <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> ceil <EoN> ( <BoN> log 2 alpha div u <EoN> / ( <NUMBER> * <BoN> m <EoN> ) ) ) <NEWLINE> <BoN> return <EoN> <BoN> max <EoN> ( <BoN> value <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> copy <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> npartitions <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> map blocks <EoN> ( <BoN> M <EoN> . <BoN> copy <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Array <EoN> ( <BoN> self <EoN> . <BoN> dask <EoN> , <BoN> self <EoN> . <BoN> name <EoN> , <BoN> self <EoN> . <BoN> chunks <EoN> , <BoN> self <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dropout <EoN> ( <BoN> x <EoN> , <BoN> level <EoN> , <BoN> noise shape <EoN> = <BoN> None <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> retain prob <EoN> = <NUMBER> - <BoN> level <EoN> <NEWLINE> <BoN> if <EoN> <BoN> seed <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> seed <EoN> = <BoN> np <EoN> . <BoN> random <EoN> . <BoN> randint <EoN> ( <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> nn <EoN> . <BoN> dropout <EoN> ( <BoN> x <EoN> * <NUMBER> , <BoN> retain prob <EoN> , <BoN> noise shape <EoN> , <BoN> seed <EoN> = <BoN> seed <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> register deep copy op c code <EoN> ( <BoN> typ <EoN> , <BoN> code <EoN> , <BoN> version <EoN> = ( ) ) : <NEWLINE> <TAB> <NEWLINE> <BoN> Deep Copy Op <EoN> . <BoN> c code and version <EoN> [ <BoN> typ <EoN> ] = ( <BoN> code <EoN> , <BoN> version <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get sliced frame result type <EoN> ( <BoN> data <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> is sparse <EoN> ( <BoN> data <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> sparse <EoN> . <BoN> api <EoN> <BoN> import <EoN> <BoN> Sparse Series <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Sparse Series <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> obj <EoN> . <BoN> constructor sliced <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to dense <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> query <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> k <EoN> = <NUMBER> , <BoN> eps <EoN> = <NUMBER> , <BoN> p <EoN> = <NUMBER> , <BoN> distance upper bound <EoN> = <BoN> np <EoN> . <BoN> inf <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> x <EoN> ) [ - <NUMBER> ] != <BoN> self <EoN> . <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <BoN> self <EoN> . <BoN> m <EoN> , <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> x <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> p <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> retshape <EoN> = <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> x <EoN> ) [ : - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> retshape <EoN> != ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> k <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dd <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> , <BoN> dtype <EoN> = <BoN> object <EoN> ) <NEWLINE> <BoN> ii <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> , <BoN> dtype <EoN> = <BoN> object <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> dd <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> + ( <BoN> k <EoN> , ) , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> dd <EoN> . <BoN> fill <EoN> ( <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <BoN> ii <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> + ( <BoN> k <EoN> , ) , <BoN> dtype <EoN> = <BoN> int <EoN> ) <NEWLINE> <BoN> ii <EoN> . <BoN> fill <EoN> ( <BoN> self <EoN> . <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> dd <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> dd <EoN> . <BoN> fill <EoN> ( <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <BoN> ii <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> retshape <EoN> , <BoN> dtype <EoN> = <BoN> int <EoN> ) <NEWLINE> <BoN> ii <EoN> . <BoN> fill <EoN> ( <BoN> self <EoN> . <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> np <EoN> . <BoN> ndindex <EoN> ( <BoN> retshape <EoN> ) : <NEWLINE> <TAB> <BoN> hits <EoN> = <BoN> self <EoN> . <BoN> query <EoN> ( <BoN> x <EoN> [ <BoN> c <EoN> ] , <BoN> k <EoN> = <BoN> k <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> p <EoN> = <BoN> p <EoN> , <BoN> distance upper bound <EoN> = <BoN> distance upper bound <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dd <EoN> [ <BoN> c <EoN> ] = [ <BoN> d <EoN> <BoN> for <EoN> ( <BoN> d <EoN> , <BoN> i <EoN> ) <BoN> in <EoN> <BoN> hits <EoN> ] <NEWLINE> <BoN> ii <EoN> [ <BoN> c <EoN> ] = [ <BoN> i <EoN> <BoN> for <EoN> ( <BoN> d <EoN> , <BoN> i <EoN> ) <BoN> in <EoN> <BoN> hits <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> hits <EoN> ) ) : <NEWLINE> <TAB> <BoN> dd <EoN> [ <BoN> c <EoN> + ( <BoN> j <EoN> , ) ] , <BoN> ii <EoN> [ <BoN> c <EoN> + ( <BoN> j <EoN> , ) ] = <BoN> hits <EoN> [ <BoN> j <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> hits <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> dd <EoN> [ <BoN> c <EoN> ] , <BoN> ii <EoN> [ <BoN> c <EoN> ] = <BoN> hits <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dd <EoN> [ <BoN> c <EoN> ] = <BoN> np <EoN> . <BoN> inf <EoN> <NEWLINE> <BoN> ii <EoN> [ <BoN> c <EoN> ] = <BoN> self <EoN> . <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> dd <EoN> , <BoN> ii <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> hits <EoN> = <BoN> self <EoN> . <BoN> query <EoN> ( <BoN> x <EoN> , <BoN> k <EoN> = <BoN> k <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> p <EoN> = <BoN> p <EoN> , <BoN> distance upper bound <EoN> = <BoN> distance upper bound <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> d <EoN> <BoN> for <EoN> ( <BoN> d <EoN> , <BoN> i <EoN> ) <BoN> in <EoN> <BoN> hits <EoN> ] , [ <BoN> i <EoN> <BoN> for <EoN> ( <BoN> d <EoN> , <BoN> i <EoN> ) <BoN> in <EoN> <BoN> hits <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> hits <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> hits <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> inf <EoN> , <BoN> self <EoN> . <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> k <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> dd <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> k <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> dd <EoN> . <BoN> fill <EoN> ( <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <BoN> ii <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> k <EoN> , <BoN> dtype <EoN> = <BoN> int <EoN> ) <NEWLINE> <BoN> ii <EoN> . <BoN> fill <EoN> ( <BoN> self <EoN> . <BoN> n <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> hits <EoN> ) ) : <NEWLINE> <TAB> <BoN> dd <EoN> [ <BoN> j <EoN> ] , <BoN> ii <EoN> [ <BoN> j <EoN> ] = <BoN> hits <EoN> [ <BoN> j <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> dd <EoN> , <BoN> ii <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> argmax <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> nv <EoN> . <BoN> validate argmax <EoN> ( <BoN> args <EoN> , <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <BoN> i 8 <EoN> = <BoN> self <EoN> . <BoN> asi 8 <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> hasnans <EoN> : <NEWLINE> <TAB> <BoN> mask <EoN> = <BoN> self <EoN> . <BoN> isnan <EoN> <NEWLINE> <BoN> if <EoN> <BoN> mask <EoN> . <BoN> all <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> - <NUMBER> <NEWLINE> <UNTAB> <BoN> i 8 <EoN> = <BoN> i 8 <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> i 8 <EoN> [ <BoN> mask <EoN> ] = <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> i 8 <EoN> . <BoN> argmax <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup decompose <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> F <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dup decompose <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> , <BoN> h <EoN> = <BoN> result <EoN> <NEWLINE> <BoN> F <EoN> = [ <BoN> h <EoN> ] + <BoN> F <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> [ <BoN> f <EoN> ] + <BoN> F <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ode 1 st homogeneous coeff subs indep div dep <EoN> ( <BoN> eq <EoN> , <BoN> func <EoN> , <BoN> order <EoN> , <BoN> match <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> func <EoN> . <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> f <EoN> = <BoN> func <EoN> . <BoN> func <EoN> <NEWLINE> <BoN> u <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> u 2 <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> r <EoN> = <BoN> match <EoN> <NEWLINE> <BoN> C 1 <EoN> = <BoN> get numbered constants <EoN> ( <BoN> eq <EoN> , <BoN> num <EoN> = <NUMBER> ) <NEWLINE> <BoN> xarg <EoN> = <BoN> match <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> yarg <EoN> = <BoN> match <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> int <EoN> = <BoN> Integral <EoN> ( <NEWLINE> <BoN> simplify <EoN> ( <NEWLINE> ( - <BoN> r <EoN> [ <BoN> r <EoN> [ <STRING> ] ] / ( <BoN> r <EoN> [ <BoN> r <EoN> [ <STRING> ] ] + <BoN> u 2 <EoN> * <BoN> r <EoN> [ <BoN> r <EoN> [ <STRING> ] ] ) ) . <BoN> subs <EoN> ( { <BoN> x <EoN> : <BoN> u 2 <EoN> , <BoN> r <EoN> [ <STRING> ] : <NUMBER> } ) ) , <NEWLINE> ( <BoN> u 2 <EoN> , <BoN> None <EoN> , <BoN> x <EoN> / <BoN> f <EoN> ( <BoN> x <EoN> ) ) ) <NEWLINE> <BoN> sol <EoN> = <BoN> logcombine <EoN> ( <BoN> Eq <EoN> ( <BoN> log <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) ) , <BoN> int <EoN> + <BoN> log <EoN> ( <BoN> C 1 <EoN> ) ) , <BoN> force <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> sol <EoN> = <BoN> sol <EoN> . <BoN> subs <EoN> ( <BoN> f <EoN> ( <BoN> x <EoN> ) , <BoN> u <EoN> ) . <BoN> subs <EoN> ( ( ( <BoN> u <EoN> , <BoN> u <EoN> - <BoN> yarg <EoN> ) , ( <BoN> x <EoN> , <BoN> x <EoN> - <BoN> xarg <EoN> ) , ( <BoN> u <EoN> , <BoN> f <EoN> ( <BoN> x <EoN> ) ) ) ) <NEWLINE> <BoN> return <EoN> <BoN> sol <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> resample <EoN> ( <BoN> self <EoN> , <BoN> lutsize <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lcm <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Factors <EoN> ) : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> Factors <EoN> ( <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> f <EoN> . <BoN> is zero <EoN> <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Factors <EoN> ( <BoN> S <EoN> . <BoN> Zero <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> factors <EoN> = <BoN> dict <EoN> ( <BoN> self <EoN> . <BoN> factors <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> factor <EoN> , <BoN> exp <EoN> <BoN> in <EoN> <BoN> other <EoN> . <BoN> factors <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> factor <EoN> <BoN> in <EoN> <BoN> factors <EoN> : <NEWLINE> <TAB> <BoN> exp <EoN> = <BoN> max <EoN> ( <BoN> exp <EoN> , <BoN> factors <EoN> [ <BoN> factor <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> factors <EoN> [ <BoN> factor <EoN> ] = <BoN> exp <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Factors <EoN> ( <BoN> factors <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parse File <EoN> ( <BoN> self <EoN> , <BoN> file or filename <EoN> , <BoN> parse All <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> file contents <EoN> = <BoN> file or filename <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> open <EoN> ( <BoN> file or filename <EoN> , <STRING> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> file contents <EoN> = <BoN> f <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> parse String <EoN> ( <BoN> file contents <EoN> , <BoN> parse All <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Parse Base Exception <EoN> <BoN> as <EoN> <BoN> exc <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> Parser Element <EoN> . <BoN> verbose stacktrace <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> expand paths if needed <EoN> ( <BoN> paths <EoN> , <BoN> mode <EoN> , <BoN> num <EoN> , <BoN> fs <EoN> , <BoN> name function <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> expanded paths <EoN> = [ ] <NEWLINE> <BoN> paths <EoN> = <BoN> list <EoN> ( <BoN> paths <EoN> ) <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> mode <EoN> <BoN> and <EoN> <BoN> sum <EoN> ( [ <NUMBER> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> paths <EoN> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> p <EoN> ] ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> curr path <EoN> <BoN> in <EoN> <BoN> paths <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> curr path <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> mode <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> expanded paths <EoN> . <BoN> extend <EoN> ( <BoN> expand paths <EoN> ( <BoN> curr path <EoN> , <BoN> name function <EoN> , <BoN> num <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> expanded paths <EoN> . <BoN> extend <EoN> ( <BoN> fs <EoN> . <BoN> glob <EoN> ( <BoN> curr path <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> expanded paths <EoN> . <BoN> append <EoN> ( <BoN> curr path <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> mode <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> expanded paths <EoN> ) > <BoN> num <EoN> : <NEWLINE> <TAB> <BoN> expanded paths <EoN> = <BoN> expanded paths <EoN> [ : <BoN> num <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> expanded paths <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> beip zeros <EoN> ( <BoN> nt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isscalar <EoN> ( <BoN> nt <EoN> ) <BoN> or <EoN> ( <BoN> floor <EoN> ( <BoN> nt <EoN> ) != <BoN> nt <EoN> ) <BoN> or <EoN> ( <BoN> nt <EoN> <= <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> specfun <EoN> . <BoN> klvnzo <EoN> ( <BoN> nt <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> denoms <EoN> ( <BoN> eq <EoN> , * <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> pot <EoN> = <BoN> preorder traversal <EoN> ( <BoN> eq <EoN> ) <NEWLINE> <BoN> dens <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> pot <EoN> : <NEWLINE> <TAB> <BoN> den <EoN> = <BoN> denom <EoN> ( <BoN> p <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> den <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> One <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> Mul <EoN> . <BoN> make args <EoN> ( <BoN> den <EoN> ) : <NEWLINE> <TAB> <BoN> dens <EoN> . <BoN> add <EoN> ( <BoN> d <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dens <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> symbols <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> iterable <EoN> ( <BoN> symbols <EoN> [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> symbols <EoN> = <BoN> symbols <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> rv <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> dens <EoN> : <NEWLINE> <TAB> <BoN> free <EoN> = <BoN> d <EoN> . <BoN> free symbols <EoN> <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> s <EoN> <BoN> in <EoN> <BoN> free <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> symbols <EoN> ) : <NEWLINE> <TAB> <BoN> rv <EoN> . <BoN> append <EoN> ( <BoN> d <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> set <EoN> ( <BoN> rv <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pack padded sequence <EoN> ( <BoN> input <EoN> , <BoN> lengths <EoN> , <BoN> batch first <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> lengths <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> lengths <EoN> = <BoN> torch <EoN> . <BoN> Long Tensor <EoN> ( <BoN> lengths <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> data <EoN> , <BoN> batch sizes <EoN> = <BoN> Pack Padded <EoN> . <BoN> apply <EoN> ( <BoN> input <EoN> , <BoN> lengths <EoN> , <BoN> batch first <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Packed Sequence <EoN> ( <BoN> data <EoN> , <BoN> batch sizes <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rewind <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> mode <EoN> != <BoN> REA D <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> OS Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> buffer <EoN> . <BoN> seek <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rfind <EoN> ( <BoN> a <EoN> , <BoN> sub <EoN> , <BoN> start <EoN> = <NUMBER> , <BoN> end <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> vec string <EoN> ( <NEWLINE> <BoN> a <EoN> , <BoN> integer <EoN> , <STRING> , [ <BoN> sub <EoN> , <BoN> start <EoN> ] + <BoN> clean args <EoN> ( <BoN> end <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read clipboard <EoN> ( <BoN> sep <EoN> = <STRING> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> encoding <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> encoding <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> encoding <EoN> . <BoN> lower <EoN> ( ) . <BoN> replace <EoN> ( <STRING> , <STRING> ) != <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> io <EoN> . <BoN> clipboard <EoN> <BoN> import <EoN> <BoN> clipboard get <EoN> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> io <EoN> . <BoN> parsers <EoN> <BoN> import <EoN> <BoN> read table <EoN> <NEWLINE> <BoN> text <EoN> = <BoN> clipboard get <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> P Y 3 <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> text <EoN> = <BoN> compat <EoN> . <BoN> bytes to str <EoN> ( <NEWLINE> <BoN> text <EoN> , <BoN> encoding <EoN> = ( <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> ) <BoN> or <EoN> <NEWLINE> <BoN> get option <EoN> ( <STRING> ) ) <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> lines <EoN> = <BoN> text <EoN> [ : <NUMBER> ] . <BoN> split <EoN> ( <STRING> ) [ : - <NUMBER> ] [ : <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> counts <EoN> = { <BoN> x <EoN> . <BoN> lstrip <EoN> ( ) . <BoN> count <EoN> ( <STRING> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> lines <EoN> } <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> lines <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> counts <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> counts <EoN> . <BoN> pop <EoN> ( ) != <NUMBER> : <NEWLINE> <TAB> <BoN> sep <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sep <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> ) <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sep <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> sep <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> ) <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> kwargs <EoN> [ <STRING> ] = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> sep <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> ) == <STRING> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> kwargs <EoN> . <BoN> get <EoN> ( <STRING> ) == <STRING> <BoN> and <EoN> <BoN> P Y 2 <EoN> : <NEWLINE> <TAB> <BoN> text <EoN> = <BoN> text <EoN> . <BoN> encode <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> read table <EoN> ( <BoN> String I O <EoN> ( <BoN> text <EoN> ) , <BoN> sep <EoN> = <BoN> sep <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> traverse <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> traverse <EoN> ( <BoN> obj <EoN> , <BoN> self <EoN> . <BoN> traverse options <EoN> , <BoN> self <EoN> . <BoN> visitor dict <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> update model v 4 <EoN> ( <BoN> tree handle <EoN> , <BoN> leaf ids <EoN> , <BoN> input labels <EoN> , <BoN> input weights <EoN> , <BoN> params <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> tree handle <EoN> , <NEWLINE> <BoN> leaf ids <EoN> , <BoN> input labels <EoN> , <BoN> input weights <EoN> , <STRING> , <BoN> params <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> update model v 4 eager fallback <EoN> ( <NEWLINE> <BoN> tree handle <EoN> , <BoN> leaf ids <EoN> , <BoN> input labels <EoN> , <BoN> input weights <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> update model v 4 <EoN> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> leaf ids <EoN> = <BoN> leaf ids <EoN> , <NEWLINE> <BoN> input labels <EoN> = <BoN> input labels <EoN> , <NEWLINE> <BoN> input weights <EoN> = <BoN> input weights <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> params <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> params <EoN> , <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> leaf ids <EoN> = <BoN> leaf ids <EoN> , <NEWLINE> <BoN> input labels <EoN> = <BoN> input labels <EoN> , <NEWLINE> <BoN> input weights <EoN> = <BoN> input weights <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> update model v 4 <EoN> , <BoN> tree handle <EoN> = <BoN> tree handle <EoN> , <BoN> leaf ids <EoN> = <BoN> leaf ids <EoN> , <NEWLINE> <BoN> input labels <EoN> = <BoN> input labels <EoN> , <NEWLINE> <BoN> input weights <EoN> = <BoN> input weights <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> op <EoN> <NEWLINE> <BoN> result <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> filter <EoN> ( <BoN> self <EoN> , * <BoN> criterion <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> criterion <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Function Filter <EoN> ( <BoN> self <EoN> , * <BoN> criterion <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> triangular <EoN> ( <BoN> self <EoN> , <BoN> low <EoN> = <NUMBER> , <BoN> high <EoN> = <NUMBER> , <BoN> mode <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> u <EoN> = <BoN> self <EoN> . <BoN> random <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <NUMBER> <BoN> if <EoN> <BoN> mode <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> ( <BoN> mode <EoN> - <BoN> low <EoN> ) / ( <BoN> high <EoN> - <BoN> low <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Zero Division Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> low <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> u <EoN> > <BoN> c <EoN> : <NEWLINE> <TAB> <BoN> u <EoN> = <NUMBER> - <BoN> u <EoN> <NEWLINE> <BoN> c <EoN> = <NUMBER> - <BoN> c <EoN> <NEWLINE> <BoN> low <EoN> , <BoN> high <EoN> = <BoN> high <EoN> , <BoN> low <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> low <EoN> + ( <BoN> high <EoN> - <BoN> low <EoN> ) * ( <BoN> u <EoN> * <BoN> c <EoN> ) ** <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> issequence <EoN> ( <BoN> seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> isinstance <EoN> ( <BoN> seq <EoN> , ( <BoN> ndarray <EoN> , <BoN> tuple <EoN> , <BoN> list <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> newfunc <EoN> ( * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> depdoc <EoN> , <BoN> Deprecation Warning <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> func <EoN> ( * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add axis labels <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> ax <EoN> , <BoN> label <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> axes <EoN> [ - <NUMBER> , : ] , <BoN> self <EoN> . <BoN> x vars <EoN> ) : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> set xlabel <EoN> ( <BoN> label <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> ax <EoN> , <BoN> label <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> axes <EoN> [ : , <NUMBER> ] , <BoN> self <EoN> . <BoN> y vars <EoN> ) : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> set ylabel <EoN> ( <BoN> label <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> save attributes to hdf 5 group <EoN> ( <BoN> group <EoN> , <BoN> name <EoN> , <BoN> data <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> bad attributes <EoN> = [ <BoN> x <EoN> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> data <EoN> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> x <EoN> ) > <BoN> HDF 5 OBJECT HEADER LIMIT <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> bad attributes <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> % ( <BoN> HDF 5 OBJECT HEADER LIMIT <EoN> , <NEWLINE> <STRING> . <BoN> join <EoN> ( [ <BoN> x <EoN> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> bad attributes <EoN> ] ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> data npy <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> data <EoN> ) <NEWLINE> <NEWLINE> <BoN> num chunks <EoN> = <NUMBER> <NEWLINE> <BoN> chunked data <EoN> = <BoN> np <EoN> . <BoN> array split <EoN> ( <BoN> data npy <EoN> , <BoN> num chunks <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> any <EoN> ( <BoN> map <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> nbytes <EoN> > <BoN> HDF 5 OBJECT HEADER LIMIT <EoN> , <BoN> chunked data <EoN> ) ) : <NEWLINE> <TAB> <BoN> num chunks <EoN> += <NUMBER> <NEWLINE> <BoN> chunked data <EoN> = <BoN> np <EoN> . <BoN> array split <EoN> ( <BoN> data npy <EoN> , <BoN> num chunks <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> num chunks <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> chunk id <EoN> , <BoN> chunk data <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> chunked data <EoN> ) : <NEWLINE> <TAB> <BoN> group <EoN> . <BoN> attrs <EoN> [ <STRING> % ( <BoN> name <EoN> , <BoN> chunk id <EoN> ) ] = <BoN> chunk data <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> group <EoN> . <BoN> attrs <EoN> [ <BoN> name <EoN> ] = <BoN> data <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> values <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dict <EoN> . <BoN> values <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> signum update <EoN> ( <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> grad <EoN> = <BoN> None <EoN> , <BoN> mom <EoN> = <BoN> None <EoN> , <BoN> lr <EoN> = <BoN> Null <EoN> , <BoN> momentum <EoN> = <BoN> Null <EoN> , <BoN> wd <EoN> = <BoN> Null <EoN> , <BoN> rescale grad <EoN> = <BoN> Null <EoN> , <BoN> clip gradient <EoN> = <BoN> Null <EoN> , <BoN> wd lh <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tuple wrapper <EoN> ( <BoN> method <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> wrap tuples <EoN> ( * <BoN> args <EoN> , ** <BoN> kw args <EoN> ) : <NEWLINE> <TAB> <BoN> newargs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> arg <EoN> ) <BoN> is <EoN> <BoN> tuple <EoN> : <NEWLINE> <TAB> <BoN> newargs <EoN> . <BoN> append <EoN> ( <BoN> Tuple <EoN> ( * <BoN> arg <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> newargs <EoN> . <BoN> append <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> method <EoN> ( * <BoN> newargs <EoN> , ** <BoN> kw args <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> wrap tuples <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> c support code <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <BoN> batch gemm defn <EoN> = <NEWLINE> <BoN> return <EoN> <BoN> blas header text <EoN> ( ) + <BoN> batch gemm defn <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fwht <EoN> ( <BoN> seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> walsh hadamard transform <EoN> ( <BoN> seq <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> mbfunc <EoN> , <BoN> fillx <EoN> = <NUMBER> , <BoN> filly <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( <BoN> MaskedBinaryOperation <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <BoN> mbfunc <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fillx <EoN> = <BoN> fillx <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> filly <EoN> = <BoN> filly <EoN> <NEWLINE> <BoN> ufunc domain <EoN> [ <BoN> mbfunc <EoN> ] = <BoN> None <EoN> <NEWLINE> <BoN> ufunc fills <EoN> [ <BoN> mbfunc <EoN> ] = ( <BoN> fillx <EoN> , <BoN> filly <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> truediv <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> delegate binop <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Not Implemented <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> true divide <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get c extract out <EoN> ( <BoN> r <EoN> , <BoN> name <EoN> , <BoN> sub <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> check input <EoN> = <BoN> getattr <EoN> ( <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> , <STRING> , <BoN> config <EoN> . <BoN> check input <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> getattr <EoN> ( <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> , <STRING> , <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> c extract <EoN> = <BoN> r <EoN> . <BoN> type <EoN> . <BoN> c extract out <EoN> ( <BoN> name <EoN> , <BoN> sub <EoN> , <BoN> check input <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> c extract <EoN> = <BoN> r <EoN> . <BoN> type <EoN> . <BoN> c extract out <EoN> ( <BoN> name <EoN> , <BoN> sub <EoN> , <BoN> check input <EoN> , <NEWLINE> <BoN> check broadcast <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> c extract <EoN> = <BoN> r <EoN> . <BoN> type <EoN> . <BoN> c extract out <EoN> ( <BoN> name <EoN> , <BoN> sub <EoN> , <BoN> check input <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> pre <EoN> = <STRING> % <BoN> locals <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> pre <EoN> + <BoN> c extract <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> upgrade <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> checked <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> strict call <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> locked <EoN> : <NEWLINE> <TAB> <BoN> errmsg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Converter Lock Error <EoN> ( <BoN> errmsg <EoN> ) <NEWLINE> <UNTAB> <BoN> statusmax <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> mapper <EoN> ) <NEWLINE> <NEWLINE> <BoN> status <EoN> = <BoN> self <EoN> . <BoN> status <EoN> <NEWLINE> <BoN> if <EoN> <BoN> status <EoN> == <BoN> statusmax <EoN> : <NEWLINE> <TAB> <BoN> errmsg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Converter Error <EoN> ( <BoN> errmsg <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> status <EoN> < <BoN> statusmax <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> status <EoN> += <NUMBER> <NEWLINE> <UNTAB> ( <BoN> self <EoN> . <BoN> type <EoN> , <BoN> self <EoN> . <BoN> func <EoN> , <BoN> default <EoN> ) = <BoN> self <EoN> . <BoN> mapper <EoN> [ <BoN> status <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> status <EoN> = <BoN> status <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> initial default <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> default <EoN> = <BoN> self <EoN> . <BoN> initial default <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> default <EoN> = <BoN> default <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> upgrade <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> iter copy <EoN> ( <BoN> structure <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> l <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> structure <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> i <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> l <EoN> . <BoN> append <EoN> ( <BoN> iter copy <EoN> ( <BoN> i <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> l <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> l <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set antialiased <EoN> ( <BoN> self <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> antialiased <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> antialiased <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rs cosh <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> rs is puiseux <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rs puiseux <EoN> ( <BoN> rs cosh <EoN> , <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> t <EoN> = <BoN> rs exp <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> t 1 <EoN> = <BoN> rs series inversion <EoN> ( <BoN> t <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> return <EoN> ( <BoN> t <EoN> + <BoN> t 1 <EoN> ) / <NUMBER> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ttest rel <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> axis <EoN> = <BoN> chk 2 asarray <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> a <EoN> ) != <BoN> len <EoN> ( <BoN> b <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> a <EoN> . <BoN> size <EoN> == <NUMBER> <BoN> or <EoN> <BoN> b <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Ttest relResult <EoN> ( <BoN> np <EoN> . <BoN> nan <EoN> , <BoN> np <EoN> . <BoN> nan <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> a <EoN> . <BoN> count <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> df <EoN> = <BoN> ma <EoN> . <BoN> asanyarray <EoN> ( <BoN> n <EoN> - <NUMBER> ) <NEWLINE> <BoN> d <EoN> = ( <BoN> a <EoN> - <BoN> b <EoN> ) . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <BoN> dm <EoN> = <BoN> d <EoN> . <BoN> mean <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> d <EoN> . <BoN> var <EoN> ( <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> ddof <EoN> = <NUMBER> ) <NEWLINE> <BoN> denom <EoN> = <BoN> ma <EoN> . <BoN> sqrt <EoN> ( <BoN> v <EoN> / <BoN> n <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> divide <EoN> = <STRING> , <BoN> invalid <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> dm <EoN> / <BoN> denom <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> probs <EoN> = <BoN> special <EoN> . <BoN> betainc <EoN> ( <NUMBER> * <BoN> df <EoN> , <NUMBER> , <BoN> df <EoN> / ( <BoN> df <EoN> + <BoN> t <EoN> * <BoN> t <EoN> ) ) . <BoN> reshape <EoN> ( <BoN> t <EoN> . <BoN> shape <EoN> ) . <BoN> squeeze <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Ttest relResult <EoN> ( <BoN> t <EoN> , <BoN> probs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> split <EoN> ( <BoN> self <EoN> , <BoN> instring <EoN> , <BoN> maxsplit <EoN> = <BoN> MAX INT <EoN> , <BoN> include Separators <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> splits <EoN> = <NUMBER> <NEWLINE> <BoN> last <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> t <EoN> , <BoN> s <EoN> , <BoN> e <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> scan String <EoN> ( <BoN> instring <EoN> , <BoN> max Matches <EoN> = <BoN> maxsplit <EoN> ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> instring <EoN> [ <BoN> last <EoN> : <BoN> s <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> include Separators <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> t <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> last <EoN> = <BoN> e <EoN> <NEWLINE> <UNTAB> <BoN> yield <EoN> <BoN> instring <EoN> [ <BoN> last <EoN> : ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> can set locale <EoN> ( <BoN> lc <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> set locale <EoN> ( <BoN> lc <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> locale <EoN> . <BoN> Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> mx op <EoN> . <BoN> register <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> convert elementwise sub <EoN> ( <BoN> node <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> helper <EoN> , <BoN> <EoN> , <BoN> <EoN> = <BoN> import onnx modules <EoN> ( ) <NEWLINE> <BoN> name <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> proc nodes <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> inputs <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> input node a id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <BoN> input node b id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <NEWLINE> <BoN> input node a <EoN> = <BoN> proc nodes <EoN> [ <BoN> input node a id <EoN> ] . <BoN> name <EoN> <NEWLINE> <BoN> input node b <EoN> = <BoN> proc nodes <EoN> [ <BoN> input node b id <EoN> ] . <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> sub node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <STRING> , <NEWLINE> [ <BoN> input node a <EoN> , <BoN> input node b <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> sub node <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> apply prediction <EoN> ( <BoN> G <EoN> , <BoN> func <EoN> , <BoN> ebunch <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> ebunch <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ebunch <EoN> = <BoN> nx <EoN> . <BoN> non edges <EoN> ( <BoN> G <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> ( ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> func <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> ebunch <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rstrip <EoN> ( <BoN> self <EoN> , <BoN> chars <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> asarray <EoN> ( <BoN> rstrip <EoN> ( <BoN> self <EoN> , <BoN> chars <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> type descriptor <EoN> ( <BoN> cls <EoN> , <BoN> typeobj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> press <EoN> ( <BoN> self <EoN> , <BoN> event <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> ( ( <BoN> self <EoN> . <BoN> polygon completed <EoN> <BoN> or <EoN> <STRING> <BoN> in <EoN> <BoN> self <EoN> . <BoN> state <EoN> ) <NEWLINE> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> xs <EoN> ) > <NUMBER> ) : <NEWLINE> <TAB> <BoN> h idx <EoN> , <BoN> h dist <EoN> = <BoN> self <EoN> . <BoN> polygon handles <EoN> . <BoN> closest <EoN> ( <BoN> event <EoN> . <BoN> x <EoN> , <BoN> event <EoN> . <BoN> y <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> h dist <EoN> < <BoN> self <EoN> . <BoN> vertex select radius <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> active handle idx <EoN> = <BoN> h idx <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> xs at press <EoN> , <BoN> self <EoN> . <BoN> ys at press <EoN> = <BoN> self <EoN> . <BoN> xs <EoN> [ : ] , <BoN> self <EoN> . <BoN> ys <EoN> [ : ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rmatvec <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> self <EoN> ) . <BoN> adjoint <EoN> == <BoN> Linear Operator <EoN> . <BoN> adjoint <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> H <EoN> . <BoN> matvec <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bind method <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> P Y 3 <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> types <EoN> . <BoN> Method Type <EoN> ( <BoN> func <EoN> , <BoN> None <EoN> , <BoN> cls <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> func <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get info <EoN> ( <BoN> self <EoN> , <BoN> notfound action <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> flag <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> has info <EoN> ( ) : <NEWLINE> <TAB> <BoN> flag <EoN> = <NUMBER> <NEWLINE> <BoN> log <EoN> . <BoN> info <EoN> ( <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> + <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> calc info <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> notfound action <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> has info <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> notfound action <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <BoN> self <EoN> . <BoN> notfounderror <EoN> . <BoN> doc <EoN> , <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> notfound action <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> self <EoN> . <BoN> notfounderror <EoN> ( <BoN> self <EoN> . <BoN> notfounderror <EoN> . <BoN> doc <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> repr <EoN> ( <BoN> notfound action <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> has info <EoN> ( ) : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <BoN> self <EoN> . <BoN> set info <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> res <EoN> = <BoN> self <EoN> . <BoN> saved results <EoN> . <BoN> get <EoN> ( <BoN> self <EoN> . <BoN> class <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> verbosity <EoN> > <NUMBER> <BoN> and <EoN> <BoN> flag <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> res <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> str <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] <BoN> and <EoN> <BoN> len <EoN> ( <BoN> v <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> v <EoN> [ : <NUMBER> ] + <STRING> + <BoN> v <EoN> [ - <NUMBER> : ] <NEWLINE> <UNTAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> k <EoN> , <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> log <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> copy <EoN> . <BoN> deepcopy <EoN> ( <BoN> res <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> evaluate standard <EoN> ( <BoN> op <EoN> , <BoN> op str <EoN> , <BoN> a <EoN> , <BoN> b <EoN> , ** <BoN> eval kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> TEST MODE <EoN> : <NEWLINE> <TAB> <BoN> store test result <EoN> ( <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> all <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> op <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> zeros <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> shape <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> , <BoN> Tensor Variable <EoN> ) ) : <NEWLINE> <TAB> <BoN> shape <EoN> = [ <BoN> shape <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> config <EoN> . <BoN> float X <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> alloc <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <NUMBER> , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) , * <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> issuperset <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> is superset <EoN> ( <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getitem <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super getitem <EoN> = <BoN> super <EoN> ( <BoN> Range Index <EoN> , <BoN> self <EoN> ) . <BoN> getitem <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is scalar <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> int <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> != <BoN> key <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> super getitem <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> ) + <BoN> key <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> <BoN> or <EoN> <BoN> n <EoN> > <BoN> len <EoN> ( <BoN> self <EoN> ) - <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> key <EoN> = <BoN> key <EoN> , <NEWLINE> <BoN> size <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> start <EoN> + <BoN> n <EoN> * <BoN> self <EoN> . <BoN> step <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> key <EoN> , <BoN> slice <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> l <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> step <EoN> = <NUMBER> <BoN> if <EoN> <BoN> key <EoN> . <BoN> step <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> key <EoN> . <BoN> step <EoN> <NEWLINE> <BoN> if <EoN> <BoN> key <EoN> . <BoN> start <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> start <EoN> = <BoN> l <EoN> - <NUMBER> <BoN> if <EoN> <BoN> step <EoN> < <NUMBER> <BoN> else <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> start <EoN> = <BoN> key <EoN> . <BoN> start <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> start <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> start <EoN> += <BoN> l <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> start <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> start <EoN> = - <NUMBER> <BoN> if <EoN> <BoN> step <EoN> < <NUMBER> <BoN> else <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> start <EoN> >= <BoN> l <EoN> : <NEWLINE> <TAB> <BoN> start <EoN> = <BoN> l <EoN> - <NUMBER> <BoN> if <EoN> <BoN> step <EoN> < <NUMBER> <BoN> else <EoN> <BoN> l <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> key <EoN> . <BoN> stop <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> stop <EoN> = - <NUMBER> <BoN> if <EoN> <BoN> step <EoN> < <NUMBER> <BoN> else <EoN> <BoN> l <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> stop <EoN> = <BoN> key <EoN> . <BoN> stop <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stop <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> stop <EoN> += <BoN> l <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stop <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> stop <EoN> = - <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> stop <EoN> > <BoN> l <EoN> : <NEWLINE> <TAB> <BoN> stop <EoN> = <BoN> l <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> ( <BoN> start <EoN> != <BoN> int <EoN> ( <BoN> start <EoN> ) <BoN> or <EoN> <NEWLINE> <BoN> stop <EoN> != <BoN> int <EoN> ( <BoN> stop <EoN> ) <BoN> or <EoN> <NEWLINE> <BoN> step <EoN> != <BoN> int <EoN> ( <BoN> step <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> super getitem <EoN> ( <BoN> key <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> start <EoN> = <BoN> self <EoN> . <BoN> start <EoN> + <BoN> self <EoN> . <BoN> step <EoN> * <BoN> start <EoN> <NEWLINE> <BoN> stop <EoN> = <BoN> self <EoN> . <BoN> start <EoN> + <BoN> self <EoN> . <BoN> step <EoN> * <BoN> stop <EoN> <NEWLINE> <BoN> step <EoN> = <BoN> self <EoN> . <BoN> step <EoN> * <BoN> step <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Range Index <EoN> ( <BoN> start <EoN> , <BoN> stop <EoN> , <BoN> step <EoN> , <BoN> name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> , <BoN> fastpath <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> super getitem <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> allow rasterization <EoN> <NEWLINE> <BoN> def <EoN> <BoN> draw <EoN> ( <BoN> self <EoN> , <BoN> renderer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> get visible <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> invalidy <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> invalidx <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> recache <EoN> ( ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> ind offset <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> subslice <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> x 0 <EoN> , <BoN> x 1 <EoN> = <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> get xbound <EoN> ( ) <NEWLINE> <BoN> i 0 <EoN> , = <BoN> self <EoN> . <BoN> x filled <EoN> . <BoN> searchsorted <EoN> ( [ <BoN> x 0 <EoN> ] , <STRING> ) <NEWLINE> <BoN> i 1 <EoN> , = <BoN> self <EoN> . <BoN> x filled <EoN> . <BoN> searchsorted <EoN> ( [ <BoN> x 1 <EoN> ] , <STRING> ) <NEWLINE> <BoN> subslice <EoN> = <BoN> slice <EoN> ( <BoN> max <EoN> ( <BoN> i 0 <EoN> - <NUMBER> , <NUMBER> ) , <BoN> i 1 <EoN> + <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> ind offset <EoN> = <BoN> subslice <EoN> . <BoN> start <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> transform path <EoN> ( <BoN> subslice <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> subslice <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> get path effects <EoN> ( ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> matplotlib <EoN> . <BoN> patheffects <EoN> <BoN> import <EoN> <BoN> Path Effect Renderer <EoN> <NEWLINE> <BoN> renderer <EoN> = <BoN> Path Effect Renderer <EoN> ( <BoN> self <EoN> . <BoN> get path effects <EoN> ( ) , <BoN> renderer <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> renderer <EoN> . <BoN> open group <EoN> ( <STRING> , <BoN> self <EoN> . <BoN> get gid <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> lineStyles <EoN> [ <BoN> self <EoN> . <BoN> linestyle <EoN> ] != <STRING> : <NEWLINE> <TAB> <BoN> tpath <EoN> , <BoN> affine <EoN> = ( <BoN> self <EoN> . <BoN> get transformed path <EoN> ( ) <NEWLINE> . <BoN> get transformed path and affine <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tpath <EoN> . <BoN> vertices <EoN> ) : <NEWLINE> <TAB> <BoN> gc <EoN> = <BoN> renderer <EoN> . <BoN> new gc <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> set gc clip <EoN> ( <BoN> gc <EoN> ) <NEWLINE> <NEWLINE> <BoN> lc rgba <EoN> = <BoN> mcolors <EoN> . <BoN> to rgba <EoN> ( <BoN> self <EoN> . <BoN> color <EoN> , <BoN> self <EoN> . <BoN> alpha <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set foreground <EoN> ( <BoN> lc rgba <EoN> , <BoN> is RGB A <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> gc <EoN> . <BoN> set antialiased <EoN> ( <BoN> self <EoN> . <BoN> antialiased <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set linewidth <EoN> ( <BoN> self <EoN> . <BoN> linewidth <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is dashed <EoN> ( ) : <NEWLINE> <TAB> <BoN> cap <EoN> = <BoN> self <EoN> . <BoN> dashcapstyle <EoN> <NEWLINE> <BoN> join <EoN> = <BoN> self <EoN> . <BoN> dashjoinstyle <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cap <EoN> = <BoN> self <EoN> . <BoN> solidcapstyle <EoN> <NEWLINE> <BoN> join <EoN> = <BoN> self <EoN> . <BoN> solidjoinstyle <EoN> <NEWLINE> <UNTAB> <BoN> gc <EoN> . <BoN> set joinstyle <EoN> ( <BoN> join <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set capstyle <EoN> ( <BoN> cap <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set snap <EoN> ( <BoN> self <EoN> . <BoN> get snap <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> get sketch params <EoN> ( ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> gc <EoN> . <BoN> set sketch params <EoN> ( * <BoN> self <EoN> . <BoN> get sketch params <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> gc <EoN> . <BoN> set dashes <EoN> ( <BoN> self <EoN> . <BoN> dashOffset <EoN> , <BoN> self <EoN> . <BoN> dashSeq <EoN> ) <NEWLINE> <BoN> renderer <EoN> . <BoN> draw path <EoN> ( <BoN> gc <EoN> , <BoN> tpath <EoN> , <BoN> affine <EoN> . <BoN> frozen <EoN> ( ) ) <NEWLINE> <BoN> gc <EoN> . <BoN> restore <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> marker <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> markersize <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> gc <EoN> = <BoN> renderer <EoN> . <BoN> new gc <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> set gc clip <EoN> ( <BoN> gc <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set linewidth <EoN> ( <BoN> self <EoN> . <BoN> markeredgewidth <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set antialiased <EoN> ( <BoN> self <EoN> . <BoN> antialiased <EoN> ) <NEWLINE> <NEWLINE> <BoN> ec rgba <EoN> = <BoN> mcolors <EoN> . <BoN> to rgba <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> get markeredgecolor <EoN> ( ) , <BoN> self <EoN> . <BoN> alpha <EoN> ) <NEWLINE> <BoN> fc rgba <EoN> = <BoN> mcolors <EoN> . <BoN> to rgba <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> get markerfacecolor <EoN> ( ) , <BoN> self <EoN> . <BoN> alpha <EoN> ) <NEWLINE> <BoN> fcalt rgba <EoN> = <BoN> mcolors <EoN> . <BoN> to rgba <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> get markerfacecolor <EoN> ( <BoN> alt <EoN> = <BoN> True <EoN> ) , <BoN> self <EoN> . <BoN> alpha <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> cbook <EoN> . <BoN> str equal <EoN> ( <BoN> self <EoN> . <BoN> markeredgecolor <EoN> , <STRING> ) <NEWLINE> <BoN> and <EoN> <BoN> not <EoN> <BoN> cbook <EoN> . <BoN> str lower equal <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> get markerfacecolor <EoN> ( ) , <STRING> ) ) : <NEWLINE> <TAB> <BoN> ec rgba <EoN> = <BoN> ec rgba <EoN> [ : <NUMBER> ] + ( <BoN> fc rgba <EoN> [ <NUMBER> ] , ) <NEWLINE> <UNTAB> <BoN> gc <EoN> . <BoN> set foreground <EoN> ( <BoN> ec rgba <EoN> , <BoN> is RGB A <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> get sketch params <EoN> ( ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> scale <EoN> , <BoN> length <EoN> , <BoN> randomness <EoN> = <BoN> self <EoN> . <BoN> get sketch params <EoN> ( ) <NEWLINE> <BoN> gc <EoN> . <BoN> set sketch params <EoN> ( <BoN> scale <EoN> / <NUMBER> , <BoN> length <EoN> / <NUMBER> , <NUMBER> * <BoN> randomness <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> marker <EoN> = <BoN> self <EoN> . <BoN> marker <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> get drawstyle <EoN> ( ) != <STRING> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> cbook <EoN> . <BoN> setattr cm <EoN> ( <NEWLINE> <BoN> self <EoN> , <BoN> drawstyle <EoN> = <STRING> , <BoN> transformed path <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> recache <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> transform path <EoN> ( <BoN> subslice <EoN> ) <NEWLINE> <BoN> tpath <EoN> , <BoN> affine <EoN> = ( <BoN> self <EoN> . <BoN> get transformed path <EoN> ( ) <NEWLINE> . <BoN> get transformed path and affine <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> tpath <EoN> , <BoN> affine <EoN> = ( <BoN> self <EoN> . <BoN> get transformed path <EoN> ( ) <NEWLINE> . <BoN> get transformed path and affine <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tpath <EoN> . <BoN> vertices <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> markevery <EoN> = <BoN> self <EoN> . <BoN> get markevery <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> markevery <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> subsampled <EoN> = <BoN> mark every path <EoN> ( <BoN> markevery <EoN> , <BoN> tpath <EoN> , <NEWLINE> <BoN> affine <EoN> , <BoN> self <EoN> . <BoN> axes <EoN> . <BoN> trans Axes <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> subsampled <EoN> = <BoN> tpath <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> snap <EoN> = <BoN> marker <EoN> . <BoN> get snap threshold <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> snap <EoN> , <BoN> Real <EoN> ) : <NEWLINE> <TAB> <BoN> snap <EoN> = <BoN> renderer <EoN> . <BoN> points to pixels <EoN> ( <BoN> self <EoN> . <BoN> markersize <EoN> ) >= <BoN> snap <EoN> <NEWLINE> <UNTAB> <BoN> gc <EoN> . <BoN> set snap <EoN> ( <BoN> snap <EoN> ) <NEWLINE> <BoN> gc <EoN> . <BoN> set joinstyle <EoN> ( <BoN> marker <EoN> . <BoN> get joinstyle <EoN> ( ) ) <NEWLINE> <BoN> gc <EoN> . <BoN> set capstyle <EoN> ( <BoN> marker <EoN> . <BoN> get capstyle <EoN> ( ) ) <NEWLINE> <BoN> marker path <EoN> = <BoN> marker <EoN> . <BoN> get path <EoN> ( ) <NEWLINE> <BoN> marker trans <EoN> = <BoN> marker <EoN> . <BoN> get transform <EoN> ( ) <NEWLINE> <BoN> w <EoN> = <BoN> renderer <EoN> . <BoN> points to pixels <EoN> ( <BoN> self <EoN> . <BoN> markersize <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> cbook <EoN> . <BoN> str equal <EoN> ( <BoN> marker <EoN> . <BoN> get marker <EoN> ( ) , <STRING> ) : <NEWLINE> <TAB> <BoN> gc <EoN> . <BoN> set linewidth <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> marker trans <EoN> = <BoN> marker trans <EoN> . <BoN> scale <EoN> ( <BoN> w <EoN> ) <NEWLINE> <UNTAB> <BoN> renderer <EoN> . <BoN> draw markers <EoN> ( <BoN> gc <EoN> , <BoN> marker path <EoN> , <BoN> marker trans <EoN> , <NEWLINE> <BoN> subsampled <EoN> , <BoN> affine <EoN> . <BoN> frozen <EoN> ( ) , <NEWLINE> <BoN> fc rgba <EoN> ) <NEWLINE> <NEWLINE> <BoN> alt marker path <EoN> = <BoN> marker <EoN> . <BoN> get alt path <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> alt marker path <EoN> : <NEWLINE> <TAB> <BoN> alt marker trans <EoN> = <BoN> marker <EoN> . <BoN> get alt transform <EoN> ( ) <NEWLINE> <BoN> alt marker trans <EoN> = <BoN> alt marker trans <EoN> . <BoN> scale <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> renderer <EoN> . <BoN> draw markers <EoN> ( <NEWLINE> <BoN> gc <EoN> , <BoN> alt marker path <EoN> , <BoN> alt marker trans <EoN> , <BoN> subsampled <EoN> , <NEWLINE> <BoN> affine <EoN> . <BoN> frozen <EoN> ( ) , <BoN> fcalt rgba <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> gc <EoN> . <BoN> restore <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> renderer <EoN> . <BoN> close group <EoN> ( <STRING> ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> slice helper <EoN> ( <BoN> tensor <EoN> , <BoN> slice spec <EoN> , <BoN> var <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> slice spec <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> slice spec <EoN> = [ <BoN> slice spec <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> begin <EoN> , <BoN> end <EoN> , <BoN> strides <EoN> = [ ] , [ ] , [ ] <NEWLINE> <BoN> index <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> new axis mask <EoN> , <BoN> shrink axis mask <EoN> = <NUMBER> , <NUMBER> <NEWLINE> <BoN> begin mask <EoN> , <BoN> end mask <EoN> = <NUMBER> , <NUMBER> <NEWLINE> <BoN> ellipsis mask <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> slice spec <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> s <EoN> , <BoN> BaseSlice <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> s <EoN> . <BoN> start <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> s <EoN> . <BoN> start <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> sys <EoN> . <BoN> maxsize <EoN> : <NEWLINE> <TAB> <BoN> check index <EoN> ( <BoN> s <EoN> . <BoN> start <EoN> ) <NEWLINE> <BoN> begin <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> . <BoN> start <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> begin <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> begin mask <EoN> |= ( <NUMBER> << <BoN> index <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> s <EoN> . <BoN> stop <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> s <EoN> . <BoN> stop <EoN> != <BoN> sys <EoN> . <BoN> maxsize <EoN> : <NEWLINE> <TAB> <BoN> check index <EoN> ( <BoN> s <EoN> . <BoN> stop <EoN> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> . <BoN> stop <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> end <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> end mask <EoN> |= ( <NUMBER> << <BoN> index <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> s <EoN> . <BoN> step <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> check index <EoN> ( <BoN> s <EoN> . <BoN> step <EoN> ) <NEWLINE> <BoN> strides <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> . <BoN> step <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> strides <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> Ellipsis <EoN> : <NEWLINE> <TAB> <BoN> begin <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> strides <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> ellipsis mask <EoN> |= ( <NUMBER> << <BoN> index <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> newaxis <EoN> : <NEWLINE> <TAB> <BoN> begin <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> strides <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> new axis mask <EoN> |= ( <NUMBER> << <BoN> index <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> check index <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> begin <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> end <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> + <NUMBER> ) <NEWLINE> <BoN> strides <EoN> . <BoN> append <EoN> ( <NUMBER> ) <NEWLINE> <BoN> shrink axis mask <EoN> |= ( <NUMBER> << <BoN> index <EoN> ) <NEWLINE> <UNTAB> <BoN> index <EoN> += <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> None <EoN> , <STRING> , <NEWLINE> [ <BoN> tensor <EoN> ] + <BoN> begin <EoN> + <BoN> end <EoN> + <BoN> strides <EoN> ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> begin <EoN> : <NEWLINE> <TAB> <BoN> packed begin <EoN> , <BoN> packed end <EoN> , <BoN> packed strides <EoN> = ( <BoN> stack <EoN> ( <BoN> begin <EoN> ) , <BoN> stack <EoN> ( <BoN> end <EoN> ) , <NEWLINE> <BoN> stack <EoN> ( <BoN> strides <EoN> ) ) <NEWLINE> <BoN> if <EoN> ( <BoN> packed begin <EoN> . <BoN> dtype <EoN> == <BoN> dtypes <EoN> . <BoN> int 64 <EoN> <BoN> or <EoN> <NEWLINE> <BoN> packed end <EoN> . <BoN> dtype <EoN> == <BoN> dtypes <EoN> . <BoN> int 64 <EoN> <BoN> or <EoN> <NEWLINE> <BoN> packed strides <EoN> . <BoN> dtype <EoN> == <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> packed begin <EoN> . <BoN> dtype <EoN> != <BoN> dtypes <EoN> . <BoN> int 64 <EoN> : <NEWLINE> <TAB> <BoN> packed begin <EoN> = <BoN> gen math ops <EoN> . <BoN> cast <EoN> ( <BoN> packed begin <EoN> , <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> packed end <EoN> . <BoN> dtype <EoN> != <BoN> dtypes <EoN> . <BoN> int 64 <EoN> : <NEWLINE> <TAB> <BoN> packed end <EoN> = <BoN> gen math ops <EoN> . <BoN> cast <EoN> ( <BoN> packed end <EoN> , <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> packed strides <EoN> . <BoN> dtype <EoN> != <BoN> dtypes <EoN> . <BoN> int 64 <EoN> : <NEWLINE> <TAB> <BoN> packed strides <EoN> = <BoN> gen math ops <EoN> . <BoN> cast <EoN> ( <BoN> packed strides <EoN> , <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> var empty <EoN> = <BoN> constant <EoN> ( [ ] , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> packed begin <EoN> = <BoN> packed end <EoN> = <BoN> packed strides <EoN> = <BoN> var empty <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> strided slice <EoN> ( <NEWLINE> <BoN> tensor <EoN> , <NEWLINE> <BoN> packed begin <EoN> , <NEWLINE> <BoN> packed end <EoN> , <NEWLINE> <BoN> packed strides <EoN> , <NEWLINE> <BoN> begin mask <EoN> = <BoN> begin mask <EoN> , <NEWLINE> <BoN> end mask <EoN> = <BoN> end mask <EoN> , <NEWLINE> <BoN> shrink axis mask <EoN> = <BoN> shrink axis mask <EoN> , <NEWLINE> <BoN> new axis mask <EoN> = <BoN> new axis mask <EoN> , <NEWLINE> <BoN> ellipsis mask <EoN> = <BoN> ellipsis mask <EoN> , <NEWLINE> <BoN> var <EoN> = <BoN> var <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> generate gexf <EoN> ( <BoN> G <EoN> , <BoN> encoding <EoN> = <STRING> , <BoN> prettyprint <EoN> = <BoN> True <EoN> , <BoN> version <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> writer <EoN> = <BoN> GEXF Writer <EoN> ( <BoN> encoding <EoN> = <BoN> encoding <EoN> , <BoN> prettyprint <EoN> = <BoN> prettyprint <EoN> , <NEWLINE> <BoN> version <EoN> = <BoN> version <EoN> ) <NEWLINE> <BoN> writer <EoN> . <BoN> add graph <EoN> ( <BoN> G <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> line <EoN> <BoN> in <EoN> <BoN> str <EoN> ( <BoN> writer <EoN> ) . <BoN> splitlines <EoN> ( ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> line <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> swapaxes <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> dim 1 <EoN> = <BoN> Null <EoN> , <BoN> dim 2 <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rs pow <EoN> ( <BoN> p 1 <EoN> , <BoN> n <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> R <EoN> = <BoN> p 1 <EoN> . <BoN> ring <EoN> <NEWLINE> <BoN> p <EoN> = <BoN> R <EoN> . <BoN> zero <EoN> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> n <EoN> , <BoN> Rational <EoN> ) : <NEWLINE> <TAB> <BoN> np <EoN> = <BoN> int <EoN> ( <BoN> n <EoN> . <BoN> p <EoN> ) <NEWLINE> <BoN> nq <EoN> = <BoN> int <EoN> ( <BoN> n <EoN> . <BoN> q <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> nq <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> rs nth root <EoN> ( <BoN> p 1 <EoN> , <BoN> nq <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> rs pow <EoN> ( <BoN> res <EoN> , <BoN> np <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> rs pow <EoN> ( <BoN> p 1 <EoN> , <BoN> np <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> as int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p 1 <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> R <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> p 1 <EoN> = <BoN> rs pow <EoN> ( <BoN> p 1 <EoN> , - <BoN> n <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> rs series inversion <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rs trunc <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> rs square <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> p 2 <EoN> = <BoN> rs square <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> rs mul <EoN> ( <BoN> p 1 <EoN> , <BoN> p 2 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> R <EoN> ( <NUMBER> ) <NEWLINE> <BoN> while <EoN> <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> n <EoN> & <NUMBER> : <NEWLINE> <TAB> <BoN> p <EoN> = <BoN> rs mul <EoN> ( <BoN> p 1 <EoN> , <BoN> p <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> n <EoN> -= <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> p 1 <EoN> = <BoN> rs square <EoN> ( <BoN> p 1 <EoN> , <BoN> x <EoN> , <BoN> prec <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> n <EoN> // <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> p <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sparse column with keys <EoN> ( <NEWLINE> <BoN> column name <EoN> , <BoN> keys <EoN> , <BoN> default value <EoN> = - <NUMBER> , <BoN> combiner <EoN> = <STRING> , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> string <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> keys <EoN> = <BoN> tuple <EoN> ( <BoN> keys <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> SparseColumnKeys <EoN> ( <NEWLINE> <BoN> column name <EoN> , <NEWLINE> <BoN> lookup config <EoN> = <BoN> SparseIdLookupConfig <EoN> ( <NEWLINE> <BoN> keys <EoN> = <BoN> keys <EoN> , <BoN> vocab size <EoN> = <BoN> len <EoN> ( <BoN> keys <EoN> ) , <BoN> default value <EoN> = <BoN> default value <EoN> ) , <NEWLINE> <BoN> combiner <EoN> = <BoN> combiner <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> backend <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> BACKEND <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sqr <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> sqr <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Operation Not Supported <EoN> ( <BoN> f <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> decode data elements <EoN> ( <BoN> self <EoN> , <BoN> graphml keys <EoN> , <BoN> obj xml <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> data <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> data element <EoN> <BoN> in <EoN> <BoN> obj xml <EoN> . <BoN> findall <EoN> ( <STRING> % <BoN> self <EoN> . <BoN> NS GRAPHML <EoN> ) : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> data element <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> data name <EoN> = <BoN> graphml keys <EoN> [ <BoN> key <EoN> ] [ <STRING> ] <NEWLINE> <BoN> data type <EoN> = <BoN> graphml keys <EoN> [ <BoN> key <EoN> ] [ <STRING> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> Network X Error <EoN> ( <STRING> % <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> text <EoN> = <BoN> data element <EoN> . <BoN> text <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> text <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> list <EoN> ( <BoN> data element <EoN> ) ) == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> data type <EoN> == <BoN> bool <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> data <EoN> [ <BoN> data name <EoN> ] = <BoN> self <EoN> . <BoN> convert bool <EoN> [ <BoN> text <EoN> . <BoN> lower <EoN> ( ) ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> [ <BoN> data name <EoN> ] = <BoN> data type <EoN> ( <BoN> text <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> list <EoN> ( <BoN> data element <EoN> ) ) > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> node label <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> node type <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> pref <EoN> = <STRING> % ( <BoN> self <EoN> . <BoN> NS Y <EoN> , <BoN> node type <EoN> , <BoN> self <EoN> . <BoN> NS Y <EoN> ) <NEWLINE> <BoN> geometry <EoN> = <BoN> data element <EoN> . <BoN> find <EoN> ( <STRING> % <BoN> pref <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> geometry <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> [ <STRING> ] = <BoN> geometry <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <BoN> data <EoN> [ <STRING> ] = <BoN> geometry <EoN> . <BoN> get <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> node label <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> node label <EoN> = <BoN> data element <EoN> . <BoN> find <EoN> ( <STRING> % <BoN> pref <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> node label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> [ <STRING> ] = <BoN> node label <EoN> . <BoN> text <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> pref <EoN> = <STRING> % ( <BoN> self <EoN> . <BoN> NS Y <EoN> , <BoN> e <EoN> , <BoN> self <EoN> . <BoN> NS Y <EoN> ) <NEWLINE> <BoN> edge label <EoN> = <BoN> data element <EoN> . <BoN> find <EoN> ( <STRING> % <BoN> pref <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> edge label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> edge label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> data <EoN> [ <STRING> ] = <BoN> edge label <EoN> . <BoN> text <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> data <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> gradient registry <EoN> . <BoN> register <EoN> ( <BoN> f <EoN> , <BoN> self <EoN> . <BoN> op type <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> simplename <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <STRING> . <BoN> join <EoN> ( <BoN> c <EoN> . <BoN> lower <EoN> ( ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> name <EoN> <BoN> if <EoN> <BoN> c <EoN> . <BoN> isalnum <EoN> ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> scale face <EoN> ( <BoN> face <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> scaled <EoN> = <BoN> face <EoN> - <BoN> face <EoN> . <BoN> min <EoN> ( ) <NEWLINE> <BoN> scaled <EoN> /= <BoN> scaled <EoN> . <BoN> max <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> scaled <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read feather <EoN> ( <BoN> path <EoN> , <BoN> nthreads <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> feather <EoN> = <BoN> try import <EoN> ( ) <NEWLINE> <BoN> path <EoN> = <BoN> stringify path <EoN> ( <BoN> path <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> Loose Version <EoN> ( <BoN> feather <EoN> . <BoN> version <EoN> ) < <BoN> Loose Version <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> feather <EoN> . <BoN> read dataframe <EoN> ( <BoN> path <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> feather <EoN> . <BoN> read dataframe <EoN> ( <BoN> path <EoN> , <BoN> nthreads <EoN> = <BoN> nthreads <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> broadcast like <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> broadcast like <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> popitem <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> next <EoN> ( <BoN> iter <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> <NEWLINE> <UNTAB> <BoN> value <EoN> = <BoN> self <EoN> [ <BoN> key <EoN> ] <NEWLINE> <BoN> del <EoN> <BoN> self <EoN> [ <BoN> key <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> key <EoN> , <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ftrl update <EoN> ( <BoN> weight <EoN> = <BoN> None <EoN> , <BoN> grad <EoN> = <BoN> None <EoN> , <BoN> z <EoN> = <BoN> None <EoN> , <BoN> n <EoN> = <BoN> None <EoN> , <BoN> lr <EoN> = <BoN> Null <EoN> , <BoN> lamda 1 <EoN> = <BoN> Null <EoN> , <BoN> beta <EoN> = <BoN> Null <EoN> , <BoN> wd <EoN> = <BoN> Null <EoN> , <BoN> rescale grad <EoN> = <BoN> Null <EoN> , <BoN> clip gradient <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> float <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> float <EoN> ( <BoN> int <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> writable <EoN> <NEWLINE> <BoN> buf <EoN> = <BoN> ctypes <EoN> . <BoN> c char p <EoN> ( ) <NEWLINE> <BoN> size <EoN> = <BoN> ctypes <EoN> . <BoN> c size t <EoN> ( ) <NEWLINE> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MX Record IO Reader Read Record <EoN> ( <BoN> self <EoN> . <BoN> handle <EoN> , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> buf <EoN> ) , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> size <EoN> ) ) ) <NEWLINE> <BoN> if <EoN> <BoN> buf <EoN> : <NEWLINE> <TAB> <BoN> buf <EoN> = <BoN> ctypes <EoN> . <BoN> cast <EoN> ( <BoN> buf <EoN> , <BoN> ctypes <EoN> . <BoN> POINTE R <EoN> ( <BoN> ctypes <EoN> . <BoN> c char <EoN> * <BoN> size <EoN> . <BoN> value <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> buf <EoN> . <BoN> contents <EoN> . <BoN> raw <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> convert <EoN> ( <BoN> entry <EoN> , <BoN> slice ok <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> invalid scal types <EoN> = [ <BoN> scal <EoN> . <BoN> float 64 <EoN> , <BoN> scal <EoN> . <BoN> float 32 <EoN> , <BoN> scal <EoN> . <BoN> float 16 <EoN> ] <NEWLINE> <BoN> scal types <EoN> = [ <BoN> scal <EoN> . <BoN> int 64 <EoN> , <BoN> scal <EoN> . <BoN> int 32 <EoN> , <BoN> scal <EoN> . <BoN> int 16 <EoN> , <BoN> scal <EoN> . <BoN> int 8 <EoN> ] <NEWLINE> <BoN> tensor types <EoN> = [ <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> lscalar <EoN> , <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> iscalar <EoN> , <NEWLINE> <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> wscalar <EoN> , <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> bscalar <EoN> ] <NEWLINE> <BoN> invalid tensor types <EoN> = [ <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> fscalar <EoN> , <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> dscalar <EoN> , <NEWLINE> <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> cscalar <EoN> , <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> zscalar <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> entry <EoN> , ( <BoN> np <EoN> . <BoN> ndarray <EoN> , <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> Variable <EoN> ) ) <BoN> and <EoN> <NEWLINE> <BoN> hasattr <EoN> ( <BoN> entry <EoN> , <STRING> ) <BoN> and <EoN> <BoN> entry <EoN> . <BoN> dtype <EoN> == <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Advanced Boolean Indexing Error <EoN> ( <BoN> Subtensor <EoN> . <BoN> e indextype <EoN> , <BoN> entry <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) <BoN> and <EoN> <NEWLINE> ( <BoN> entry <EoN> . <BoN> type <EoN> <BoN> in <EoN> <BoN> invalid scal types <EoN> <BoN> or <EoN> <NEWLINE> <BoN> entry <EoN> . <BoN> type <EoN> <BoN> in <EoN> <BoN> invalid tensor types <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) <BoN> and <EoN> <BoN> entry <EoN> . <BoN> type <EoN> <BoN> in <EoN> <BoN> scal types <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> entry <EoN> . <BoN> type <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> gof <EoN> . <BoN> Type <EoN> ) <BoN> and <EoN> <BoN> entry <EoN> <BoN> in <EoN> <BoN> scal types <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> entry <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> gof <EoN> . <BoN> Variable <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> entry <EoN> . <BoN> type <EoN> <BoN> in <EoN> <BoN> tensor types <EoN> <BoN> and <EoN> <NEWLINE> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> entry <EoN> . <BoN> type <EoN> . <BoN> broadcastable <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> scal <EoN> . <BoN> get scalar type <EoN> ( <BoN> entry <EoN> . <BoN> type <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> gof <EoN> . <BoN> Type <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> entry <EoN> <BoN> in <EoN> <BoN> tensor types <EoN> <BoN> and <EoN> <NEWLINE> <BoN> np <EoN> . <BoN> all <EoN> ( <BoN> entry <EoN> . <BoN> broadcastable <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> scal <EoN> . <BoN> get scalar type <EoN> ( <BoN> entry <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> slice ok <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> entry <EoN> , <BoN> slice <EoN> ) : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> entry <EoN> . <BoN> start <EoN> <NEWLINE> <BoN> b <EoN> = <BoN> entry <EoN> . <BoN> stop <EoN> <NEWLINE> <BoN> c <EoN> = <BoN> entry <EoN> . <BoN> step <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> a <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> slice a <EoN> = <BoN> Subtensor <EoN> . <BoN> convert <EoN> ( <BoN> a <EoN> , <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> slice a <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> b <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> b <EoN> != <BoN> sys <EoN> . <BoN> maxsize <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> slice b <EoN> = <BoN> Subtensor <EoN> . <BoN> convert <EoN> ( <BoN> b <EoN> , <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> slice b <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> c <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> slice c <EoN> = <BoN> Subtensor <EoN> . <BoN> convert <EoN> ( <BoN> c <EoN> , <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> slice c <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> slice <EoN> ( <BoN> slice a <EoN> , <BoN> slice b <EoN> , <BoN> slice c <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> entry <EoN> , ( <BoN> integer types <EoN> , <BoN> np <EoN> . <BoN> integer <EoN> ) ) : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Advanced Indexing Error <EoN> ( <BoN> Subtensor <EoN> . <BoN> e indextype <EoN> , <BoN> entry <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> from biadjacency matrix <EoN> ( <BoN> A <EoN> , <BoN> create using <EoN> = <BoN> None <EoN> , <BoN> edge attribute <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> = <BoN> nx <EoN> . <BoN> empty graph <EoN> ( <NUMBER> , <BoN> create using <EoN> ) <NEWLINE> <BoN> n <EoN> , <BoN> m <EoN> = <BoN> A <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> G <EoN> . <BoN> add nodes from <EoN> ( <BoN> range <EoN> ( <BoN> n <EoN> ) , <BoN> bipartite <EoN> = <NUMBER> ) <NEWLINE> <BoN> G <EoN> . <BoN> add nodes from <EoN> ( <BoN> range <EoN> ( <BoN> n <EoN> , <BoN> n <EoN> + <BoN> m <EoN> ) , <BoN> bipartite <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> triples <EoN> = ( ( <BoN> u <EoN> , <BoN> n <EoN> + <BoN> v <EoN> , <BoN> d <EoN> ) <BoN> for <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> d <EoN> ) <BoN> in <EoN> <BoN> generate weighted edges <EoN> ( <BoN> A <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> A <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) <BoN> and <EoN> <BoN> G <EoN> . <BoN> is multigraph <EoN> ( ) : <NEWLINE> <TAB> <BoN> chain <EoN> = <BoN> itertools <EoN> . <BoN> chain <EoN> . <BoN> from iterable <EoN> <NEWLINE> <BoN> triples <EoN> = <BoN> chain <EoN> ( ( ( <BoN> u <EoN> , <BoN> v <EoN> , <NUMBER> ) <BoN> for <EoN> <BoN> d <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> w <EoN> ) ) <BoN> for <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> , <BoN> w <EoN> ) <BoN> in <EoN> <BoN> triples <EoN> ) <NEWLINE> <UNTAB> <BoN> G <EoN> . <BoN> add weighted edges from <EoN> ( <BoN> triples <EoN> , <BoN> weight <EoN> = <BoN> edge attribute <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> max <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> N <EoN> . <BoN> ndarray <EoN> . <BoN> max <EoN> ( <BoN> self <EoN> , <BoN> axis <EoN> , <BoN> out <EoN> , <BoN> keepdims <EoN> = <BoN> True <EoN> ) . <BoN> collapse <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> items <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> modules <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> in ipnb <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> ip <EoN> = <BoN> get ipython <EoN> ( ) <NEWLINE> <BoN> front end <EoN> = ( <NEWLINE> <BoN> ip <EoN> . <BoN> config <EoN> . <BoN> get <EoN> ( <STRING> , { } ) . <BoN> get <EoN> ( <STRING> , <STRING> ) <BoN> or <EoN> <NEWLINE> <BoN> ip <EoN> . <BoN> config <EoN> . <BoN> get <EoN> ( <STRING> , { } ) . <BoN> get <EoN> ( <STRING> , <STRING> ) ) <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> front end <EoN> . <BoN> lower <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check for import lib <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> major version <EoN> , <BoN> minor version <EoN> = <BoN> tuple <EoN> ( <BoN> sys <EoN> . <BoN> version info <EoN> [ : <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> patterns <EoN> = [ <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> stems <EoN> = [ <BoN> sys <EoN> . <BoN> prefix <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> sys <EoN> , <STRING> ) <BoN> and <EoN> <BoN> sys <EoN> . <BoN> base prefix <EoN> != <BoN> sys <EoN> . <BoN> prefix <EoN> : <NEWLINE> <TAB> <BoN> stems <EoN> . <BoN> append <EoN> ( <BoN> sys <EoN> . <BoN> base prefix <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> sys <EoN> , <STRING> ) <BoN> and <EoN> <BoN> sys <EoN> . <BoN> real prefix <EoN> != <BoN> sys <EoN> . <BoN> prefix <EoN> : <NEWLINE> <TAB> <BoN> stems <EoN> . <BoN> append <EoN> ( <BoN> sys <EoN> . <BoN> real prefix <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sub dirs <EoN> = [ <STRING> , <STRING> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> candidates <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> pat <EoN> <BoN> in <EoN> <BoN> patterns <EoN> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> pat <EoN> % ( <BoN> major version <EoN> , <BoN> minor version <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> stem dir <EoN> <BoN> in <EoN> <BoN> stems <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> folder <EoN> <BoN> in <EoN> <BoN> sub dirs <EoN> : <NEWLINE> <TAB> <BoN> candidates <EoN> . <BoN> append <EoN> ( <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> stem dir <EoN> , <BoN> folder <EoN> , <BoN> filename <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> fullname <EoN> <BoN> in <EoN> <BoN> candidates <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> isfile <EoN> ( <BoN> fullname <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> True <EoN> , <BoN> fullname <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> ( <BoN> False <EoN> , <BoN> candidates <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup inner isolate real roots <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> , <BoN> eps <EoN> = <BoN> None <EoN> , <BoN> fast <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> = <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> , <BoN> K <EoN> . <BoN> zero <EoN> , <BoN> K <EoN> . <BoN> one <EoN> <NEWLINE> <NEWLINE> <BoN> k <EoN> = <BoN> dup sign variations <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> roots <EoN> = [ <BoN> dup inner refine real root <EoN> ( <NEWLINE> <BoN> f <EoN> , ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> ) , <BoN> K <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> fast <EoN> = <BoN> fast <EoN> , <BoN> mobius <EoN> = <BoN> True <EoN> ) ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> roots <EoN> , <BoN> stack <EoN> = [ ] , [ ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> , <BoN> f <EoN> , <BoN> k <EoN> ) ] <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> stack <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> , <BoN> f <EoN> , <BoN> k <EoN> = <BoN> stack <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> A <EoN> = <BoN> dup root lower bound <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> A <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> A <EoN> = <BoN> K <EoN> ( <BoN> int <EoN> ( <BoN> A <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> A <EoN> = <BoN> K <EoN> . <BoN> zero <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fast <EoN> <BoN> and <EoN> <BoN> A <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> dup scale <EoN> ( <BoN> f <EoN> , <BoN> A <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> a <EoN> , <BoN> c <EoN> , <BoN> A <EoN> = <BoN> A <EoN> * <BoN> a <EoN> , <BoN> A <EoN> * <BoN> c <EoN> , <BoN> K <EoN> . <BoN> one <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> A <EoN> >= <BoN> K <EoN> . <BoN> one <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> dup shift <EoN> ( <BoN> f <EoN> , <BoN> A <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> b <EoN> , <BoN> d <EoN> = <BoN> A <EoN> * <BoN> a <EoN> + <BoN> b <EoN> , <BoN> A <EoN> * <BoN> c <EoN> + <BoN> d <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dup TC <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( ( <BoN> f <EoN> , ( <BoN> b <EoN> , <BoN> b <EoN> , <BoN> d <EoN> , <BoN> d <EoN> ) ) ) <NEWLINE> <BoN> f <EoN> = <BoN> dup rshift <EoN> ( <BoN> f <EoN> , <NUMBER> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> dup sign variations <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> k <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( <BoN> dup inner refine real root <EoN> ( <NEWLINE> <BoN> f <EoN> , ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> c <EoN> , <BoN> d <EoN> ) , <BoN> K <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> fast <EoN> = <BoN> fast <EoN> , <BoN> mobius <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> f 1 <EoN> = <BoN> dup shift <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> a 1 <EoN> , <BoN> b 1 <EoN> , <BoN> c 1 <EoN> , <BoN> d 1 <EoN> , <BoN> r <EoN> = <BoN> a <EoN> , <BoN> a <EoN> + <BoN> b <EoN> , <BoN> c <EoN> , <BoN> c <EoN> + <BoN> d <EoN> , <NUMBER> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dup TC <EoN> ( <BoN> f 1 <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( ( <BoN> f 1 <EoN> , ( <BoN> b 1 <EoN> , <BoN> b 1 <EoN> , <BoN> d 1 <EoN> , <BoN> d 1 <EoN> ) ) ) <NEWLINE> <BoN> f 1 <EoN> , <BoN> r <EoN> = <BoN> dup rshift <EoN> ( <BoN> f 1 <EoN> , <NUMBER> , <BoN> K <EoN> ) , <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> k 1 <EoN> = <BoN> dup sign variations <EoN> ( <BoN> f 1 <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> k 2 <EoN> = <BoN> k <EoN> - <BoN> k 1 <EoN> - <BoN> r <EoN> <NEWLINE> <NEWLINE> <BoN> a 2 <EoN> , <BoN> b 2 <EoN> , <BoN> c 2 <EoN> , <BoN> d 2 <EoN> = <BoN> b <EoN> , <BoN> a <EoN> + <BoN> b <EoN> , <BoN> d <EoN> , <BoN> c <EoN> + <BoN> d <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k 2 <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> f 2 <EoN> = <BoN> dup shift <EoN> ( <BoN> dup reverse <EoN> ( <BoN> f <EoN> ) , <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dup TC <EoN> ( <BoN> f 2 <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <BoN> f 2 <EoN> = <BoN> dup rshift <EoN> ( <BoN> f 2 <EoN> , <NUMBER> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> k 2 <EoN> = <BoN> dup sign variations <EoN> ( <BoN> f 2 <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> f 2 <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> k 1 <EoN> < <BoN> k 2 <EoN> : <NEWLINE> <TAB> <BoN> a 1 <EoN> , <BoN> a 2 <EoN> , <BoN> b 1 <EoN> , <BoN> b 2 <EoN> = <BoN> a 2 <EoN> , <BoN> a 1 <EoN> , <BoN> b 2 <EoN> , <BoN> b 1 <EoN> <NEWLINE> <BoN> c 1 <EoN> , <BoN> c 2 <EoN> , <BoN> d 1 <EoN> , <BoN> d 2 <EoN> = <BoN> c 2 <EoN> , <BoN> c 1 <EoN> , <BoN> d 2 <EoN> , <BoN> d 1 <EoN> <NEWLINE> <BoN> f 1 <EoN> , <BoN> f 2 <EoN> , <BoN> k 1 <EoN> , <BoN> k 2 <EoN> = <BoN> f 2 <EoN> , <BoN> f 1 <EoN> , <BoN> k 2 <EoN> , <BoN> k 1 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> k 1 <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> f 1 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> f 1 <EoN> = <BoN> dup shift <EoN> ( <BoN> dup reverse <EoN> ( <BoN> f <EoN> ) , <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dup TC <EoN> ( <BoN> f 1 <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <BoN> f 1 <EoN> = <BoN> dup rshift <EoN> ( <BoN> f 1 <EoN> , <NUMBER> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> k 1 <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( <BoN> dup inner refine real root <EoN> ( <NEWLINE> <BoN> f 1 <EoN> , ( <BoN> a 1 <EoN> , <BoN> b 1 <EoN> , <BoN> c 1 <EoN> , <BoN> d 1 <EoN> ) , <BoN> K <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> fast <EoN> = <BoN> fast <EoN> , <BoN> mobius <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> stack <EoN> . <BoN> append <EoN> ( ( <BoN> a 1 <EoN> , <BoN> b 1 <EoN> , <BoN> c 1 <EoN> , <BoN> d 1 <EoN> , <BoN> f 1 <EoN> , <BoN> k 1 <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> k 2 <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> f 2 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> f 2 <EoN> = <BoN> dup shift <EoN> ( <BoN> dup reverse <EoN> ( <BoN> f <EoN> ) , <BoN> K <EoN> . <BoN> one <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> dup TC <EoN> ( <BoN> f 2 <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <BoN> f 2 <EoN> = <BoN> dup rshift <EoN> ( <BoN> f 2 <EoN> , <NUMBER> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> k 2 <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( <BoN> dup inner refine real root <EoN> ( <NEWLINE> <BoN> f 2 <EoN> , ( <BoN> a 2 <EoN> , <BoN> b 2 <EoN> , <BoN> c 2 <EoN> , <BoN> d 2 <EoN> ) , <BoN> K <EoN> , <BoN> eps <EoN> = <BoN> eps <EoN> , <BoN> fast <EoN> = <BoN> fast <EoN> , <BoN> mobius <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> stack <EoN> . <BoN> append <EoN> ( ( <BoN> a 2 <EoN> , <BoN> b 2 <EoN> , <BoN> c 2 <EoN> , <BoN> d 2 <EoN> , <BoN> f 2 <EoN> , <BoN> k 2 <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> roots <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dot graph from checkpoint <EoN> ( <BoN> save path <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> reader <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> New Checkpoint Reader <EoN> ( <BoN> save path <EoN> ) <NEWLINE> <BoN> object graph <EoN> = <BoN> checkpointable utils <EoN> . <BoN> object metadata <EoN> ( <BoN> save path <EoN> ) <NEWLINE> <BoN> shape map <EoN> = <BoN> reader <EoN> . <BoN> get variable to shape map <EoN> ( ) <NEWLINE> <BoN> dtype map <EoN> = <BoN> reader <EoN> . <BoN> get variable to dtype map <EoN> ( ) <NEWLINE> <BoN> graph <EoN> = <STRING> <NEWLINE> <BoN> def <EoN> <BoN> escape <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> name <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) <NEWLINE> <UNTAB> <BoN> slot ids <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> node <EoN> <BoN> in <EoN> <BoN> object graph <EoN> . <BoN> nodes <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> slot reference <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> slot variables <EoN> : <NEWLINE> <TAB> <BoN> slot ids <EoN> . <BoN> add <EoN> ( <BoN> slot reference <EoN> . <BoN> slot variable node id <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> node id <EoN> , <BoN> node <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> object graph <EoN> . <BoN> nodes <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> len <EoN> ( <BoN> node <EoN> . <BoN> attributes <EoN> ) == <NUMBER> <NEWLINE> <BoN> and <EoN> <BoN> node <EoN> . <BoN> attributes <EoN> [ <NUMBER> ] . <BoN> name <EoN> == <BoN> checkpointable <EoN> . <BoN> VARIABLE VALUE KEY <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> node id <EoN> <BoN> in <EoN> <BoN> slot ids <EoN> : <NEWLINE> <TAB> <BoN> color <EoN> = <STRING> <NEWLINE> <BoN> tooltip prefix <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> color <EoN> = <STRING> <NEWLINE> <BoN> tooltip prefix <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> attribute <EoN> = <BoN> node <EoN> . <BoN> attributes <EoN> [ <NUMBER> ] <NEWLINE> <BoN> graph <EoN> += ( <STRING> <NEWLINE> <STRING> ) % ( <NEWLINE> <BoN> node id <EoN> , <NEWLINE> <BoN> color <EoN> , <NEWLINE> <BoN> tooltip prefix <EoN> , <NEWLINE> <BoN> escape <EoN> ( <BoN> attribute <EoN> . <BoN> full name <EoN> ) , <NEWLINE> <BoN> shape map <EoN> [ <BoN> attribute <EoN> . <BoN> checkpoint key <EoN> ] , <NEWLINE> <BoN> dtype map <EoN> [ <BoN> attribute <EoN> . <BoN> checkpoint key <EoN> ] . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> node <EoN> . <BoN> slot variables <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> += ( <STRING> <NEWLINE> <STRING> ) % <BoN> node id <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> += <STRING> % <BoN> node id <EoN> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> reference <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> children <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> += <STRING> % ( <NEWLINE> <BoN> node id <EoN> , <BoN> reference <EoN> . <BoN> node id <EoN> , <BoN> escape <EoN> ( <BoN> reference <EoN> . <BoN> local name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> slot reference <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> slot variables <EoN> : <NEWLINE> <TAB> <BoN> graph <EoN> += <STRING> % ( <NEWLINE> <BoN> node id <EoN> , <NEWLINE> <BoN> slot reference <EoN> . <BoN> slot variable node id <EoN> , <NEWLINE> <BoN> escape <EoN> ( <BoN> slot reference <EoN> . <BoN> slot name <EoN> ) ) <NEWLINE> <BoN> graph <EoN> += <STRING> % ( <NEWLINE> <BoN> slot reference <EoN> . <BoN> original variable node id <EoN> , <NEWLINE> <BoN> slot reference <EoN> . <BoN> slot variable node id <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> graph <EoN> += <STRING> <NEWLINE> <BoN> return <EoN> <BoN> graph <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> max roi pooling <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> fix attribute names <EoN> ( <BoN> attrs <EoN> , <NEWLINE> { <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> } ) <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> new attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> make loss <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> estimator export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> train and evaluate <EoN> ( <BoN> estimator <EoN> , <BoN> train spec <EoN> , <BoN> eval spec <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert eval spec <EoN> ( <BoN> eval spec <EoN> ) <NEWLINE> <NEWLINE> <BoN> executor <EoN> = <BoN> TrainingExecutor <EoN> ( <NEWLINE> <BoN> estimator <EoN> = <BoN> estimator <EoN> , <BoN> train spec <EoN> = <BoN> train spec <EoN> , <BoN> eval spec <EoN> = <BoN> eval spec <EoN> ) <NEWLINE> <BoN> config <EoN> = <BoN> estimator <EoN> . <BoN> config <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> distribute coordinator training <EoN> . <BoN> should run distribute coordinator <EoN> ( <BoN> config <EoN> ) : <NEWLINE> <TAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> ) <NEWLINE> <BoN> distribute coordinator training <EoN> . <BoN> train and evaluate <EoN> ( <NEWLINE> <BoN> estimator <EoN> , <BoN> train spec <EoN> , <BoN> eval spec <EoN> , <BoN> TrainingExecutor <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> config <EoN> . <BoN> task type <EoN> == <BoN> run config lib <EoN> . <BoN> Task Type <EoN> . <BoN> EVALUATO R <EoN> <BoN> and <EoN> <NEWLINE> <BoN> config <EoN> . <BoN> task id <EoN> > <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> config <EoN> . <BoN> task id <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> executor <EoN> . <BoN> run <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> tocsr <EoN> ( <BoN> self <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> tocoo <EoN> ( <BoN> copy <EoN> = <BoN> copy <EoN> ) . <BoN> tocsr <EoN> ( <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> matrix solve <EoN> ( <BoN> matrix <EoN> , <BoN> rhs <EoN> , <BoN> adjoint <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> matrix <EoN> , <BoN> rhs <EoN> , <STRING> , <BoN> adjoint <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> matrix solve eager fallback <EoN> ( <NEWLINE> <BoN> matrix <EoN> , <BoN> rhs <EoN> , <BoN> adjoint <EoN> = <BoN> adjoint <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> matrix solve <EoN> , <BoN> matrix <EoN> = <BoN> matrix <EoN> , <BoN> rhs <EoN> = <BoN> rhs <EoN> , <BoN> adjoint <EoN> = <BoN> adjoint <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> adjoint <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> adjoint <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> adjoint <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> adjoint <EoN> , <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> matrix <EoN> = <BoN> matrix <EoN> , <BoN> rhs <EoN> = <BoN> rhs <EoN> , <BoN> adjoint <EoN> = <BoN> adjoint <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> matrix solve <EoN> , <BoN> matrix <EoN> = <BoN> matrix <EoN> , <BoN> rhs <EoN> = <BoN> rhs <EoN> , <BoN> adjoint <EoN> = <BoN> adjoint <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on attach <EoN> ( <BoN> self <EoN> , <BoN> fgraph <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> already there <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> fgraph <EoN> <BoN> is <EoN> <BoN> fgraph <EoN> : <NEWLINE> <TAB> <BoN> already there <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> fgraph <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> attr <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> fgraph <EoN> , <BoN> attr <EoN> ) : <NEWLINE> <TAB> <BoN> already there <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> already there <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> toolbox <EoN> . <BoN> Already There <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> unpickle <EoN> ( <BoN> fgraph <EoN> ) <NEWLINE> <BoN> fgraph <EoN> . <BoN> destroy handler <EoN> = <BoN> self <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> fgraph <EoN> = <BoN> fgraph <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> destroyers <EoN> = <BoN> Ordered Set <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> view i <EoN> = { } <NEWLINE> <BoN> self <EoN> . <BoN> view o <EoN> = { } <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> clients <EoN> = <BoN> Ordered Dict <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> stale droot <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> debug all apps <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> do imports on attach <EoN> : <NEWLINE> <TAB> <BoN> toolbox <EoN> . <BoN> Bookkeeper <EoN> . <BoN> on attach <EoN> ( <BoN> self <EoN> , <BoN> fgraph <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> find <EoN> ( <BoN> self <EoN> , <BoN> query <EoN> , <BoN> group <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> query <EoN> = <BoN> make find query <EoN> ( <BoN> query <EoN> ) <NEWLINE> <BoN> results <EoN> = <BoN> list <EoN> ( <BoN> filter <EoN> ( <BoN> query <EoN> , <BoN> preorder traversal <EoN> ( <BoN> self <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> group <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> set <EoN> ( <BoN> results <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> groups <EoN> = { } <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> result <EoN> <BoN> in <EoN> <BoN> results <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> result <EoN> <BoN> in <EoN> <BoN> groups <EoN> : <NEWLINE> <TAB> <BoN> groups <EoN> [ <BoN> result <EoN> ] += <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> groups <EoN> [ <BoN> result <EoN> ] = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> groups <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> default helper c code args <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> { <STRING> : <STRING> , <NEWLINE> <STRING> : <NUMBER> } <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> stack <EoN> ( * <BoN> data <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> np datetime 64 compat <EoN> ( <BoN> s <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np version under 1 p 11 <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> tz replacer <EoN> ( <BoN> s <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> datetime 64 <EoN> ( <BoN> s <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> slice <EoN> ( <BoN> self <EoN> , <BoN> slicer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get values <EoN> ( ) [ <BoN> slicer <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> marker <EoN> = <BoN> None <EoN> , <BoN> fillstyle <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> marker function <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> set fillstyle <EoN> ( <BoN> fillstyle <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> set marker <EoN> ( <BoN> marker <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on timer <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> func <EoN> , <BoN> args <EoN> , <BoN> kwargs <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> callbacks <EoN> : <NEWLINE> <TAB> <BoN> ret <EoN> = <BoN> func <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> ret <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> callbacks <EoN> . <BoN> remove <EoN> ( ( <BoN> func <EoN> , <BoN> args <EoN> , <BoN> kwargs <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> callbacks <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> stop <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set Break <EoN> ( <BoN> self <EoN> , <BoN> break Flag <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> break Flag <EoN> : <NEWLINE> <TAB> <BoN> parseMethod <EoN> = <BoN> self <EoN> . <BoN> parse <EoN> <NEWLINE> <BoN> def <EoN> <BoN> breaker <EoN> ( <BoN> instring <EoN> , <BoN> loc <EoN> , <BoN> do Actions <EoN> = <BoN> True <EoN> , <BoN> call Pre Parse <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> pdb <EoN> <NEWLINE> <BoN> pdb <EoN> . <BoN> set trace <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> parseMethod <EoN> ( <BoN> instring <EoN> , <BoN> loc <EoN> , <BoN> do Actions <EoN> , <BoN> call Pre Parse <EoN> ) <NEWLINE> <UNTAB> <BoN> breaker <EoN> . <BoN> originalParseMethod <EoN> = <BoN> parseMethod <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> parse <EoN> = <BoN> breaker <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> . <BoN> parse <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> parse <EoN> = <BoN> self <EoN> . <BoN> parse <EoN> . <BoN> originalParseMethod <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> resource apply sparse <EoN> ( <BoN> self <EoN> , <BoN> grad <EoN> , <BoN> handle <EoN> , <BoN> indices <EoN> , <BoN> state <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> normal conjugates known scale predictive <EoN> ( <BoN> prior <EoN> , <BoN> scale <EoN> , <BoN> s <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> prior <EoN> , <BoN> normal <EoN> . <BoN> Normal <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> s <EoN> . <BoN> dtype <EoN> != <BoN> prior <EoN> . <BoN> dtype <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> % ( <BoN> s <EoN> . <BoN> dtype <EoN> , <BoN> prior <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> n <EoN> , <BoN> prior <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> scale 0 2 <EoN> = <BoN> math ops <EoN> . <BoN> square <EoN> ( <BoN> prior <EoN> . <BoN> scale <EoN> ) <NEWLINE> <BoN> scale 2 <EoN> = <BoN> math ops <EoN> . <BoN> square <EoN> ( <BoN> scale <EoN> ) <NEWLINE> <BoN> scalep 2 <EoN> = <NUMBER> / ( <NUMBER> / <BoN> scale 0 2 <EoN> + <BoN> n <EoN> / <BoN> scale 2 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> normal <EoN> . <BoN> Normal <EoN> ( <NEWLINE> <BoN> loc <EoN> = ( <BoN> prior <EoN> . <BoN> loc <EoN> / <BoN> scale 0 2 <EoN> + <BoN> s <EoN> / <BoN> scale 2 <EoN> ) * <BoN> scalep 2 <EoN> , <NEWLINE> <BoN> scale <EoN> = <BoN> math ops <EoN> . <BoN> sqrt <EoN> ( <BoN> scalep 2 <EoN> + <BoN> scale 2 <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> flatten <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> integrate <EoN> ( <BoN> self <EoN> , <BoN> ranges <EoN> , <BoN> extrapolate <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> ndim <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> extrapolate <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> extrapolate <EoN> = <BoN> self <EoN> . <BoN> extrapolate <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> extrapolate <EoN> = <BoN> bool <EoN> ( <BoN> extrapolate <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> ranges <EoN> , <STRING> ) <BoN> or <EoN> <BoN> len <EoN> ( <BoN> ranges <EoN> ) != <BoN> ndim <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> ensure c contiguous <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> c <EoN> = <BoN> self <EoN> . <BoN> c <EoN> <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> , ( <BoN> a <EoN> , <BoN> b <EoN> ) <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> ranges <EoN> ) : <NEWLINE> <TAB> <BoN> swap <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( <BoN> c <EoN> . <BoN> ndim <EoN> ) ) <NEWLINE> <BoN> swap <EoN> . <BoN> insert <EoN> ( <NUMBER> , <BoN> swap <EoN> [ <BoN> ndim <EoN> - <BoN> n <EoN> ] ) <NEWLINE> <BoN> del <EoN> <BoN> swap <EoN> [ <BoN> ndim <EoN> - <BoN> n <EoN> + <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> c <EoN> = <BoN> c <EoN> . <BoN> transpose <EoN> ( <BoN> swap <EoN> ) <NEWLINE> <NEWLINE> <BoN> p <EoN> = <BoN> P Poly <EoN> . <BoN> construct fast <EoN> ( <BoN> c <EoN> , <BoN> self <EoN> . <BoN> x <EoN> [ <BoN> n <EoN> ] , <BoN> extrapolate <EoN> = <BoN> extrapolate <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> p <EoN> . <BoN> integrate <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> extrapolate <EoN> = <BoN> extrapolate <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> out <EoN> . <BoN> reshape <EoN> ( <BoN> c <EoN> . <BoN> shape <EoN> [ <NUMBER> : ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> matvec <EoN> ( <BoN> self <EoN> , <BoN> v <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> collapsed <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> self <EoN> . <BoN> collapsed <EoN> , <BoN> v <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Low Rank Matrix <EoN> . <BoN> matvec <EoN> ( <BoN> v <EoN> , <BoN> self <EoN> . <BoN> alpha <EoN> , <BoN> self <EoN> . <BoN> cs <EoN> , <BoN> self <EoN> . <BoN> ds <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ensure index <EoN> ( <BoN> index like <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> index like <EoN> , <BoN> Index <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> index like <EoN> = <BoN> index like <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> index like <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> index like <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Index <EoN> ( <BoN> index like <EoN> , <BoN> name <EoN> = <BoN> index like <EoN> . <BoN> name <EoN> , <BoN> copy <EoN> = <BoN> copy <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> is iterator <EoN> ( <BoN> index like <EoN> ) : <NEWLINE> <TAB> <BoN> index like <EoN> = <BoN> list <EoN> ( <BoN> index like <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> index like <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> index like <EoN> ) != <BoN> list <EoN> : <NEWLINE> <TAB> <BoN> index like <EoN> = <BoN> list <EoN> ( <BoN> index like <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> converted <EoN> , <BoN> all arrays <EoN> = <BoN> lib <EoN> . <BoN> clean index list <EoN> ( <BoN> index like <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> converted <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> all arrays <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> . <BoN> multi <EoN> <BoN> import <EoN> <BoN> Multi Index <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Multi Index <EoN> . <BoN> from arrays <EoN> ( <BoN> converted <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> index like <EoN> = <BoN> converted <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> copy <EoN> <BoN> import <EoN> <BoN> copy <EoN> <NEWLINE> <BoN> index like <EoN> = <BoN> copy <EoN> ( <BoN> index like <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> Index <EoN> ( <BoN> index like <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> random transform <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> params <EoN> = <BoN> self <EoN> . <BoN> get random transform <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> , <BoN> seed <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> apply transform <EoN> ( <BoN> x <EoN> , <BoN> params <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> interpolate <EoN> ( <BoN> input <EoN> , <BoN> size <EoN> = <BoN> None <EoN> , <BoN> scale factor <EoN> = <BoN> None <EoN> , <BoN> mode <EoN> = <STRING> , <BoN> align corners <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> numbers <EoN> <BoN> import <EoN> <BoN> Integral <EoN> <NEWLINE> <BoN> from <EoN> . <BoN> modules <EoN> . <BoN> utils <EoN> <BoN> import <EoN> <BoN> ntuple <EoN> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> check size scale factor <EoN> ( <BoN> dim <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> size <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> scale factor <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> size <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> scale factor <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> scale factor <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> scale factor <EoN> , <BoN> tuple <EoN> ) <BoN> and <EoN> <BoN> len <EoN> ( <BoN> scale factor <EoN> ) != <BoN> dim <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> dim <EoN> , <BoN> len <EoN> ( <BoN> scale factor <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> def <EoN> <BoN> output size <EoN> ( <BoN> dim <EoN> ) : <NEWLINE> <TAB> <BoN> check size scale factor <EoN> ( <BoN> dim <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> size <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> size <EoN> <NEWLINE> <UNTAB> <BoN> scale factors <EoN> = <BoN> ntuple <EoN> ( <BoN> dim <EoN> ) ( <BoN> scale factor <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> int <EoN> ( <BoN> math <EoN> . <BoN> floor <EoN> ( <BoN> input <EoN> . <BoN> size <EoN> ( <BoN> i <EoN> + <NUMBER> ) * <BoN> scale factors <EoN> [ <BoN> i <EoN> ] ) ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> dim <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mode <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> align corners <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> align corners <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> mode <EoN> ) ) <NEWLINE> <BoN> align corners <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample nearest 1 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample nearest 2 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample nearest 3 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> adaptive avg pool 1 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> adaptive avg pool 2 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> adaptive avg pool 3 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample linear 1 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) , <BoN> align corners <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample bilinear 2 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) , <BoN> align corners <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> input <EoN> . <BoN> dim <EoN> ( ) == <NUMBER> <BoN> and <EoN> <BoN> mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> nn <EoN> . <BoN> upsample trilinear 3 d <EoN> ( <BoN> input <EoN> , <BoN> output size <EoN> ( <NUMBER> ) , <BoN> align corners <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> input <EoN> . <BoN> dim <EoN> ( ) , <BoN> mode <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abc <EoN> . <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> evaluate <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> plot <EoN> ( <BoN> self <EoN> , <BoN> ax <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> line kwargs <EoN> = <BoN> dict <EoN> ( <BoN> linewidths <EoN> = <NUMBER> , <BoN> colors <EoN> = <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rotate <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> lines <EoN> = <BoN> Line Collection <EoN> ( [ <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> dependent coord <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> independent coord <EoN> ) ] , <NEWLINE> ** <BoN> line kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> lines <EoN> = <BoN> Line Collection <EoN> ( [ <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> x <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> self <EoN> . <BoN> independent coord <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> dependent coord <EoN> ) ] , <NEWLINE> ** <BoN> line kwargs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> ax <EoN> . <BoN> add collection <EoN> ( <BoN> lines <EoN> ) <NEWLINE> <BoN> number of leaves <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> reordered ind <EoN> ) <NEWLINE> <BoN> max dependent coord <EoN> = <BoN> max <EoN> ( <BoN> map <EoN> ( <BoN> max <EoN> , <BoN> self <EoN> . <BoN> dependent coord <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rotate <EoN> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> yaxis <EoN> . <BoN> set ticks position <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> ax <EoN> . <BoN> set ylim <EoN> ( <NUMBER> , <BoN> number of leaves <EoN> * <NUMBER> ) <NEWLINE> <BoN> ax <EoN> . <BoN> set xlim <EoN> ( <NUMBER> , <BoN> max dependent coord <EoN> * <NUMBER> ) <NEWLINE> <NEWLINE> <BoN> ax <EoN> . <BoN> invert xaxis <EoN> ( ) <NEWLINE> <BoN> ax <EoN> . <BoN> invert yaxis <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> set xlim <EoN> ( <NUMBER> , <BoN> number of leaves <EoN> * <NUMBER> ) <NEWLINE> <BoN> ax <EoN> . <BoN> set ylim <EoN> ( <NUMBER> , <BoN> max dependent coord <EoN> * <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> despine <EoN> ( <BoN> ax <EoN> = <BoN> ax <EoN> , <BoN> bottom <EoN> = <BoN> True <EoN> , <BoN> left <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> ax <EoN> . <BoN> set <EoN> ( <BoN> xticks <EoN> = <BoN> self <EoN> . <BoN> xticks <EoN> , <BoN> yticks <EoN> = <BoN> self <EoN> . <BoN> yticks <EoN> , <NEWLINE> <BoN> xlabel <EoN> = <BoN> self <EoN> . <BoN> xlabel <EoN> , <BoN> ylabel <EoN> = <BoN> self <EoN> . <BoN> ylabel <EoN> ) <NEWLINE> <BoN> xtl <EoN> = <BoN> ax <EoN> . <BoN> set xticklabels <EoN> ( <BoN> self <EoN> . <BoN> xticklabels <EoN> ) <NEWLINE> <BoN> ytl <EoN> = <BoN> ax <EoN> . <BoN> set yticklabels <EoN> ( <BoN> self <EoN> . <BoN> yticklabels <EoN> , <BoN> rotation <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> ax <EoN> . <BoN> figure <EoN> . <BoN> canvas <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> figure <EoN> . <BoN> draw <EoN> ( <BoN> ax <EoN> . <BoN> figure <EoN> . <BoN> canvas <EoN> . <BoN> get renderer <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> ytl <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> axis ticklabels overlap <EoN> ( <BoN> ytl <EoN> ) : <NEWLINE> <TAB> <BoN> plt <EoN> . <BoN> setp <EoN> ( <BoN> ytl <EoN> , <BoN> rotation <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> xtl <EoN> ) > <NUMBER> <BoN> and <EoN> <BoN> axis ticklabels overlap <EoN> ( <BoN> xtl <EoN> ) : <NEWLINE> <TAB> <BoN> plt <EoN> . <BoN> setp <EoN> ( <BoN> xtl <EoN> , <BoN> rotation <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add tools to container <EoN> ( <BoN> container <EoN> , <BoN> tools <EoN> = <BoN> default toolbar tools <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> group <EoN> , <BoN> grouptools <EoN> <BoN> in <EoN> <BoN> tools <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> position <EoN> , <BoN> tool <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> grouptools <EoN> ) : <NEWLINE> <TAB> <BoN> container <EoN> . <BoN> add tool <EoN> ( <BoN> tool <EoN> , <BoN> group <EoN> , <BoN> position <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> get saver <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> saver <EoN> = <BoN> get first op from collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> saver <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> saver <EoN> : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> saver <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> saver <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> variables <EoN> . <BoN> global variables <EoN> ( ) : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> tf saver <EoN> . <BoN> Saver <EoN> ( ) <NEWLINE> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> SAVER S <EoN> , <BoN> saver <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> saver <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> long <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> type <EoN> ( <BoN> type <EoN> ( <BoN> self <EoN> ) . <BoN> module <EoN> + <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get loc <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> method <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> codes <EoN> = <BoN> self <EoN> . <BoN> categories <EoN> . <BoN> get loc <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> if <EoN> ( <BoN> codes <EoN> == - <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> engine <EoN> . <BoN> get loc <EoN> ( <BoN> codes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> modify <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> phil <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> [ <BoN> name <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> value <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> attr <EoN> = <BoN> h 5 a <EoN> . <BoN> open <EoN> ( <BoN> self <EoN> . <BoN> id <EoN> , <BoN> self <EoN> . <BoN> e <EoN> ( <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is empty dataspace <EoN> ( <BoN> attr <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> IO Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> value <EoN> . <BoN> shape <EoN> != <BoN> attr <EoN> . <BoN> shape <EoN> ) <BoN> and <EoN> <BoN> not <EoN> ( <BoN> numpy <EoN> . <BoN> product <EoN> ( <BoN> value <EoN> . <BoN> shape <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> numpy <EoN> . <BoN> product <EoN> ( <BoN> attr <EoN> . <BoN> shape <EoN> ) == <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> attr <EoN> . <BoN> write <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast chunks <EoN> ( * <BoN> chunkss <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> chunkss <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> chunkss <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> chunkss <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> max <EoN> ( <BoN> map <EoN> ( <BoN> len <EoN> , <BoN> chunkss <EoN> ) ) <NEWLINE> <BoN> chunkss 2 <EoN> = [ ( ( <NUMBER> , ) , ) * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> c <EoN> ) ) + <BoN> c <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> chunkss <EoN> ] <NEWLINE> <BoN> result <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> step 1 <EoN> = [ <BoN> c <EoN> [ <BoN> i <EoN> ] <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> chunkss 2 <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> all <EoN> ( <BoN> c <EoN> == ( <NUMBER> , ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> step 1 <EoN> ) : <NEWLINE> <TAB> <BoN> step 2 <EoN> = <BoN> step 1 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> step 2 <EoN> = [ <BoN> c <EoN> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> step 1 <EoN> <BoN> if <EoN> <BoN> c <EoN> != ( <NUMBER> , ) ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> set <EoN> ( <BoN> step 2 <EoN> ) ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> str <EoN> ( <BoN> step 2 <EoN> ) ) <NEWLINE> <UNTAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> step 2 <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cdf 2 rdf <EoN> ( <BoN> w <EoN> , <BoN> v <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> w <EoN> , <BoN> v <EoN> = <BoN> asarray validated <EoN> ( <BoN> w <EoN> ) , <BoN> asarray validated <EoN> ( <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> w <EoN> . <BoN> ndim <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> v <EoN> . <BoN> ndim <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> v <EoN> . <BoN> ndim <EoN> != <BoN> w <EoN> . <BoN> ndim <EoN> + <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> w <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> M <EoN> = <BoN> w <EoN> . <BoN> shape <EoN> [ : - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> v <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] != <BoN> v <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> v <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] != <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> complex mask <EoN> = <BoN> iscomplex <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> n complex <EoN> = <BoN> complex mask <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = - <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> n complex <EoN> % <NUMBER> == <NUMBER> ) . <BoN> all <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> idx <EoN> = <BoN> nonzero <EoN> ( <BoN> complex mask <EoN> ) <NEWLINE> <BoN> idx stack <EoN> = <BoN> idx <EoN> [ : - <NUMBER> ] <NEWLINE> <BoN> idx elem <EoN> = <BoN> idx <EoN> [ - <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> j <EoN> = <BoN> idx elem <EoN> [ <NUMBER> : : <NUMBER> ] <NEWLINE> <BoN> k <EoN> = <BoN> idx elem <EoN> [ <NUMBER> : : <NUMBER> ] <NEWLINE> <BoN> stack ind <EoN> = ( ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> idx stack <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> assert <EoN> ( <BoN> i <EoN> [ <NUMBER> : : <NUMBER> ] == <BoN> i <EoN> [ <NUMBER> : : <NUMBER> ] ) . <BoN> all <EoN> ( ) , <STRING> <NEWLINE> <BoN> stack ind <EoN> += ( <BoN> i <EoN> [ <NUMBER> : : <NUMBER> ] , ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> wr <EoN> = <BoN> zeros <EoN> ( <BoN> M <EoN> + ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> w <EoN> . <BoN> real <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> di <EoN> = <BoN> range <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> wr <EoN> [ ... , <BoN> di <EoN> , <BoN> di <EoN> ] = <BoN> w <EoN> . <BoN> real <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> wr <EoN> [ <BoN> stack ind <EoN> + ( <BoN> j <EoN> , <BoN> k <EoN> ) ] = <BoN> w <EoN> [ <BoN> stack ind <EoN> + ( <BoN> j <EoN> , ) ] . <BoN> imag <EoN> <NEWLINE> <BoN> wr <EoN> [ <BoN> stack ind <EoN> + ( <BoN> k <EoN> , <BoN> j <EoN> ) ] = <BoN> w <EoN> [ <BoN> stack ind <EoN> + ( <BoN> k <EoN> , ) ] . <BoN> imag <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> u <EoN> = <BoN> zeros <EoN> ( <BoN> M <EoN> + ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> numpy <EoN> . <BoN> cdouble <EoN> ) <NEWLINE> <BoN> u <EoN> [ ... , <BoN> di <EoN> , <BoN> di <EoN> ] = <NUMBER> <NEWLINE> <BoN> u <EoN> [ <BoN> stack ind <EoN> + ( <BoN> j <EoN> , <BoN> j <EoN> ) ] = <NUMBER> <NEWLINE> <BoN> u <EoN> [ <BoN> stack ind <EoN> + ( <BoN> j <EoN> , <BoN> k <EoN> ) ] = <NUMBER> <NEWLINE> <BoN> u <EoN> [ <BoN> stack ind <EoN> + ( <BoN> k <EoN> , <BoN> j <EoN> ) ] = - <NUMBER> <NEWLINE> <BoN> u <EoN> [ <BoN> stack ind <EoN> + ( <BoN> k <EoN> , <BoN> k <EoN> ) ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> vr <EoN> = <BoN> einsum <EoN> ( <STRING> , <BoN> v <EoN> , <BoN> u <EoN> ) . <BoN> real <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> wr <EoN> , <BoN> vr <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> concatenate <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> other <EoN> = <BoN> as shape <EoN> ( <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> dims <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> other <EoN> . <BoN> dims <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> unknown shape <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Tensor Shape <EoN> ( <BoN> self <EoN> . <BoN> dims <EoN> + <BoN> other <EoN> . <BoN> dims <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> update core <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> iteration <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write header <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> shape <EoN> , <BoN> P <EoN> = <BoN> mi DOUBL E <EoN> , <BoN> T <EoN> = <BoN> mxFULL CLASS <EoN> , <BoN> imagf <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> header <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( ( ) , <BoN> mdtypes template <EoN> [ <STRING> ] ) <NEWLINE> <BoN> M <EoN> = <BoN> not <EoN> <BoN> SYS LITTLE ENDIAN <EoN> <NEWLINE> <BoN> O <EoN> = <NUMBER> <NEWLINE> <BoN> header <EoN> [ <STRING> ] = ( <BoN> M <EoN> * <NUMBER> + <NEWLINE> <BoN> O <EoN> * <NUMBER> + <NEWLINE> <BoN> P <EoN> * <NUMBER> + <NEWLINE> <BoN> T <EoN> ) <NEWLINE> <BoN> header <EoN> [ <STRING> ] = <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> header <EoN> [ <STRING> ] = <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> header <EoN> [ <STRING> ] = <BoN> imagf <EoN> <NEWLINE> <BoN> header <EoN> [ <STRING> ] = <BoN> len <EoN> ( <BoN> name <EoN> ) + <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> write bytes <EoN> ( <BoN> header <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> write string <EoN> ( <BoN> asbytes <EoN> ( <BoN> name <EoN> + <STRING> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> div no nan <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> div no nan eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> integer nthroot <EoN> ( <BoN> y <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y <EoN> , <BoN> n <EoN> = <BoN> as int <EoN> ( <BoN> y <EoN> ) , <BoN> as int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> y <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> y <EoN> <BoN> in <EoN> ( <NUMBER> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> y <EoN> , <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> y <EoN> , <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> rem <EoN> = <BoN> mpmath sqrtrem <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> x <EoN> ) , <BoN> not <EoN> <BoN> rem <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> > <BoN> y <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> , <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> guess <EoN> = <BoN> int <EoN> ( <BoN> y <EoN> ** ( <NUMBER> / <BoN> n <EoN> ) + <NUMBER> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Overflow Error <EoN> : <NEWLINE> <TAB> <BoN> exp <EoN> = <BoN> log <EoN> ( <BoN> y <EoN> , <NUMBER> ) / <BoN> n <EoN> <NEWLINE> <BoN> if <EoN> <BoN> exp <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> shift <EoN> = <BoN> int <EoN> ( <BoN> exp <EoN> - <NUMBER> ) <NEWLINE> <BoN> guess <EoN> = <BoN> int <EoN> ( <NUMBER> ** ( <BoN> exp <EoN> - <BoN> shift <EoN> ) + <NUMBER> ) << <BoN> shift <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> guess <EoN> = <BoN> int <EoN> ( <NUMBER> ** <BoN> exp <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> guess <EoN> > <NUMBER> ** <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> xprev <EoN> , <BoN> x <EoN> = - <NUMBER> , <BoN> guess <EoN> <NEWLINE> <BoN> while <EoN> <NUMBER> : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> x <EoN> ** ( <BoN> n <EoN> - <NUMBER> ) <NEWLINE> <BoN> xprev <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , ( ( <BoN> n <EoN> - <NUMBER> ) * <BoN> x <EoN> + <BoN> y <EoN> // <BoN> t <EoN> ) // <BoN> n <EoN> <NEWLINE> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> x <EoN> - <BoN> xprev <EoN> ) < <NUMBER> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> guess <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> t <EoN> = <BoN> x <EoN> ** <BoN> n <EoN> <NEWLINE> <BoN> while <EoN> <BoN> t <EoN> < <BoN> y <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> += <NUMBER> <NEWLINE> <BoN> t <EoN> = <BoN> x <EoN> ** <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> t <EoN> > <BoN> y <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> -= <NUMBER> <NEWLINE> <BoN> t <EoN> = <BoN> x <EoN> ** <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> int <EoN> ( <BoN> x <EoN> ) , <BoN> t <EoN> == <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dijkstra path <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> target <EoN> , <BoN> weight <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> ( <BoN> length <EoN> , <BoN> path <EoN> ) = <BoN> single source dijkstra <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> target <EoN> = <BoN> target <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> path <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is symbolic <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval is symbolic <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> freeze <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> G <EoN> . <BoN> add node <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> add nodes from <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> remove node <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> remove nodes from <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> add edge <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> add edges from <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> add weighted edges from <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> remove edge <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> remove edges from <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> clear <EoN> = <BoN> frozen <EoN> <NEWLINE> <BoN> G <EoN> . <BoN> frozen <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rem <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> take grad <EoN> ( <BoN> self <EoN> , <BoN> num required <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> gen data flow ops <EoN> . <BoN> sparse accumulator take gradient <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> accumulator ref <EoN> , <BoN> num required <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> quo <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> GMPY Rational <EoN> ( <BoN> a <EoN> ) / <BoN> GMPY Rational <EoN> ( <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> freeze graph with def protos <EoN> ( <BoN> input graph def <EoN> , <BoN> output node names <EoN> , <NEWLINE> <BoN> initializer names <EoN> , <BoN> shared init op name <EoN> , <NEWLINE> <BoN> input saver def <EoN> , <BoN> input checkpoint <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> Graph <EoN> ( ) . <BoN> as default <EoN> ( ) : <NEWLINE> <TAB> <BoN> <EoN> = <BoN> importer <EoN> . <BoN> import graph def <EoN> ( <BoN> input graph def <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> session <EoN> . <BoN> Session <EoN> ( ) <BoN> as <EoN> <BoN> sess <EoN> : <NEWLINE> <TAB> <BoN> saver <EoN> = <BoN> saver lib <EoN> . <BoN> Saver <EoN> ( <BoN> saver def <EoN> = <BoN> input saver def <EoN> ) <NEWLINE> <BoN> saver <EoN> . <BoN> restore <EoN> ( <BoN> sess <EoN> , <BoN> input checkpoint <EoN> ) <NEWLINE> <BoN> output graph def <EoN> = <BoN> graph util <EoN> . <BoN> convert variables to constants <EoN> ( <NEWLINE> <BoN> sess <EoN> , <BoN> input graph def <EoN> , <BoN> output node names <EoN> + <BoN> initializer names <EoN> ) <NEWLINE> <BoN> connect to shared init op <EoN> ( <BoN> output graph def <EoN> , <BoN> shared init op name <EoN> , <NEWLINE> <BoN> initializer names <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> output graph def <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> monomial gcd <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tuple <EoN> ( [ <BoN> min <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <BoN> for <EoN> <BoN> a <EoN> , <BoN> b <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> floyd warshall numpy <EoN> ( <BoN> G <EoN> , <BoN> nodelist <EoN> = <BoN> None <EoN> , <BoN> weight <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> numpy <EoN> <BoN> as <EoN> <BoN> np <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> A <EoN> = <BoN> nx <EoN> . <BoN> to numpy matrix <EoN> ( <BoN> G <EoN> , <BoN> nodelist <EoN> = <BoN> nodelist <EoN> , <BoN> multigraph weight <EoN> = <BoN> min <EoN> , <NEWLINE> <BoN> weight <EoN> = <BoN> weight <EoN> , <BoN> nonedge <EoN> = <BoN> np <EoN> . <BoN> inf <EoN> ) <NEWLINE> <BoN> n <EoN> , <BoN> m <EoN> = <BoN> A <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> I <EoN> = <BoN> np <EoN> . <BoN> identity <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> A <EoN> [ <BoN> I <EoN> == <NUMBER> ] = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> A <EoN> = <BoN> np <EoN> . <BoN> minimum <EoN> ( <BoN> A <EoN> , <BoN> A <EoN> [ <BoN> i <EoN> , : ] + <BoN> A <EoN> [ : , <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> A <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get mnist pkl <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> isdir <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> os <EoN> . <BoN> makedirs <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> exists <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> download <EoN> ( <STRING> , <NEWLINE> <BoN> dirname <EoN> = <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> string to number <EoN> ( <BoN> string tensor <EoN> , <BoN> out type <EoN> = <BoN> dtypes <EoN> . <BoN> float 32 <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> string tensor <EoN> , <NEWLINE> <STRING> , <BoN> out type <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> string to number eager fallback <EoN> ( <NEWLINE> <BoN> string tensor <EoN> , <BoN> out type <EoN> = <BoN> out type <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> out type <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> out type <EoN> = <BoN> dtypes <EoN> . <BoN> float 32 <EoN> <NEWLINE> <UNTAB> <BoN> out type <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> out type <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> string tensor <EoN> = <BoN> string tensor <EoN> , <BoN> out type <EoN> = <BoN> out type <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> variable axis size partitioner <EoN> ( <NEWLINE> <BoN> max shard bytes <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> bytes per string element <EoN> = <NUMBER> , <BoN> max shards <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> max shard bytes <EoN> < <NUMBER> <BoN> or <EoN> <BoN> bytes per string element <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> max shards <EoN> <BoN> and <EoN> <BoN> max shards <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> partitioner <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> shape <EoN> , <BoN> tensor shape <EoN> . <BoN> Tensor Shape <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> shape <EoN> . <BoN> is fully defined <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> dtype <EoN> , <BoN> dtypes <EoN> . <BoN> D Type <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dtype <EoN> . <BoN> base dtype <EoN> == <BoN> dtypes <EoN> . <BoN> string <EoN> : <NEWLINE> <TAB> <BoN> element size <EoN> = <BoN> bytes per string element <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> element size <EoN> = <BoN> dtype <EoN> . <BoN> size <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> partitions <EoN> = [ <NUMBER> ] * <BoN> shape <EoN> . <BoN> ndims <EoN> <NEWLINE> <BoN> bytes per slice <EoN> = <NUMBER> * ( <NEWLINE> <BoN> shape <EoN> . <BoN> num elements <EoN> ( ) / <BoN> shape <EoN> . <BoN> dims <EoN> [ <BoN> axis <EoN> ] . <BoN> value <EoN> ) * <BoN> element size <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> slices per shard <EoN> = <BoN> max <EoN> ( <NUMBER> , <BoN> math <EoN> . <BoN> floor <EoN> ( <BoN> max shard bytes <EoN> / <BoN> bytes per slice <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> axis shards <EoN> = <BoN> int <EoN> ( <BoN> math <EoN> . <BoN> ceil <EoN> ( <NEWLINE> <NUMBER> * <BoN> shape <EoN> . <BoN> dims <EoN> [ <BoN> axis <EoN> ] . <BoN> value <EoN> / <BoN> slices per shard <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> max shards <EoN> : <NEWLINE> <TAB> <BoN> axis shards <EoN> = <BoN> min <EoN> ( <BoN> max shards <EoN> , <BoN> axis shards <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> partitions <EoN> [ <BoN> axis <EoN> ] = <BoN> axis shards <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> partitions <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> partitioner <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set device <EoN> ( <BoN> self <EoN> , <BoN> device <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> device <EoN> = <BoN> device <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read eval metrics <EoN> ( <BoN> eval dir <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> eval metrics dict <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> event <EoN> <BoN> in <EoN> <BoN> summaries <EoN> ( <BoN> eval dir <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> event <EoN> . <BoN> Has Field <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> metrics <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> value <EoN> <BoN> in <EoN> <BoN> event <EoN> . <BoN> summary <EoN> . <BoN> value <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> value <EoN> . <BoN> Has Field <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> metrics <EoN> [ <BoN> value <EoN> . <BoN> tag <EoN> ] = <BoN> value <EoN> . <BoN> simple value <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> metrics <EoN> : <NEWLINE> <TAB> <BoN> eval metrics dict <EoN> [ <BoN> event <EoN> . <BoN> step <EoN> ] = <BoN> metrics <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> collections <EoN> . <BoN> Ordered Dict <EoN> ( <NEWLINE> <BoN> sorted <EoN> ( <BoN> eval metrics dict <EoN> . <BoN> items <EoN> ( ) , <BoN> key <EoN> = <BoN> lambda <EoN> <BoN> t <EoN> : <BoN> t <EoN> [ <NUMBER> ] ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> char ngrams <EoN> ( <BoN> self <EoN> , <BoN> text document <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> text document <EoN> = <BoN> self <EoN> . <BoN> white spaces <EoN> . <BoN> sub <EoN> ( <STRING> , <BoN> text document <EoN> ) <NEWLINE> <NEWLINE> <BoN> text len <EoN> = <BoN> len <EoN> ( <BoN> text document <EoN> ) <NEWLINE> <BoN> min n <EoN> , <BoN> max n <EoN> = <BoN> self <EoN> . <BoN> ngram range <EoN> <NEWLINE> <BoN> if <EoN> <BoN> min n <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> ngrams <EoN> = <BoN> list <EoN> ( <BoN> text document <EoN> ) <NEWLINE> <BoN> min n <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ngrams <EoN> = [ ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> ngrams append <EoN> = <BoN> ngrams <EoN> . <BoN> append <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> min n <EoN> , <BoN> min <EoN> ( <BoN> max n <EoN> + <NUMBER> , <BoN> text len <EoN> + <NUMBER> ) ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> text len <EoN> - <BoN> n <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> ngrams append <EoN> ( <BoN> text document <EoN> [ <BoN> i <EoN> : <BoN> i <EoN> + <BoN> n <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> ngrams <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> mutate <EoN> ( <BoN> self <EoN> , <BoN> candidate <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> trial <EoN> = <BoN> np <EoN> . <BoN> copy <EoN> ( <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> candidate <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> rng <EoN> = <BoN> self <EoN> . <BoN> random number generator <EoN> <NEWLINE> <NEWLINE> <BoN> fill point <EoN> = <BoN> rng <EoN> . <BoN> randint <EoN> ( <NUMBER> , <BoN> self <EoN> . <BoN> parameter count <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> strategy <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> bprime <EoN> = <BoN> self <EoN> . <BoN> mutation func <EoN> ( <BoN> candidate <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> select samples <EoN> ( <BoN> candidate <EoN> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> bprime <EoN> = <BoN> self <EoN> . <BoN> mutation func <EoN> ( <BoN> self <EoN> . <BoN> select samples <EoN> ( <BoN> candidate <EoN> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> strategy <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> binomial <EoN> : <NEWLINE> <TAB> <BoN> crossovers <EoN> = <BoN> rng <EoN> . <BoN> rand <EoN> ( <BoN> self <EoN> . <BoN> parameter count <EoN> ) <NEWLINE> <BoN> crossovers <EoN> = <BoN> crossovers <EoN> < <BoN> self <EoN> . <BoN> cross over probability <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> crossovers <EoN> [ <BoN> fill point <EoN> ] = <BoN> True <EoN> <NEWLINE> <BoN> trial <EoN> = <BoN> np <EoN> . <BoN> where <EoN> ( <BoN> crossovers <EoN> , <BoN> bprime <EoN> , <BoN> trial <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> trial <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> strategy <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> exponential <EoN> : <NEWLINE> <TAB> <BoN> i <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> ( <BoN> i <EoN> < <BoN> self <EoN> . <BoN> parameter count <EoN> <BoN> and <EoN> <NEWLINE> <BoN> rng <EoN> . <BoN> rand <EoN> ( ) < <BoN> self <EoN> . <BoN> cross over probability <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> trial <EoN> [ <BoN> fill point <EoN> ] = <BoN> bprime <EoN> [ <BoN> fill point <EoN> ] <NEWLINE> <BoN> fill point <EoN> = ( <BoN> fill point <EoN> + <NUMBER> ) % <BoN> self <EoN> . <BoN> parameter count <EoN> <NEWLINE> <BoN> i <EoN> += <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> trial <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast logical and <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> switch to thread local <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> stack state is thread local <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> stack state is thread local <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> quantized bias add eager fallback <EoN> ( <BoN> input <EoN> , <BoN> bias <EoN> , <BoN> min input <EoN> , <BoN> max input <EoN> , <BoN> min bias <EoN> , <BoN> max bias <EoN> , <BoN> out type <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> out type <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> out type <EoN> , <STRING> ) <NEWLINE> <BoN> attr T 1 <EoN> , ( <BoN> input <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> attr T 2 <EoN> , ( <BoN> bias <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> bias <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> min input <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> min input <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> max input <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> max input <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> min bias <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> min bias <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> max bias <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> max bias <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> , <BoN> bias <EoN> , <BoN> min input <EoN> , <BoN> max input <EoN> , <BoN> min bias <EoN> , <BoN> max bias <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T 1 <EoN> , <STRING> , <BoN> attr T 2 <EoN> , <STRING> , <BoN> out type <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedBiasAddOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abc <EoN> . <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> cluster spec <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> regularized loss <EoN> ( <BoN> self <EoN> , <BoN> examples <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assertSpecified <EoN> ( [ <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> ] , <BoN> examples <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> assertList <EoN> ( [ <STRING> , <STRING> ] , <BoN> examples <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> weights <EoN> = <BoN> internal convert to tensor <EoN> ( <BoN> examples <EoN> [ <STRING> ] ) <NEWLINE> <BoN> return <EoN> ( ( <NEWLINE> <BoN> self <EoN> . <BoN> l 1 loss <EoN> ( ) + <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> l 2 loss <EoN> ( <BoN> self <EoN> . <BoN> options <EoN> [ <STRING> ] ) ) / <NEWLINE> <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> weights <EoN> , <BoN> dtypes <EoN> . <BoN> float 64 <EoN> ) ) + <NEWLINE> <BoN> self <EoN> . <BoN> unregularized loss <EoN> ( <BoN> examples <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> constructor <EoN> <NEWLINE> <BoN> def <EoN> <BoN> stack <EoN> ( * <BoN> tensors <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> tensors <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> kwargs <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> tensors <EoN> [ <NUMBER> ] , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> Deprecation Warning <EoN> , <NEWLINE> <BoN> stacklevel <EoN> = <NUMBER> ) <NEWLINE> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> tensors <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tensors <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> tensors <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <STRING> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> tensors <EoN> = <BoN> tensors <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> tensors <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Exception <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> all <EoN> ( <NEWLINE> [ <NEWLINE> <BoN> isinstance <EoN> ( <BoN> t <EoN> , ( <BoN> np <EoN> . <BoN> number <EoN> , <BoN> float <EoN> , <BoN> integer types <EoN> , <NEWLINE> <BoN> python complex <EoN> ) ) <BoN> or <EoN> <NEWLINE> ( <BoN> isinstance <EoN> ( <BoN> t <EoN> , <BoN> Variable <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> t <EoN> . <BoN> type <EoN> , <BoN> Tensor Type <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> t <EoN> . <BoN> ndim <EoN> == <NUMBER> ) <NEWLINE> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> tensors <EoN> ] ) : <NEWLINE> <NEWLINE> <TAB> <BoN> tensors <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> as tensor variable <EoN> , <BoN> tensors <EoN> ) ) <NEWLINE> <BoN> dtype <EoN> = <BoN> scal <EoN> . <BoN> upcast <EoN> ( * [ <BoN> i <EoN> . <BoN> dtype <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> tensors <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> opt <EoN> . <BoN> Make Vector <EoN> ( <BoN> dtype <EoN> ) ( * <BoN> tensors <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> join <EoN> ( <BoN> axis <EoN> , * [ <BoN> shape padaxis <EoN> ( <BoN> t <EoN> , <BoN> axis <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> tensors <EoN> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> compressor file <EoN> ( <BoN> self <EoN> , <BoN> fileobj <EoN> , <BoN> compresslevel <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> check versions <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> compresslevel <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> fileobj factory <EoN> ( <BoN> fileobj <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> fileobj factory <EoN> ( <BoN> fileobj <EoN> , <STRING> , <NEWLINE> <BoN> compression level <EoN> = <BoN> compresslevel <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> append <EoN> ( <BoN> self <EoN> , <BoN> to append <EoN> , <BoN> ignore index <EoN> = <BoN> False <EoN> , <BoN> verify integrity <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> reshape <EoN> . <BoN> concat <EoN> <BoN> import <EoN> <BoN> concat <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> to append <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> to concat <EoN> = [ <BoN> self <EoN> ] + <BoN> to append <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> to concat <EoN> = [ <BoN> self <EoN> , <BoN> to append <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> concat <EoN> ( <BoN> to concat <EoN> , <BoN> ignore index <EoN> = <BoN> ignore index <EoN> , <NEWLINE> <BoN> verify integrity <EoN> = <BoN> verify integrity <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tile <EoN> ( <BoN> x <EoN> , <BoN> reps <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Tile <EoN> ( <BoN> reps <EoN> ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bitname <EoN> ( <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> name <EoN> = <BoN> obj <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> [ - <NUMBER> ] == <STRING> : <NEWLINE> <TAB> <BoN> newname <EoN> = <BoN> name <EoN> [ : - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> newname <EoN> = <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> info <EoN> = <BoN> typeinfo <EoN> [ <BoN> english upper <EoN> ( <BoN> newname <EoN> ) ] <NEWLINE> <BoN> assert <EoN> ( <BoN> info <EoN> [ - <NUMBER> ] == <BoN> obj <EoN> ) <NEWLINE> <BoN> bits <EoN> = <BoN> info <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> base <EoN> , <BoN> bits <EoN> = <BoN> evalname <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> char <EoN> = <BoN> base <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <BoN> bits <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sys <EoN> . <BoN> version info <EoN> [ <NUMBER> ] >= <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> <NEWLINE> <BoN> base <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> bytes <EoN> = <BoN> bits <EoN> // <NUMBER> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> char <EoN> != <STRING> <BoN> and <EoN> <BoN> bytes <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> char <EoN> = <STRING> % ( <BoN> char <EoN> , <BoN> bytes <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> base <EoN> , <BoN> bits <EoN> , <BoN> char <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trunc <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set prop cycle <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> args <EoN> <BoN> and <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <NUMBER> <BoN> and <EoN> <BoN> args <EoN> [ <NUMBER> ] <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prop cycle <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> prop cycle <EoN> = <BoN> cycler <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> get lines <EoN> . <BoN> set prop cycle <EoN> ( <BoN> prop cycle <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> get patches for fill <EoN> . <BoN> set prop cycle <EoN> ( <BoN> prop cycle <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ode sol simplicity <EoN> ( <BoN> sol <EoN> , <BoN> func <EoN> , <BoN> trysolving <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> iterable <EoN> ( <BoN> sol <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> sol <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ode sol simplicity <EoN> ( <BoN> i <EoN> , <BoN> func <EoN> , <BoN> trysolving <EoN> = <BoN> trysolving <EoN> ) == <BoN> oo <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> oo <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> str <EoN> ( <BoN> sol <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sol <EoN> . <BoN> has <EoN> ( <BoN> Integral <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> oo <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sol <EoN> . <BoN> lhs <EoN> == <BoN> func <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> sol <EoN> . <BoN> rhs <EoN> . <BoN> has <EoN> ( <BoN> func <EoN> ) <BoN> or <EoN> <BoN> sol <EoN> . <BoN> rhs <EoN> == <BoN> func <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> sol <EoN> . <BoN> lhs <EoN> . <BoN> has <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> trysolving <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> sols <EoN> = <BoN> solve <EoN> ( <BoN> sol <EoN> , <BoN> func <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> sols <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Not Implemented Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> - <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> str <EoN> ( <BoN> sol <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> self <EoN> , <BoN> sync <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> ( <BoN> self <EoN> . <BoN> device <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> device <EoN> >= <NUMBER> <BoN> and <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stream <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> sync <EoN> : <NEWLINE> <TAB> <BoN> cuda <EoN> . <BoN> cupy <EoN> . <BoN> cuda <EoN> . <BoN> runtime <EoN> . <BoN> device Synchronize <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> ret array <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> drop duplicates <EoN> ( <BoN> self <EoN> , <BoN> keep <EoN> = <STRING> , <BoN> inplace <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> super <EoN> ( <BoN> Series <EoN> , <BoN> self <EoN> ) . <BoN> drop duplicates <EoN> ( <BoN> keep <EoN> = <BoN> keep <EoN> , <BoN> inplace <EoN> = <BoN> inplace <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mobilenet 1 0 <EoN> ( ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> get mobilenet <EoN> ( <NUMBER> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> xavier uniform <EoN> ( <BoN> tensor <EoN> , <BoN> gain <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> fan in <EoN> , <BoN> fan out <EoN> = <BoN> calculate fan in and fan out <EoN> ( <BoN> tensor <EoN> ) <NEWLINE> <BoN> std <EoN> = <BoN> gain <EoN> * <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> / ( <BoN> fan in <EoN> + <BoN> fan out <EoN> ) ) <NEWLINE> <BoN> a <EoN> = <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> ) * <BoN> std <EoN> <NEWLINE> <BoN> with <EoN> <BoN> torch <EoN> . <BoN> no grad <EoN> ( ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tensor <EoN> . <BoN> uniform <EoN> ( - <BoN> a <EoN> , <BoN> a <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> safe no dnn workmem bwd <EoN> ( <BoN> workmem <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> workmem <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> union <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> assert can do setop <EoN> ( <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Datetime Index <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> Datetime Index <EoN> ( <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> this <EoN> , <BoN> other <EoN> = <BoN> self <EoN> . <BoN> maybe utc convert <EoN> ( <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> this <EoN> . <BoN> can fast union <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> this <EoN> . <BoN> fast union <EoN> ( <BoN> other <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> Index <EoN> . <BoN> union <EoN> ( <BoN> this <EoN> , <BoN> other <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> result <EoN> , <BoN> Datetime Index <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> tz <EoN> = <BoN> timezones <EoN> . <BoN> tz standardize <EoN> ( <BoN> this <EoN> . <BoN> tz <EoN> ) <NEWLINE> <BoN> if <EoN> ( <BoN> result <EoN> . <BoN> freq <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> ( <BoN> this <EoN> . <BoN> freq <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> other <EoN> . <BoN> freq <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) ) : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> freq <EoN> = <BoN> to offset <EoN> ( <BoN> result <EoN> . <BoN> inferred freq <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set clip box <EoN> ( <BoN> self <EoN> , <BoN> clipbox <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> super <EoN> ( ) . <BoN> set clip box <EoN> ( <BoN> clipbox <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> update clip properties <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> doctest depends on <EoN> ( <BoN> modules <EoN> = ( <STRING> , ) ) <NEWLINE> <BoN> def <EoN> <BoN> symarray <EoN> ( <BoN> prefix <EoN> , <BoN> shape <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> numpy <EoN> <BoN> import <EoN> <BoN> empty <EoN> , <BoN> ndindex <EoN> <NEWLINE> <BoN> arr <EoN> = <BoN> empty <EoN> ( <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> object <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> index <EoN> <BoN> in <EoN> <BoN> ndindex <EoN> ( <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> arr <EoN> [ <BoN> index <EoN> ] = <BoN> Symbol <EoN> ( <STRING> % ( <BoN> prefix <EoN> , <STRING> . <BoN> join <EoN> ( <BoN> map <EoN> ( <BoN> str <EoN> , <BoN> index <EoN> ) ) ) , <NEWLINE> ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> arr <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> chebgrid 3 d <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> z <EoN> , <BoN> c <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> c <EoN> = <BoN> chebval <EoN> ( <BoN> x <EoN> , <BoN> c <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> chebval <EoN> ( <BoN> y <EoN> , <BoN> c <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> chebval <EoN> ( <BoN> z <EoN> , <BoN> c <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> deprecated <EoN> ( <BoN> None <EoN> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> extend export strategy <EoN> ( <BoN> base export strategy <EoN> , <NEWLINE> <BoN> post export fn <EoN> , <NEWLINE> <BoN> post export name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> export fn <EoN> ( <BoN> estimator <EoN> , <BoN> export dir base <EoN> , <BoN> checkpoint path <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> tmp base export folder <EoN> = <STRING> + <BoN> str <EoN> ( <BoN> int <EoN> ( <BoN> time <EoN> . <BoN> time <EoN> ( ) ) ) <NEWLINE> <BoN> tmp base export dir <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> export dir base <EoN> , <BoN> tmp base export folder <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> gfile <EoN> . <BoN> Exists <EoN> ( <BoN> tmp base export dir <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> gfile <EoN> . <BoN> Make Dirs <EoN> ( <BoN> tmp base export dir <EoN> ) <NEWLINE> <BoN> tmp base export <EoN> = <BoN> base export strategy <EoN> . <BoN> export <EoN> ( <NEWLINE> <BoN> estimator <EoN> , <BoN> tmp base export dir <EoN> , <BoN> checkpoint path <EoN> ) <NEWLINE> <NEWLINE> <BoN> tmp post export folder <EoN> = <STRING> + <BoN> str <EoN> ( <BoN> int <EoN> ( <BoN> time <EoN> . <BoN> time <EoN> ( ) ) ) <NEWLINE> <BoN> tmp post export dir <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> export dir base <EoN> , <BoN> tmp post export folder <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> gfile <EoN> . <BoN> Exists <EoN> ( <BoN> tmp post export dir <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> gfile <EoN> . <BoN> Make Dirs <EoN> ( <BoN> tmp post export dir <EoN> ) <NEWLINE> <BoN> tmp post export <EoN> = <BoN> post export fn <EoN> ( <BoN> tmp base export <EoN> , <BoN> tmp post export dir <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> tmp post export <EoN> . <BoN> startswith <EoN> ( <BoN> tmp post export dir <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> tmp post export dir <EoN> ) ) <NEWLINE> <UNTAB> <BoN> post export relpath <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> relpath <EoN> ( <BoN> tmp post export <EoN> , <BoN> tmp post export dir <EoN> ) <NEWLINE> <BoN> post export <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> export dir base <EoN> , <BoN> post export relpath <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> gfile <EoN> . <BoN> Exists <EoN> ( <BoN> post export <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> gfile <EoN> . <BoN> Rename <EoN> ( <BoN> tmp post export <EoN> , <BoN> post export <EoN> ) <NEWLINE> <NEWLINE> <BoN> gfile <EoN> . <BoN> Delete Recursively <EoN> ( <BoN> tmp base export dir <EoN> ) <NEWLINE> <BoN> gfile <EoN> . <BoN> Delete Recursively <EoN> ( <BoN> tmp post export dir <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> post export <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> name <EoN> = <BoN> post export name <EoN> <BoN> if <EoN> <BoN> post export name <EoN> <BoN> else <EoN> <BoN> base export strategy <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> return <EoN> <BoN> export strategy <EoN> . <BoN> Export Strategy <EoN> ( <BoN> name <EoN> , <BoN> export fn <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> getcycle <EoN> ( <BoN> d <EoN> , <BoN> keys <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> toposort <EoN> ( <BoN> d <EoN> , <BoN> keys <EoN> = <BoN> keys <EoN> , <BoN> returncycle <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> reduce <EoN> ( <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new args <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> while <EoN> ( <BoN> new args <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> id 1 <EoN> , <BoN> s <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> args <EoN> ) : <NEWLINE> <TAB> <BoN> new args <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> id 2 <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> args <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> id 1 <EoN> == <BoN> id 2 <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> new seq <EoN> = <BoN> s <EoN> . <BoN> mul <EoN> ( <BoN> t <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> new seq <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> new args <EoN> = [ <BoN> a <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> args <EoN> <BoN> if <EoN> <BoN> a <EoN> <BoN> not <EoN> <BoN> in <EoN> ( <BoN> s <EoN> , <BoN> t <EoN> ) ] <NEWLINE> <BoN> new args <EoN> . <BoN> append <EoN> ( <BoN> new seq <EoN> ) <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> new args <EoN> : <NEWLINE> <TAB> <BoN> args <EoN> = <BoN> new args <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> args <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Seq Mul <EoN> ( <BoN> args <EoN> , <BoN> evaluate <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> value container <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Element Wise Sum <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> module checkpoint <EoN> ( <BoN> mod <EoN> , <BoN> prefix <EoN> , <BoN> period <EoN> = <NUMBER> , <BoN> save optimizer states <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> period <EoN> = <BoN> int <EoN> ( <BoN> max <EoN> ( <NUMBER> , <BoN> period <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> callback <EoN> ( <BoN> iter no <EoN> , <BoN> sym <EoN> = <BoN> None <EoN> , <BoN> arg <EoN> = <BoN> None <EoN> , <BoN> aux <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> ( <BoN> iter no <EoN> + <NUMBER> ) % <BoN> period <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> mod <EoN> . <BoN> save checkpoint <EoN> ( <BoN> prefix <EoN> , <BoN> iter no <EoN> + <NUMBER> , <BoN> save optimizer states <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> callback <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> self <EoN> , <BoN> block <EoN> = <BoN> True <EoN> , <BoN> timeout <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> not empty <EoN> . <BoN> acquire <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> block <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> empty <EoN> ( ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Empty <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> timeout <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> while <EoN> <BoN> self <EoN> . <BoN> empty <EoN> ( ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> not empty <EoN> . <BoN> wait <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> timeout <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> endtime <EoN> = <BoN> time <EoN> ( ) + <BoN> timeout <EoN> <NEWLINE> <BoN> while <EoN> <BoN> self <EoN> . <BoN> empty <EoN> ( ) : <NEWLINE> <TAB> <BoN> remaining <EoN> = <BoN> endtime <EoN> - <BoN> time <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> remaining <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Empty <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> not empty <EoN> . <BoN> wait <EoN> ( <BoN> remaining <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> item <EoN> = <BoN> self <EoN> . <BoN> get <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> not full <EoN> . <BoN> notify <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> item <EoN> <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> not empty <EoN> . <BoN> release <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random helper <EoN> ( <BoN> random <EoN> , <BoN> sampler <EoN> , <BoN> params <EoN> , <BoN> shape <EoN> , <BoN> dtype <EoN> , <BoN> ctx <EoN> , <BoN> out <EoN> , <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> params <EoN> [ <NUMBER> ] , <BoN> ND Array <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> params <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> isinstance <EoN> ( <BoN> i <EoN> , <BoN> ND Array <EoN> ) , <STRING> <STRING> % ( <BoN> type <EoN> ( <BoN> params <EoN> [ <NUMBER> ] ) , <BoN> type <EoN> ( <BoN> i <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sampler <EoN> ( * <BoN> params <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> out <EoN> = <BoN> out <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> params <EoN> [ <NUMBER> ] , <BoN> numeric types <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ctx <EoN> = <BoN> current context <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> shape <EoN> <BoN> is <EoN> <BoN> Null <EoN> <BoN> and <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> shape <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> params <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> isinstance <EoN> ( <BoN> i <EoN> , <BoN> numeric types <EoN> ) , <STRING> <STRING> % ( <BoN> type <EoN> ( <BoN> params <EoN> [ <NUMBER> ] ) , <BoN> type <EoN> ( <BoN> i <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> random <EoN> ( * <BoN> params <EoN> , <BoN> shape <EoN> = <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> out <EoN> = <BoN> out <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> params <EoN> [ <NUMBER> ] ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> do begin <EoN> ( <BoN> self <EoN> , <BoN> dbapi connection <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gather <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> import r <EoN> ( <BoN> self <EoN> , <BoN> variable <EoN> , <BoN> reason <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> variable <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> variable <EoN> . <BoN> owner <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> apply nodes <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> import <EoN> ( <BoN> variable <EoN> . <BoN> owner <EoN> , <BoN> reason <EoN> = <BoN> reason <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> variable <EoN> . <BoN> owner <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> variable <EoN> , <BoN> graph <EoN> . <BoN> Constant <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> variable <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inputs <EoN> ) : <NEWLINE> <TAB> <BoN> global <EoN> <BoN> Null Type <EoN> <NEWLINE> <BoN> if <EoN> <BoN> Null Type <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> . <BoN> null type <EoN> <BoN> import <EoN> <BoN> Null Type <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> variable <EoN> . <BoN> type <EoN> , <BoN> Null Type <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> + <NEWLINE> <BoN> variable <EoN> . <BoN> type <EoN> . <BoN> why null <EoN> ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Missing Input Error <EoN> ( <STRING> , <BoN> variable <EoN> = <BoN> variable <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> getattr <EoN> ( <BoN> variable <EoN> , <STRING> , <BoN> None <EoN> ) <BoN> is <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> setup r <EoN> ( <BoN> variable <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> variables <EoN> . <BoN> add <EoN> ( <BoN> variable <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> mouseevent <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> callable <EoN> ( <BoN> self <EoN> . <BoN> contains <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> contains <EoN> ( <BoN> self <EoN> , <BoN> mouseevent <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> patch <EoN> . <BoN> contains <EoN> ( <BoN> mouseevent <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> scatter add ndim <EoN> ( <BoN> input <EoN> , <BoN> indices <EoN> , <BoN> deltas <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> indices <EoN> = <BoN> indices <EoN> , <BoN> deltas <EoN> = <BoN> deltas <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> scatter add ndim <EoN> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> indices <EoN> = <BoN> indices <EoN> , <BoN> deltas <EoN> = <BoN> deltas <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> op <EoN> <NEWLINE> <BoN> result <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> , <NEWLINE> <BoN> warn once <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> bijectors <EoN> = <BoN> None <EoN> , <BoN> validate args <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> bijectors <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bijectors <EoN> = ( ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> bijectors <EoN> = <BoN> bijectors <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> a bijector <EoN> <BoN> in <EoN> <BoN> bijectors <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> a bijector <EoN> . <BoN> is injective <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <NEWLINE> <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> a bijector <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> dtype <EoN> = <BoN> list <EoN> ( <BoN> set <EoN> ( [ <BoN> b <EoN> . <BoN> dtype <EoN> <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> bijectors <EoN> ] ) ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> dtype <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> dtype <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype <EoN> [ <NUMBER> ] <BoN> if <EoN> <BoN> dtype <EoN> [ <NUMBER> ] <BoN> is <EoN> <BoN> None <EoN> <BoN> else <EoN> <BoN> dtype <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> dtype <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> dtype <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> inverse min event ndims <EoN> = <BoN> compute min event ndims <EoN> ( <NEWLINE> <BoN> bijectors <EoN> , <BoN> compute forward <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> forward min event ndims <EoN> = <BoN> compute min event ndims <EoN> ( <NEWLINE> <BoN> bijectors <EoN> , <BoN> compute forward <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> super <EoN> ( <BoN> Chain <EoN> , <BoN> self <EoN> ) . <BoN> init <EoN> ( <NEWLINE> <BoN> graph parents <EoN> = <BoN> list <EoN> ( <BoN> itertools <EoN> . <BoN> chain <EoN> . <BoN> from iterable <EoN> ( <NEWLINE> <BoN> b <EoN> . <BoN> graph parents <EoN> <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> bijectors <EoN> ) ) , <NEWLINE> <BoN> forward min event ndims <EoN> = <BoN> forward min event ndims <EoN> , <NEWLINE> <BoN> inverse min event ndims <EoN> = <BoN> inverse min event ndims <EoN> , <NEWLINE> <BoN> is constant jacobian <EoN> = <BoN> all <EoN> ( <BoN> b <EoN> . <BoN> is constant jacobian <EoN> <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> bijectors <EoN> ) , <NEWLINE> <BoN> validate args <EoN> = <BoN> validate args <EoN> , <NEWLINE> <BoN> dtype <EoN> = <BoN> dtype <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> <BoN> or <EoN> ( <STRING> <BoN> if <EoN> <BoN> not <EoN> <BoN> bijectors <EoN> <BoN> else <EoN> <NEWLINE> <STRING> . <BoN> join <EoN> ( [ <STRING> ] + [ <BoN> b <EoN> . <BoN> name <EoN> <BoN> for <EoN> <BoN> b <EoN> <BoN> in <EoN> <BoN> bijectors <EoN> ] ) ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> src <EoN> , <BoN> label <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> random <EoN> . <BoN> random <EoN> ( ) < <BoN> self <EoN> . <BoN> p <EoN> : <NEWLINE> <TAB> <BoN> src <EoN> = <BoN> nd <EoN> . <BoN> flip <EoN> ( <BoN> src <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> flip label <EoN> ( <BoN> label <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> ( <BoN> src <EoN> , <BoN> label <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> inputs <EoN> , <BoN> state <EoN> , <BoN> scope <EoN> = <BoN> None <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> base layer <EoN> . <BoN> Layer <EoN> . <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> inputs <EoN> , <BoN> state <EoN> , <BoN> scope <EoN> = <BoN> scope <EoN> , <NEWLINE> * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> le <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pure complex <EoN> ( <BoN> v <EoN> , <BoN> or real <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> h <EoN> , <BoN> t <EoN> = <BoN> v <EoN> . <BoN> as coeff Add <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> t <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> or real <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> h <EoN> , <BoN> t <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> c <EoN> , <BoN> i <EoN> = <BoN> t <EoN> . <BoN> as coeff Mul <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Imaginary Unit <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> h <EoN> , <BoN> c <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> concatenate join units <EoN> ( <BoN> join units <EoN> , <BoN> concat axis <EoN> , <BoN> copy <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> concat axis <EoN> == <NUMBER> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> join units <EoN> ) > <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> empty dtype <EoN> , <BoN> upcasted na <EoN> = <BoN> get empty dtype and na <EoN> ( <BoN> join units <EoN> ) <NEWLINE> <NEWLINE> <BoN> to concat <EoN> = [ <BoN> ju <EoN> . <BoN> get reindexed values <EoN> ( <BoN> empty dtype <EoN> = <BoN> empty dtype <EoN> , <NEWLINE> <BoN> upcasted na <EoN> = <BoN> upcasted na <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> ju <EoN> <BoN> in <EoN> <BoN> join units <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> to concat <EoN> ) == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> concat values <EoN> = <BoN> to concat <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> concat values <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> concat values <EoN> . <BoN> base <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> concat values <EoN> = <BoN> concat values <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> concat values <EoN> = <BoN> concat values <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> concat values <EoN> = <BoN> concat <EoN> . <BoN> concat compat <EoN> ( <BoN> to concat <EoN> , <BoN> axis <EoN> = <BoN> concat axis <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> concat values <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dropout <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mode <EoN> = <STRING> <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> attrs <EoN> <BoN> and <EoN> <BoN> attrs <EoN> [ <STRING> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> mode <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> fix attribute names <EoN> ( <BoN> attrs <EoN> , <NEWLINE> { <STRING> : <STRING> } ) <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> remove attributes <EoN> ( <BoN> new attrs <EoN> , [ <STRING> ] ) <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> add extra attributes <EoN> ( <BoN> new attrs <EoN> , { <STRING> : <BoN> mode <EoN> } ) <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> new attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> mycielskian <EoN> ( <BoN> G <EoN> , <BoN> iterations <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> n <EoN> = <BoN> G <EoN> . <BoN> number of nodes <EoN> ( ) <NEWLINE> <BoN> M <EoN> = <BoN> nx <EoN> . <BoN> convert node labels to integers <EoN> ( <BoN> G <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> iterations <EoN> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> M <EoN> . <BoN> number of nodes <EoN> ( ) <NEWLINE> <BoN> M <EoN> . <BoN> add nodes from <EoN> ( <BoN> range <EoN> ( <BoN> n <EoN> , <NUMBER> * <BoN> n <EoN> ) ) <NEWLINE> <BoN> old edges <EoN> = <BoN> list <EoN> ( <BoN> M <EoN> . <BoN> edges <EoN> ( ) ) <NEWLINE> <BoN> M <EoN> . <BoN> add edges from <EoN> ( ( <BoN> u <EoN> , <BoN> v <EoN> + <BoN> n <EoN> ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> old edges <EoN> ) <NEWLINE> <BoN> M <EoN> . <BoN> add edges from <EoN> ( ( <BoN> u <EoN> + <BoN> n <EoN> , <BoN> v <EoN> ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> old edges <EoN> ) <NEWLINE> <BoN> M <EoN> . <BoN> add node <EoN> ( <NUMBER> * <BoN> n <EoN> ) <NEWLINE> <BoN> M <EoN> . <BoN> add edges from <EoN> ( ( <BoN> u <EoN> + <BoN> n <EoN> , <NUMBER> * <BoN> n <EoN> ) <BoN> for <EoN> <BoN> u <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> M <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> fertile stats serialize <EoN> ( <BoN> stats handle <EoN> , <BoN> params <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <NEWLINE> <BoN> stats handle <EoN> , <STRING> , <BoN> params <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> fertile stats serialize eager fallback <EoN> ( <NEWLINE> <BoN> stats handle <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> fertile stats serialize <EoN> , <BoN> stats handle <EoN> = <BoN> stats handle <EoN> , <NEWLINE> <BoN> params <EoN> = <BoN> params <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> params <EoN> = <BoN> execute <EoN> . <BoN> make str <EoN> ( <BoN> params <EoN> , <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> stats handle <EoN> = <BoN> stats handle <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> fertile stats serialize <EoN> , <BoN> stats handle <EoN> = <BoN> stats handle <EoN> , <BoN> params <EoN> = <BoN> params <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> argmax <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> argmax <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tc <EoN> . <BoN> returns <EoN> ( <BoN> Axis <EoN> ) <NEWLINE> @ <BoN> tc <EoN> . <BoN> accepts <EoN> ( <BoN> tc <EoN> . <BoN> Collection <EoN> ( <BoN> Axis <EoN> ) ) <NEWLINE> <BoN> def <EoN> <BoN> concat axes <EoN> ( <BoN> axes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> a <EoN> , <BoN> Axis <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <BoN> a <EoN> , <BoN> type <EoN> ( <BoN> a <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> names <EoN> = <BoN> set <EoN> ( <BoN> a <EoN> . <BoN> name <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> names <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> names <EoN> ) <NEWLINE> <UNTAB> <BoN> name <EoN> , = <BoN> names <EoN> <NEWLINE> <NEWLINE> <BoN> all have labels <EoN> = <BoN> all <EoN> ( <BoN> a <EoN> . <BoN> labels <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> ) <NEWLINE> <BoN> any has unknown size <EoN> = <BoN> any <EoN> ( <BoN> a <EoN> . <BoN> size <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> all have labels <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> tuple <EoN> ( <BoN> label <EoN> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> <BoN> for <EoN> <BoN> label <EoN> <BoN> in <EoN> <BoN> a <EoN> . <BoN> labels <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> any has unknown size <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> value <EoN> = <BoN> sum <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> axes <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Axis <EoN> ( <BoN> name <EoN> , <BoN> value <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get func fullname <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> modules <EoN> , <BoN> funcname <EoN> = <BoN> get func name <EoN> ( <BoN> func <EoN> ) <NEWLINE> <BoN> modules <EoN> . <BoN> append <EoN> ( <BoN> funcname <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( * <BoN> modules <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get kern dist from name <EoN> ( <BoN> self <EoN> , <BoN> name 1 <EoN> , <BoN> name 2 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> kern <EoN> . <BoN> get <EoN> ( ( <BoN> name 1 <EoN> , <BoN> name 2 <EoN> ) , <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tile <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> reps <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> sparse slice <EoN> ( <BoN> sp input <EoN> , <BoN> start <EoN> , <BoN> size <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> sp input <EoN> = <BoN> convert to sparse tensor <EoN> ( <BoN> sp input <EoN> ) <NEWLINE> <BoN> start <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> start <EoN> , <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <BoN> size <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> size <EoN> , <BoN> dtypes <EoN> . <BoN> int 64 <EoN> ) <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> sp input <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> output indices <EoN> , <BoN> output values <EoN> , <BoN> output shape <EoN> = <BoN> gen sparse ops <EoN> . <BoN> sparse slice <EoN> ( <NEWLINE> <BoN> sp input <EoN> . <BoN> indices <EoN> , <NEWLINE> <BoN> sp input <EoN> . <BoN> values <EoN> , <NEWLINE> <BoN> sp input <EoN> . <BoN> dense shape <EoN> , <NEWLINE> <BoN> start <EoN> , <NEWLINE> <BoN> size <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> sparse tensor <EoN> . <BoN> Sparse Tensor <EoN> ( <BoN> output indices <EoN> , <BoN> output values <EoN> , <NEWLINE> <BoN> output shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add edge <EoN> ( <BoN> self <EoN> , <BoN> u of edge <EoN> , <BoN> v of edge <EoN> , ** <BoN> attr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> u <EoN> , <BoN> v <EoN> = <BoN> u of edge <EoN> , <BoN> v of edge <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> u <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> node <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> u <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> node <EoN> [ <BoN> u <EoN> ] = { } <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> v <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> node <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> v <EoN> ] = <BoN> self <EoN> . <BoN> adjlist inner dict factory <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> node <EoN> [ <BoN> v <EoN> ] = { } <NEWLINE> <NEWLINE> <UNTAB> <BoN> datadict <EoN> = <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> u <EoN> ] . <BoN> get <EoN> ( <BoN> v <EoN> , <BoN> self <EoN> . <BoN> edge attr dict factory <EoN> ( ) ) <NEWLINE> <BoN> datadict <EoN> . <BoN> update <EoN> ( <BoN> attr <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> u <EoN> ] [ <BoN> v <EoN> ] = <BoN> datadict <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> adj <EoN> [ <BoN> v <EoN> ] [ <BoN> u <EoN> ] = <BoN> datadict <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sample <EoN> ( <BoN> self <EoN> , <BoN> time <EoN> , <BoN> outputs <EoN> , <BoN> state <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> del <EoN> <BoN> time <EoN> , <BoN> state <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> outputs <EoN> , <BoN> ops <EoN> . <BoN> Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <NEWLINE> <BoN> type <EoN> ( <BoN> outputs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> softmax temperature <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> logits <EoN> = <BoN> outputs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> logits <EoN> = <BoN> outputs <EoN> / <BoN> self <EoN> . <BoN> softmax temperature <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sample id sampler <EoN> = <BoN> categorical <EoN> . <BoN> Categorical <EoN> ( <BoN> logits <EoN> = <BoN> logits <EoN> ) <NEWLINE> <BoN> sample ids <EoN> = <BoN> sample id sampler <EoN> . <BoN> sample <EoN> ( <BoN> seed <EoN> = <BoN> self <EoN> . <BoN> seed <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> sample ids <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rand <EoN> ( * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> args <EoN> [ <NUMBER> ] , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> args <EoN> = <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> asmatrix <EoN> ( <BoN> np <EoN> . <BoN> random <EoN> . <BoN> rand <EoN> ( * <BoN> args <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> identity <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> recompute transform <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> center <EoN> = ( <BoN> self <EoN> . <BoN> convert xunits <EoN> ( <BoN> self <EoN> . <BoN> center <EoN> [ <NUMBER> ] ) , <NEWLINE> <BoN> self <EoN> . <BoN> convert yunits <EoN> ( <BoN> self <EoN> . <BoN> center <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> width <EoN> = <BoN> self <EoN> . <BoN> convert xunits <EoN> ( <BoN> self <EoN> . <BoN> width <EoN> ) <NEWLINE> <BoN> height <EoN> = <BoN> self <EoN> . <BoN> convert yunits <EoN> ( <BoN> self <EoN> . <BoN> height <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> patch transform <EoN> = <BoN> transforms <EoN> . <BoN> Affine 2 D <EoN> ( ) . <BoN> scale <EoN> ( <BoN> width <EoN> * <NUMBER> , <BoN> height <EoN> * <NUMBER> ) . <BoN> rotate deg <EoN> ( <BoN> self <EoN> . <BoN> angle <EoN> ) . <BoN> translate <EoN> ( * <BoN> center <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get command obj <EoN> ( <BoN> self <EoN> , <BoN> command <EoN> , <BoN> create <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cmd obj <EoN> = <BoN> self <EoN> . <BoN> command obj <EoN> . <BoN> get <EoN> ( <BoN> command <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> cmd obj <EoN> <BoN> and <EoN> <BoN> create <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> DEBU G <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> announce <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> command <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> klass <EoN> = <BoN> self <EoN> . <BoN> get command class <EoN> ( <BoN> command <EoN> ) <NEWLINE> <BoN> cmd obj <EoN> = <BoN> self <EoN> . <BoN> command obj <EoN> [ <BoN> command <EoN> ] = <BoN> klass <EoN> ( <BoN> self <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> have run <EoN> [ <BoN> command <EoN> ] = <NUMBER> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> options <EoN> = <BoN> self <EoN> . <BoN> command options <EoN> . <BoN> get <EoN> ( <BoN> command <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> options <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set command options <EoN> ( <BoN> cmd obj <EoN> , <BoN> options <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> cmd obj <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sum <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <BoN> Null <EoN> , <BoN> keepdims <EoN> = <BoN> Null <EoN> , <BoN> exclude <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> palplot <EoN> ( <BoN> pal <EoN> , <BoN> size <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n <EoN> = <BoN> len <EoN> ( <BoN> pal <EoN> ) <NEWLINE> <BoN> f <EoN> , <BoN> ax <EoN> = <BoN> plt <EoN> . <BoN> subplots <EoN> ( <NUMBER> , <NUMBER> , <BoN> figsize <EoN> = ( <BoN> n <EoN> * <BoN> size <EoN> , <BoN> size <EoN> ) ) <NEWLINE> <BoN> ax <EoN> . <BoN> imshow <EoN> ( <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> n <EoN> ) . <BoN> reshape <EoN> ( <NUMBER> , <BoN> n <EoN> ) , <NEWLINE> <BoN> cmap <EoN> = <BoN> mpl <EoN> . <BoN> colors <EoN> . <BoN> Listed Colormap <EoN> ( <BoN> list <EoN> ( <BoN> pal <EoN> ) ) , <NEWLINE> <BoN> interpolation <EoN> = <STRING> , <BoN> aspect <EoN> = <STRING> ) <NEWLINE> <BoN> ax <EoN> . <BoN> set xticks <EoN> ( <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> n <EoN> ) - <NUMBER> ) <NEWLINE> <BoN> ax <EoN> . <BoN> set yticks <EoN> ( [ - <NUMBER> , <NUMBER> ] ) <NEWLINE> <BoN> ax <EoN> . <BoN> set xticklabels <EoN> ( [ ] ) <NEWLINE> <BoN> ax <EoN> . <BoN> set yticklabels <EoN> ( [ ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getitem <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> flags <EoN> ( ) [ <BoN> name <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> to timestamp <EoN> ( <BoN> self <EoN> , <BoN> freq <EoN> = <BoN> None <EoN> , <BoN> how <EoN> = <STRING> , <BoN> axis <EoN> = <NUMBER> , <BoN> copy <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new data <EoN> = <BoN> self <EoN> . <BoN> data <EoN> <NEWLINE> <BoN> if <EoN> <BoN> copy <EoN> : <NEWLINE> <TAB> <BoN> new data <EoN> = <BoN> new data <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> axis <EoN> = <BoN> self <EoN> . <BoN> get axis number <EoN> ( <BoN> axis <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> new data <EoN> . <BoN> set axis <EoN> ( <NUMBER> , <BoN> self <EoN> . <BoN> index <EoN> . <BoN> to timestamp <EoN> ( <BoN> freq <EoN> = <BoN> freq <EoN> , <BoN> how <EoN> = <BoN> how <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> new data <EoN> . <BoN> set axis <EoN> ( <NUMBER> , <BoN> self <EoN> . <BoN> columns <EoN> . <BoN> to timestamp <EoN> ( <BoN> freq <EoN> = <BoN> freq <EoN> , <BoN> how <EoN> = <BoN> how <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <STRING> . <BoN> format <EoN> ( <NEWLINE> <BoN> ax <EoN> = <BoN> axis <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> new data <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get children <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> children <EoN> = [ <BoN> self <EoN> . <BoN> patch <EoN> ] <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> artists <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> axes <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> lines <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> patches <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> texts <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> images <EoN> ) <NEWLINE> <BoN> children <EoN> . <BoN> extend <EoN> ( <BoN> self <EoN> . <BoN> legends <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> children <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set linespacing <EoN> ( <BoN> self <EoN> , <BoN> spacing <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> linespacing <EoN> = <BoN> spacing <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> str <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> f <EoN> ( <BoN> sh <EoN> , <BoN> shape left <EoN> , <BoN> i <EoN> , <BoN> j <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> shape left <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <STRING> + <STRING> . <BoN> join <EoN> ( [ <BoN> str <EoN> ( <BoN> self <EoN> [ <BoN> e <EoN> ] ) <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> i <EoN> , <BoN> j <EoN> ) ] ) + <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sh <EoN> //= <BoN> shape left <EoN> [ <NUMBER> ] <NEWLINE> <BoN> return <EoN> <STRING> + <STRING> . <BoN> join <EoN> ( [ <BoN> f <EoN> ( <BoN> sh <EoN> , <BoN> shape left <EoN> [ <NUMBER> : ] , <BoN> i <EoN> + <BoN> e <EoN> * <BoN> sh <EoN> , <BoN> i <EoN> + ( <BoN> e <EoN> + <NUMBER> ) * <BoN> sh <EoN> ) <BoN> for <EoN> <BoN> e <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> shape left <EoN> [ <NUMBER> ] ) ] ) + <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rank <EoN> ( ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> [ ( ) ] . <BoN> str <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> ( <BoN> self <EoN> . <BoN> loop size <EoN> , <BoN> self <EoN> . <BoN> shape <EoN> , <NUMBER> , <BoN> self <EoN> . <BoN> loop size <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get edgecolor <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> edgecolor <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compose transforms <EoN> ( * <BoN> transforms <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> transforms <EoN> , <STRING> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> composed <EoN> = <BoN> flat transforms to matrices <EoN> ( <BoN> transforms <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> for <EoN> <BoN> tr <EoN> <BoN> in <EoN> <BoN> transforms <EoN> [ <NUMBER> : ] : <NEWLINE> <NEWLINE> <TAB> <BoN> composed <EoN> = <BoN> math ops <EoN> . <BoN> matmul <EoN> ( <BoN> composed <EoN> , <BoN> flat transforms to matrices <EoN> ( <BoN> tr <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> matrices to flat transforms <EoN> ( <BoN> composed <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> intersection <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , ( <BoN> Accum Bounds <EoN> , <BoN> Finite Set <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Finite Set <EoN> ) : <NEWLINE> <TAB> <BoN> fin set <EoN> = <BoN> S <EoN> . <BoN> Empty Set <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> other <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> self <EoN> : <NEWLINE> <TAB> <BoN> fin set <EoN> = <BoN> fin set <EoN> + <BoN> Finite Set <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> fin set <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> max <EoN> < <BoN> other <EoN> . <BoN> min <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> min <EoN> > <BoN> other <EoN> . <BoN> max <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Empty Set <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> min <EoN> <= <BoN> other <EoN> . <BoN> min <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> max <EoN> <= <BoN> other <EoN> . <BoN> max <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Accum Bounds <EoN> ( <BoN> other <EoN> . <BoN> min <EoN> , <BoN> self <EoN> . <BoN> max <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> max <EoN> > <BoN> other <EoN> . <BoN> max <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> other <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> other <EoN> . <BoN> min <EoN> <= <BoN> self <EoN> . <BoN> min <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> other <EoN> . <BoN> max <EoN> < <BoN> self <EoN> . <BoN> max <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Accum Bounds <EoN> ( <BoN> self <EoN> . <BoN> min <EoN> , <BoN> other <EoN> . <BoN> max <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> other <EoN> . <BoN> max <EoN> > <BoN> self <EoN> . <BoN> max <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample uniform <EoN> ( <BoN> low <EoN> = <BoN> None <EoN> , <BoN> high <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup abs <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> K <EoN> . <BoN> abs <EoN> ( <BoN> coeff <EoN> ) <BoN> for <EoN> <BoN> coeff <EoN> <BoN> in <EoN> <BoN> f <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is compatible <EoN> ( <BoN> self <EoN> , <BoN> other column <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other column <EoN> , <BoN> WeightedSparseColumn <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> sparse id column <EoN> . <BoN> is compatible <EoN> ( <BoN> other column <EoN> . <BoN> sparse id column <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> sparse id column <EoN> . <BoN> is compatible <EoN> ( <BoN> other column <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arcsin <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> atan 2 <EoN> ( <BoN> y <EoN> , <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> y <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> atan 2 eager fallback <EoN> ( <NEWLINE> <BoN> y <EoN> , <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> atan 2 <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> atan 2 <EoN> , <BoN> y <EoN> = <BoN> y <EoN> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> map <EoN> ( <BoN> self <EoN> , <BoN> seq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> result <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> elt <EoN> <BoN> in <EoN> <BoN> seq <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> elt <EoN> , <BoN> list <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> self <EoN> . <BoN> map <EoN> ( <BoN> elt <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> append <EoN> ( <BoN> self <EoN> ( <BoN> elt <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> encloses point <EoN> ( <BoN> self <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p <EoN> = <BoN> Point <EoN> ( <BoN> p <EoN> , <BoN> dim <EoN> = <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> p <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> vertices <EoN> <BoN> or <EoN> <BoN> any <EoN> ( <BoN> p <EoN> <BoN> in <EoN> <BoN> s <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> sides <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> lit <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> vertices <EoN> : <NEWLINE> <TAB> <BoN> lit <EoN> . <BoN> append <EoN> ( <BoN> v <EoN> - <BoN> p <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> lit <EoN> [ - <NUMBER> ] . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> poly <EoN> = <BoN> Polygon <EoN> ( * <BoN> lit <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> args <EoN> = <BoN> poly <EoN> . <BoN> args <EoN> <NEWLINE> <BoN> indices <EoN> = <BoN> list <EoN> ( <BoN> range <EoN> ( - <BoN> len <EoN> ( <BoN> args <EoN> ) , <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> poly <EoN> . <BoN> is convex <EoN> ( ) : <NEWLINE> <TAB> <BoN> orientation <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> indices <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> args <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> b <EoN> = <BoN> args <EoN> [ <BoN> i <EoN> + <NUMBER> ] <NEWLINE> <BoN> test <EoN> = ( ( - <BoN> a <EoN> . <BoN> y <EoN> ) * ( <BoN> b <EoN> . <BoN> x <EoN> - <BoN> a <EoN> . <BoN> x <EoN> ) - ( - <BoN> a <EoN> . <BoN> x <EoN> ) * ( <BoN> b <EoN> . <BoN> y <EoN> - <BoN> a <EoN> . <BoN> y <EoN> ) ) . <BoN> is negative <EoN> <NEWLINE> <BoN> if <EoN> <BoN> orientation <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> orientation <EoN> = <BoN> test <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> test <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> orientation <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> hit odd <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> p 1 x <EoN> , <BoN> p 1 y <EoN> = <BoN> args <EoN> [ <NUMBER> ] . <BoN> args <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> indices <EoN> [ <NUMBER> : ] : <NEWLINE> <TAB> <BoN> p 2 x <EoN> , <BoN> p 2 y <EoN> = <BoN> args <EoN> [ <BoN> i <EoN> ] . <BoN> args <EoN> <NEWLINE> <BoN> if <EoN> <NUMBER> > <BoN> min <EoN> ( <BoN> p 1 y <EoN> , <BoN> p 2 y <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <NUMBER> <= <BoN> max <EoN> ( <BoN> p 1 y <EoN> , <BoN> p 2 y <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <NUMBER> <= <BoN> max <EoN> ( <BoN> p 1 x <EoN> , <BoN> p 2 x <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> p 1 y <EoN> != <BoN> p 2 y <EoN> : <NEWLINE> <TAB> <BoN> xinters <EoN> = ( - <BoN> p 1 y <EoN> ) * ( <BoN> p 2 x <EoN> - <BoN> p 1 x <EoN> ) / ( <BoN> p 2 y <EoN> - <BoN> p 1 y <EoN> ) + <BoN> p 1 x <EoN> <NEWLINE> <BoN> if <EoN> <BoN> p 1 x <EoN> == <BoN> p 2 x <EoN> <BoN> or <EoN> <NUMBER> <= <BoN> xinters <EoN> : <NEWLINE> <TAB> <BoN> hit odd <EoN> = <BoN> not <EoN> <BoN> hit odd <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> p 1 x <EoN> , <BoN> p 1 y <EoN> = <BoN> p 2 x <EoN> , <BoN> p 2 y <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> hit odd <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lookfor generate cache <EoN> ( <BoN> module <EoN> , <BoN> import modules <EoN> , <BoN> regenerate <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> global <EoN> <BoN> lookfor caches <EoN> <NEWLINE> <NEWLINE> <BoN> import <EoN> <BoN> inspect <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sys <EoN> . <BoN> version info <EoN> [ <NUMBER> ] >= <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> from <EoN> <BoN> io <EoN> <BoN> import <EoN> <BoN> String I O <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> String I O <EoN> <BoN> import <EoN> <BoN> String I O <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> module <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> module <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> ( <BoN> module <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> { } <NEWLINE> <UNTAB> <BoN> module <EoN> = <BoN> sys <EoN> . <BoN> modules <EoN> [ <BoN> module <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> module <EoN> , <BoN> list <EoN> ) <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> module <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> cache <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> mod <EoN> <BoN> in <EoN> <BoN> module <EoN> : <NEWLINE> <TAB> <BoN> cache <EoN> . <BoN> update <EoN> ( <BoN> lookfor generate cache <EoN> ( <BoN> mod <EoN> , <BoN> import modules <EoN> , <NEWLINE> <BoN> regenerate <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> cache <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> id <EoN> ( <BoN> module <EoN> ) <BoN> in <EoN> <BoN> lookfor caches <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> regenerate <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> lookfor caches <EoN> [ <BoN> id <EoN> ( <BoN> module <EoN> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> cache <EoN> = { } <NEWLINE> <BoN> lookfor caches <EoN> [ <BoN> id <EoN> ( <BoN> module <EoN> ) ] = <BoN> cache <EoN> <NEWLINE> <BoN> seen <EoN> = { } <NEWLINE> <BoN> index <EoN> = <NUMBER> <NEWLINE> <BoN> stack <EoN> = [ ( <BoN> module <EoN> . <BoN> name <EoN> , <BoN> module <EoN> ) ] <NEWLINE> <BoN> while <EoN> <BoN> stack <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> , <BoN> item <EoN> = <BoN> stack <EoN> . <BoN> pop <EoN> ( <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> id <EoN> ( <BoN> item <EoN> ) <BoN> in <EoN> <BoN> seen <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> seen <EoN> [ <BoN> id <EoN> ( <BoN> item <EoN> ) ] = <BoN> True <EoN> <NEWLINE> <NEWLINE> <BoN> index <EoN> += <NUMBER> <NEWLINE> <BoN> kind <EoN> = <STRING> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> inspect <EoN> . <BoN> ismodule <EoN> ( <BoN> item <EoN> ) : <NEWLINE> <TAB> <BoN> kind <EoN> = <STRING> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> all <EoN> = <BoN> item <EoN> . <BoN> all <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> all <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> import modules <EoN> <BoN> and <EoN> <BoN> hasattr <EoN> ( <BoN> item <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> pth <EoN> <BoN> in <EoN> <BoN> item <EoN> . <BoN> path <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> mod path <EoN> <BoN> in <EoN> <BoN> os <EoN> . <BoN> listdir <EoN> ( <BoN> pth <EoN> ) : <NEWLINE> <TAB> <BoN> this py <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> pth <EoN> , <BoN> mod path <EoN> ) <NEWLINE> <BoN> init py <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> join <EoN> ( <BoN> pth <EoN> , <BoN> mod path <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> ( <BoN> os <EoN> . <BoN> path <EoN> . <BoN> isfile <EoN> ( <BoN> this py <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> mod path <EoN> . <BoN> endswith <EoN> ( <STRING> ) ) : <NEWLINE> <TAB> <BoN> to import <EoN> = <BoN> mod path <EoN> [ : - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> isfile <EoN> ( <BoN> init py <EoN> ) : <NEWLINE> <TAB> <BoN> to import <EoN> = <BoN> mod path <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> to import <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> old stdout <EoN> = <BoN> sys <EoN> . <BoN> stdout <EoN> <NEWLINE> <BoN> old stderr <EoN> = <BoN> sys <EoN> . <BoN> stderr <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> sys <EoN> . <BoN> stdout <EoN> = <BoN> String I O <EoN> ( ) <NEWLINE> <BoN> sys <EoN> . <BoN> stderr <EoN> = <BoN> String I O <EoN> ( ) <NEWLINE> <BoN> import <EoN> ( <STRING> % ( <BoN> name <EoN> , <BoN> to import <EoN> ) ) <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> sys <EoN> . <BoN> stdout <EoN> = <BoN> old stdout <EoN> <NEWLINE> <BoN> sys <EoN> . <BoN> stderr <EoN> = <BoN> old stderr <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Base Exception <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> n <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> getmembers <EoN> ( <BoN> item <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> item name <EoN> = <BoN> getattr <EoN> ( <BoN> v <EoN> , <STRING> , <STRING> % ( <BoN> name <EoN> , <BoN> n <EoN> ) ) <NEWLINE> <BoN> mod name <EoN> = <BoN> getattr <EoN> ( <BoN> v <EoN> , <STRING> , <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Name Error <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> item name <EoN> = <STRING> % ( <BoN> name <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> mod name <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> item name <EoN> <BoN> and <EoN> <BoN> mod name <EoN> : <NEWLINE> <TAB> <BoN> item name <EoN> = <STRING> % ( <BoN> mod name <EoN> , <BoN> item name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> item name <EoN> . <BoN> startswith <EoN> ( <BoN> name <EoN> + <STRING> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> v <EoN> , <BoN> ufunc <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> ( <BoN> inspect <EoN> . <BoN> ismodule <EoN> ( <BoN> v <EoN> ) <BoN> or <EoN> <BoN> all <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> all <EoN> ) : <NEWLINE> <TAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> stack <EoN> . <BoN> append <EoN> ( ( <STRING> % ( <BoN> name <EoN> , <BoN> n <EoN> ) , <BoN> v <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> inspect <EoN> . <BoN> isclass <EoN> ( <BoN> item <EoN> ) : <NEWLINE> <TAB> <BoN> kind <EoN> = <STRING> <NEWLINE> <BoN> for <EoN> <BoN> n <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> getmembers <EoN> ( <BoN> item <EoN> ) : <NEWLINE> <TAB> <BoN> stack <EoN> . <BoN> append <EoN> ( ( <STRING> % ( <BoN> name <EoN> , <BoN> n <EoN> ) , <BoN> v <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> item <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> kind <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> doc <EoN> = <BoN> inspect <EoN> . <BoN> getdoc <EoN> ( <BoN> item <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Name Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> doc <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> doc <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> cache <EoN> [ <BoN> name <EoN> ] = ( <BoN> doc <EoN> , <BoN> kind <EoN> , <BoN> index <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> cache <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rvs <EoN> ( <BoN> self <EoN> , <BoN> mean <EoN> = <BoN> None <EoN> , <BoN> rowcov <EoN> = <NUMBER> , <BoN> colcov <EoN> = <NUMBER> , <BoN> size <EoN> = <NUMBER> , <BoN> random state <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> size <EoN> = <BoN> int <EoN> ( <BoN> size <EoN> ) <NEWLINE> <BoN> dims <EoN> , <BoN> mean <EoN> , <BoN> rowcov <EoN> , <BoN> colcov <EoN> = <BoN> self <EoN> . <BoN> process parameters <EoN> ( <BoN> mean <EoN> , <BoN> rowcov <EoN> , <NEWLINE> <BoN> colcov <EoN> ) <NEWLINE> <BoN> rowchol <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> cholesky <EoN> ( <BoN> rowcov <EoN> , <BoN> lower <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> colchol <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> cholesky <EoN> ( <BoN> colcov <EoN> , <BoN> lower <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> random state <EoN> = <BoN> self <EoN> . <BoN> get random state <EoN> ( <BoN> random state <EoN> ) <NEWLINE> <BoN> std norm <EoN> = <BoN> random state <EoN> . <BoN> standard normal <EoN> ( <BoN> size <EoN> = ( <BoN> dims <EoN> [ <NUMBER> ] , <BoN> size <EoN> , <BoN> dims <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> roll rvs <EoN> = <BoN> np <EoN> . <BoN> tensordot <EoN> ( <BoN> colchol <EoN> , <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> std norm <EoN> , <BoN> rowchol <EoN> . <BoN> T <EoN> ) , <NUMBER> ) <NEWLINE> <BoN> out <EoN> = <BoN> np <EoN> . <BoN> rollaxis <EoN> ( <BoN> roll rvs <EoN> . <BoN> T <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> start <EoN> = <NUMBER> ) + <BoN> mean <EoN> [ <BoN> np <EoN> . <BoN> newaxis <EoN> , : , : ] <NEWLINE> <BoN> if <EoN> <BoN> size <EoN> == <NUMBER> : <NEWLINE> <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> out <EoN> . <BoN> reshape <EoN> ( <BoN> mean <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reduce ndarray <EoN> ( <BoN> data <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> rebuild ndarray <EoN> , <BoN> data <EoN> . <BoN> to shared mem <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf trace map <EoN> ( <BoN> f <EoN> , <BoN> n <EoN> , <BoN> g <EoN> , <BoN> b <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> f <EoN> = <BoN> gf rem <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> h <EoN> = <BoN> f <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> f <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> h <EoN> = <BoN> gf frobenius map <EoN> ( <BoN> h <EoN> , <BoN> g <EoN> , <BoN> b <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> r <EoN> = <BoN> gf add <EoN> ( <BoN> r <EoN> , <BoN> h <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <BoN> r <EoN> = <BoN> gf rem <EoN> ( <BoN> r <EoN> , <BoN> g <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> flatten <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> , [ - <NUMBER> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get index <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get indices <EoN> ( [ <BoN> name <EoN> ] ) [ <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> , <BoN> weight <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> get device <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> x <EoN> += <BoN> weight <EoN> * <BoN> value <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> x 2 <EoN> += <BoN> weight <EoN> * <BoN> value <EoN> * <BoN> value <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> n <EoN> += <BoN> weight <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> X <EoN> , <BoN> y <EoN> = <BoN> check X y <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , [ <STRING> , <STRING> , <STRING> ] , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> float 64 <EoN> , <NEWLINE> <BoN> multi output <EoN> = <BoN> True <EoN> , <BoN> y numeric <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> sample weight <EoN> , <BoN> float <EoN> ) : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <BoN> check array <EoN> ( <BoN> sample weight <EoN> , <BoN> ensure 2 d <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> n samples <EoN> , <BoN> n features <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> <NEWLINE> <NEWLINE> <BoN> X <EoN> , <BoN> y <EoN> , <BoN> X offset <EoN> , <BoN> y offset <EoN> , <BoN> X scale <EoN> = <BoN> Linear Model <EoN> . <BoN> preprocess data <EoN> ( <NEWLINE> <BoN> X <EoN> , <BoN> y <EoN> , <BoN> self <EoN> . <BoN> fit intercept <EoN> , <BoN> self <EoN> . <BoN> normalize <EoN> , <BoN> self <EoN> . <BoN> copy X <EoN> , <NEWLINE> <BoN> sample weight <EoN> = <BoN> sample weight <EoN> ) <NEWLINE> <NEWLINE> <BoN> gcv mode <EoN> = <BoN> self <EoN> . <BoN> gcv mode <EoN> <NEWLINE> <BoN> with sw <EoN> = <BoN> len <EoN> ( <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> sample weight <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> gcv mode <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> gcv mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> sparse <EoN> . <BoN> issparse <EoN> ( <BoN> X <EoN> ) <BoN> or <EoN> <BoN> n features <EoN> > <BoN> n samples <EoN> <BoN> or <EoN> <BoN> with sw <EoN> : <NEWLINE> <TAB> <BoN> gcv mode <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> gcv mode <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> gcv mode <EoN> == <STRING> <BoN> and <EoN> <BoN> with sw <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <BoN> gcv mode <EoN> = <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> gcv mode <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> pre compute <EoN> = <BoN> self <EoN> . <BoN> pre compute <EoN> <NEWLINE> <BoN> errors <EoN> = <BoN> self <EoN> . <BoN> errors <EoN> <NEWLINE> <BoN> values <EoN> = <BoN> self <EoN> . <BoN> values <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> gcv mode <EoN> == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> pre compute <EoN> = <BoN> self <EoN> . <BoN> pre compute svd <EoN> <NEWLINE> <BoN> errors <EoN> = <BoN> self <EoN> . <BoN> errors svd <EoN> <NEWLINE> <BoN> values <EoN> = <BoN> self <EoN> . <BoN> values svd <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> gcv mode <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> , <BoN> y <EoN> = <BoN> rescale data <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> sample weight <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> centered kernel <EoN> = <BoN> not <EoN> <BoN> sparse <EoN> . <BoN> issparse <EoN> ( <BoN> X <EoN> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> fit intercept <EoN> <NEWLINE> <NEWLINE> <BoN> v <EoN> , <BoN> Q <EoN> , <BoN> QT y <EoN> = <BoN> pre compute <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> centered kernel <EoN> ) <NEWLINE> <BoN> n y <EoN> = <NUMBER> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> y <EoN> . <BoN> shape <EoN> ) == <NUMBER> <BoN> else <EoN> <BoN> y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <BoN> cv values <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> n samples <EoN> * <BoN> n y <EoN> , <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) ) ) <NEWLINE> <BoN> C <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> scorer <EoN> = <BoN> check scoring <EoN> ( <BoN> self <EoN> , <BoN> scoring <EoN> = <BoN> self <EoN> . <BoN> scoring <EoN> , <BoN> allow none <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> error <EoN> = <BoN> scorer <EoN> <BoN> is <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> < <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> alpha <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> error <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> , <BoN> c <EoN> = <BoN> errors <EoN> ( <BoN> float <EoN> ( <BoN> alpha <EoN> ) , <BoN> y <EoN> , <BoN> v <EoN> , <BoN> Q <EoN> , <BoN> QT y <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> , <BoN> c <EoN> = <BoN> values <EoN> ( <BoN> float <EoN> ( <BoN> alpha <EoN> ) , <BoN> y <EoN> , <BoN> v <EoN> , <BoN> Q <EoN> , <BoN> QT y <EoN> ) <NEWLINE> <UNTAB> <BoN> cv values <EoN> [ : , <BoN> i <EoN> ] = <BoN> out <EoN> . <BoN> ravel <EoN> ( ) <NEWLINE> <BoN> C <EoN> . <BoN> append <EoN> ( <BoN> c <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> error <EoN> : <NEWLINE> <TAB> <BoN> best <EoN> = <BoN> cv values <EoN> . <BoN> mean <EoN> ( <BoN> axis <EoN> = <NUMBER> ) . <BoN> argmin <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> def <EoN> <BoN> identity estimator <EoN> ( ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> identity estimator <EoN> . <BoN> decision function <EoN> = <BoN> lambda <EoN> <BoN> y predict <EoN> : <BoN> y predict <EoN> <NEWLINE> <BoN> identity estimator <EoN> . <BoN> predict <EoN> = <BoN> lambda <EoN> <BoN> y predict <EoN> : <BoN> y predict <EoN> <NEWLINE> <NEWLINE> <BoN> out <EoN> = [ <BoN> scorer <EoN> ( <BoN> identity estimator <EoN> , <BoN> y <EoN> . <BoN> ravel <EoN> ( ) , <BoN> cv values <EoN> [ : , <BoN> i <EoN> ] ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) ) ] <NEWLINE> <BoN> best <EoN> = <BoN> np <EoN> . <BoN> argmax <EoN> ( <BoN> out <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> alpha <EoN> = <BoN> self <EoN> . <BoN> alphas <EoN> [ <BoN> best <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> dual coef <EoN> = <BoN> C <EoN> [ <BoN> best <EoN> ] <NEWLINE> <BoN> self <EoN> . <BoN> coef <EoN> = <BoN> safe sparse dot <EoN> ( <BoN> self <EoN> . <BoN> dual coef <EoN> . <BoN> T <EoN> , <BoN> X <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> set intercept <EoN> ( <BoN> X offset <EoN> , <BoN> y offset <EoN> , <BoN> X scale <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> store cv values <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> y <EoN> . <BoN> shape <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> cv values shape <EoN> = <BoN> n samples <EoN> , <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> cv values shape <EoN> = <BoN> n samples <EoN> , <BoN> n y <EoN> , <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> alphas <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> cv values <EoN> = <BoN> cv values <EoN> . <BoN> reshape <EoN> ( <BoN> cv values shape <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set in layout <EoN> ( <BoN> self <EoN> , <BoN> in layout <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> in layout <EoN> = <BoN> in layout <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> on train begin <EoN> ( <BoN> self <EoN> , <BoN> logs <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> logs <EoN> = <BoN> logs <EoN> <BoN> or <EoN> { } <NEWLINE> <BoN> for <EoN> <BoN> callback <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> callbacks <EoN> : <NEWLINE> <TAB> <BoN> callback <EoN> . <BoN> on train begin <EoN> ( <BoN> logs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> identity <EoN> ( <BoN> n <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> array <EoN> ( [ <NUMBER> ] + <BoN> n <EoN> * [ <NUMBER> ] , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> b <EoN> = <BoN> empty <EoN> ( ( <BoN> n <EoN> , <BoN> n <EoN> ) , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <BoN> b <EoN> . <BoN> flat <EoN> = <BoN> a <EoN> <NEWLINE> <BoN> return <EoN> <BoN> b <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assign Value <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> data <EoN> . <BoN> flags <EoN> . <BoN> writeable <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> data <EoN> . <BoN> itemset <EoN> ( <BoN> value <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> integrate kde <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> other <EoN> . <BoN> d <EoN> != <BoN> self <EoN> . <BoN> d <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> other <EoN> . <BoN> n <EoN> < <BoN> self <EoN> . <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> small <EoN> = <BoN> other <EoN> <NEWLINE> <BoN> large <EoN> = <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> small <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> large <EoN> = <BoN> other <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sum cov <EoN> = <BoN> small <EoN> . <BoN> covariance <EoN> + <BoN> large <EoN> . <BoN> covariance <EoN> <NEWLINE> <BoN> sum cov chol <EoN> = <BoN> linalg <EoN> . <BoN> cho factor <EoN> ( <BoN> sum cov <EoN> ) <NEWLINE> <BoN> result <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> small <EoN> . <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> mean <EoN> = <BoN> small <EoN> . <BoN> dataset <EoN> [ : , <BoN> i <EoN> , <BoN> newaxis <EoN> ] <NEWLINE> <BoN> diff <EoN> = <BoN> large <EoN> . <BoN> dataset <EoN> - <BoN> mean <EoN> <NEWLINE> <BoN> tdiff <EoN> = <BoN> linalg <EoN> . <BoN> cho solve <EoN> ( <BoN> sum cov chol <EoN> , <BoN> diff <EoN> ) <NEWLINE> <NEWLINE> <BoN> energies <EoN> = <BoN> sum <EoN> ( <BoN> diff <EoN> * <BoN> tdiff <EoN> , <BoN> axis <EoN> = <NUMBER> ) / <NUMBER> <NEWLINE> <BoN> result <EoN> += <BoN> sum <EoN> ( <BoN> exp <EoN> ( - <BoN> energies <EoN> ) , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> sqrt det <EoN> = <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> np <EoN> . <BoN> diagonal <EoN> ( <BoN> sum cov chol <EoN> [ <NUMBER> ] ) ) <NEWLINE> <BoN> norm const <EoN> = <BoN> power <EoN> ( <NUMBER> * <BoN> pi <EoN> , <BoN> sum cov <EoN> . <BoN> shape <EoN> [ <NUMBER> ] / <NUMBER> ) * <BoN> sqrt det <EoN> <NEWLINE> <NEWLINE> <BoN> result <EoN> /= <BoN> norm const <EoN> * <BoN> large <EoN> . <BoN> n <EoN> * <BoN> small <EoN> . <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp ff trivial gcd <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> zero f <EoN> = <BoN> dmp zero p <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> ) <NEWLINE> <BoN> zero g <EoN> = <BoN> dmp zero p <EoN> ( <BoN> g <EoN> , <BoN> u <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> zero f <EoN> <BoN> and <EoN> <BoN> zero g <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> dmp zeros <EoN> ( <NUMBER> , <BoN> u <EoN> , <BoN> K <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> zero f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> dmp ground monic <EoN> ( <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) , <NEWLINE> <BoN> dmp zero <EoN> ( <BoN> u <EoN> ) , <NEWLINE> <BoN> dmp ground <EoN> ( <BoN> dmp ground LC <EoN> ( <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) , <BoN> u <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> zero g <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> dmp ground monic <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) , <NEWLINE> <BoN> dmp ground <EoN> ( <BoN> dmp ground LC <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) , <BoN> u <EoN> ) , <NEWLINE> <BoN> dmp zero <EoN> ( <BoN> u <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> query <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dmp simplify gcd <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add internal <EoN> ( <BoN> self <EoN> , <BoN> sprite <EoN> , <BoN> layer <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> sprite <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Attribute Error <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> sprite <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Attribute Error <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> sprite <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Attribute Error <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> sprite <EoN> , <BoN> Dirty Sprite <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> sprite <EoN> . <BoN> dirty <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> sprite <EoN> . <BoN> dirty <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> Layered Updates <EoN> . <BoN> add internal <EoN> ( <BoN> self <EoN> , <BoN> sprite <EoN> , <BoN> layer <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <BoN> None <EoN> , <BoN> DEPRECATION INSTRUCTION <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> add queue runner <EoN> ( <BoN> qr <EoN> , <BoN> collection <EoN> = <BoN> ops <EoN> . <BoN> Graph Keys <EoN> . <BoN> QUEUE RUNNERS <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ops <EoN> . <BoN> add to collection <EoN> ( <BoN> collection <EoN> , <BoN> qr <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> select options <EoN> ( <BoN> pat <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> pat <EoN> <BoN> in <EoN> <BoN> registered options <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> pat <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> keys <EoN> = <BoN> sorted <EoN> ( <BoN> registered options <EoN> . <BoN> keys <EoN> ( ) ) <NEWLINE> <BoN> if <EoN> <BoN> pat <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> keys <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> [ <BoN> k <EoN> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> keys <EoN> <BoN> if <EoN> <BoN> re <EoN> . <BoN> search <EoN> ( <BoN> pat <EoN> , <BoN> k <EoN> , <BoN> re <EoN> . <BoN> I <EoN> ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update from <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> artist <EoN> . <BoN> Artist <EoN> . <BoN> update from <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> edgecolor <EoN> = <BoN> other <EoN> . <BoN> edgecolor <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> facecolor <EoN> = <BoN> other <EoN> . <BoN> facecolor <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> original edgecolor <EoN> = <BoN> other <EoN> . <BoN> original edgecolor <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> original facecolor <EoN> = <BoN> other <EoN> . <BoN> original facecolor <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> fill <EoN> = <BoN> other <EoN> . <BoN> fill <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> hatch <EoN> = <BoN> other <EoN> . <BoN> hatch <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> hatch color <EoN> = <BoN> other <EoN> . <BoN> hatch color <EoN> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> us dashes <EoN> = <BoN> other <EoN> . <BoN> us dashes <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> set linewidth <EoN> ( <BoN> other <EoN> . <BoN> linewidth <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> set transform <EoN> ( <BoN> other <EoN> . <BoN> get data transform <EoN> ( ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> transformSet <EoN> = <BoN> other <EoN> . <BoN> is transform set <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> cumprod <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> exclusive <EoN> = <BoN> False <EoN> , <BoN> reverse <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> x <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> gen math ops <EoN> . <BoN> cumprod <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> exclusive <EoN> = <BoN> exclusive <EoN> , <BoN> reverse <EoN> = <BoN> reverse <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> multiply <EoN> ( <BoN> a <EoN> , <BoN> i <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a arr <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> i arr <EoN> = <BoN> numpy <EoN> . <BoN> asarray <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> issubclass <EoN> ( <BoN> i arr <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> integer <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> out size <EoN> = <BoN> get num chars <EoN> ( <BoN> a arr <EoN> ) * <BoN> max <EoN> ( <BoN> long <EoN> ( <BoN> i arr <EoN> . <BoN> max <EoN> ( ) ) , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <BoN> vec string <EoN> ( <NEWLINE> <BoN> a arr <EoN> , ( <BoN> a arr <EoN> . <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> out size <EoN> ) , <STRING> , ( <BoN> i arr <EoN> , ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> skewtest <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> nan policy <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> axis <EoN> = <BoN> chk asarray <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <BoN> contains nan <EoN> , <BoN> nan policy <EoN> = <BoN> contains nan <EoN> ( <BoN> a <EoN> , <BoN> nan policy <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> contains nan <EoN> <BoN> and <EoN> <BoN> nan policy <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> ma <EoN> . <BoN> masked invalid <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> mstats basic <EoN> . <BoN> skewtest <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> axis <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> ravel <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> b 2 <EoN> = <BoN> skew <EoN> ( <BoN> a <EoN> , <BoN> axis <EoN> ) <NEWLINE> <BoN> n <EoN> = <BoN> float <EoN> ( <BoN> a <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> int <EoN> ( <BoN> n <EoN> ) ) <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> b 2 <EoN> * <BoN> math <EoN> . <BoN> sqrt <EoN> ( ( ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) ) / ( <NUMBER> * ( <BoN> n <EoN> - <NUMBER> ) ) ) <NEWLINE> <BoN> beta 2 <EoN> = ( <NUMBER> * ( <BoN> n <EoN> ** <NUMBER> + <NUMBER> * <BoN> n <EoN> - <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) / <NEWLINE> ( ( <BoN> n <EoN> - <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) * ( <BoN> n <EoN> + <NUMBER> ) ) ) <NEWLINE> <BoN> W 2 <EoN> = - <NUMBER> + <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> * ( <BoN> beta 2 <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> delta <EoN> = <NUMBER> / <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> * <BoN> math <EoN> . <BoN> log <EoN> ( <BoN> W 2 <EoN> ) ) <NEWLINE> <BoN> alpha <EoN> = <BoN> math <EoN> . <BoN> sqrt <EoN> ( <NUMBER> / ( <BoN> W 2 <EoN> - <NUMBER> ) ) <NEWLINE> <BoN> y <EoN> = <BoN> np <EoN> . <BoN> where <EoN> ( <BoN> y <EoN> == <NUMBER> , <NUMBER> , <BoN> y <EoN> ) <NEWLINE> <BoN> Z <EoN> = <BoN> delta <EoN> * <BoN> np <EoN> . <BoN> log <EoN> ( <BoN> y <EoN> / <BoN> alpha <EoN> + <BoN> np <EoN> . <BoN> sqrt <EoN> ( ( <BoN> y <EoN> / <BoN> alpha <EoN> ) ** <NUMBER> + <NUMBER> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Skewtest Result <EoN> ( <BoN> Z <EoN> , <NUMBER> * <BoN> distributions <EoN> . <BoN> norm <EoN> . <BoN> sf <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> Z <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> cell <EoN> , <BoN> helper <EoN> , <BoN> initial state <EoN> , <BoN> output layer <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> rnn cell impl <EoN> . <BoN> assert like rnncell <EoN> ( <STRING> , <BoN> cell <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> helper <EoN> , <BoN> helper py <EoN> . <BoN> Helper <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> % <BoN> type <EoN> ( <BoN> helper <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> output layer <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <BoN> and <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> output layer <EoN> , <BoN> layers base <EoN> . <BoN> Layer <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> output layer <EoN> ) ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> cell <EoN> = <BoN> cell <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> helper <EoN> = <BoN> helper <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> initial state <EoN> = <BoN> initial state <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> output layer <EoN> = <BoN> output layer <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logical and <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> uniform <EoN> ( <BoN> self <EoN> , <BoN> size <EoN> = <BoN> None <EoN> , <BoN> low <EoN> = <NUMBER> , <BoN> high <EoN> = <NUMBER> , <BoN> ndim <EoN> = <BoN> None <EoN> , <BoN> dtype <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> gen <EoN> ( <BoN> uniform <EoN> , <BoN> size <EoN> , <BoN> low <EoN> , <BoN> high <EoN> , <BoN> ndim <EoN> = <BoN> ndim <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read block <EoN> ( <BoN> f <EoN> , <BoN> offset <EoN> , <BoN> length <EoN> , <BoN> delimiter <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> offset <EoN> != <BoN> f <EoN> . <BoN> tell <EoN> ( ) : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> seek <EoN> ( <BoN> offset <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> offset <EoN> <BoN> and <EoN> <BoN> length <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> f <EoN> . <BoN> tell <EoN> ( ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> read <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> delimiter <EoN> : <NEWLINE> <TAB> <BoN> seek delimiter <EoN> ( <BoN> f <EoN> , <BoN> delimiter <EoN> , <NUMBER> ** <NUMBER> ) <NEWLINE> <BoN> start <EoN> = <BoN> f <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> length <EoN> -= <BoN> start <EoN> - <BoN> offset <EoN> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> seek <EoN> ( <BoN> start <EoN> + <BoN> length <EoN> ) <NEWLINE> <BoN> seek delimiter <EoN> ( <BoN> f <EoN> , <BoN> delimiter <EoN> , <NUMBER> ** <NUMBER> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> OS Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> seek <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> end <EoN> = <BoN> f <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> offset <EoN> = <BoN> start <EoN> <NEWLINE> <BoN> length <EoN> = <BoN> end <EoN> - <BoN> start <EoN> <NEWLINE> <NEWLINE> <BoN> f <EoN> . <BoN> seek <EoN> ( <BoN> offset <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> read <EoN> ( <BoN> length <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> char <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> type <EoN> ( <BoN> self <EoN> ) ( <BoN> self <EoN> . <BoN> data <EoN> . <BoN> char <EoN> ( ) , <BoN> self <EoN> . <BoN> batch sizes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fresnels zeros <EoN> ( <BoN> nt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> ( <BoN> floor <EoN> ( <BoN> nt <EoN> ) != <BoN> nt <EoN> ) <BoN> or <EoN> ( <BoN> nt <EoN> <= <NUMBER> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> isscalar <EoN> ( <BoN> nt <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> specfun <EoN> . <BoN> fcszo <EoN> ( <NUMBER> , <BoN> nt <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> readtime dtype <EoN> ( <BoN> basetype <EoN> , <BoN> names <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> names <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> basetype <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> basetype <EoN> . <BoN> names <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> names <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> basetype <EoN> . <BoN> names <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> numpy <EoN> . <BoN> dtype <EoN> ( [ ( <BoN> name <EoN> , <BoN> basetype <EoN> . <BoN> fields <EoN> [ <BoN> name <EoN> ] [ <NUMBER> ] ) <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> names <EoN> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> mk Tuple <EoN> ( <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> args <EoN> = [ <BoN> String <EoN> ( <BoN> arg <EoN> ) <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> arg <EoN> , <BoN> string types <EoN> ) <BoN> else <EoN> <BoN> arg <EoN> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> return <EoN> <BoN> Tuple <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> should read directly <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> is compressed file <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> fileno <EoN> ( ) >= <NUMBER> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> io <EoN> . <BoN> Unsupported Operation <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get kernel <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> , <BoN> signature <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> hdl <EoN> = <BoN> Cuda Kernel Handle <EoN> ( ) <NEWLINE> <BoN> is ndarray <EoN> = [ ] <NEWLINE> <BoN> is const <EoN> = [ ] <NEWLINE> <BoN> dtypes <EoN> = [ ] <NEWLINE> <BoN> pattern <EoN> = <BoN> re <EoN> . <BoN> compile <EoN> ( <STRING> ) <NEWLINE> <BoN> args <EoN> = <BoN> re <EoN> . <BoN> sub <EoN> ( <STRING> , <STRING> , <BoN> signature <EoN> ) . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> match <EoN> = <BoN> pattern <EoN> . <BoN> match <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> match <EoN> <BoN> or <EoN> <BoN> match <EoN> . <BoN> groups <EoN> ( ) [ <NUMBER> ] == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> arg <EoN> ) <NEWLINE> <UNTAB> <BoN> is const <EoN> . <BoN> append <EoN> ( <BoN> bool <EoN> ( <BoN> match <EoN> . <BoN> groups <EoN> ( ) [ <NUMBER> ] ) ) <NEWLINE> <BoN> dtype <EoN> = <BoN> match <EoN> . <BoN> groups <EoN> ( ) [ <NUMBER> ] <NEWLINE> <BoN> is ndarray <EoN> . <BoN> append <EoN> ( <BoN> bool <EoN> ( <BoN> match <EoN> . <BoN> groups <EoN> ( ) [ <NUMBER> ] ) ) <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> DTYPE CPP TO NP <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> arg <EoN> , <STRING> . <BoN> join <EoN> ( <BoN> DTYPE CPP TO NP <EoN> . <BoN> keys <EoN> ( ) ) ) ) <NEWLINE> <UNTAB> <BoN> dtypes <EoN> . <BoN> append <EoN> ( <BoN> DTYPE NP TO MX <EoN> [ <BoN> DTYPE CPP TO NP <EoN> [ <BoN> dtype <EoN> ] ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MX Rtc Cuda Kernel Create <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> handle <EoN> , <NEWLINE> <BoN> c str <EoN> ( <BoN> name <EoN> ) , <NEWLINE> <BoN> len <EoN> ( <BoN> dtypes <EoN> ) , <NEWLINE> <BoN> c array buf <EoN> ( <BoN> ctypes <EoN> . <BoN> c int <EoN> , <BoN> array <EoN> ( <STRING> , <BoN> is ndarray <EoN> ) ) , <NEWLINE> <BoN> c array buf <EoN> ( <BoN> ctypes <EoN> . <BoN> c int <EoN> , <BoN> array <EoN> ( <STRING> , <BoN> is const <EoN> ) ) , <NEWLINE> <BoN> c array buf <EoN> ( <BoN> ctypes <EoN> . <BoN> c int <EoN> , <BoN> array <EoN> ( <STRING> , <BoN> dtypes <EoN> ) ) , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> hdl <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Cuda Kernel <EoN> ( <BoN> hdl <EoN> , <BoN> name <EoN> , <BoN> is ndarray <EoN> , <BoN> dtypes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> process parameters <EoN> ( <BoN> self <EoN> , <BoN> mean <EoN> , <BoN> rowcov <EoN> , <BoN> colcov <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> mean <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> mean <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> mean <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> meanshape <EoN> = <BoN> mean <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> meanshape <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> any <EoN> ( <BoN> meanshape <EoN> == <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> rowcov <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> rowcov <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> rowcov <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> mean <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> rowcov <EoN> = <BoN> rowcov <EoN> * <BoN> np <EoN> . <BoN> identity <EoN> ( <BoN> meanshape <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> rowcov <EoN> = <BoN> rowcov <EoN> * <BoN> np <EoN> . <BoN> identity <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> rowcov <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> rowcov <EoN> = <BoN> np <EoN> . <BoN> diag <EoN> ( <BoN> rowcov <EoN> ) <NEWLINE> <UNTAB> <BoN> rowshape <EoN> = <BoN> rowcov <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> rowshape <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rowshape <EoN> [ <NUMBER> ] != <BoN> rowshape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> rowshape <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> numrows <EoN> = <BoN> rowshape <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> colcov <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> colcov <EoN> , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> colcov <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> mean <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> colcov <EoN> = <BoN> colcov <EoN> * <BoN> np <EoN> . <BoN> identity <EoN> ( <BoN> meanshape <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> colcov <EoN> = <BoN> colcov <EoN> * <BoN> np <EoN> . <BoN> identity <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> colcov <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> colcov <EoN> = <BoN> np <EoN> . <BoN> diag <EoN> ( <BoN> colcov <EoN> ) <NEWLINE> <UNTAB> <BoN> colshape <EoN> = <BoN> colcov <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> colshape <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> colshape <EoN> [ <NUMBER> ] != <BoN> colshape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> colshape <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> numcols <EoN> = <BoN> colshape <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> mean <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> meanshape <EoN> [ <NUMBER> ] != <BoN> numrows <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> meanshape <EoN> [ <NUMBER> ] != <BoN> numcols <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> mean <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> numrows <EoN> , <BoN> numcols <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> dims <EoN> = ( <BoN> numrows <EoN> , <BoN> numcols <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dims <EoN> , <BoN> mean <EoN> , <BoN> rowcov <EoN> , <BoN> colcov <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> collapse <EoN> ( <BoN> G <EoN> , <BoN> grouped nodes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> mapping <EoN> = { } <NEWLINE> <BoN> members <EoN> = { } <NEWLINE> <BoN> C <EoN> = <BoN> G <EoN> . <BoN> class <EoN> ( ) <NEWLINE> <BoN> i <EoN> = <NUMBER> <NEWLINE> <BoN> remaining <EoN> = <BoN> set <EoN> ( <BoN> G <EoN> . <BoN> nodes <EoN> ( ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> group <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> grouped nodes <EoN> ) : <NEWLINE> <TAB> <BoN> group <EoN> = <BoN> set <EoN> ( <BoN> group <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> remaining <EoN> . <BoN> issuperset <EoN> ( <BoN> group <EoN> ) , ( <NEWLINE> <STRING> ) <NEWLINE> <BoN> remaining <EoN> . <BoN> difference update <EoN> ( <BoN> group <EoN> ) <NEWLINE> <BoN> members <EoN> [ <BoN> i <EoN> ] = <BoN> group <EoN> <NEWLINE> <BoN> mapping <EoN> . <BoN> update <EoN> ( ( <BoN> n <EoN> , <BoN> i <EoN> ) <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> group <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> , <BoN> node <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> remaining <EoN> , <BoN> start <EoN> = <BoN> i <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> group <EoN> = <BoN> set <EoN> ( [ <BoN> node <EoN> ] ) <NEWLINE> <BoN> members <EoN> [ <BoN> i <EoN> ] = <BoN> group <EoN> <NEWLINE> <BoN> mapping <EoN> . <BoN> update <EoN> ( ( <BoN> n <EoN> , <BoN> i <EoN> ) <BoN> for <EoN> <BoN> n <EoN> <BoN> in <EoN> <BoN> group <EoN> ) <NEWLINE> <UNTAB> <BoN> number of groups <EoN> = <BoN> i <EoN> + <NUMBER> <NEWLINE> <BoN> C <EoN> . <BoN> add nodes from <EoN> ( <BoN> range <EoN> ( <BoN> number of groups <EoN> ) ) <NEWLINE> <BoN> C <EoN> . <BoN> add edges from <EoN> ( ( <BoN> mapping <EoN> [ <BoN> u <EoN> ] , <BoN> mapping <EoN> [ <BoN> v <EoN> ] ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> edges <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> mapping <EoN> [ <BoN> u <EoN> ] != <BoN> mapping <EoN> [ <BoN> v <EoN> ] ) <NEWLINE> <NEWLINE> <BoN> nx <EoN> . <BoN> set node attributes <EoN> ( <BoN> C <EoN> , <BoN> name <EoN> = <STRING> , <BoN> values <EoN> = <BoN> members <EoN> ) <NEWLINE> <NEWLINE> <BoN> C <EoN> . <BoN> graph <EoN> [ <STRING> ] = <BoN> mapping <EoN> <NEWLINE> <BoN> return <EoN> <BoN> C <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> try coerce result <EoN> ( <BoN> self <EoN> , <BoN> result <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> result <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> result <EoN> . <BoN> dtype <EoN> . <BoN> kind <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> result <EoN> . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> result <EoN> , ( <BoN> np <EoN> . <BoN> integer <EoN> , <BoN> np <EoN> . <BoN> float <EoN> , <BoN> np <EoN> . <BoN> datetime 64 <EoN> ) ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> box func <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> contextmanager <EoN> <NEWLINE> <BoN> def <EoN> <BoN> decompress file <EoN> ( <BoN> path <EoN> , <BoN> compression <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> compression <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> open <EoN> ( <BoN> path <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> compression <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> gzip <EoN> <NEWLINE> <BoN> f <EoN> = <BoN> gzip <EoN> . <BoN> open <EoN> ( <BoN> path <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> compression <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> bz 2 <EoN> <NEWLINE> <BoN> f <EoN> = <BoN> bz 2 <EoN> . <BoN> B Z 2 File <EoN> ( <BoN> path <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> compression <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> lzma <EoN> = <BoN> compat <EoN> . <BoN> import lzma <EoN> ( ) <NEWLINE> <BoN> f <EoN> = <BoN> lzma <EoN> . <BoN> LZMA File <EoN> ( <BoN> path <EoN> , <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> compression <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> zipfile <EoN> <NEWLINE> <BoN> zip file <EoN> = <BoN> zipfile <EoN> . <BoN> Zip File <EoN> ( <BoN> path <EoN> ) <NEWLINE> <BoN> zip names <EoN> = <BoN> zip file <EoN> . <BoN> namelist <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> zip names <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> zip file <EoN> . <BoN> open <EoN> ( <BoN> zip names <EoN> . <BoN> pop <EoN> ( ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> . <BoN> format <EoN> ( <BoN> path <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> . <BoN> format <EoN> ( <BoN> compression <EoN> ) <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> yield <EoN> <BoN> f <EoN> <NEWLINE> <BoN> f <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> collect metrics <EoN> ( <BoN> metrics <EoN> , <BoN> output names <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> metrics <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ [ ] <BoN> for <EoN> <BoN> <EoN> <BoN> in <EoN> <BoN> output names <EoN> ] <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> metrics <EoN> , <BoN> list <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> copy <EoN> . <BoN> copy <EoN> ( <BoN> metrics <EoN> ) <BoN> for <EoN> <BoN> <EoN> <BoN> in <EoN> <BoN> output names <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> metrics <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> nested metrics <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> output names <EoN> : <NEWLINE> <TAB> <BoN> output metrics <EoN> = <BoN> metrics <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> , [ ] ) <NEWLINE> <BoN> output metrics <EoN> = <BoN> to list <EoN> ( <BoN> output metrics <EoN> ) <NEWLINE> <BoN> nested metrics <EoN> . <BoN> append <EoN> ( <BoN> output metrics <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> nested metrics <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> <NEWLINE> <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> metrics <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> inverse <EoN> ( <BoN> self <EoN> , <BoN> argindex <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> acot <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> deprecation <EoN> . <BoN> deprecated <EoN> ( <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> optimizer or optimizer fn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> optimizer or optimizer fn <EoN> = <BoN> optimizer or optimizer fn <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict classes <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> batch size <EoN> = <NUMBER> , <BoN> verbose <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> proba <EoN> = <BoN> self <EoN> . <BoN> predict <EoN> ( <BoN> x <EoN> , <BoN> batch size <EoN> = <BoN> batch size <EoN> , <BoN> verbose <EoN> = <BoN> verbose <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> proba <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] > <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> proba <EoN> . <BoN> argmax <EoN> ( <BoN> axis <EoN> = - <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> proba <EoN> > <NUMBER> ) . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trimboth <EoN> ( <BoN> data <EoN> , <BoN> proportiontocut <EoN> = <NUMBER> , <BoN> inclusive <EoN> = ( <BoN> True <EoN> , <BoN> True <EoN> ) , <BoN> axis <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> trimr <EoN> ( <BoN> data <EoN> , <BoN> limits <EoN> = ( <BoN> proportiontocut <EoN> , <BoN> proportiontocut <EoN> ) , <NEWLINE> <BoN> inclusive <EoN> = <BoN> inclusive <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup rr trivial gcd <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> f <EoN> <BoN> or <EoN> <BoN> g <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ ] , [ ] , [ ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> K <EoN> . <BoN> is nonnegative <EoN> ( <BoN> dup LC <EoN> ( <BoN> g <EoN> , <BoN> K <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> g <EoN> , [ ] , [ <BoN> K <EoN> . <BoN> one <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dup neg <EoN> ( <BoN> g <EoN> , <BoN> K <EoN> ) , [ ] , [ - <BoN> K <EoN> . <BoN> one <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> g <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> K <EoN> . <BoN> is nonnegative <EoN> ( <BoN> dup LC <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> , [ <BoN> K <EoN> . <BoN> one <EoN> ] , [ ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dup neg <EoN> ( <BoN> f <EoN> , <BoN> K <EoN> ) , [ - <BoN> K <EoN> . <BoN> one <EoN> ] , [ ] <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> draw to density <EoN> ( <BoN> self <EoN> , <BoN> ax <EoN> , <BoN> center <EoN> , <BoN> val <EoN> , <BoN> support <EoN> , <BoN> density <EoN> , <BoN> split <EoN> , ** <BoN> kws <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> idx <EoN> = <BoN> np <EoN> . <BoN> argmin <EoN> ( <BoN> np <EoN> . <BoN> abs <EoN> ( <BoN> support <EoN> - <BoN> val <EoN> ) ) <NEWLINE> <BoN> width <EoN> = <BoN> self <EoN> . <BoN> dwidth <EoN> * <BoN> density <EoN> [ <BoN> idx <EoN> ] * <NUMBER> <NEWLINE> <NEWLINE> <BoN> kws <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> gray <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> orient <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> split <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> center <EoN> - <BoN> width <EoN> , <BoN> center <EoN> ] , [ <BoN> val <EoN> , <BoN> val <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> split <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> center <EoN> , <BoN> center <EoN> + <BoN> width <EoN> ] , [ <BoN> val <EoN> , <BoN> val <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> center <EoN> - <BoN> width <EoN> , <BoN> center <EoN> + <BoN> width <EoN> ] , [ <BoN> val <EoN> , <BoN> val <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> split <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> val <EoN> , <BoN> val <EoN> ] , [ <BoN> center <EoN> - <BoN> width <EoN> , <BoN> center <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> split <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> val <EoN> , <BoN> val <EoN> ] , [ <BoN> center <EoN> , <BoN> center <EoN> + <BoN> width <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( [ <BoN> val <EoN> , <BoN> val <EoN> ] , [ <BoN> center <EoN> - <BoN> width <EoN> , <BoN> center <EoN> + <BoN> width <EoN> ] , ** <BoN> kws <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> byte <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> type <EoN> ( <BoN> self <EoN> ) ( <BoN> self <EoN> . <BoN> data <EoN> . <BoN> byte <EoN> ( ) , <BoN> self <EoN> . <BoN> batch sizes <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> arange <EoN> ( <BoN> start <EoN> , <BoN> stop <EoN> = <BoN> None <EoN> , <BoN> step <EoN> = <NUMBER> , <BoN> dtype <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> stop <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> start <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> start <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> start <EoN> , <BoN> limit <EoN> = <BoN> stop <EoN> , <BoN> delta <EoN> = <BoN> step <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> dtype <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> cast <EoN> ( <BoN> result <EoN> , <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dense image warp <EoN> ( <BoN> image <EoN> , <BoN> flow <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> ) : <NEWLINE> <TAB> <BoN> batch size <EoN> , <BoN> height <EoN> , <BoN> width <EoN> , <BoN> channels <EoN> = ( <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> image <EoN> ) [ <NUMBER> ] , <NEWLINE> <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> image <EoN> ) [ <NUMBER> ] , <NEWLINE> <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> image <EoN> ) [ <NUMBER> ] , <NEWLINE> <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> image <EoN> ) [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> grid x <EoN> , <BoN> grid y <EoN> = <BoN> array ops <EoN> . <BoN> meshgrid <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> width <EoN> ) , <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> height <EoN> ) ) <NEWLINE> <BoN> stacked grid <EoN> = <BoN> math ops <EoN> . <BoN> cast <EoN> ( <NEWLINE> <BoN> array ops <EoN> . <BoN> stack <EoN> ( [ <BoN> grid y <EoN> , <BoN> grid x <EoN> ] , <BoN> axis <EoN> = <NUMBER> ) , <BoN> flow <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> batched grid <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> stacked grid <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> query points on grid <EoN> = <BoN> batched grid <EoN> - <BoN> flow <EoN> <NEWLINE> <BoN> query points flattened <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> query points on grid <EoN> , <NEWLINE> [ <BoN> batch size <EoN> , <BoN> height <EoN> * <BoN> width <EoN> , <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> interpolated <EoN> = <BoN> interpolate bilinear <EoN> ( <BoN> image <EoN> , <BoN> query points flattened <EoN> ) <NEWLINE> <BoN> interpolated <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> interpolated <EoN> , <NEWLINE> [ <BoN> batch size <EoN> , <BoN> height <EoN> , <BoN> width <EoN> , <BoN> channels <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> interpolated <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as coeff add <EoN> ( <BoN> self <EoN> , * <BoN> deps <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> deps <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> has <EoN> ( * <BoN> deps <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> , <BoN> tuple <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> , ( <BoN> self <EoN> , ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> next <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> batch size <EoN> = <BoN> self <EoN> . <BoN> batch size <EoN> <NEWLINE> <BoN> c <EoN> , <BoN> h <EoN> , <BoN> w <EoN> = <BoN> self <EoN> . <BoN> data shape <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> cache data <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> cache label <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> , <STRING> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> cache idx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> , <STRING> <NEWLINE> <BoN> batch data <EoN> = <BoN> self <EoN> . <BoN> cache data <EoN> <NEWLINE> <BoN> batch label <EoN> = <BoN> self <EoN> . <BoN> cache label <EoN> <NEWLINE> <BoN> i <EoN> = <BoN> self <EoN> . <BoN> cache idx <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> batch data <EoN> = <BoN> nd <EoN> . <BoN> empty <EoN> ( ( <BoN> batch size <EoN> , <BoN> c <EoN> , <BoN> h <EoN> , <BoN> w <EoN> ) ) <NEWLINE> <BoN> batch label <EoN> = <BoN> nd <EoN> . <BoN> empty <EoN> ( <BoN> self <EoN> . <BoN> provide label <EoN> [ <NUMBER> ] [ <NUMBER> ] ) <NEWLINE> <BoN> i <EoN> = <BoN> self <EoN> . <BoN> batchify <EoN> ( <BoN> batch data <EoN> , <BoN> batch label <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> pad <EoN> = <BoN> batch size <EoN> - <BoN> i <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> pad <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> last batch handle <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Stop Iteration <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> last batch handle <EoN> == <STRING> <BoN> and <EoN> <BoN> self <EoN> . <BoN> cache data <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> cache data <EoN> = <BoN> batch data <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> cache label <EoN> = <BoN> batch label <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> cache idx <EoN> = <BoN> i <EoN> <NEWLINE> <BoN> raise <EoN> <BoN> Stop Iteration <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> <EoN> = <BoN> self <EoN> . <BoN> batchify <EoN> ( <BoN> batch data <EoN> , <BoN> batch label <EoN> , <BoN> i <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> last batch handle <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> allow read <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> cache data <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> cache label <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> cache idx <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> io <EoN> . <BoN> Data Batch <EoN> ( [ <BoN> batch data <EoN> ] , [ <BoN> batch label <EoN> ] , <BoN> pad <EoN> = <BoN> pad <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> generate circle mask <EoN> ( <BoN> point <EoN> , <BoN> image <EoN> , <BoN> shape <EoN> , <BoN> random <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> shape <EoN> [ <NUMBER> ] == <NUMBER> <BoN> or <EoN> <BoN> shape <EoN> [ <NUMBER> ] == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> min radius <EoN> = <BoN> shape <EoN> [ <NUMBER> ] / <NUMBER> <NEWLINE> <BoN> max radius <EoN> = <BoN> shape <EoN> [ <NUMBER> ] / <NUMBER> <NEWLINE> <BoN> left <EoN> = <BoN> point <EoN> [ <NUMBER> ] <NEWLINE> <BoN> right <EoN> = <BoN> image <EoN> [ <NUMBER> ] - <BoN> point <EoN> [ <NUMBER> ] <NEWLINE> <BoN> top <EoN> = <BoN> point <EoN> [ <NUMBER> ] <NEWLINE> <BoN> bottom <EoN> = <BoN> image <EoN> [ <NUMBER> ] - <BoN> point <EoN> [ <NUMBER> ] <NEWLINE> <BoN> available radius <EoN> = <BoN> min <EoN> ( <BoN> left <EoN> , <BoN> right <EoN> , <BoN> top <EoN> , <BoN> bottom <EoN> , <BoN> max radius <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> available radius <EoN> < <BoN> min radius <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Arithmetic Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> radius <EoN> = <BoN> random <EoN> . <BoN> randint <EoN> ( <BoN> min radius <EoN> , <BoN> available radius <EoN> + <NUMBER> ) <NEWLINE> <BoN> circle <EoN> = <BoN> draw circle <EoN> ( <BoN> point <EoN> [ <NUMBER> ] , <BoN> point <EoN> [ <NUMBER> ] , <BoN> radius <EoN> ) <NEWLINE> <BoN> label <EoN> = ( <STRING> , ( ( <BoN> point <EoN> [ <NUMBER> ] - <BoN> radius <EoN> + <NUMBER> , <BoN> point <EoN> [ <NUMBER> ] + <BoN> radius <EoN> ) , <NEWLINE> ( <BoN> point <EoN> [ <NUMBER> ] - <BoN> radius <EoN> + <NUMBER> , <BoN> point <EoN> [ <NUMBER> ] + <BoN> radius <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> circle <EoN> , <BoN> label <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getrow <EoN> ( <BoN> self <EoN> , <BoN> i <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> M <EoN> , <BoN> N <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> i <EoN> = <BoN> int <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> i <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> i <EoN> += <BoN> M <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> i <EoN> < <NUMBER> <BoN> or <EoN> <BoN> i <EoN> >= <BoN> M <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <STRING> % <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> idx <EoN> = <BoN> slice <EoN> ( * <BoN> self <EoN> . <BoN> indptr <EoN> [ <BoN> i <EoN> : <BoN> i <EoN> + <NUMBER> ] ) <NEWLINE> <BoN> data <EoN> = <BoN> self <EoN> . <BoN> data <EoN> [ <BoN> idx <EoN> ] . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> indices <EoN> = <BoN> self <EoN> . <BoN> indices <EoN> [ <BoN> idx <EoN> ] . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> indptr <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( [ <NUMBER> , <BoN> len <EoN> ( <BoN> indices <EoN> ) ] , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> indptr <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> csr matrix <EoN> ( ( <BoN> data <EoN> , <BoN> indices <EoN> , <BoN> indptr <EoN> ) , <BoN> shape <EoN> = ( <NUMBER> , <BoN> N <EoN> ) , <NEWLINE> <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> replace booleans <EoN> ( <BoN> tok <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> toknum <EoN> , <BoN> tokval <EoN> = <BoN> tok <EoN> <NEWLINE> <BoN> if <EoN> <BoN> toknum <EoN> == <BoN> tokenize <EoN> . <BoN> O P <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> tokval <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tokenize <EoN> . <BoN> NAM E <EoN> , <STRING> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> tokval <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> tokenize <EoN> . <BoN> NAM E <EoN> , <STRING> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> toknum <EoN> , <BoN> tokval <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> toknum <EoN> , <BoN> tokval <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> deepcopy <EoN> ( <BoN> self <EoN> , <BoN> memo <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> codes <EoN> = <BoN> self <EoN> . <BoN> codes <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> codes <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> class <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> vertices <EoN> . <BoN> copy <EoN> ( ) , <BoN> codes <EoN> , <NEWLINE> <BoN> interpolation steps <EoN> = <BoN> self <EoN> . <BoN> interpolation steps <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get test <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> , <BoN> name <EoN> , <BoN> module <EoN> , <BoN> globs <EoN> , <BoN> source lines <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> obj <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> docstring <EoN> = <BoN> obj <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> obj <EoN> . <BoN> doc <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> docstring <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> docstring <EoN> = <BoN> obj <EoN> . <BoN> doc <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> docstring <EoN> , <BoN> str <EoN> ) : <NEWLINE> <TAB> <BoN> docstring <EoN> = <BoN> str <EoN> ( <BoN> docstring <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Attribute Error <EoN> ) : <NEWLINE> <TAB> <BoN> docstring <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> lineno <EoN> = <BoN> self <EoN> . <BoN> find lineno <EoN> ( <BoN> obj <EoN> , <BoN> source lines <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> exclude empty <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> docstring <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> module <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> getattr <EoN> ( <BoN> module <EoN> , <STRING> , <BoN> module <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> filename <EoN> [ - <NUMBER> : ] == <STRING> : <NEWLINE> <TAB> <BoN> filename <EoN> = <BoN> filename <EoN> [ : - <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> parser <EoN> . <BoN> get doctest <EoN> ( <BoN> docstring <EoN> , <BoN> globs <EoN> , <BoN> name <EoN> , <NEWLINE> <BoN> filename <EoN> , <BoN> lineno <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> integrate box 1 d <EoN> ( <BoN> self <EoN> , <BoN> low <EoN> , <BoN> high <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> d <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> stdev <EoN> = <BoN> ravel <EoN> ( <BoN> sqrt <EoN> ( <BoN> self <EoN> . <BoN> covariance <EoN> ) ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> normalized low <EoN> = <BoN> ravel <EoN> ( ( <BoN> low <EoN> - <BoN> self <EoN> . <BoN> dataset <EoN> ) / <BoN> stdev <EoN> ) <NEWLINE> <BoN> normalized high <EoN> = <BoN> ravel <EoN> ( ( <BoN> high <EoN> - <BoN> self <EoN> . <BoN> dataset <EoN> ) / <BoN> stdev <EoN> ) <NEWLINE> <NEWLINE> <BoN> value <EoN> = <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> special <EoN> . <BoN> ndtr <EoN> ( <BoN> normalized high <EoN> ) - <NEWLINE> <BoN> special <EoN> . <BoN> ndtr <EoN> ( <BoN> normalized low <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sparse fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> strategy <EoN> , <BoN> missing values <EoN> , <BoN> axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> X <EoN> = <BoN> X <EoN> . <BoN> tocsr <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> X <EoN> = <BoN> X <EoN> . <BoN> tocsc <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> missing values <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> n zeros axis <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( <BoN> X <EoN> . <BoN> shape <EoN> [ <BoN> not <EoN> <BoN> axis <EoN> ] , <BoN> dtype <EoN> = <BoN> int <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> n zeros axis <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] - <BoN> np <EoN> . <BoN> diff <EoN> ( <BoN> X <EoN> . <BoN> indptr <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> strategy <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> missing values <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> n non missing <EoN> = <BoN> n zeros axis <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> mask missing values <EoN> = <BoN> get mask <EoN> ( <BoN> X <EoN> . <BoN> data <EoN> , <BoN> missing values <EoN> ) <NEWLINE> <BoN> mask valids <EoN> = <BoN> np <EoN> . <BoN> logical not <EoN> ( <BoN> mask missing values <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new data <EoN> = <BoN> X <EoN> . <BoN> data <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> new data <EoN> [ <BoN> mask missing values <EoN> ] = <NUMBER> <NEWLINE> <BoN> X <EoN> = <BoN> sparse <EoN> . <BoN> csc matrix <EoN> ( ( <BoN> new data <EoN> , <BoN> X <EoN> . <BoN> indices <EoN> , <BoN> X <EoN> . <BoN> indptr <EoN> ) , <NEWLINE> <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> sums <EoN> = <BoN> X <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> mask non zeros <EoN> = <BoN> sparse <EoN> . <BoN> csc matrix <EoN> ( <NEWLINE> ( <BoN> mask valids <EoN> . <BoN> astype <EoN> ( <BoN> np <EoN> . <BoN> float 64 <EoN> ) , <NEWLINE> <BoN> X <EoN> . <BoN> indices <EoN> , <NEWLINE> <BoN> X <EoN> . <BoN> indptr <EoN> ) , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> s <EoN> = <BoN> mask non zeros <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> n non missing <EoN> = <BoN> np <EoN> . <BoN> add <EoN> ( <BoN> n non missing <EoN> , <BoN> s <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sums <EoN> = <BoN> X <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> n non missing <EoN> = <BoN> np <EoN> . <BoN> diff <EoN> ( <BoN> X <EoN> . <BoN> indptr <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> np <EoN> . <BoN> errstate <EoN> ( <BoN> all <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> ravel <EoN> ( <BoN> sums <EoN> ) / <BoN> np <EoN> . <BoN> ravel <EoN> ( <BoN> n non missing <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> columns all <EoN> = <BoN> np <EoN> . <BoN> hsplit <EoN> ( <BoN> X <EoN> . <BoN> data <EoN> , <BoN> X <EoN> . <BoN> indptr <EoN> [ <NUMBER> : - <NUMBER> ] ) <NEWLINE> <BoN> mask missing values <EoN> = <BoN> get mask <EoN> ( <BoN> X <EoN> . <BoN> data <EoN> , <BoN> missing values <EoN> ) <NEWLINE> <BoN> mask valids <EoN> = <BoN> np <EoN> . <BoN> hsplit <EoN> ( <BoN> np <EoN> . <BoN> logical not <EoN> ( <BoN> mask missing values <EoN> ) , <NEWLINE> <BoN> X <EoN> . <BoN> indptr <EoN> [ <NUMBER> : - <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> columns <EoN> = [ <BoN> col <EoN> [ <BoN> mask <EoN> . <BoN> astype <EoN> ( <BoN> bool <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) ] <NEWLINE> <BoN> for <EoN> <BoN> col <EoN> , <BoN> mask <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> columns all <EoN> , <BoN> mask valids <EoN> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> strategy <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> median <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> len <EoN> ( <BoN> columns <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> column <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> columns <EoN> ) : <NEWLINE> <TAB> <BoN> median <EoN> [ <BoN> i <EoN> ] = <BoN> get median <EoN> ( <BoN> column <EoN> , <BoN> n zeros axis <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> median <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> strategy <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> most frequent <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> len <EoN> ( <BoN> columns <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> column <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> columns <EoN> ) : <NEWLINE> <TAB> <BoN> most frequent <EoN> [ <BoN> i <EoN> ] = <BoN> most frequent <EoN> ( <BoN> column <EoN> , <NEWLINE> <NUMBER> , <NEWLINE> <BoN> n zeros axis <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> most frequent <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> logpdf <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dim <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> = <BoN> self <EoN> . <BoN> process parameters <EoN> ( <BoN> df <EoN> , <BoN> scale <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> self <EoN> . <BoN> process quantiles <EoN> ( <BoN> x <EoN> , <BoN> dim <EoN> ) <NEWLINE> <BoN> <EoN> , <BoN> log det scale <EoN> = <BoN> self <EoN> . <BoN> cholesky logdet <EoN> ( <BoN> scale <EoN> ) <NEWLINE> <BoN> out <EoN> = <BoN> self <EoN> . <BoN> logpdf <EoN> ( <BoN> x <EoN> , <BoN> dim <EoN> , <BoN> df <EoN> , <BoN> scale <EoN> , <BoN> log det scale <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> squeeze output <EoN> ( <BoN> out <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> bymonthday <EoN> = <BoN> None <EoN> , <BoN> interval <EoN> = <NUMBER> , <BoN> tz <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> interval <EoN> == <BoN> int <EoN> ( <BoN> interval <EoN> ) <BoN> or <EoN> <BoN> interval <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> bymonthday <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> bymonthday <EoN> = <BoN> range <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> bymonthday <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> bymonthday <EoN> = [ <BoN> x <EoN> . <BoN> item <EoN> ( ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> bymonthday <EoN> . <BoN> astype <EoN> ( <BoN> int <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> rule <EoN> = <BoN> rrulewrapper <EoN> ( <BoN> DAIL Y <EoN> , <BoN> bymonthday <EoN> = <BoN> bymonthday <EoN> , <NEWLINE> <BoN> interval <EoN> = <BoN> interval <EoN> , ** <BoN> self <EoN> . <BoN> hms 0 d <EoN> ) <NEWLINE> <BoN> R Rule Locator <EoN> . <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> rule <EoN> , <BoN> tz <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> draw image <EoN> ( <BoN> self <EoN> , <BoN> gc <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> im <EoN> , <BoN> transform <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> set verbosity <EoN> ( <BoN> v <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> get logger <EoN> ( ) . <BoN> set Level <EoN> ( <BoN> v <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> from tensors <EoN> ( <BoN> tensors <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Tensor Dataset <EoN> ( <BoN> tensors <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> draw rubberband <EoN> ( <BoN> self <EoN> , * <BoN> data <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get output mask at <EoN> ( <BoN> self <EoN> , <BoN> node index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get node attribute at index <EoN> ( <BoN> node index <EoN> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> nodes or number <EoN> ( <NUMBER> ) <NEWLINE> <BoN> def <EoN> <BoN> cycle graph <EoN> ( <BoN> n <EoN> , <BoN> create using <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n orig <EoN> , <BoN> nodes <EoN> = <BoN> n <EoN> <NEWLINE> <BoN> G <EoN> = <BoN> empty graph <EoN> ( <BoN> nodes <EoN> , <BoN> create using <EoN> ) <NEWLINE> <BoN> G <EoN> . <BoN> add edges from <EoN> ( <BoN> pairwise <EoN> ( <BoN> nodes <EoN> ) ) <NEWLINE> <BoN> G <EoN> . <BoN> add edge <EoN> ( <BoN> nodes <EoN> [ - <NUMBER> ] , <BoN> nodes <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> return <EoN> <BoN> G <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> parallel poly from expr <EoN> ( <BoN> exprs <EoN> , <BoN> opt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> functions <EoN> . <BoN> elementary <EoN> . <BoN> piecewise <EoN> <BoN> import <EoN> <BoN> Piecewise <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> exprs <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> f <EoN> , <BoN> g <EoN> = <BoN> exprs <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> f <EoN> , <BoN> Poly <EoN> ) <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> g <EoN> , <BoN> Poly <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> f <EoN> . <BoN> class <EoN> . <BoN> from poly <EoN> ( <BoN> f <EoN> , <BoN> opt <EoN> ) <NEWLINE> <BoN> g <EoN> = <BoN> g <EoN> . <BoN> class <EoN> . <BoN> from poly <EoN> ( <BoN> g <EoN> , <BoN> opt <EoN> ) <NEWLINE> <NEWLINE> <BoN> f <EoN> , <BoN> g <EoN> = <BoN> f <EoN> . <BoN> unify <EoN> ( <BoN> g <EoN> ) <NEWLINE> <NEWLINE> <BoN> opt <EoN> . <BoN> gens <EoN> = <BoN> f <EoN> . <BoN> gens <EoN> <NEWLINE> <BoN> opt <EoN> . <BoN> domain <EoN> = <BoN> f <EoN> . <BoN> domain <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> opt <EoN> . <BoN> polys <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> opt <EoN> . <BoN> polys <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> [ <BoN> f <EoN> , <BoN> g <EoN> ] , <BoN> opt <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> origs <EoN> , <BoN> exprs <EoN> = <BoN> list <EoN> ( <BoN> exprs <EoN> ) , [ ] <NEWLINE> <BoN> exprs <EoN> , <BoN> polys <EoN> = [ ] , [ ] <NEWLINE> <NEWLINE> <BoN> failed <EoN> = <BoN> False <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> expr <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> origs <EoN> ) : <NEWLINE> <TAB> <BoN> expr <EoN> = <BoN> sympify <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> expr <EoN> , <BoN> Basic <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expr <EoN> . <BoN> is Poly <EoN> : <NEWLINE> <TAB> <BoN> polys <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> exprs <EoN> . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> opt <EoN> . <BoN> expand <EoN> : <NEWLINE> <TAB> <BoN> expr <EoN> = <BoN> expr <EoN> . <BoN> expand <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> failed <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> exprs <EoN> . <BoN> append <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> failed <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polification Failed <EoN> ( <BoN> opt <EoN> , <BoN> origs <EoN> , <BoN> exprs <EoN> , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> polys <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> polys <EoN> : <NEWLINE> <TAB> <BoN> exprs <EoN> [ <BoN> i <EoN> ] = <BoN> exprs <EoN> [ <BoN> i <EoN> ] . <BoN> as expr <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> reps <EoN> , <BoN> opt <EoN> = <BoN> parallel dict from expr <EoN> ( <BoN> exprs <EoN> , <BoN> opt <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> opt <EoN> . <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polification Failed <EoN> ( <BoN> opt <EoN> , <BoN> origs <EoN> , <BoN> exprs <EoN> , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> opt <EoN> . <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> k <EoN> , <BoN> Piecewise <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polynomial Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> coeffs list <EoN> , <BoN> lengths <EoN> = [ ] , [ ] <NEWLINE> <NEWLINE> <BoN> all monoms <EoN> = [ ] <NEWLINE> <BoN> all coeffs <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> rep <EoN> <BoN> in <EoN> <BoN> reps <EoN> : <NEWLINE> <TAB> <BoN> monoms <EoN> , <BoN> coeffs <EoN> = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> list <EoN> ( <BoN> rep <EoN> . <BoN> items <EoN> ( ) ) ) ) <NEWLINE> <NEWLINE> <BoN> coeffs list <EoN> . <BoN> extend <EoN> ( <BoN> coeffs <EoN> ) <NEWLINE> <BoN> all monoms <EoN> . <BoN> append <EoN> ( <BoN> monoms <EoN> ) <NEWLINE> <NEWLINE> <BoN> lengths <EoN> . <BoN> append <EoN> ( <BoN> len <EoN> ( <BoN> coeffs <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> domain <EoN> = <BoN> opt <EoN> . <BoN> domain <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> domain <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> opt <EoN> . <BoN> domain <EoN> , <BoN> coeffs list <EoN> = <BoN> construct domain <EoN> ( <BoN> coeffs list <EoN> , <BoN> opt <EoN> = <BoN> opt <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> coeffs list <EoN> = <BoN> list <EoN> ( <BoN> map <EoN> ( <BoN> domain <EoN> . <BoN> from sympy <EoN> , <BoN> coeffs list <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> lengths <EoN> : <NEWLINE> <TAB> <BoN> all coeffs <EoN> . <BoN> append <EoN> ( <BoN> coeffs list <EoN> [ : <BoN> k <EoN> ] ) <NEWLINE> <BoN> coeffs list <EoN> = <BoN> coeffs list <EoN> [ <BoN> k <EoN> : ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> polys <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> monoms <EoN> , <BoN> coeffs <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> all monoms <EoN> , <BoN> all coeffs <EoN> ) : <NEWLINE> <TAB> <BoN> rep <EoN> = <BoN> dict <EoN> ( <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> monoms <EoN> , <BoN> coeffs <EoN> ) ) ) <NEWLINE> <BoN> poly <EoN> = <BoN> Poly <EoN> . <BoN> from dict <EoN> ( <BoN> rep <EoN> , <BoN> opt <EoN> ) <NEWLINE> <BoN> polys <EoN> . <BoN> append <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> opt <EoN> . <BoN> polys <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> opt <EoN> . <BoN> polys <EoN> = <BoN> bool <EoN> ( <BoN> polys <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> polys <EoN> , <BoN> opt <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> is tournament <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> ( <BoN> all <EoN> ( ( <BoN> v <EoN> <BoN> in <EoN> <BoN> G <EoN> [ <BoN> u <EoN> ] ) ^ ( <BoN> u <EoN> <BoN> in <EoN> <BoN> G <EoN> [ <BoN> v <EoN> ] ) <BoN> for <EoN> <BoN> u <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> combinations <EoN> ( <BoN> G <EoN> , <NUMBER> ) ) <BoN> and <EoN> <NEWLINE> <BoN> nx <EoN> . <BoN> number of selfloops <EoN> ( <BoN> G <EoN> ) == <NUMBER> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> compare term <EoN> ( <BoN> minterm <EoN> , <BoN> term <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> x <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> term <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> x <EoN> != <NUMBER> <BoN> and <EoN> <BoN> x <EoN> != <BoN> minterm <EoN> [ <BoN> i <EoN> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> seek <EoN> ( <BoN> self <EoN> , <BoN> offset <EoN> , <BoN> whence <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> whence <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> offset <EoN> + <BoN> offset <EoN> , <BoN> whence <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> whence <EoN> == <NUMBER> <BoN> and <EoN> <BoN> self <EoN> . <BoN> size <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> offset <EoN> + <BoN> self <EoN> . <BoN> size <EoN> + <BoN> offset <EoN> , <NUMBER> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> offset <EoN> , <BoN> whence <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> expect broadcast shapes <EoN> ( * <BoN> shape types <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> shapes <EoN> = [ <BoN> eval <EoN> ( <BoN> s <EoN> ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> shape types <EoN> ] <NEWLINE> <BoN> error <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> numpy <EoN> . <BoN> broadcast <EoN> ( * [ <BoN> numpy <EoN> . <BoN> empty <EoN> ( <BoN> s <EoN> + ( <NUMBER> , ) ) <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> shapes <EoN> ] ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> msgs <EoN> = [ <STRING> ] <NEWLINE> <BoN> for <EoN> <BoN> shape type <EoN> , <BoN> shape <EoN> <BoN> in <EoN> <BoN> six <EoN> . <BoN> moves <EoN> . <BoN> zip <EoN> ( <BoN> shape types <EoN> , <BoN> shapes <EoN> ) : <NEWLINE> <TAB> <BoN> msgs <EoN> . <BoN> append <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> shape type <EoN> , <BoN> shape <EoN> ) ) <NEWLINE> <UNTAB> <BoN> error <EoN> = <BoN> Invalid Type <EoN> ( <STRING> , <STRING> , <BoN> msg <EoN> = <STRING> . <BoN> join <EoN> ( <BoN> msgs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> error <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> record <EoN> ( <BoN> self <EoN> , <BoN> stream <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> stream <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> stream <EoN> = <BoN> torch <EoN> . <BoN> cuda <EoN> . <BoN> current stream <EoN> ( ) <NEWLINE> <UNTAB> <BoN> stream <EoN> . <BoN> record event <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fix gemm <EoN> ( <BoN> op name <EoN> , <BoN> inputs <EoN> , <BoN> old attr <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> op sym <EoN> = <BoN> getattr <EoN> ( <BoN> symbol <EoN> , <BoN> op name <EoN> , <BoN> None <EoN> ) <NEWLINE> <BoN> alpha <EoN> = <BoN> float <EoN> ( <BoN> old attr <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <BoN> beta <EoN> = <BoN> float <EoN> ( <BoN> old attr <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <BoN> trans a <EoN> = <BoN> int <EoN> ( <BoN> old attr <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <BoN> trans b <EoN> = <BoN> int <EoN> ( <BoN> old attr <EoN> . <BoN> get <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <BoN> if <EoN> <BoN> trans a <EoN> : <NEWLINE> <TAB> <BoN> inputs <EoN> [ <NUMBER> ] = <BoN> symbol <EoN> . <BoN> transpose <EoN> ( <BoN> inputs <EoN> [ <NUMBER> ] , <BoN> axes <EoN> = ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> trans b <EoN> : <NEWLINE> <TAB> <BoN> inputs <EoN> [ <NUMBER> ] = <BoN> symbol <EoN> . <BoN> transpose <EoN> ( <BoN> inputs <EoN> [ <NUMBER> ] , <BoN> axes <EoN> = ( <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> new inputs <EoN> = [ <BoN> alpha <EoN> * <BoN> inputs <EoN> [ <NUMBER> ] , <BoN> inputs <EoN> [ <NUMBER> ] , <BoN> beta <EoN> * <BoN> inputs <EoN> [ <NUMBER> ] ] <NEWLINE> <BoN> new attr <EoN> = { <STRING> : <BoN> proto obj <EoN> . <BoN> params <EoN> [ <BoN> inputs <EoN> [ <NUMBER> ] . <BoN> name <EoN> ] . <BoN> shape <EoN> [ <NUMBER> ] } <NEWLINE> <BoN> return <EoN> <BoN> op sym <EoN> , <BoN> new attr <EoN> , <BoN> new inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> random contrast <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> min factor <EoN> = <BoN> Null <EoN> , <BoN> max factor <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pow <EoN> ( <BoN> x <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> tf <EoN> . <BoN> pow <EoN> ( <BoN> x <EoN> , <BoN> a <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> trace <EoN> ( <BoN> self <EoN> , <BoN> offset <EoN> = <NUMBER> , <BoN> axis 1 <EoN> = <NUMBER> , <BoN> axis 2 <EoN> = <NUMBER> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> m <EoN> = <BoN> self <EoN> . <BoN> mask <EoN> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> <BoN> is <EoN> <BoN> nomask <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> super <EoN> ( <BoN> Masked Array <EoN> , <BoN> self <EoN> ) . <BoN> trace <EoN> ( <BoN> offset <EoN> = <BoN> offset <EoN> , <BoN> axis 1 <EoN> = <BoN> axis 1 <EoN> , <NEWLINE> <BoN> axis 2 <EoN> = <BoN> axis 2 <EoN> , <BoN> out <EoN> = <BoN> out <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> . <BoN> astype <EoN> ( <BoN> dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> D <EoN> = <BoN> self <EoN> . <BoN> diagonal <EoN> ( <BoN> offset <EoN> = <BoN> offset <EoN> , <BoN> axis 1 <EoN> = <BoN> axis 1 <EoN> , <BoN> axis 2 <EoN> = <BoN> axis 2 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> D <EoN> . <BoN> astype <EoN> ( <BoN> dtype <EoN> ) . <BoN> filled <EoN> ( <NUMBER> ) . <BoN> sum <EoN> ( <BoN> axis <EoN> = - <NUMBER> , <BoN> out <EoN> = <BoN> out <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> floor eager fallback <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> x <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> x <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> x <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> collapse repeated <EoN> ( <BoN> labels <EoN> , <BoN> seq length <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , <NEWLINE> [ <BoN> labels <EoN> , <BoN> seq length <EoN> ] ) : <NEWLINE> <TAB> <BoN> labels <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> labels <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <BoN> seq length <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> seq length <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> label mask <EoN> = <BoN> array ops <EoN> . <BoN> concat <EoN> ( <NEWLINE> [ <BoN> array ops <EoN> . <BoN> ones like <EoN> ( <BoN> labels <EoN> [ : , : <NUMBER> ] , <BoN> dtypes <EoN> . <BoN> bool <EoN> ) , <NEWLINE> <BoN> math ops <EoN> . <BoN> not equal <EoN> ( <BoN> labels <EoN> [ : , <NUMBER> : ] , <BoN> labels <EoN> [ : , : - <NUMBER> ] ) ] , <NEWLINE> <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> maxlen <EoN> = <BoN> get dim <EoN> ( <BoN> labels <EoN> , <NUMBER> ) <NEWLINE> <BoN> seq mask <EoN> = <BoN> array ops <EoN> . <BoN> sequence mask <EoN> ( <BoN> seq length <EoN> , <BoN> maxlen <EoN> = <BoN> maxlen <EoN> ) <NEWLINE> <BoN> label mask <EoN> = <BoN> math ops <EoN> . <BoN> logical and <EoN> ( <BoN> label mask <EoN> , <BoN> seq mask <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new seq len <EoN> = <BoN> math ops <EoN> . <BoN> reduce sum <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> label mask <EoN> , <BoN> dtypes <EoN> . <BoN> int 32 <EoN> ) , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> new maxlen <EoN> = <BoN> math ops <EoN> . <BoN> reduce max <EoN> ( <BoN> new seq len <EoN> ) <NEWLINE> <BoN> idx mask <EoN> = <BoN> array ops <EoN> . <BoN> sequence mask <EoN> ( <BoN> new seq len <EoN> , <BoN> maxlen <EoN> = <BoN> new maxlen <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> flat labels <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> labels <EoN> , [ - <NUMBER> ] ) <NEWLINE> <BoN> flat label mask <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> label mask <EoN> , [ - <NUMBER> ] ) <NEWLINE> <BoN> flat idx mask <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> idx mask <EoN> , [ - <NUMBER> ] ) <NEWLINE> <BoN> idx <EoN> = <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> get dim <EoN> ( <BoN> flat idx mask <EoN> , <NUMBER> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> flat <EoN> = <BoN> array ops <EoN> . <BoN> scatter nd <EoN> ( <NEWLINE> <BoN> indices <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <NEWLINE> <BoN> array ops <EoN> . <BoN> boolean mask <EoN> ( <BoN> idx <EoN> , <BoN> flat idx mask <EoN> ) , <BoN> axis <EoN> = <NUMBER> ) , <NEWLINE> <BoN> updates <EoN> = <BoN> array ops <EoN> . <BoN> boolean mask <EoN> ( <BoN> flat labels <EoN> , <BoN> flat label mask <EoN> ) , <NEWLINE> <BoN> shape <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> flat idx mask <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> batch size <EoN> = <BoN> get dim <EoN> ( <BoN> labels <EoN> , <NUMBER> ) <NEWLINE> <BoN> new shape <EoN> = [ <BoN> batch size <EoN> , <BoN> new maxlen <EoN> ] <NEWLINE> <BoN> return <EoN> ( <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> flat <EoN> , <BoN> new shape <EoN> ) , <NEWLINE> <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> new seq len <EoN> , <BoN> seq length <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is forest <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> G <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> nx <EoN> . <BoN> exception <EoN> . <BoN> Network X Pointless Concept <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> G <EoN> . <BoN> is directed <EoN> ( ) : <NEWLINE> <TAB> <BoN> components <EoN> = <BoN> nx <EoN> . <BoN> weakly connected component subgraphs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> components <EoN> = <BoN> nx <EoN> . <BoN> connected component subgraphs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> all <EoN> ( <BoN> len <EoN> ( <BoN> c <EoN> ) - <NUMBER> == <BoN> c <EoN> . <BoN> number of edges <EoN> ( ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> components <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> floordiv <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> groups <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> X <EoN> , <BoN> y <EoN> = <BoN> check X y <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> cv <EoN> = <BoN> check cv <EoN> ( <BoN> self <EoN> . <BoN> cv <EoN> , <BoN> y <EoN> , <BoN> is classifier <EoN> ( <BoN> self <EoN> . <BoN> estimator <EoN> ) ) <NEWLINE> <BoN> scorer <EoN> = <BoN> check scoring <EoN> ( <BoN> self <EoN> . <BoN> estimator <EoN> , <BoN> scoring <EoN> = <BoN> self <EoN> . <BoN> scoring <EoN> ) <NEWLINE> <BoN> n features <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <NUMBER> < <BoN> self <EoN> . <BoN> step <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> step <EoN> = <BoN> int <EoN> ( <BoN> max <EoN> ( <NUMBER> , <BoN> self <EoN> . <BoN> step <EoN> * <BoN> n features <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> step <EoN> = <BoN> int <EoN> ( <BoN> self <EoN> . <BoN> step <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> step <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> rfe <EoN> = <BoN> RF E <EoN> ( <BoN> estimator <EoN> = <BoN> self <EoN> . <BoN> estimator <EoN> , <NEWLINE> <BoN> n features to select <EoN> = <BoN> self <EoN> . <BoN> min features to select <EoN> , <NEWLINE> <BoN> step <EoN> = <BoN> self <EoN> . <BoN> step <EoN> , <BoN> verbose <EoN> = <BoN> self <EoN> . <BoN> verbose <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> effective n jobs <EoN> ( <BoN> self <EoN> . <BoN> n jobs <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> parallel <EoN> , <BoN> func <EoN> = <BoN> list <EoN> , <BoN> rfe single fit <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> parallel <EoN> = <BoN> Parallel <EoN> ( <BoN> n jobs <EoN> = <BoN> self <EoN> . <BoN> n jobs <EoN> ) <NEWLINE> <BoN> func <EoN> = <BoN> delayed <EoN> ( <BoN> rfe single fit <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> scores <EoN> = <BoN> parallel <EoN> ( <NEWLINE> <BoN> func <EoN> ( <BoN> rfe <EoN> , <BoN> self <EoN> . <BoN> estimator <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> train <EoN> , <BoN> test <EoN> , <BoN> scorer <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> train <EoN> , <BoN> test <EoN> <BoN> in <EoN> <BoN> cv <EoN> . <BoN> split <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> groups <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> scores <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> scores <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> scores rev <EoN> = <BoN> scores <EoN> [ : : - <NUMBER> ] <NEWLINE> <BoN> argmax idx <EoN> = <BoN> len <EoN> ( <BoN> scores <EoN> ) - <BoN> np <EoN> . <BoN> argmax <EoN> ( <BoN> scores rev <EoN> ) - <NUMBER> <NEWLINE> <BoN> n features to select <EoN> = <BoN> max <EoN> ( <NEWLINE> <BoN> n features <EoN> - ( <BoN> argmax idx <EoN> * <BoN> step <EoN> ) , <NEWLINE> <BoN> self <EoN> . <BoN> min features to select <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> rfe <EoN> = <BoN> RF E <EoN> ( <BoN> estimator <EoN> = <BoN> self <EoN> . <BoN> estimator <EoN> , <NEWLINE> <BoN> n features to select <EoN> = <BoN> n features to select <EoN> , <BoN> step <EoN> = <BoN> self <EoN> . <BoN> step <EoN> , <NEWLINE> <BoN> verbose <EoN> = <BoN> self <EoN> . <BoN> verbose <EoN> ) <NEWLINE> <NEWLINE> <BoN> rfe <EoN> . <BoN> fit <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> support <EoN> = <BoN> rfe <EoN> . <BoN> support <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> n features <EoN> = <BoN> rfe <EoN> . <BoN> n features <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> ranking <EoN> = <BoN> rfe <EoN> . <BoN> ranking <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> estimator <EoN> = <BoN> clone <EoN> ( <BoN> self <EoN> . <BoN> estimator <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> estimator <EoN> . <BoN> fit <EoN> ( <BoN> self <EoN> . <BoN> transform <EoN> ( <BoN> X <EoN> ) , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> grid scores <EoN> = <BoN> scores <EoN> [ : : - <NUMBER> ] / <BoN> cv <EoN> . <BoN> get n splits <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> groups <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> setxor 1 d <EoN> ( <BoN> ar 1 <EoN> , <BoN> ar 2 <EoN> , <BoN> assume unique <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> assume unique <EoN> : <NEWLINE> <TAB> <BoN> ar 1 <EoN> = <BoN> unique <EoN> ( <BoN> ar 1 <EoN> ) <NEWLINE> <BoN> ar 2 <EoN> = <BoN> unique <EoN> ( <BoN> ar 2 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> aux <EoN> = <BoN> ma <EoN> . <BoN> concatenate <EoN> ( ( <BoN> ar 1 <EoN> , <BoN> ar 2 <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> aux <EoN> . <BoN> size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> aux <EoN> <NEWLINE> <UNTAB> <BoN> aux <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> auxf <EoN> = <BoN> aux <EoN> . <BoN> filled <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> flag <EoN> = <BoN> ma <EoN> . <BoN> concatenate <EoN> ( ( [ <BoN> True <EoN> ] , ( <BoN> auxf <EoN> [ <NUMBER> : ] != <BoN> auxf <EoN> [ : - <NUMBER> ] ) , [ <BoN> True <EoN> ] ) ) <NEWLINE> <NEWLINE> <BoN> flag 2 <EoN> = ( <BoN> flag <EoN> [ <NUMBER> : ] == <BoN> flag <EoN> [ : - <NUMBER> ] ) <NEWLINE> <BoN> return <EoN> <BoN> aux <EoN> [ <BoN> flag 2 <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval nseries <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> n <EoN> , <BoN> logx <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> Order <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> sets <EoN> . <BoN> sets <EoN> <BoN> import <EoN> <BoN> Finite Set <EoN> <NEWLINE> <BoN> args <EoN> = <BoN> self <EoN> . <BoN> args <EoN> <NEWLINE> <BoN> args 0 <EoN> = [ <BoN> t <EoN> . <BoN> limit <EoN> ( <BoN> x <EoN> , <NUMBER> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( <BoN> t <EoN> . <BoN> is finite <EoN> <BoN> is <EoN> <BoN> False <EoN> <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> args 0 <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> oo <EoN> , <BoN> zoo <EoN> , <BoN> nan <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> a <EoN> = [ <BoN> t <EoN> . <BoN> compute leading term <EoN> ( <BoN> x <EoN> , <BoN> logx <EoN> = <BoN> logx <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> a 0 <EoN> = [ <BoN> t <EoN> . <BoN> limit <EoN> ( <BoN> x <EoN> , <NUMBER> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> a <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> any <EoN> ( [ <BoN> t <EoN> . <BoN> has <EoN> ( <BoN> oo <EoN> , - <BoN> oo <EoN> , <BoN> zoo <EoN> , <BoN> nan <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> a 0 <EoN> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval aseries <EoN> ( <BoN> n <EoN> , <BoN> args 0 <EoN> , <BoN> x <EoN> , <BoN> logx <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> = [ <BoN> t <EoN> . <BoN> eval nseries <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> , <BoN> logx <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> args <EoN> ] <NEWLINE> <BoN> z <EoN> = [ <BoN> r <EoN> - <BoN> r 0 <EoN> <BoN> for <EoN> ( <BoN> r <EoN> , <BoN> r 0 <EoN> ) <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> a <EoN> , <BoN> a 0 <EoN> ) ] <NEWLINE> <BoN> p <EoN> = [ <BoN> Dummy <EoN> ( ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> z <EoN> ] <NEWLINE> <BoN> q <EoN> = [ ] <NEWLINE> <BoN> v <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> for <EoN> <BoN> ai <EoN> , <BoN> zi <EoN> , <BoN> pi <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> a 0 <EoN> , <BoN> z <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> zi <EoN> . <BoN> has <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> v <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <BoN> q <EoN> . <BoN> append <EoN> ( <BoN> ai <EoN> + <BoN> pi <EoN> ) <NEWLINE> <BoN> v <EoN> = <BoN> pi <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> q <EoN> . <BoN> append <EoN> ( <BoN> ai <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> e 1 <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( * <BoN> q <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> v <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> e 1 <EoN> <NEWLINE> <UNTAB> <BoN> s <EoN> = <BoN> e 1 <EoN> . <BoN> eval nseries <EoN> ( <BoN> v <EoN> , <BoN> n <EoN> , <BoN> logx <EoN> ) <NEWLINE> <BoN> o <EoN> = <BoN> s <EoN> . <BoN> get O <EoN> ( ) <NEWLINE> <BoN> s <EoN> = <BoN> s <EoN> . <BoN> remove O <EoN> ( ) <NEWLINE> <BoN> s <EoN> = <BoN> s <EoN> . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> zi <EoN> ) . <BoN> expand <EoN> ( ) + <BoN> Order <EoN> ( <BoN> o <EoN> . <BoN> expr <EoN> . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> zi <EoN> ) , <BoN> x <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> s <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> self <EoN> . <BoN> func <EoN> . <BoN> nargs <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Naturals 0 <EoN> <NEWLINE> <BoN> or <EoN> ( <BoN> self <EoN> . <BoN> func <EoN> . <BoN> nargs <EoN> == <BoN> Finite Set <EoN> ( <NUMBER> ) <BoN> and <EoN> <BoN> args 0 <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> or <EoN> <BoN> any <EoN> ( <BoN> c <EoN> > <NUMBER> <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> func <EoN> . <BoN> nargs <EoN> ) ) : <NEWLINE> <TAB> <BoN> e <EoN> = <BoN> self <EoN> <NEWLINE> <BoN> e 1 <EoN> = <BoN> e <EoN> . <BoN> expand <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> e <EoN> == <BoN> e 1 <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> term <EoN> = <BoN> e <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , <BoN> S <EoN> . <BoN> Zero <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> term <EoN> . <BoN> is finite <EoN> <BoN> is <EoN> <BoN> False <EoN> <BoN> or <EoN> <BoN> term <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Na N <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Pole Error <EoN> ( <STRING> % ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <BoN> series <EoN> = <BoN> term <EoN> <NEWLINE> <BoN> fact <EoN> = <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <BoN> x <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> e <EoN> = <BoN> e <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , <BoN> x <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> i <EoN> += <NUMBER> <NEWLINE> <BoN> fact <EoN> *= <BoN> Rational <EoN> ( <BoN> i <EoN> ) <NEWLINE> <BoN> e <EoN> = <BoN> e <EoN> . <BoN> diff <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> subs <EoN> = <BoN> e <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , <BoN> S <EoN> . <BoN> Zero <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> subs <EoN> <BoN> is <EoN> <BoN> S <EoN> . <BoN> Na N <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> subs <EoN> = <BoN> e <EoN> . <BoN> limit <EoN> ( <BoN> x <EoN> , <BoN> S <EoN> . <BoN> Zero <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> subs <EoN> . <BoN> is finite <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Pole Error <EoN> ( <STRING> % ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <BoN> term <EoN> = <BoN> subs <EoN> * ( <BoN> x <EoN> ** <BoN> i <EoN> ) / <BoN> fact <EoN> <NEWLINE> <BoN> term <EoN> = <BoN> term <EoN> . <BoN> expand <EoN> ( ) <NEWLINE> <BoN> series <EoN> += <BoN> term <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> series <EoN> + <BoN> Order <EoN> ( <BoN> x <EoN> ** <BoN> n <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> e 1 <EoN> . <BoN> nseries <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> = <BoN> n <EoN> , <BoN> logx <EoN> = <BoN> logx <EoN> ) <NEWLINE> <UNTAB> <BoN> arg <EoN> = <BoN> self <EoN> . <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <BoN> l <EoN> = [ ] <NEWLINE> <BoN> g <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> nterms <EoN> = <BoN> n <EoN> + <NUMBER> <NEWLINE> <BoN> cf <EoN> = <BoN> Order <EoN> ( <BoN> arg <EoN> . <BoN> as leading term <EoN> ( <BoN> x <EoN> ) , <BoN> x <EoN> ) . <BoN> getn <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> cf <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> nterms <EoN> = <BoN> int <EoN> ( <BoN> nterms <EoN> / <BoN> cf <EoN> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> nterms <EoN> ) : <NEWLINE> <TAB> <BoN> g <EoN> = <BoN> self <EoN> . <BoN> taylor term <EoN> ( <BoN> i <EoN> , <BoN> arg <EoN> , <BoN> g <EoN> ) <NEWLINE> <BoN> g <EoN> = <BoN> g <EoN> . <BoN> nseries <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> = <BoN> n <EoN> , <BoN> logx <EoN> = <BoN> logx <EoN> ) <NEWLINE> <BoN> l <EoN> . <BoN> append <EoN> ( <BoN> g <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Add <EoN> ( * <BoN> l <EoN> ) + <BoN> Order <EoN> ( <BoN> x <EoN> ** <BoN> n <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> inputs <EoN> , <BoN> state <EoN> , <BoN> scope <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> state <EoN> = <BoN> array ops <EoN> . <BoN> expand dims <EoN> ( <BoN> state <EoN> , <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> transition scores <EoN> = <BoN> state <EoN> + <BoN> self <EoN> . <BoN> transition params <EoN> <NEWLINE> <BoN> new alphas <EoN> = <BoN> inputs <EoN> + <BoN> math ops <EoN> . <BoN> reduce logsumexp <EoN> ( <BoN> transition scores <EoN> , [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> new alphas <EoN> , <BoN> new alphas <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> scalar op helper <EoN> ( <BoN> node <EoN> , <BoN> op name <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> helper <EoN> , <BoN> numpy helper <EoN> , <BoN> mapping <EoN> = <BoN> import onnx modules <EoN> ( ) <NEWLINE> <BoN> name <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> proc nodes <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> inputs <EoN> = <BoN> node <EoN> [ <STRING> ] <NEWLINE> <BoN> scalar value <EoN> = [ <BoN> float <EoN> ( <BoN> node <EoN> . <BoN> get <EoN> ( <STRING> , { } ) . <BoN> get <EoN> ( <STRING> , <NUMBER> ) ) ] <NEWLINE> <NEWLINE> <BoN> input name id <EoN> = <BoN> kwargs <EoN> [ <STRING> ] [ <BoN> inputs <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <BoN> input node <EoN> = <BoN> proc nodes <EoN> [ <BoN> input name id <EoN> ] . <BoN> name <EoN> <NEWLINE> <NEWLINE> <BoN> initializer <EoN> = <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <BoN> flag <EoN> = <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> initializer <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> i <EoN> . <BoN> name <EoN> == <BoN> input node <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> op name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> new initializer <EoN> = <BoN> numpy helper <EoN> . <BoN> to array <EoN> ( <BoN> i <EoN> ) * <BoN> scalar value <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> op name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> new initializer <EoN> = <BoN> numpy helper <EoN> . <BoN> to array <EoN> ( <BoN> i <EoN> ) - <BoN> scalar value <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> op name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> new initializer <EoN> = <BoN> numpy helper <EoN> . <BoN> to array <EoN> ( <BoN> i <EoN> ) + <BoN> scalar value <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> op name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> new initializer <EoN> = <BoN> numpy helper <EoN> . <BoN> to array <EoN> ( <BoN> i <EoN> ) / <BoN> scalar value <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> flag <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> flag <EoN> <BoN> is <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> np arr <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> scalar value <EoN> ) <NEWLINE> <BoN> data type <EoN> = <BoN> mapping <EoN> . <BoN> NP TYPE TO TENSOR TYPE <EoN> [ <BoN> np arr <EoN> . <BoN> dtype <EoN> ] <NEWLINE> <BoN> dims <EoN> = <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> np arr <EoN> ) <NEWLINE> <NEWLINE> <BoN> scalar op name <EoN> = <STRING> + <BoN> str <EoN> ( <BoN> kwargs <EoN> [ <STRING> ] ) <NEWLINE> <BoN> tensor node <EoN> = <BoN> helper <EoN> . <BoN> make tensor value info <EoN> ( <BoN> scalar op name <EoN> , <BoN> data type <EoN> , <BoN> dims <EoN> ) <NEWLINE> <NEWLINE> <BoN> initializer <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> helper <EoN> . <BoN> make tensor <EoN> ( <NEWLINE> <BoN> name <EoN> = <BoN> scalar op name <EoN> , <NEWLINE> <BoN> data type <EoN> = <BoN> data type <EoN> , <NEWLINE> <BoN> dims <EoN> = <BoN> dims <EoN> , <NEWLINE> <BoN> vals <EoN> = <BoN> scalar value <EoN> , <NEWLINE> <BoN> raw <EoN> = <BoN> False <EoN> , <NEWLINE> ) <NEWLINE> ) <NEWLINE> <NEWLINE> <BoN> mul node <EoN> = <BoN> helper <EoN> . <BoN> make node <EoN> ( <NEWLINE> <BoN> op name <EoN> , <NEWLINE> [ <BoN> input node <EoN> , <BoN> scalar op name <EoN> ] , <NEWLINE> [ <BoN> name <EoN> ] , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> <NEWLINE> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> [ <BoN> tensor node <EoN> , <BoN> mul node <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> data type <EoN> = <BoN> mapping <EoN> . <BoN> NP TYPE TO TENSOR TYPE <EoN> [ <BoN> new initializer <EoN> . <BoN> dtype <EoN> ] <NEWLINE> <BoN> dims <EoN> = <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> new initializer <EoN> ) <NEWLINE> <NEWLINE> <BoN> new a node <EoN> = <BoN> input node <EoN> + <BoN> str <EoN> ( <BoN> kwargs <EoN> [ <STRING> ] ) <NEWLINE> <BoN> tensor node <EoN> = <BoN> helper <EoN> . <BoN> make tensor value info <EoN> ( <BoN> new a node <EoN> , <BoN> data type <EoN> , <BoN> dims <EoN> ) <NEWLINE> <NEWLINE> <BoN> initializer <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> helper <EoN> . <BoN> make tensor <EoN> ( <NEWLINE> <BoN> name <EoN> = <BoN> new a node <EoN> , <NEWLINE> <BoN> data type <EoN> = <BoN> data type <EoN> , <NEWLINE> <BoN> dims <EoN> = <BoN> dims <EoN> , <NEWLINE> <BoN> vals <EoN> = <BoN> new initializer <EoN> , <NEWLINE> <BoN> raw <EoN> = <BoN> False <EoN> , <NEWLINE> ) <NEWLINE> ) <NEWLINE> <BoN> return <EoN> [ <BoN> tensor node <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> variables <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> state <EoN> = <BoN> self <EoN> . <BoN> get per graph state <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> state <EoN> . <BoN> variables <EoN> ( ) <BoN> if <EoN> <BoN> state <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> else <EoN> [ ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> median <EoN> ( <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> linkage <EoN> ( <BoN> y <EoN> , <BoN> method <EoN> = <STRING> , <BoN> metric <EoN> = <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pos <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> + <BoN> a <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> line integrate <EoN> ( <BoN> field <EoN> , <BoN> curve <EoN> , <BoN> vars <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> geometry <EoN> <BoN> import <EoN> <BoN> Curve <EoN> <NEWLINE> <BoN> F <EoN> = <BoN> sympify <EoN> ( <BoN> field <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> F <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> curve <EoN> , <BoN> Curve <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> is sequence <EoN> ( <BoN> vars <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> curve <EoN> . <BoN> functions <EoN> ) != <BoN> len <EoN> ( <BoN> vars <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> curve <EoN> . <BoN> parameter <EoN> <BoN> in <EoN> <BoN> vars <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> Ft <EoN> = <BoN> F <EoN> <NEWLINE> <BoN> dldt <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> var <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> vars <EoN> ) : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> curve <EoN> . <BoN> functions <EoN> [ <BoN> i <EoN> ] <NEWLINE> <BoN> dn <EoN> = <BoN> diff <EoN> ( <BoN> f <EoN> , <BoN> curve <EoN> . <BoN> parameter <EoN> ) <NEWLINE> <NEWLINE> <BoN> dldt <EoN> = <BoN> dldt <EoN> + ( <BoN> dn <EoN> * <BoN> dn <EoN> ) <NEWLINE> <BoN> Ft <EoN> = <BoN> Ft <EoN> . <BoN> subs <EoN> ( <BoN> var <EoN> , <BoN> f <EoN> ) <NEWLINE> <UNTAB> <BoN> Ft <EoN> = <BoN> Ft <EoN> * <BoN> sqrt <EoN> ( <BoN> dldt <EoN> ) <NEWLINE> <NEWLINE> <BoN> integral <EoN> = <BoN> Integral <EoN> ( <BoN> Ft <EoN> , <BoN> curve <EoN> . <BoN> limits <EoN> ) . <BoN> doit <EoN> ( <BoN> deep <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> integral <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> memodict <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> class <EoN> <BoN> memodict <EoN> ( <BoN> defaultdict <EoN> ) : <NEWLINE> <TAB> <BoN> def <EoN> <BoN> missing <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> ret <EoN> = <BoN> self <EoN> [ <BoN> key <EoN> ] = <BoN> f <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> memodict <EoN> ( ) . <BoN> getitem <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> set default tensor type <EoN> ( <BoN> t <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> t <EoN> , <BoN> string classes <EoN> ) : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> import dotted name <EoN> ( <BoN> t <EoN> ) <NEWLINE> <UNTAB> <BoN> C <EoN> . <BoN> set default tensor type <EoN> ( <BoN> t <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> links <EoN> ( <BoN> self <EoN> , <BoN> skipself <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> skipself <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sort <EoN> ( <BoN> key <EoN> , <BoN> new <EoN> = <BoN> new <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> sort rl <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> new <EoN> ( <BoN> expr <EoN> . <BoN> class <EoN> , * <BoN> sorted <EoN> ( <BoN> expr <EoN> . <BoN> args <EoN> , <BoN> key <EoN> = <BoN> key <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sort rl <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert can do op <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> is scalar <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> type <EoN> ( <BoN> value <EoN> ) . <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> preprocess data <EoN> ( <BoN> replace names <EoN> = [ <STRING> , <STRING> ] , <BoN> label namer <EoN> = <BoN> None <EoN> , <NEWLINE> <BoN> positional parameter names <EoN> = [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <BoN> def <EoN> <BoN> fill <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> kwargs <EoN> = <BoN> cbook <EoN> . <BoN> normalize kwargs <EoN> ( <BoN> kwargs <EoN> , <BoN> mlines <EoN> . <BoN> Line 2 D <EoN> . <BoN> alias map <EoN> ) <NEWLINE> <NEWLINE> <BoN> patches <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> poly <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> get patches for fill <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> add patch <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <BoN> patches <EoN> . <BoN> append <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> autoscale view <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> patches <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> iirpeak <EoN> ( <BoN> w 0 <EoN> , <BoN> Q <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> design notch peak filter <EoN> ( <BoN> w 0 <EoN> , <BoN> Q <EoN> , <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> equal <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> math ops <EoN> . <BoN> equal <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> clear <EoN> ( <BoN> self <EoN> , <BoN> event <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> ignore <EoN> ( <BoN> event <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> useblit <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> background <EoN> = <BoN> self <EoN> . <BoN> canvas <EoN> . <BoN> copy from bbox <EoN> ( <BoN> self <EoN> . <BoN> ax <EoN> . <BoN> bbox <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> linev <EoN> . <BoN> set visible <EoN> ( <BoN> False <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> lineh <EoN> . <BoN> set visible <EoN> ( <BoN> False <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> arccosh <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> arccosh <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> linalg syrk <EoN> ( <BoN> A <EoN> = <BoN> None <EoN> , <BoN> transpose <EoN> = <BoN> Null <EoN> , <BoN> alpha <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> print jpg <EoN> ( <BoN> self <EoN> , <BoN> filename or obj <EoN> , * <BoN> args <EoN> , <BoN> dryrun <EoN> = <BoN> False <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> buf <EoN> , <BoN> size <EoN> = <BoN> self <EoN> . <BoN> print to buffer <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> dryrun <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> image <EoN> = <BoN> Image <EoN> . <BoN> frombuffer <EoN> ( <STRING> , <BoN> size <EoN> , <BoN> buf <EoN> , <STRING> , <STRING> , <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> rgba <EoN> = <BoN> mcolors <EoN> . <BoN> to rgba <EoN> ( <BoN> rc Params <EoN> [ <STRING> ] ) <NEWLINE> <BoN> color <EoN> = <BoN> tuple <EoN> ( [ <BoN> int <EoN> ( <BoN> x <EoN> * <NUMBER> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> rgba <EoN> [ : <NUMBER> ] ] ) <NEWLINE> <BoN> background <EoN> = <BoN> Image <EoN> . <BoN> new <EoN> ( <STRING> , <BoN> size <EoN> , <BoN> color <EoN> ) <NEWLINE> <BoN> background <EoN> . <BoN> paste <EoN> ( <BoN> image <EoN> , <BoN> image <EoN> ) <NEWLINE> <BoN> options <EoN> = { <BoN> k <EoN> : <BoN> kwargs <EoN> [ <BoN> k <EoN> ] <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> } <NEWLINE> <BoN> options <EoN> . <BoN> setdefault <EoN> ( <STRING> , <BoN> rc Params <EoN> [ <STRING> ] ) <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> options <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> options <EoN> [ <STRING> ] = ( <BoN> options <EoN> [ <STRING> ] , <BoN> options <EoN> [ <STRING> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> background <EoN> . <BoN> save <EoN> ( <BoN> filename or obj <EoN> , <BoN> format <EoN> = <STRING> , ** <BoN> options <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> convert <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <BoN> by item <EoN> = <BoN> True <EoN> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> <BoN> else <EoN> <BoN> kwargs <EoN> [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> new inputs <EoN> = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <BoN> new style <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> kw <EoN> <BoN> in <EoN> <BoN> new inputs <EoN> : <NEWLINE> <TAB> <BoN> new style <EoN> |= <BoN> kw <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> new style <EoN> : <NEWLINE> <TAB> <BoN> fn <EoN> = <BoN> soft convert objects <EoN> <NEWLINE> <BoN> fn inputs <EoN> = <BoN> new inputs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> fn <EoN> = <BoN> maybe convert objects <EoN> <NEWLINE> <BoN> fn inputs <EoN> = [ <STRING> , <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <UNTAB> <BoN> fn inputs <EoN> += [ <STRING> ] <NEWLINE> <NEWLINE> <BoN> fn kwargs <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> fn inputs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> fn kwargs <EoN> [ <BoN> key <EoN> ] = <BoN> kwargs <EoN> [ <BoN> key <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> def <EoN> <BoN> f <EoN> ( <BoN> m <EoN> , <BoN> v <EoN> , <BoN> i <EoN> ) : <NEWLINE> <TAB> <BoN> shape <EoN> = <BoN> v <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> values <EoN> = <BoN> fn <EoN> ( <BoN> v <EoN> . <BoN> ravel <EoN> ( ) , ** <BoN> fn kwargs <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> values <EoN> . <BoN> reshape <EoN> ( <BoN> shape <EoN> ) <NEWLINE> <BoN> values <EoN> = <BoN> block shape <EoN> ( <BoN> values <EoN> , <BoN> ndim <EoN> = <BoN> self <EoN> . <BoN> ndim <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Attribute Error <EoN> , <BoN> Not Implemented Error <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> values <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> by item <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is single block <EoN> : <NEWLINE> <TAB> <BoN> blocks <EoN> = <BoN> self <EoN> . <BoN> split and operate <EoN> ( <BoN> None <EoN> , <BoN> f <EoN> , <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> f <EoN> ( <BoN> None <EoN> , <BoN> self <EoN> . <BoN> values <EoN> . <BoN> ravel <EoN> ( ) , <BoN> None <EoN> ) <NEWLINE> <BoN> blocks <EoN> = [ <BoN> make block <EoN> ( <BoN> values <EoN> , <BoN> ndim <EoN> = <BoN> self <EoN> . <BoN> ndim <EoN> , <NEWLINE> <BoN> placement <EoN> = <BoN> self <EoN> . <BoN> mgr locs <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> blocks <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get array module <EoN> ( * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> chainer <EoN> . <BoN> backend <EoN> . <BoN> get array module <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write <EoN> ( <BoN> self <EoN> , <BoN> bytestring <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> write <EoN> ( <BoN> bytestring <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Is Attrs <EoN> ( <BoN> o <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> pywrap tensorflow internal <EoN> . <BoN> Is Attrs <EoN> ( <BoN> o <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> slice with newaxes <EoN> ( <BoN> out name <EoN> , <BoN> in name <EoN> , <BoN> blockdims <EoN> , <BoN> index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> index 2 <EoN> = <BoN> tuple <EoN> ( [ <BoN> ind <EoN> <BoN> for <EoN> <BoN> ind <EoN> <BoN> in <EoN> <BoN> index <EoN> <BoN> if <EoN> <BoN> ind <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] ) <NEWLINE> <BoN> where none <EoN> = [ <BoN> i <EoN> <BoN> for <EoN> <BoN> i <EoN> , <BoN> ind <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> index <EoN> ) <BoN> if <EoN> <BoN> ind <EoN> <BoN> is <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> where none orig <EoN> = <BoN> list <EoN> ( <BoN> where none <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> x <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> where none <EoN> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> sum <EoN> ( <BoN> isinstance <EoN> ( <BoN> ind <EoN> , <BoN> Integral <EoN> ) <BoN> for <EoN> <BoN> ind <EoN> <BoN> in <EoN> <BoN> index <EoN> [ : <BoN> x <EoN> ] ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> where none <EoN> [ <BoN> i <EoN> ] -= <BoN> n <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> dsk <EoN> , <BoN> blockdims 2 <EoN> = <BoN> slice wrap lists <EoN> ( <BoN> out name <EoN> , <BoN> in name <EoN> , <BoN> blockdims <EoN> , <BoN> index 2 <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> where none <EoN> : <NEWLINE> <TAB> <BoN> expand <EoN> = <BoN> expander <EoN> ( <BoN> where none <EoN> ) <NEWLINE> <BoN> expand orig <EoN> = <BoN> expander <EoN> ( <BoN> where none orig <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> dsk 2 <EoN> = { ( <BoN> out name <EoN> , ) + <BoN> expand <EoN> ( <BoN> k <EoN> [ <NUMBER> : ] , <NUMBER> ) : <NEWLINE> ( <BoN> v <EoN> [ : <NUMBER> ] + ( <BoN> expand orig <EoN> ( <BoN> v <EoN> [ <NUMBER> ] , <BoN> None <EoN> ) , ) ) <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> dsk <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> [ <NUMBER> ] == <BoN> out name <EoN> } <NEWLINE> <NEWLINE> <NEWLINE> <BoN> dsk 3 <EoN> = <BoN> merge <EoN> ( <BoN> dsk 2 <EoN> , { <BoN> k <EoN> : <BoN> v <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> dsk <EoN> . <BoN> items <EoN> ( ) <BoN> if <EoN> <BoN> k <EoN> [ <NUMBER> ] != <BoN> out name <EoN> } ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> blockdims 3 <EoN> = <BoN> expand <EoN> ( <BoN> blockdims 2 <EoN> , ( <NUMBER> , ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> dsk 3 <EoN> , <BoN> blockdims 3 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> dsk <EoN> , <BoN> blockdims 2 <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> execute <EoN> ( <BoN> self <EoN> , <BoN> object <EoN> , * <BoN> multiparams <EoN> , ** <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> object <EoN> , <BoN> util <EoN> . <BoN> string types <EoN> [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> execute text <EoN> ( <BoN> object <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> meth <EoN> = <BoN> object <EoN> . <BoN> execute on connection <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> exc <EoN> . <BoN> Object Not Executable Error <EoN> ( <BoN> object <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> meth <EoN> ( <BoN> self <EoN> , <BoN> multiparams <EoN> , <BoN> params <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> logistic grad hess <EoN> ( <BoN> w <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> alpha <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> n samples <EoN> , <BoN> n features <EoN> = <BoN> X <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> grad <EoN> = <BoN> np <EoN> . <BoN> empty like <EoN> ( <BoN> w <EoN> ) <NEWLINE> <BoN> fit intercept <EoN> = <BoN> grad <EoN> . <BoN> shape <EoN> [ <NUMBER> ] > <BoN> n features <EoN> <NEWLINE> <NEWLINE> <BoN> w <EoN> , <BoN> c <EoN> , <BoN> yz <EoN> = <BoN> intercept dot <EoN> ( <BoN> w <EoN> , <BoN> X <EoN> , <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <BoN> np <EoN> . <BoN> ones <EoN> ( <BoN> y <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> z <EoN> = <BoN> expit <EoN> ( <BoN> yz <EoN> ) <NEWLINE> <BoN> z 0 <EoN> = <BoN> sample weight <EoN> * ( <BoN> z <EoN> - <NUMBER> ) * <BoN> y <EoN> <NEWLINE> <NEWLINE> <BoN> grad <EoN> [ : <BoN> n features <EoN> ] = <BoN> safe sparse dot <EoN> ( <BoN> X <EoN> . <BoN> T <EoN> , <BoN> z 0 <EoN> ) + <BoN> alpha <EoN> * <BoN> w <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> fit intercept <EoN> : <NEWLINE> <TAB> <BoN> grad <EoN> [ - <NUMBER> ] = <BoN> z 0 <EoN> . <BoN> sum <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> d <EoN> = <BoN> sample weight <EoN> * <BoN> z <EoN> * ( <NUMBER> - <BoN> z <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> sparse <EoN> . <BoN> issparse <EoN> ( <BoN> X <EoN> ) : <NEWLINE> <TAB> <BoN> d X <EoN> = <BoN> safe sparse dot <EoN> ( <BoN> sparse <EoN> . <BoN> dia matrix <EoN> ( ( <BoN> d <EoN> , <NUMBER> ) , <NEWLINE> <BoN> shape <EoN> = ( <BoN> n samples <EoN> , <BoN> n samples <EoN> ) ) , <BoN> X <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> d X <EoN> = <BoN> d <EoN> [ : , <BoN> np <EoN> . <BoN> newaxis <EoN> ] * <BoN> X <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> fit intercept <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> dd intercept <EoN> = <BoN> np <EoN> . <BoN> squeeze <EoN> ( <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> d X <EoN> . <BoN> sum <EoN> ( <BoN> axis <EoN> = <NUMBER> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> Hs <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> ret <EoN> = <BoN> np <EoN> . <BoN> empty like <EoN> ( <BoN> s <EoN> ) <NEWLINE> <BoN> ret <EoN> [ : <BoN> n features <EoN> ] = <BoN> X <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> d X <EoN> . <BoN> dot <EoN> ( <BoN> s <EoN> [ : <BoN> n features <EoN> ] ) ) <NEWLINE> <BoN> ret <EoN> [ : <BoN> n features <EoN> ] += <BoN> alpha <EoN> * <BoN> s <EoN> [ : <BoN> n features <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> fit intercept <EoN> : <NEWLINE> <TAB> <BoN> ret <EoN> [ : <BoN> n features <EoN> ] += <BoN> s <EoN> [ - <NUMBER> ] * <BoN> dd intercept <EoN> <NEWLINE> <BoN> ret <EoN> [ - <NUMBER> ] = <BoN> dd intercept <EoN> . <BoN> dot <EoN> ( <BoN> s <EoN> [ : <BoN> n features <EoN> ] ) <NEWLINE> <BoN> ret <EoN> [ - <NUMBER> ] += <BoN> d <EoN> . <BoN> sum <EoN> ( ) * <BoN> s <EoN> [ - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> grad <EoN> , <BoN> Hs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> add cyclegan image summaries <EoN> ( <BoN> cyclegan model <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> cyclegan model <EoN> , <BoN> namedtuples <EoN> . <BoN> Cycle GAN Model <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> % <BoN> type <EoN> ( <BoN> cyclegan model <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> model x 2 y <EoN> . <BoN> generator inputs <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> model x 2 y <EoN> . <BoN> generated data <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> reconstructed x <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> model y 2 x <EoN> . <BoN> generator inputs <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> model y 2 x <EoN> . <BoN> generated data <EoN> ) <NEWLINE> <BoN> assert is image <EoN> ( <BoN> cyclegan model <EoN> . <BoN> reconstructed y <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> add comparison summary <EoN> ( <BoN> gan model <EoN> , <BoN> reconstructions <EoN> ) : <NEWLINE> <TAB> <BoN> image list <EoN> = ( <BoN> array ops <EoN> . <BoN> unstack <EoN> ( <BoN> gan model <EoN> . <BoN> generator inputs <EoN> [ : <NUMBER> ] ) + <NEWLINE> <BoN> array ops <EoN> . <BoN> unstack <EoN> ( <BoN> gan model <EoN> . <BoN> generated data <EoN> [ : <NUMBER> ] ) + <NEWLINE> <BoN> array ops <EoN> . <BoN> unstack <EoN> ( <BoN> reconstructions <EoN> [ : <NUMBER> ] ) ) <NEWLINE> <BoN> summary <EoN> . <BoN> image <EoN> ( <NEWLINE> <STRING> , <BoN> eval utils <EoN> . <BoN> image reshaper <EoN> ( <NEWLINE> <BoN> image list <EoN> , <BoN> num cols <EoN> = <BoN> len <EoN> ( <BoN> image list <EoN> ) ) , <BoN> max outputs <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> add comparison summary <EoN> ( <NEWLINE> <BoN> cyclegan model <EoN> . <BoN> model x 2 y <EoN> , <BoN> cyclegan model <EoN> . <BoN> reconstructed x <EoN> ) <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> add comparison summary <EoN> ( <NEWLINE> <BoN> cyclegan model <EoN> . <BoN> model y 2 x <EoN> , <BoN> cyclegan model <EoN> . <BoN> reconstructed y <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fix bias <EoN> ( <BoN> op name <EoN> , <BoN> attrs <EoN> , <BoN> num inputs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> num inputs <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> attrs <EoN> [ <STRING> ] = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> num inputs <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> attrs <EoN> [ <STRING> ] = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> op name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> attrs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get value <EoN> ( <BoN> self <EoN> , <BoN> series <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is convertible to td <EoN> ( <BoN> key <EoN> ) : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> Timedelta <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get value maybe box <EoN> ( <BoN> series <EoN> , <BoN> key <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> com <EoN> . <BoN> maybe box <EoN> ( <BoN> self <EoN> , <BoN> Index <EoN> . <BoN> get value <EoN> ( <BoN> self <EoN> , <BoN> series <EoN> , <BoN> key <EoN> ) , <NEWLINE> <BoN> series <EoN> , <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> loc <EoN> = <BoN> self <EoN> . <BoN> get string slice <EoN> ( <BoN> key <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> series <EoN> [ <BoN> loc <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> , <BoN> Key Error <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get value maybe box <EoN> ( <BoN> series <EoN> , <BoN> key <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> , <BoN> Key Error <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <BoN> key <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> arr or dtype <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> np <EoN> . <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> type <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> Extension Dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> Datetime TZ Dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> Period Dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> Interval Dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is categorical dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Categorical Dtype <EoN> . <BoN> construct from string <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is datetime 64 tz dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Datetime TZ Dtype <EoN> . <BoN> construct from string <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is period dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Period Dtype <EoN> . <BoN> construct from string <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> is interval dtype <EoN> ( <BoN> arr or dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Interval Dtype <EoN> . <BoN> construct from string <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> arr or dtype <EoN> , ( <BoN> ABC Categorical <EoN> , <BoN> ABC Categorical Index <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> arr or dtype <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> arr or dtype <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> arr or dtype <EoN> = <BoN> arr or dtype <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> dtype <EoN> ( <BoN> arr or dtype <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> cbook <EoN> . <BoN> deprecated <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> rec summarize <EoN> ( <BoN> r <EoN> , <BoN> summaryfuncs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> names <EoN> = <BoN> list <EoN> ( <BoN> r <EoN> . <BoN> dtype <EoN> . <BoN> names <EoN> ) <NEWLINE> <BoN> arrays <EoN> = [ <BoN> r <EoN> [ <BoN> name <EoN> ] <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> names <EoN> ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> attr <EoN> , <BoN> func <EoN> , <BoN> outname <EoN> <BoN> in <EoN> <BoN> summaryfuncs <EoN> : <NEWLINE> <TAB> <BoN> names <EoN> . <BoN> append <EoN> ( <BoN> outname <EoN> ) <NEWLINE> <BoN> arrays <EoN> . <BoN> append <EoN> ( <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> func <EoN> ( <BoN> r <EoN> [ <BoN> attr <EoN> ] ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> rec <EoN> . <BoN> fromarrays <EoN> ( <BoN> arrays <EoN> , <BoN> names <EoN> = <BoN> names <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ifac <EoN> ( <BoN> n <EoN> , <BoN> memo <EoN> = { <NUMBER> : <NUMBER> , <NUMBER> : <NUMBER> } ) : <NEWLINE> <TAB> <NEWLINE> <BoN> f <EoN> = <BoN> memo <EoN> . <BoN> get <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <UNTAB> <BoN> k <EoN> = <BoN> len <EoN> ( <BoN> memo <EoN> ) <NEWLINE> <BoN> p <EoN> = <BoN> memo <EoN> [ <BoN> k <EoN> - <NUMBER> ] <NEWLINE> <BoN> MA X <EoN> = <BoN> MAX FACTORIAL CACHE <EoN> <NEWLINE> <BoN> while <EoN> <BoN> k <EoN> <= <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> *= <BoN> k <EoN> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <= <BoN> MA X <EoN> : <NEWLINE> <TAB> <BoN> memo <EoN> [ <BoN> k <EoN> ] = <BoN> p <EoN> <NEWLINE> <UNTAB> <BoN> k <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> p <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> Substitution <EoN> ( <BoN> name <EoN> = <STRING> ) <NEWLINE> @ <BoN> Appender <EoN> ( <BoN> doc template <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> shift <EoN> ( <BoN> self <EoN> , <BoN> periods <EoN> = <NUMBER> , <BoN> freq <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> freq <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> axis <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> apply <EoN> ( <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> x <EoN> . <BoN> shift <EoN> ( <BoN> periods <EoN> , <BoN> freq <EoN> , <BoN> axis <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> get cythonized result <EoN> ( <STRING> , <NEWLINE> <BoN> self <EoN> . <BoN> grouper <EoN> , <BoN> cython dtype <EoN> = <BoN> np <EoN> . <BoN> int 64 <EoN> , <NEWLINE> <BoN> needs ngroups <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> result is index <EoN> = <BoN> True <EoN> , <NEWLINE> <BoN> periods <EoN> = <BoN> periods <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> slice <EoN> ( <BoN> self <EoN> , <BoN> slicer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> slicer <EoN> , <BoN> tuple <EoN> ) <BoN> and <EoN> <BoN> len <EoN> ( <BoN> slicer <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> com <EoN> . <BoN> is null slice <EoN> ( <BoN> slicer <EoN> [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Assertion Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> slicer <EoN> = <BoN> slicer <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> values <EoN> [ <BoN> slicer <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set owner <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> constant renumber <EoN> ( <BoN> expr <EoN> , <BoN> symbolname <EoN> , <BoN> startnumber <EoN> , <BoN> endnumber <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> expr <EoN> ) <BoN> in <EoN> ( <BoN> set <EoN> , <BoN> list <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> type <EoN> ( <BoN> expr <EoN> ) ( <NEWLINE> [ <BoN> constant renumber <EoN> ( <BoN> i <EoN> , <BoN> symbolname <EoN> = <BoN> symbolname <EoN> , <BoN> startnumber <EoN> = <BoN> startnumber <EoN> , <BoN> endnumber <EoN> = <BoN> endnumber <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> expr <EoN> ] <NEWLINE> ) <NEWLINE> <UNTAB> <BoN> global <EoN> <BoN> newstartnumber <EoN> <NEWLINE> <BoN> newstartnumber <EoN> = <NUMBER> <NEWLINE> <BoN> constants found <EoN> = [ <BoN> None <EoN> ] * ( <BoN> endnumber <EoN> + <NUMBER> ) <NEWLINE> <BoN> constantsymbols <EoN> = [ <BoN> Symbol <EoN> ( <NEWLINE> <BoN> symbolname <EoN> + <STRING> % <BoN> t <EoN> ) <BoN> for <EoN> <BoN> t <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> startnumber <EoN> , <NEWLINE> <BoN> endnumber <EoN> + <NUMBER> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> C 1 <EoN> = [ ( <BoN> ci <EoN> , <BoN> S <EoN> . <BoN> One <EoN> ) <BoN> for <EoN> <BoN> ci <EoN> <BoN> in <EoN> <BoN> constantsymbols <EoN> ] <NEWLINE> <BoN> sort key <EoN> = <BoN> lambda <EoN> <BoN> arg <EoN> : <BoN> default sort key <EoN> ( <BoN> arg <EoN> . <BoN> subs <EoN> ( <BoN> C 1 <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> constant renumber <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> global <EoN> <BoN> newstartnumber <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> expr <EoN> , <BoN> Equality <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Eq <EoN> ( <NEWLINE> <BoN> constant renumber <EoN> ( <BoN> expr <EoN> . <BoN> lhs <EoN> ) , <NEWLINE> <BoN> constant renumber <EoN> ( <BoN> expr <EoN> . <BoN> rhs <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> expr <EoN> ) <BoN> not <EoN> <BoN> in <EoN> ( <BoN> Mul <EoN> , <BoN> Add <EoN> , <BoN> Pow <EoN> ) <BoN> and <EoN> <BoN> not <EoN> <BoN> expr <EoN> . <BoN> is Function <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> expr <EoN> . <BoN> has <EoN> ( * <BoN> constantsymbols <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> expr <EoN> . <BoN> is Piecewise <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> expr <EoN> <BoN> in <EoN> <BoN> constantsymbols <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expr <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> constants found <EoN> : <NEWLINE> <TAB> <BoN> constants found <EoN> [ <BoN> newstartnumber <EoN> ] = <BoN> expr <EoN> <NEWLINE> <BoN> newstartnumber <EoN> += <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> expr <EoN> . <BoN> is Function <EoN> <BoN> or <EoN> <BoN> expr <EoN> . <BoN> is Pow <EoN> <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> expr <EoN> , <BoN> Tuple <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> expr <EoN> . <BoN> func <EoN> ( <NEWLINE> * [ <BoN> constant renumber <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> expr <EoN> . <BoN> args <EoN> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> sortedargs <EoN> = <BoN> list <EoN> ( <BoN> expr <EoN> . <BoN> args <EoN> ) <NEWLINE> <BoN> sortedargs <EoN> . <BoN> sort <EoN> ( <BoN> key <EoN> = <BoN> sort key <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> expr <EoN> . <BoN> func <EoN> ( * [ <BoN> constant renumber <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> sortedargs <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> expr <EoN> = <BoN> constant renumber <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <NEWLINE> <BoN> newconsts <EoN> = <BoN> symbols <EoN> ( <STRING> % <BoN> newstartnumber <EoN> ) <NEWLINE> <BoN> expr <EoN> = <BoN> expr <EoN> . <BoN> subs <EoN> ( <BoN> zip <EoN> ( <BoN> constants found <EoN> [ <NUMBER> : ] , <BoN> newconsts <EoN> ) , <BoN> simultaneous <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> expr <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> dispatch <EoN> . <BoN> add dispatch list <EoN> <NEWLINE> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> quantized concat <EoN> ( <BoN> concat dim <EoN> , <BoN> values <EoN> , <BoN> input mins <EoN> , <BoN> input maxes <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> concat dim <EoN> , <NEWLINE> <BoN> values <EoN> , <BoN> input mins <EoN> , <BoN> input maxes <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedConcatOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> quantized concat eager fallback <EoN> ( <NEWLINE> <BoN> concat dim <EoN> , <BoN> values <EoN> , <BoN> input mins <EoN> , <BoN> input maxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> quantized concat <EoN> , <BoN> concat dim <EoN> = <BoN> concat dim <EoN> , <BoN> values <EoN> = <BoN> values <EoN> , <NEWLINE> <BoN> input mins <EoN> = <BoN> input mins <EoN> , <NEWLINE> <BoN> input maxes <EoN> = <BoN> input maxes <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> values <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> values <EoN> ) <NEWLINE> <UNTAB> <BoN> attr N <EoN> = <BoN> len <EoN> ( <BoN> values <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> input mins <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> input mins <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input mins <EoN> ) != <BoN> attr N <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> len <EoN> ( <BoN> input mins <EoN> ) , <BoN> attr N <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> input maxes <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> input maxes <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> input maxes <EoN> ) != <BoN> attr N <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> len <EoN> ( <BoN> input maxes <EoN> ) , <BoN> attr N <EoN> ) ) <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> concat dim <EoN> = <BoN> concat dim <EoN> , <BoN> values <EoN> = <BoN> values <EoN> , <NEWLINE> <BoN> input mins <EoN> = <BoN> input mins <EoN> , <BoN> input maxes <EoN> = <BoN> input maxes <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> ( <BoN> Type Error <EoN> , <BoN> Value Error <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> dispatch <EoN> . <BoN> dispatch <EoN> ( <NEWLINE> <BoN> quantized concat <EoN> , <BoN> concat dim <EoN> = <BoN> concat dim <EoN> , <BoN> values <EoN> = <BoN> values <EoN> , <NEWLINE> <BoN> input mins <EoN> = <BoN> input mins <EoN> , <BoN> input maxes <EoN> = <BoN> input maxes <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> result <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> dispatch <EoN> . <BoN> Op Dispatcher <EoN> . <BoN> NOT SUPPORTED <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedConcatOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get theta offset <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> theta offset <EoN> . <BoN> get matrix <EoN> ( ) [ <NUMBER> , <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> gcd <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> python gcd <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> W <EoN> . <BoN> array <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> initialize params <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> convolution 2 d <EoN> . <BoN> convolution 2 d <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> self <EoN> . <BoN> W <EoN> , <BoN> self <EoN> . <BoN> b <EoN> , <BoN> self <EoN> . <BoN> stride <EoN> , <BoN> self <EoN> . <BoN> pad <EoN> , <BoN> dilate <EoN> = <BoN> self <EoN> . <BoN> dilate <EoN> , <NEWLINE> <BoN> groups <EoN> = <BoN> self <EoN> . <BoN> groups <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eq <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <BoN> is <EoN> <BoN> other <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> invertx <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p 1 <EoN> = <BoN> poly from expr <EoN> ( <BoN> p <EoN> , <BoN> x <EoN> ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> n <EoN> = <BoN> degree <EoN> ( <BoN> p 1 <EoN> ) <NEWLINE> <BoN> a <EoN> = [ <BoN> c <EoN> * <BoN> x <EoN> ** ( <BoN> n <EoN> - <BoN> i <EoN> ) <BoN> for <EoN> ( <BoN> i <EoN> , ) , <BoN> c <EoN> <BoN> in <EoN> <BoN> p 1 <EoN> . <BoN> terms <EoN> ( ) ] <NEWLINE> <BoN> return <EoN> <BoN> Add <EoN> ( * <BoN> a <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get complex part <EoN> ( <BoN> expr <EoN> , <BoN> no <EoN> , <BoN> prec <EoN> , <BoN> options <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> workprec <EoN> = <BoN> prec <EoN> <NEWLINE> <BoN> i <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> <NUMBER> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> evalf <EoN> ( <BoN> expr <EoN> , <BoN> workprec <EoN> , <BoN> options <EoN> ) <NEWLINE> <BoN> value <EoN> , <BoN> accuracy <EoN> = <BoN> res <EoN> [ <BoN> no <EoN> : : <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> value <EoN> ) <BoN> or <EoN> <BoN> accuracy <EoN> >= <BoN> prec <EoN> <BoN> or <EoN> - <BoN> value <EoN> [ <NUMBER> ] > <BoN> prec <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> value <EoN> , <BoN> None <EoN> , <BoN> accuracy <EoN> , <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> workprec <EoN> += <BoN> max <EoN> ( <NUMBER> , <NUMBER> ** <BoN> i <EoN> ) <NEWLINE> <BoN> i <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get init op <EoN> ( <BoN> self <EoN> , <BoN> task index <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> init ops <EoN> = [ ] <NEWLINE> <BoN> local vars <EoN> = <BoN> variables <EoN> . <BoN> trainable variables <EoN> ( ) <NEWLINE> <BoN> global center vars <EoN> = [ <BoN> self <EoN> . <BoN> global map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <BoN> grad vars <EoN> = [ <BoN> self <EoN> . <BoN> grad map <EoN> [ <BoN> var <EoN> ] <BoN> for <EoN> <BoN> var <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> local vars <EoN> <BoN> and <EoN> <BoN> global center vars <EoN> <BoN> and <EoN> <BoN> grad vars <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> lvar <EoN> , <BoN> gc var <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> local vars <EoN> , <BoN> global center vars <EoN> ) : <NEWLINE> <TAB> <BoN> init ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> lvar <EoN> , <BoN> gc var <EoN> ) ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> g <EoN> <BoN> in <EoN> <BoN> grad vars <EoN> : <NEWLINE> <TAB> <BoN> init ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> g <EoN> , <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> g <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> init op <EoN> = <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * ( <BoN> init ops <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> init op <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> check chain <EoN> ( <BoN> r <EoN> , <BoN> chain <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> chain <EoN> = <BoN> list <EoN> ( <BoN> reversed <EoN> ( <BoN> chain <EoN> ) ) <NEWLINE> <BoN> while <EoN> <BoN> chain <EoN> : <NEWLINE> <TAB> <BoN> elem <EoN> = <BoN> chain <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> elem <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> r <EoN> . <BoN> owner <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> r <EoN> . <BoN> owner <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> elem <EoN> , <BoN> op <EoN> . <BoN> Op <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> elem <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> issubclass <EoN> ( <BoN> elem <EoN> , <BoN> op <EoN> . <BoN> Op <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> , <BoN> elem <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> chain <EoN> : <NEWLINE> <TAB> <BoN> r <EoN> = <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <BoN> chain <EoN> . <BoN> pop <EoN> ( ) ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> ( <BoN> r <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> iterkeys <EoN> ( <BoN> d <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> iter <EoN> ( <BoN> getattr <EoN> ( <BoN> d <EoN> , <BoN> iterkeys <EoN> ) ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> detach <EoN> ( <BoN> self <EoN> , <BoN> dbapi connection <EoN> , <BoN> connection record <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> compute <EoN> ( <BoN> self <EoN> , <BoN> method <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> from <EoN> <BoN> pandas <EoN> <BoN> import <EoN> <BoN> Int 64 Index <EoN> <NEWLINE> <BoN> n <EoN> = <BoN> self <EoN> . <BoN> n <EoN> <NEWLINE> <BoN> frame <EoN> = <BoN> self <EoN> . <BoN> obj <EoN> <NEWLINE> <BoN> columns <EoN> = <BoN> self <EoN> . <BoN> columns <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> column <EoN> <BoN> in <EoN> <BoN> columns <EoN> : <NEWLINE> <TAB> <BoN> dtype <EoN> = <BoN> frame <EoN> [ <BoN> column <EoN> ] . <BoN> dtype <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> is valid dtype n method <EoN> ( <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( ( <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> ) . <BoN> format <EoN> ( <BoN> column <EoN> = <BoN> column <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> method <EoN> = <BoN> method <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> def <EoN> <BoN> get indexer <EoN> ( <BoN> current indexer <EoN> , <BoN> other indexer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> method <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> current indexer <EoN> . <BoN> append <EoN> ( <BoN> other indexer <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> other indexer <EoN> . <BoN> append <EoN> ( <BoN> current indexer <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> original index <EoN> = <BoN> frame <EoN> . <BoN> index <EoN> <NEWLINE> <BoN> cur frame <EoN> = <BoN> frame <EoN> = <BoN> frame <EoN> . <BoN> reset index <EoN> ( <BoN> drop <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> cur n <EoN> = <BoN> n <EoN> <NEWLINE> <BoN> indexer <EoN> = <BoN> Int 64 Index <EoN> ( [ ] ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> column <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> columns <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> series <EoN> = <BoN> cur frame <EoN> [ <BoN> column <EoN> ] <NEWLINE> <BoN> values <EoN> = <BoN> getattr <EoN> ( <BoN> series <EoN> , <BoN> method <EoN> ) ( <BoN> cur n <EoN> , <BoN> keep <EoN> = <BoN> self <EoN> . <BoN> keep <EoN> ) <NEWLINE> <BoN> is last column <EoN> = <BoN> len <EoN> ( <BoN> columns <EoN> ) - <NUMBER> == <BoN> i <EoN> <NEWLINE> <BoN> if <EoN> <BoN> is last column <EoN> <BoN> or <EoN> <BoN> values <EoN> . <BoN> nunique <EoN> ( ) == <BoN> series <EoN> . <BoN> isin <EoN> ( <BoN> values <EoN> ) . <BoN> sum <EoN> ( ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> indexer <EoN> = <BoN> get indexer <EoN> ( <BoN> indexer <EoN> , <BoN> values <EoN> . <BoN> index <EoN> ) <NEWLINE> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> duplicated filter <EoN> = <BoN> series <EoN> . <BoN> duplicated <EoN> ( <BoN> keep <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> duplicated <EoN> = <BoN> values <EoN> [ <BoN> duplicated filter <EoN> ] <NEWLINE> <BoN> non duplicated <EoN> = <BoN> values <EoN> [ ~ <BoN> duplicated filter <EoN> ] <NEWLINE> <BoN> indexer <EoN> = <BoN> get indexer <EoN> ( <BoN> indexer <EoN> , <BoN> non duplicated <EoN> . <BoN> index <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> cur frame <EoN> = <BoN> cur frame <EoN> [ <BoN> series <EoN> . <BoN> isin <EoN> ( <BoN> duplicated <EoN> ) ] <NEWLINE> <BoN> cur n <EoN> = <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> indexer <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> frame <EoN> = <BoN> frame <EoN> . <BoN> take <EoN> ( <BoN> indexer <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> frame <EoN> . <BoN> index <EoN> = <BoN> original index <EoN> . <BoN> take <EoN> ( <BoN> indexer <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> frame <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> matrix multiply elementwise <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> A <EoN> . <BoN> shape <EoN> != <BoN> B <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Shape Error <EoN> ( ) <NEWLINE> <UNTAB> <BoN> shape <EoN> = <BoN> A <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> return <EoN> <BoN> classof <EoN> ( <BoN> A <EoN> , <BoN> B <EoN> ) . <BoN> new <EoN> ( <BoN> shape <EoN> [ <NUMBER> ] , <BoN> shape <EoN> [ <NUMBER> ] , <NEWLINE> <BoN> lambda <EoN> <BoN> i <EoN> , <BoN> j <EoN> : <BoN> A <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] * <BoN> B <EoN> [ <BoN> i <EoN> , <BoN> j <EoN> ] ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cond <EoN> ( <BoN> x <EoN> , <BoN> p <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> asarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> p <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> svd <EoN> ( <BoN> x <EoN> , <BoN> compute uv <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> s <EoN> [ ... , <NUMBER> ] / <BoN> s <EoN> [ ... , - <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> norm <EoN> ( <BoN> x <EoN> , <BoN> p <EoN> , <BoN> axis <EoN> = ( - <NUMBER> , - <NUMBER> ) ) * <BoN> norm <EoN> ( <BoN> inv <EoN> ( <BoN> x <EoN> ) , <BoN> p <EoN> , <BoN> axis <EoN> = ( - <NUMBER> , - <NUMBER> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> initialize read <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> file reader <EoN> = <BoN> Var Reader 5 <EoN> ( <BoN> self <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> matrix reader <EoN> = <BoN> Var Reader 5 <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> @ <BoN> dispatch <EoN> . <BoN> add dispatch support <EoN> <NEWLINE> <BoN> def <EoN> <BoN> imag <EoN> ( <BoN> input <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> name <EoN> , <STRING> , [ <BoN> input <EoN> ] ) <BoN> as <EoN> <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> input <EoN> . <BoN> dtype <EoN> . <BoN> is complex <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> gen math ops <EoN> . <BoN> imag <EoN> ( <BoN> input <EoN> , <BoN> Tout <EoN> = <BoN> input <EoN> . <BoN> dtype <EoN> . <BoN> real dtype <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> input <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> do connect <EoN> ( <BoN> self <EoN> , <BoN> dialect <EoN> , <BoN> conn rec <EoN> , <BoN> cargs <EoN> , <BoN> cparams <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set bounds <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> args <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> l <EoN> , <BoN> b <EoN> , <BoN> w <EoN> , <BoN> h <EoN> = <BoN> args <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> l <EoN> , <BoN> b <EoN> , <BoN> w <EoN> , <BoN> h <EoN> = <BoN> args <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> x 0 <EoN> = <BoN> l <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> y 0 <EoN> = <BoN> b <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> width <EoN> = <BoN> w <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> height <EoN> = <BoN> h <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> update x 1 <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> update y 1 <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set offsets <EoN> ( <BoN> self <EoN> , <BoN> offsets <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> offsets <EoN> = <BoN> np <EoN> . <BoN> asanyarray <EoN> ( <BoN> offsets <EoN> , <BoN> float <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> offsets <EoN> . <BoN> shape <EoN> == ( <NUMBER> , ) : <NEWLINE> <TAB> <BoN> offsets <EoN> = <BoN> offsets <EoN> [ <BoN> None <EoN> , : ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> uniform offsets <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> offsets <EoN> = <BoN> offsets <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> uniform offsets <EoN> = <BoN> offsets <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> polynomial <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> terms <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> t <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <BoN> xp <EoN> = <BoN> self <EoN> . <BoN> get pow x <EoN> ( <BoN> t <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> xp <EoN> >= <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> xp <EoN> . <BoN> is integer <EoN> <BoN> is <EoN> <BoN> True <EoN> <BoN> and <EoN> <BoN> i <EoN> == <BoN> n <EoN> + <NUMBER> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> t <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> : <NEWLINE> <TAB> <BoN> terms <EoN> . <BoN> append <EoN> ( <BoN> t <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> Add <EoN> ( * <BoN> terms <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> perform selection <EoN> ( <BoN> self <EoN> , <BoN> points <EoN> , <BoN> op <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> points <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> points <EoN> , <BoN> order <EoN> = <STRING> , <BoN> dtype <EoN> = <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> points <EoN> . <BoN> shape <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> points <EoN> . <BoN> shape <EoN> = ( <NUMBER> , <BoN> points <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> id <EoN> . <BoN> get select type <EoN> ( ) != <BoN> h 5 s <EoN> . <BoN> SEL POINTS <EoN> : <NEWLINE> <TAB> <BoN> op <EoN> = <BoN> h 5 s <EoN> . <BoN> SELECT SET <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> points <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> id <EoN> . <BoN> select none <EoN> ( ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> id <EoN> . <BoN> select elements <EoN> ( <BoN> points <EoN> , <BoN> op <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> visit Call <EoN> ( <BoN> self <EoN> , <BoN> node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> func <EoN> = <BoN> anno <EoN> . <BoN> getanno <EoN> ( <BoN> node <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> func <EoN> <BoN> in <EoN> <BoN> non differentiable <EoN> . <BoN> NON DIFFERENTIABLE <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> node <EoN> , [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> func <EoN> == <BoN> tracing <EoN> . <BoN> Traceable <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> primal and adjoint for tracing <EoN> ( <BoN> node <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> func <EoN> <BoN> in <EoN> <BoN> grads <EoN> . <BoN> UNIMPLEMENTED ADJOINTS <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> errors <EoN> . <BoN> Reverse Not Implemented Error <EoN> ( <BoN> func <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> func <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> grads <EoN> . <BoN> adjoints <EoN> : <NEWLINE> <TAB> <BoN> active args <EoN> = <BoN> tuple <EoN> ( <BoN> i <EoN> <BoN> for <EoN> <BoN> i <EoN> , <BoN> arg <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> node <EoN> . <BoN> args <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> arg <EoN> . <BoN> id <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> active variables <EoN> ) <NEWLINE> <NEWLINE> <BoN> already counted <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> for <EoN> <BoN> f <EoN> , <BoN> a <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> required <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> f <EoN> . <BoN> name <EoN> == <BoN> func <EoN> . <BoN> name <EoN> <BoN> and <EoN> <BoN> set <EoN> ( <BoN> a <EoN> ) == <BoN> set <EoN> ( <BoN> active args <EoN> ) : <NEWLINE> <TAB> <BoN> already counted <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> already counted <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> required <EoN> . <BoN> append <EoN> ( ( <BoN> func <EoN> , <BoN> active args <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> pri name <EoN> = <BoN> naming <EoN> . <BoN> primal name <EoN> ( <BoN> func <EoN> , <BoN> active args <EoN> ) <NEWLINE> <BoN> pri call <EoN> = <BoN> gast <EoN> . <BoN> Call <EoN> ( <NEWLINE> <BoN> func <EoN> = <BoN> gast <EoN> . <BoN> Name <EoN> ( <BoN> id <EoN> = <BoN> pri name <EoN> , <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Load <EoN> ( ) , <BoN> annotation <EoN> = <BoN> None <EoN> ) , <NEWLINE> <BoN> args <EoN> = [ <BoN> self <EoN> . <BoN> substack <EoN> ] + <BoN> node <EoN> . <BoN> args <EoN> , <NEWLINE> <BoN> keywords <EoN> = <BoN> node <EoN> . <BoN> keywords <EoN> ) <NEWLINE> <BoN> anno <EoN> . <BoN> setanno <EoN> ( <BoN> pri call <EoN> , <STRING> , <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> dy <EoN> = <BoN> create <EoN> . <BoN> create grad <EoN> ( <BoN> self <EoN> . <BoN> target <EoN> , <BoN> self <EoN> . <BoN> namer <EoN> ) <NEWLINE> <BoN> dy <EoN> . <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Load <EoN> ( ) <NEWLINE> <BoN> dx <EoN> = <BoN> create <EoN> . <BoN> create grad <EoN> ( <BoN> node <EoN> . <BoN> args <EoN> [ <NUMBER> ] , <BoN> self <EoN> . <BoN> namer <EoN> ) <NEWLINE> <BoN> dx <EoN> . <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Store <EoN> ( ) <NEWLINE> <BoN> adj name <EoN> = <BoN> naming <EoN> . <BoN> adjoint name <EoN> ( <BoN> func <EoN> , <BoN> active args <EoN> ) <NEWLINE> <BoN> adj call <EoN> = <BoN> gast <EoN> . <BoN> Call <EoN> ( <NEWLINE> <BoN> func <EoN> = <BoN> gast <EoN> . <BoN> Name <EoN> ( <BoN> id <EoN> = <BoN> adj name <EoN> , <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Load <EoN> ( ) , <BoN> annotation <EoN> = <BoN> None <EoN> ) , <NEWLINE> <BoN> args <EoN> = [ <BoN> self <EoN> . <BoN> substack <EoN> , <BoN> dy <EoN> ] + <BoN> node <EoN> . <BoN> args <EoN> , <NEWLINE> <BoN> keywords <EoN> = <BoN> node <EoN> . <BoN> keywords <EoN> ) <NEWLINE> <BoN> anno <EoN> . <BoN> setanno <EoN> ( <BoN> adj call <EoN> , <STRING> , <BoN> True <EoN> ) <NEWLINE> <BoN> adjoint <EoN> = [ <BoN> template <EoN> . <BoN> replace <EoN> ( <STRING> , <BoN> namer <EoN> = <BoN> self <EoN> . <BoN> namer <EoN> , <BoN> dfx <EoN> = <BoN> adj call <EoN> ) ] <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> , <BoN> i <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> active args <EoN> ) : <NEWLINE> <TAB> <BoN> adjoint <EoN> . <BoN> append <EoN> ( <BoN> template <EoN> . <BoN> replace <EoN> ( <STRING> , <BoN> namer <EoN> = <BoN> self <EoN> . <BoN> namer <EoN> , <NEWLINE> <BoN> x <EoN> = <BoN> node <EoN> . <BoN> args <EoN> [ <BoN> i <EoN> ] . <BoN> id <EoN> , <BoN> i <EoN> = <BoN> gast <EoN> . <BoN> Num <EoN> ( <BoN> n <EoN> = <BoN> j <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> pri call <EoN> , <BoN> adjoint <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> template <EoN> = <BoN> grads <EoN> . <BoN> adjoints <EoN> [ <BoN> func <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sig <EoN> = <BoN> funcsigs <EoN> . <BoN> signature <EoN> ( <BoN> template <EoN> ) <NEWLINE> <BoN> sig <EoN> = <BoN> sig <EoN> . <BoN> replace <EoN> ( <BoN> parameters <EoN> = <BoN> list <EoN> ( <BoN> sig <EoN> . <BoN> parameters <EoN> . <BoN> values <EoN> ( ) ) [ <NUMBER> : ] ) <NEWLINE> <BoN> kwargs <EoN> = <BoN> dict <EoN> ( ( <BoN> keyword <EoN> . <BoN> arg <EoN> , <BoN> keyword <EoN> . <BoN> value <EoN> ) <BoN> for <EoN> <BoN> keyword <EoN> <BoN> in <EoN> <BoN> node <EoN> . <BoN> keywords <EoN> ) <NEWLINE> <BoN> bound args <EoN> = <BoN> sig <EoN> . <BoN> bind <EoN> ( * <BoN> node <EoN> . <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> args <EoN> = <BoN> quoting <EoN> . <BoN> parse function <EoN> ( <BoN> template <EoN> ) . <BoN> body <EoN> [ <NUMBER> ] . <BoN> args <EoN> <NEWLINE> <BoN> kwargs <EoN> = <BoN> dict <EoN> ( <BoN> zip <EoN> ( * <BoN> map <EoN> ( <BoN> reversed <EoN> , [ <BoN> args <EoN> . <BoN> args <EoN> , <BoN> args <EoN> . <BoN> defaults <EoN> ] ) ) ) <NEWLINE> <BoN> kwargs <EoN> . <BoN> update <EoN> ( <BoN> dict <EoN> ( <BoN> zip <EoN> ( <BoN> args <EoN> . <BoN> kwonlyargs <EoN> , <BoN> args <EoN> . <BoN> kw defaults <EoN> ) ) ) <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> , <BoN> val <EoN> <BoN> in <EoN> <BoN> kwargs <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> arg <EoN> . <BoN> id <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> bound args <EoN> . <BoN> arguments <EoN> : <NEWLINE> <TAB> <BoN> bound args <EoN> . <BoN> arguments <EoN> [ <BoN> arg <EoN> . <BoN> id <EoN> ] = <BoN> val <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> output name <EoN> = <BoN> six <EoN> . <BoN> get function code <EoN> ( <BoN> template <EoN> ) . <BoN> co varnames <EoN> [ <NUMBER> ] <NEWLINE> <BoN> arg replacements <EoN> = { <BoN> output name <EoN> : <BoN> ast <EoN> . <BoN> copy node <EoN> ( <BoN> self <EoN> . <BoN> target <EoN> ) } <NEWLINE> <BoN> arg replacements <EoN> . <BoN> update <EoN> ( <BoN> bound args <EoN> . <BoN> arguments <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> packing <EoN> = [ ] <NEWLINE> <BoN> flags <EoN> = <BoN> six <EoN> . <BoN> get function code <EoN> ( <BoN> template <EoN> ) . <BoN> co flags <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> flags <EoN> & <BoN> inspect <EoN> . <BoN> CO VARARGS <EoN> : <NEWLINE> <TAB> <BoN> to pack <EoN> = <BoN> node <EoN> . <BoN> args <EoN> [ <BoN> six <EoN> . <BoN> get function code <EoN> ( <BoN> template <EoN> ) . <BoN> co argcount <EoN> - <NUMBER> : ] <NEWLINE> <BoN> vararg name <EoN> = <BoN> six <EoN> . <BoN> get function code <EoN> ( <BoN> template <EoN> ) . <BoN> co varnames <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> target <EoN> = <BoN> gast <EoN> . <BoN> Name <EoN> ( <BoN> annotation <EoN> = <BoN> None <EoN> , <BoN> id <EoN> = <BoN> vararg name <EoN> , <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Store <EoN> ( ) ) <NEWLINE> <BoN> value <EoN> = <BoN> gast <EoN> . <BoN> Tuple <EoN> ( <BoN> elts <EoN> = <BoN> to pack <EoN> , <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Load <EoN> ( ) ) <NEWLINE> <BoN> packing <EoN> = [ <BoN> gast <EoN> . <BoN> Assign <EoN> ( <BoN> targets <EoN> = [ <BoN> target <EoN> ] , <BoN> value <EoN> = <BoN> value <EoN> ) ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> arg replacements <EoN> [ <BoN> six <EoN> . <BoN> get function code <EoN> ( <NEWLINE> <BoN> template <EoN> ) . <BoN> co varnames <EoN> [ - <NUMBER> ] ] = <BoN> target <EoN> <NEWLINE> <UNTAB> <BoN> adjoint <EoN> = <BoN> template <EoN> . <BoN> replace <EoN> ( <BoN> template <EoN> , <BoN> namer <EoN> = <BoN> self <EoN> . <BoN> namer <EoN> , ** <BoN> arg replacements <EoN> ) <NEWLINE> <BoN> unpacking <EoN> = [ ] <NEWLINE> <BoN> if <EoN> <BoN> flags <EoN> & <BoN> inspect <EoN> . <BoN> CO VARARGS <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> dto pack <EoN> = [ <BoN> create <EoN> . <BoN> create temp grad <EoN> ( <BoN> arg <EoN> , <BoN> self <EoN> . <BoN> namer <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> to pack <EoN> ] <NEWLINE> <BoN> value <EoN> = <BoN> create <EoN> . <BoN> create grad <EoN> ( <BoN> target <EoN> , <BoN> self <EoN> . <BoN> namer <EoN> ) <NEWLINE> <BoN> target <EoN> = <BoN> gast <EoN> . <BoN> Tuple <EoN> ( <BoN> elts <EoN> = <BoN> dto pack <EoN> , <BoN> ctx <EoN> = <BoN> gast <EoN> . <BoN> Store <EoN> ( ) ) <NEWLINE> <BoN> unpacking <EoN> = [ <BoN> gast <EoN> . <BoN> Assign <EoN> ( <BoN> targets <EoN> = [ <BoN> target <EoN> ] , <BoN> value <EoN> = <BoN> value <EoN> ) ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> node <EoN> , <BoN> packing <EoN> + <BoN> adjoint <EoN> + <BoN> unpacking <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> plot boot traces <EoN> ( <BoN> ax <EoN> , <BoN> x <EoN> , <BoN> boot data <EoN> , <BoN> color <EoN> , <BoN> err kws <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> err kws <EoN> . <BoN> setdefault <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> err kws <EoN> . <BoN> setdefault <EoN> ( <STRING> , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <STRING> <BoN> in <EoN> <BoN> err kws <EoN> : <NEWLINE> <TAB> <BoN> err kws <EoN> [ <STRING> ] = <BoN> err kws <EoN> . <BoN> pop <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> ax <EoN> . <BoN> plot <EoN> ( <BoN> x <EoN> , <BoN> boot data <EoN> . <BoN> T <EoN> , <BoN> color <EoN> = <BoN> color <EoN> , <BoN> label <EoN> = <STRING> , ** <BoN> err kws <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> getinfo <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> info <EoN> = <BoN> self <EoN> . <BoN> Name To Info <EoN> . <BoN> get <EoN> ( <BoN> name <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> info <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Key Error <EoN> ( <NEWLINE> <STRING> % <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> info <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> einsum <EoN> ( * <BoN> operands <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> input subscripts <EoN> , <BoN> output subscript <EoN> , <BoN> ioperands <EoN> = <BoN> parse einsum input <EoN> ( <BoN> operands <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Ein Sum <EoN> ( <NEWLINE> <BoN> in subs <EoN> = <BoN> input subscripts <EoN> , <NEWLINE> <BoN> out sub <EoN> = <BoN> output subscript <EoN> , <NEWLINE> ) . <BoN> apply <EoN> ( <BoN> ioperands <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> topk <EoN> ( <BoN> a <EoN> , <BoN> k <EoN> , <BoN> axis <EoN> , <BoN> keepdims <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> keepdims <EoN> <BoN> is <EoN> <BoN> True <EoN> <NEWLINE> <BoN> axis <EoN> = <BoN> axis <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> abs <EoN> ( <BoN> k <EoN> ) >= <BoN> a <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> a <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> partition <EoN> ( <BoN> a <EoN> , - <BoN> k <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> k slice <EoN> = <BoN> slice <EoN> ( - <BoN> k <EoN> , <BoN> None <EoN> ) <BoN> if <EoN> <BoN> k <EoN> > <NUMBER> <BoN> else <EoN> <BoN> slice <EoN> ( - <BoN> k <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> a <EoN> [ <BoN> tuple <EoN> ( <BoN> k slice <EoN> <BoN> if <EoN> <BoN> i <EoN> == <BoN> axis <EoN> <BoN> else <EoN> <BoN> slice <EoN> ( <BoN> None <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> a <EoN> . <BoN> ndim <EoN> ) ) ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> splitlines <EoN> ( <BoN> a <EoN> , <BoN> keepends <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> vec string <EoN> ( <NEWLINE> <BoN> a <EoN> , <BoN> object <EoN> , <STRING> , <BoN> clean args <EoN> ( <BoN> keepends <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> rcdefaults <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> warnings <EoN> . <BoN> catch warnings <EoN> ( ) : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> simplefilter <EoN> ( <STRING> , <BoN> mpl Deprecation <EoN> ) <NEWLINE> <BoN> from <EoN> . <BoN> style <EoN> . <BoN> core <EoN> <BoN> import <EoN> <BoN> STYLE BLACKLIST <EoN> <NEWLINE> <BoN> rc Params <EoN> . <BoN> clear <EoN> ( ) <NEWLINE> <BoN> rc Params <EoN> . <BoN> update <EoN> ( { <BoN> k <EoN> : <BoN> v <EoN> <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> rc Params Default <EoN> . <BoN> items <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> STYLE BLACKLIST <EoN> } ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup slice <EoN> ( <BoN> f <EoN> , <BoN> m <EoN> , <BoN> n <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> k <EoN> = <BoN> len <EoN> ( <BoN> f <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> k <EoN> >= <BoN> m <EoN> : <NEWLINE> <TAB> <BoN> M <EoN> = <BoN> k <EoN> - <BoN> m <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> M <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> k <EoN> >= <BoN> n <EoN> : <NEWLINE> <TAB> <BoN> N <EoN> = <BoN> k <EoN> - <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> N <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> = <BoN> f <EoN> [ <BoN> N <EoN> : <BoN> M <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> + [ <BoN> K <EoN> . <BoN> zero <EoN> ] * <BoN> m <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parse <EoN> ( <BoN> self <EoN> , <BoN> argument <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> argument <EoN> , <BoN> self <EoN> . <BoN> enum class <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> argument <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> argument <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> enum class <EoN> . <BoN> members <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> <STRING> . <BoN> join <EoN> ( <BoN> self <EoN> . <BoN> enum class <EoN> . <BoN> members <EoN> . <BoN> keys <EoN> ( ) ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> enum class <EoN> [ <BoN> argument <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> lcm <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> ring <EoN> = <BoN> self <EoN> . <BoN> get ring <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Domain Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> a <EoN> * <BoN> b <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> p <EoN> = <BoN> ring <EoN> . <BoN> lcm <EoN> ( <BoN> self <EoN> . <BoN> numer <EoN> ( <BoN> a <EoN> ) , <BoN> self <EoN> . <BoN> numer <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <BoN> q <EoN> = <BoN> ring <EoN> . <BoN> gcd <EoN> ( <BoN> self <EoN> . <BoN> denom <EoN> ( <BoN> a <EoN> ) , <BoN> self <EoN> . <BoN> denom <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> convert <EoN> ( <BoN> p <EoN> , <BoN> ring <EoN> ) / <BoN> q <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> read <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> packet char <EoN> , <BoN> packet ends <EoN> = <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <BoN> packet len <EoN> , <BoN> packet width <EoN> = <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <BoN> while <EoN> <BoN> True <EoN> : <NEWLINE> <TAB> <BoN> byte <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> read <EoN> ( <NUMBER> ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> state <EoN> <BoN> is <EoN> <BoN> dvistate <EoN> . <BoN> inpage <EoN> : <NEWLINE> <TAB> <BoN> byte at <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> tell <EoN> ( ) - <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> byte at <EoN> == <BoN> packet ends <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> finalize packet <EoN> ( <BoN> packet char <EoN> , <BoN> packet width <EoN> ) <NEWLINE> <BoN> packet len <EoN> , <BoN> packet char <EoN> , <BoN> packet width <EoN> = <BoN> None <EoN> , <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> byte at <EoN> > <BoN> packet ends <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> byte <EoN> <BoN> in <EoN> ( <NUMBER> , <NUMBER> ) <BoN> or <EoN> <BoN> byte <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> % <BoN> byte <EoN> ) <NEWLINE> <UNTAB> <BoN> Dvi <EoN> . <BoN> dtable <EoN> [ <BoN> byte <EoN> ] ( <BoN> self <EoN> , <BoN> byte <EoN> ) <NEWLINE> <BoN> continue <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> byte <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> packet len <EoN> = <BoN> byte <EoN> <NEWLINE> <BoN> packet char <EoN> , <BoN> packet width <EoN> = <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) , <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) <NEWLINE> <BoN> packet ends <EoN> = <BoN> self <EoN> . <BoN> init packet <EoN> ( <BoN> byte <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> state <EoN> = <BoN> dvistate <EoN> . <BoN> inpage <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> byte <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> packet len <EoN> , <BoN> packet char <EoN> , <BoN> packet width <EoN> = [ <BoN> self <EoN> . <BoN> arg <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> ) ] <NEWLINE> <BoN> self <EoN> . <BoN> init packet <EoN> ( <BoN> packet len <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <NUMBER> <= <BoN> byte <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> k <EoN> = <BoN> self <EoN> . <BoN> arg <EoN> ( <BoN> byte <EoN> - <NUMBER> , <BoN> byte <EoN> == <NUMBER> ) <NEWLINE> <BoN> c <EoN> , <BoN> s <EoN> , <BoN> d <EoN> , <BoN> a <EoN> , <BoN> l <EoN> = [ <BoN> self <EoN> . <BoN> arg <EoN> ( <BoN> x <EoN> ) <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) ] <NEWLINE> <BoN> self <EoN> . <BoN> fnt def real <EoN> ( <BoN> k <EoN> , <BoN> c <EoN> , <BoN> s <EoN> , <BoN> d <EoN> , <BoN> a <EoN> , <BoN> l <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> first font <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> first font <EoN> = <BoN> k <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> byte <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> i <EoN> , <BoN> k <EoN> = <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) , <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) <NEWLINE> <BoN> x <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> read <EoN> ( <BoN> k <EoN> ) <NEWLINE> <BoN> cs <EoN> , <BoN> ds <EoN> = <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) , <BoN> self <EoN> . <BoN> arg <EoN> ( <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> pre <EoN> ( <BoN> i <EoN> , <BoN> x <EoN> , <BoN> cs <EoN> , <BoN> ds <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> byte <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> byte <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> modules to main <EoN> ( <BoN> mod List <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> mod List <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> main <EoN> = <BoN> sys <EoN> . <BoN> modules <EoN> [ <STRING> ] <NEWLINE> <BoN> for <EoN> <BoN> modname <EoN> <BoN> in <EoN> <BoN> mod List <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> modname <EoN> ) <BoN> is <EoN> <BoN> str <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> mod <EoN> = <BoN> import <EoN> ( <BoN> modname <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> sys <EoN> . <BoN> stderr <EoN> . <BoN> write <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> modname <EoN> ) <NEWLINE> <BoN> print exec <EoN> ( <BoN> sys <EoN> . <BoN> stderr <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> main <EoN> , <BoN> mod <EoN> . <BoN> name <EoN> , <BoN> mod <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> correspond <EoN> ( <BoN> Z <EoN> , <BoN> Y <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> is valid linkage <EoN> ( <BoN> Z <EoN> , <BoN> throw <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> distance <EoN> . <BoN> is valid y <EoN> ( <BoN> Y <EoN> , <BoN> throw <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> Z <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> Z <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <BoN> Y <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> Y <EoN> , <BoN> order <EoN> = <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> distance <EoN> . <BoN> num obs y <EoN> ( <BoN> Y <EoN> ) == <BoN> num obs linkage <EoN> ( <BoN> Z <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> evaluate <EoN> ( <BoN> self <EoN> , <BoN> points <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> points <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> points <EoN> ) <NEWLINE> <NEWLINE> <BoN> dim <EoN> , <BoN> num m <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> points <EoN> ) . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> dim <EoN> != <BoN> self <EoN> . <BoN> dim <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> dim <EoN> , <BoN> self <EoN> . <BoN> dim <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> result <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> num m <EoN> , ) , <BoN> dtype <EoN> = <BoN> float <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> num m <EoN> >= <BoN> self <EoN> . <BoN> num dp <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> num dp <EoN> ) : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> self <EoN> . <BoN> dataset <EoN> [ : , <BoN> i <EoN> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] - <BoN> points <EoN> <NEWLINE> <BoN> tdiff <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> self <EoN> . <BoN> inv cov <EoN> , <BoN> diff <EoN> ) <NEWLINE> <BoN> energy <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> diff <EoN> * <BoN> tdiff <EoN> , <BoN> axis <EoN> = <NUMBER> ) / <NUMBER> <NEWLINE> <BoN> result <EoN> = <BoN> result <EoN> + <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> energy <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> num m <EoN> ) : <NEWLINE> <TAB> <BoN> diff <EoN> = <BoN> self <EoN> . <BoN> dataset <EoN> - <BoN> points <EoN> [ : , <BoN> i <EoN> , <BoN> np <EoN> . <BoN> newaxis <EoN> ] <NEWLINE> <BoN> tdiff <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> self <EoN> . <BoN> inv cov <EoN> , <BoN> diff <EoN> ) <NEWLINE> <BoN> energy <EoN> = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> diff <EoN> * <BoN> tdiff <EoN> , <BoN> axis <EoN> = <NUMBER> ) / <NUMBER> <NEWLINE> <BoN> result <EoN> [ <BoN> i <EoN> ] = <BoN> np <EoN> . <BoN> sum <EoN> ( <BoN> np <EoN> . <BoN> exp <EoN> ( - <BoN> energy <EoN> ) , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> result <EoN> = <BoN> result <EoN> / <BoN> self <EoN> . <BoN> norm factor <EoN> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> condition <EoN> ( <BoN> cond <EoN> , <BoN> brule <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> conditioned brl <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> cond <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> brule <EoN> ( <BoN> expr <EoN> ) : <BoN> yield <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> conditioned brl <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> pde separate add <EoN> ( <BoN> eq <EoN> , <BoN> fun <EoN> , <BoN> sep <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> pde separate <EoN> ( <BoN> eq <EoN> , <BoN> fun <EoN> , <BoN> sep <EoN> , <BoN> strategy <EoN> = <STRING> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get weights <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> K <EoN> . <BoN> batch get value <EoN> ( <BoN> self <EoN> . <BoN> weights <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rand 2 <EoN> ( <BoN> self <EoN> , <BoN> samples <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> r 0 <EoN> , <BoN> r 1 <EoN> , <BoN> r 2 <EoN> , <BoN> r 3 <EoN> , <BoN> r 4 <EoN> = <BoN> samples <EoN> <NEWLINE> <BoN> bprime <EoN> = ( <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> r 0 <EoN> ] + <BoN> self <EoN> . <BoN> scale <EoN> * <NEWLINE> ( <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> r 1 <EoN> ] + <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> r 2 <EoN> ] - <NEWLINE> <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> r 3 <EoN> ] - <BoN> self <EoN> . <BoN> population <EoN> [ <BoN> r 4 <EoN> ] ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> bprime <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> Proposal <EoN> ( <BoN> cls prob <EoN> = <BoN> None <EoN> , <BoN> bbox pred <EoN> = <BoN> None <EoN> , <BoN> im info <EoN> = <BoN> None <EoN> , <BoN> rpn pre nms top n <EoN> = <BoN> Null <EoN> , <BoN> rpn post nms top n <EoN> = <BoN> Null <EoN> , <BoN> threshold <EoN> = <BoN> Null <EoN> , <BoN> rpn min size <EoN> = <BoN> Null <EoN> , <BoN> scales <EoN> = <BoN> Null <EoN> , <BoN> ratios <EoN> = <BoN> Null <EoN> , <BoN> feature stride <EoN> = <BoN> Null <EoN> , <BoN> output score <EoN> = <BoN> Null <EoN> , <BoN> iou loss <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup euclidean prs <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> prs <EoN> = [ <BoN> f <EoN> , <BoN> g <EoN> ] <NEWLINE> <BoN> h <EoN> = <BoN> dup rem <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> h <EoN> : <NEWLINE> <TAB> <BoN> prs <EoN> . <BoN> append <EoN> ( <BoN> h <EoN> ) <NEWLINE> <BoN> f <EoN> , <BoN> g <EoN> = <BoN> g <EoN> , <BoN> h <EoN> <NEWLINE> <BoN> h <EoN> = <BoN> dup rem <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> prs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> join <EoN> ( <BoN> self <EoN> , <BoN> timeout <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> parent pid <EoN> == <BoN> os <EoN> . <BoN> getpid <EoN> ( ) , <STRING> <NEWLINE> <BoN> assert <EoN> <BoN> self <EoN> . <BoN> popen <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> , <STRING> <NEWLINE> <BoN> res <EoN> = <BoN> self <EoN> . <BoN> popen <EoN> . <BoN> wait <EoN> ( <BoN> timeout <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> res <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> children <EoN> . <BoN> discard <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> depth to space <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> op <EoN> . <BoN> depth to space <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> update shape <EoN> ( <BoN> self <EoN> , <BoN> r <EoN> , <BoN> other r <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> assert <EoN> <BoN> other r <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> shape of <EoN> , ( <STRING> , <BoN> other r <EoN> ) <NEWLINE> <BoN> other shape <EoN> = <BoN> self <EoN> . <BoN> shape of <EoN> [ <BoN> other r <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> other shape <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> r <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> shape of <EoN> : <NEWLINE> <TAB> <BoN> r shape <EoN> = <BoN> self <EoN> . <BoN> shape of <EoN> [ <BoN> r <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set shape <EoN> ( <BoN> r <EoN> , <BoN> other shape <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> other r <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <BoN> r <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <NEWLINE> <BoN> other r <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> == <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> <BoN> and <EoN> <NEWLINE> <BoN> other r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> == <BoN> r <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> merged shape <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> ps <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> other shape <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> r shape <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> other shape <EoN> : <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> other shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> ps <EoN> . <BoN> owner <EoN> <BoN> and <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> getattr <EoN> ( <BoN> ps <EoN> . <BoN> owner <EoN> , <STRING> , <BoN> None <EoN> ) , <BoN> Shape i <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> ps <EoN> . <BoN> owner <EoN> . <BoN> op <EoN> . <BoN> i <EoN> == <BoN> i <EoN> <BoN> and <EoN> <NEWLINE> <BoN> ps <EoN> . <BoN> owner <EoN> . <BoN> inputs <EoN> [ <NUMBER> ] <BoN> in <EoN> ( <BoN> r <EoN> , <BoN> other r <EoN> ) ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> r shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> r shape <EoN> [ <BoN> i <EoN> ] , ( <BoN> Constant <EoN> , <BoN> integer types <EoN> ) ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> r shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> other shape <EoN> [ <BoN> i <EoN> ] , ( <BoN> Constant <EoN> , <BoN> integer types <EoN> ) ) : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> other shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> other shape <EoN> [ <BoN> i <EoN> ] == <BoN> r shape <EoN> [ <BoN> i <EoN> ] : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> r shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> r shape <EoN> [ <BoN> i <EoN> ] <BoN> in <EoN> <BoN> theano <EoN> . <BoN> gof <EoN> . <BoN> graph <EoN> . <BoN> ancestors <EoN> ( [ <BoN> other shape <EoN> [ <BoN> i <EoN> ] ] ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> r shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> merged shape <EoN> . <BoN> append <EoN> ( <BoN> other shape <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> assert <EoN> <BoN> all <EoN> ( [ ( <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> r <EoN> . <BoN> type <EoN> , <STRING> ) <BoN> or <EoN> <NEWLINE> <BoN> not <EoN> <BoN> r <EoN> . <BoN> type <EoN> . <BoN> broadcastable <EoN> [ <BoN> i <EoN> ] <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> other r <EoN> . <BoN> type <EoN> . <BoN> broadcastable <EoN> [ <BoN> i <EoN> ] ) <BoN> or <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> lscalar one <EoN> . <BoN> equals <EoN> ( <BoN> merged shape <EoN> [ <BoN> i <EoN> ] ) <BoN> or <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> lscalar one <EoN> . <BoN> equals <EoN> ( <NEWLINE> <BoN> T <EoN> . <BoN> extract constant <EoN> ( <BoN> merged shape <EoN> [ <BoN> i <EoN> ] , <BoN> only process constants <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> xrange <EoN> ( <BoN> r <EoN> . <BoN> ndim <EoN> ) ] ) <NEWLINE> <BoN> self <EoN> . <BoN> shape of <EoN> [ <BoN> r <EoN> ] = <BoN> tuple <EoN> ( <BoN> merged shape <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> sv <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> shape of <EoN> [ <BoN> r <EoN> ] : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> shape of reverse index <EoN> . <BoN> setdefault <EoN> ( <BoN> sv <EoN> , <BoN> set <EoN> ( ) ) . <BoN> add <EoN> ( <BoN> r <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> warning text <EoN> ( <BoN> name <EoN> , <BoN> amb <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> text <EoN> = <STRING> % ( <BoN> name <EoN> ) <NEWLINE> <BoN> text <EoN> += <STRING> <NEWLINE> <BoN> for <EoN> <BoN> pair <EoN> <BoN> in <EoN> <BoN> amb <EoN> : <NEWLINE> <TAB> <BoN> text <EoN> += <STRING> + <STRING> . <BoN> join <EoN> ( <STRING> + <BoN> str signature <EoN> ( <BoN> s <EoN> ) + <STRING> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> pair <EoN> ) + <STRING> <NEWLINE> <UNTAB> <BoN> text <EoN> += <STRING> <NEWLINE> <BoN> text <EoN> += <STRING> . <BoN> join <EoN> ( [ <STRING> + <BoN> str signature <EoN> ( <BoN> super signature <EoN> ( <BoN> s <EoN> ) ) <NEWLINE> + <STRING> % <BoN> name <EoN> <BoN> for <EoN> <BoN> s <EoN> <BoN> in <EoN> <BoN> amb <EoN> ] ) <NEWLINE> <BoN> return <EoN> <BoN> text <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> y <EoN> , <BoN> sample weight <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check X y <EoN> ( <BoN> X <EoN> , <BoN> y <EoN> , <BoN> accept sparse <EoN> = [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> <BoN> multi output <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> label binarizer <EoN> = <BoN> Label Binarizer <EoN> ( <BoN> pos label <EoN> = <NUMBER> , <BoN> neg label <EoN> = - <NUMBER> ) <NEWLINE> <BoN> Y <EoN> = <BoN> self <EoN> . <BoN> label binarizer <EoN> . <BoN> fit transform <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> label binarizer <EoN> . <BoN> y type <EoN> . <BoN> startswith <EoN> ( <STRING> ) : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> column or 1 d <EoN> ( <BoN> y <EoN> , <BoN> warn <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> class weight <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> sample weight <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> sample weight <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> sample weight <EoN> = ( <BoN> sample weight <EoN> * <NEWLINE> <BoN> compute sample weight <EoN> ( <BoN> self <EoN> . <BoN> class weight <EoN> , <BoN> y <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> BaseRidgeCV <EoN> . <BoN> fit <EoN> ( <BoN> self <EoN> , <BoN> X <EoN> , <BoN> Y <EoN> , <BoN> sample weight <EoN> = <BoN> sample weight <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hash array <EoN> ( <BoN> vals <EoN> , <BoN> encoding <EoN> = <STRING> , <BoN> hash key <EoN> = <BoN> None <EoN> , <BoN> categorize <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> hasattr <EoN> ( <BoN> vals <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> dtype <EoN> = <BoN> vals <EoN> . <BoN> dtype <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hash key <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> hash key <EoN> = <BoN> default hash key <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> is categorical dtype <EoN> ( <BoN> dtype <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> hash categorical <EoN> ( <BoN> vals <EoN> , <BoN> encoding <EoN> , <BoN> hash key <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> np <EoN> . <BoN> issubdtype <EoN> ( <BoN> dtype <EoN> , <BoN> np <EoN> . <BoN> complex 128 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> hash array <EoN> ( <BoN> vals <EoN> . <BoN> real <EoN> ) + <NUMBER> * <BoN> hash array <EoN> ( <BoN> vals <EoN> . <BoN> imag <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> dtype <EoN> , <BoN> np <EoN> . <BoN> bool <EoN> ) : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> vals <EoN> . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> issubclass <EoN> ( <BoN> dtype <EoN> . <BoN> type <EoN> , ( <BoN> np <EoN> . <BoN> datetime 64 <EoN> , <BoN> np <EoN> . <BoN> timedelta 64 <EoN> ) ) : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> vals <EoN> . <BoN> view <EoN> ( <STRING> ) . <BoN> astype <EoN> ( <STRING> , <BoN> copy <EoN> = <BoN> False <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> issubclass <EoN> ( <BoN> dtype <EoN> . <BoN> type <EoN> , <BoN> np <EoN> . <BoN> number <EoN> ) <BoN> and <EoN> <BoN> dtype <EoN> . <BoN> itemsize <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> vals <EoN> . <BoN> view <EoN> ( <STRING> . <BoN> format <EoN> ( <BoN> vals <EoN> . <BoN> dtype <EoN> . <BoN> itemsize <EoN> ) ) . <BoN> astype <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> categorize <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> pandas <EoN> <BoN> import <EoN> <BoN> factorize <EoN> , <BoN> Categorical <EoN> , <BoN> Index <EoN> <NEWLINE> <BoN> codes <EoN> , <BoN> categories <EoN> = <BoN> factorize <EoN> ( <BoN> vals <EoN> , <BoN> sort <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> cat <EoN> = <BoN> Categorical <EoN> ( <BoN> codes <EoN> , <BoN> Index <EoN> ( <BoN> categories <EoN> ) , <NEWLINE> <BoN> ordered <EoN> = <BoN> False <EoN> , <BoN> fastpath <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> hash categorical <EoN> ( <BoN> cat <EoN> , <BoN> encoding <EoN> , <BoN> hash key <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> hashing <EoN> . <BoN> hash object array <EoN> ( <BoN> vals <EoN> , <BoN> hash key <EoN> , <BoN> encoding <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> vals <EoN> = <BoN> hashing <EoN> . <BoN> hash object array <EoN> ( <BoN> vals <EoN> . <BoN> astype <EoN> ( <BoN> str <EoN> ) . <BoN> astype <EoN> ( <BoN> object <EoN> ) , <NEWLINE> <BoN> hash key <EoN> , <BoN> encoding <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> vals <EoN> ^= <BoN> vals <EoN> >> <NUMBER> <NEWLINE> <BoN> vals <EoN> *= <BoN> np <EoN> . <BoN> uint 64 <EoN> ( <NUMBER> ) <NEWLINE> <BoN> vals <EoN> ^= <BoN> vals <EoN> >> <NUMBER> <NEWLINE> <BoN> vals <EoN> *= <BoN> np <EoN> . <BoN> uint 64 <EoN> ( <NUMBER> ) <NEWLINE> <BoN> vals <EoN> ^= <BoN> vals <EoN> >> <NUMBER> <NEWLINE> <BoN> return <EoN> <BoN> vals <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> identifier <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> identifier <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> six <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> identifier <EoN> = <BoN> str <EoN> ( <BoN> identifier <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> deserialize <EoN> ( <BoN> identifier <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> deserialize <EoN> ( <BoN> identifier <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> callable <EoN> ( <BoN> identifier <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> identifier <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> , <BoN> identifier <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rotate deg around <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> degrees <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> x <EoN> , <BoN> y <EoN> = <BoN> float <EoN> ( <BoN> x <EoN> ) , <BoN> float <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> translate <EoN> ( - <BoN> x <EoN> , - <BoN> y <EoN> ) . <BoN> rotate deg <EoN> ( <BoN> degrees <EoN> ) . <BoN> translate <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> requantization range eager fallback <EoN> ( <BoN> input <EoN> , <BoN> input min <EoN> , <BoN> input max <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr Tinput <EoN> , ( <BoN> input <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> input min <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> input min <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> input max <EoN> = <BoN> ops <EoN> . <BoN> convert to tensor <EoN> ( <BoN> input max <EoN> , <BoN> dtypes <EoN> . <BoN> float 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> , <BoN> input min <EoN> , <BoN> input max <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr Tinput <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> RequantizationRangeOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> cbook <EoN> . <BoN> deprecated <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> rec groupby <EoN> ( <BoN> r <EoN> , <BoN> groupby <EoN> , <BoN> stats <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> rowd <EoN> = { } <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> , <BoN> row <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( <BoN> r <EoN> ) : <NEWLINE> <TAB> <BoN> key <EoN> = <BoN> tuple <EoN> ( [ <BoN> row <EoN> [ <BoN> attr <EoN> ] <BoN> for <EoN> <BoN> attr <EoN> <BoN> in <EoN> <BoN> groupby <EoN> ] ) <NEWLINE> <BoN> rowd <EoN> . <BoN> setdefault <EoN> ( <BoN> key <EoN> , [ ] ) . <BoN> append <EoN> ( <BoN> i <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> rows <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> rowd <EoN> ) : <NEWLINE> <TAB> <BoN> row <EoN> = <BoN> list <EoN> ( <BoN> key <EoN> ) <NEWLINE> <NEWLINE> <BoN> ind <EoN> = <BoN> rowd <EoN> [ <BoN> key <EoN> ] <NEWLINE> <BoN> thisr <EoN> = <BoN> r <EoN> [ <BoN> ind <EoN> ] <NEWLINE> <NEWLINE> <BoN> row <EoN> . <BoN> extend <EoN> ( [ <BoN> func <EoN> ( <BoN> thisr <EoN> [ <BoN> attr <EoN> ] ) <BoN> for <EoN> <BoN> attr <EoN> , <BoN> func <EoN> , <BoN> outname <EoN> <BoN> in <EoN> <BoN> stats <EoN> ] ) <NEWLINE> <BoN> rows <EoN> . <BoN> append <EoN> ( <BoN> row <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> attrs <EoN> , <BoN> funcs <EoN> , <BoN> outnames <EoN> = <BoN> list <EoN> ( <BoN> zip <EoN> ( * <BoN> stats <EoN> ) ) <NEWLINE> <BoN> names <EoN> = <BoN> list <EoN> ( <BoN> groupby <EoN> ) <NEWLINE> <BoN> names <EoN> . <BoN> extend <EoN> ( <BoN> outnames <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> rec <EoN> . <BoN> fromrecords <EoN> ( <BoN> rows <EoN> , <BoN> names <EoN> = <BoN> names <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> query <EoN> , <BoN> state <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> with <EoN> <BoN> variable scope <EoN> . <BoN> variable scope <EoN> ( <BoN> None <EoN> , <STRING> , [ <BoN> query <EoN> ] ) : <NEWLINE> <TAB> <BoN> processed query <EoN> = <BoN> self <EoN> . <BoN> query layer <EoN> ( <BoN> query <EoN> ) <BoN> if <EoN> <BoN> self <EoN> . <BoN> query layer <EoN> <BoN> else <EoN> <BoN> query <EoN> <NEWLINE> <BoN> score <EoN> = <BoN> bahdanau score <EoN> ( <BoN> processed query <EoN> , <BoN> self <EoN> . <BoN> keys <EoN> , <BoN> self <EoN> . <BoN> normalize <EoN> ) <NEWLINE> <UNTAB> <BoN> alignments <EoN> = <BoN> self <EoN> . <BoN> probability fn <EoN> ( <BoN> score <EoN> , <BoN> state <EoN> ) <NEWLINE> <BoN> next state <EoN> = <BoN> alignments <EoN> <NEWLINE> <BoN> return <EoN> <BoN> alignments <EoN> , <BoN> next state <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get flinalg funcs <EoN> ( <BoN> names <EoN> , <BoN> arrays <EoN> = ( ) , <BoN> debug <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ordering <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> len <EoN> ( <BoN> arrays <EoN> ) ) : <NEWLINE> <TAB> <BoN> t <EoN> = <BoN> arrays <EoN> [ <BoN> i <EoN> ] . <BoN> dtype <EoN> . <BoN> char <EoN> <NEWLINE> <BoN> if <EoN> <BoN> t <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> type conv <EoN> : <NEWLINE> <TAB> <BoN> t <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> ordering <EoN> . <BoN> append <EoN> ( ( <BoN> t <EoN> , <BoN> i <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ordering <EoN> : <NEWLINE> <TAB> <BoN> ordering <EoN> . <BoN> sort <EoN> ( ) <NEWLINE> <BoN> required prefix <EoN> = <BoN> type conv <EoN> [ <BoN> ordering <EoN> [ <NUMBER> ] [ <NUMBER> ] ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> required prefix <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ordering <EoN> <BoN> and <EoN> <BoN> has column major storage <EoN> ( <BoN> arrays <EoN> [ <BoN> ordering <EoN> [ <NUMBER> ] [ <NUMBER> ] ] ) : <NEWLINE> <TAB> <BoN> suffix 1 <EoN> , <BoN> suffix 2 <EoN> = <STRING> , <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> suffix 1 <EoN> , <BoN> suffix 2 <EoN> = <STRING> , <STRING> <NEWLINE> <NEWLINE> <UNTAB> <BoN> funcs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> names <EoN> : <NEWLINE> <TAB> <BoN> func name <EoN> = <BoN> required prefix <EoN> + <BoN> name <EoN> <NEWLINE> <BoN> func <EoN> = <BoN> getattr <EoN> ( <BoN> flinalg <EoN> , <BoN> func name <EoN> + <BoN> suffix 1 <EoN> , <NEWLINE> <BoN> getattr <EoN> ( <BoN> flinalg <EoN> , <BoN> func name <EoN> + <BoN> suffix 2 <EoN> , <BoN> None <EoN> ) ) <NEWLINE> <BoN> funcs <EoN> . <BoN> append <EoN> ( <BoN> func <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tuple <EoN> ( <BoN> funcs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp subresultants <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> dmp inner subresultants <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> he uniform <EoN> ( <BoN> seed <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Variance Scaling <EoN> ( <BoN> scale <EoN> = <NUMBER> , <NEWLINE> <BoN> mode <EoN> = <STRING> , <NEWLINE> <BoN> distribution <EoN> = <STRING> , <NEWLINE> <BoN> seed <EoN> = <BoN> seed <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> compute time features <EoN> ( <BoN> self <EoN> , <BoN> time <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> batch size <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> time <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> num periods <EoN> = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> periodicities <EoN> ) <NEWLINE> <NEWLINE> <BoN> periods <EoN> = <BoN> constant op <EoN> . <BoN> constant <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> periodicities <EoN> , <BoN> shape <EoN> = [ <NUMBER> , <NUMBER> , <BoN> num periods <EoN> , <NUMBER> ] , <BoN> dtype <EoN> = <BoN> time <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <BoN> time <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> time <EoN> , [ <BoN> batch size <EoN> , - <NUMBER> , <NUMBER> , <NUMBER> ] ) <NEWLINE> <BoN> window offset <EoN> = <BoN> time <EoN> / <BoN> self <EoN> . <BoN> periodicities <EoN> <NEWLINE> <NEWLINE> <BoN> mod <EoN> = ( <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> time <EoN> % <BoN> periods <EoN> , <BoN> self <EoN> . <BoN> dtype <EoN> ) * <BoN> self <EoN> . <BoN> buckets <EoN> / <NEWLINE> <BoN> math ops <EoN> . <BoN> cast <EoN> ( <BoN> periods <EoN> , <BoN> self <EoN> . <BoN> dtype <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> intervals <EoN> = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> range <EoN> ( <BoN> self <EoN> . <BoN> buckets <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> dtype <EoN> ) , <NEWLINE> [ <NUMBER> , <NUMBER> , <NUMBER> , <BoN> self <EoN> . <BoN> buckets <EoN> ] ) <NEWLINE> <BoN> mod <EoN> = <BoN> nn ops <EoN> . <BoN> relu <EoN> ( <BoN> mod <EoN> - <BoN> intervals <EoN> ) <NEWLINE> <BoN> mod <EoN> = <BoN> array ops <EoN> . <BoN> where <EoN> ( <BoN> mod <EoN> < <NUMBER> , <BoN> mod <EoN> , <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> mod <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> window offset <EoN> , <BoN> mod <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hermite <EoN> ( <BoN> n <EoN> , <BoN> monic <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> n 1 <EoN> = <BoN> n <EoN> + <NUMBER> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> n 1 <EoN> = <BoN> n <EoN> <NEWLINE> <UNTAB> <BoN> x <EoN> , <BoN> w <EoN> , <BoN> mu 0 <EoN> = <BoN> roots hermite <EoN> ( <BoN> n 1 <EoN> , <BoN> mu <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> wfunc <EoN> = <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> exp <EoN> ( - <BoN> x <EoN> * <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> w <EoN> = [ ] , [ ] <NEWLINE> <UNTAB> <BoN> hn <EoN> = <NUMBER> ** <BoN> n <EoN> * <BoN> gam <EoN> ( <BoN> n <EoN> + <NUMBER> ) * <BoN> sqrt <EoN> ( <BoN> pi <EoN> ) <NEWLINE> <BoN> kn <EoN> = <NUMBER> ** <BoN> n <EoN> <NEWLINE> <BoN> p <EoN> = <BoN> orthopoly 1 d <EoN> ( <BoN> x <EoN> , <BoN> w <EoN> , <BoN> hn <EoN> , <BoN> kn <EoN> , <BoN> wfunc <EoN> , ( - <BoN> inf <EoN> , <BoN> inf <EoN> ) , <BoN> monic <EoN> , <NEWLINE> <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> eval hermite <EoN> ( <BoN> n <EoN> , <BoN> x <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> p <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set size <EoN> ( <BoN> self <EoN> , <BoN> size <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> size <EoN> = <BoN> size <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> invalid <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> cdf <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> , <BoN> name <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> call cdf <EoN> ( <BoN> value <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add ground <EoN> ( <BoN> f <EoN> , <BoN> coeff <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> f <EoN> . <BoN> rep <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> f <EoN> . <BoN> rep <EoN> . <BoN> add ground <EoN> ( <BoN> coeff <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Operation Not Supported <EoN> ( <BoN> f <EoN> , <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> f <EoN> . <BoN> per <EoN> ( <BoN> result <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cumprod <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> exclusive <EoN> = <BoN> False <EoN> , <BoN> reverse <EoN> = <BoN> False <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <STRING> , <NEWLINE> <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> x <EoN> , <BoN> axis <EoN> , <STRING> , <BoN> exclusive <EoN> , <NEWLINE> <STRING> , <BoN> reverse <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> cumprod eager fallback <EoN> ( <NEWLINE> <BoN> x <EoN> , <BoN> axis <EoN> , <BoN> exclusive <EoN> = <BoN> exclusive <EoN> , <BoN> reverse <EoN> = <BoN> reverse <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> exclusive <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> exclusive <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> exclusive <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> exclusive <EoN> , <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> reverse <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> reverse <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> reverse <EoN> = <BoN> execute <EoN> . <BoN> make bool <EoN> ( <BoN> reverse <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> x <EoN> = <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> , <BoN> exclusive <EoN> = <BoN> exclusive <EoN> , <BoN> reverse <EoN> = <BoN> reverse <EoN> , <NEWLINE> <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> fillna <EoN> ( <BoN> self <EoN> , <BoN> value <EoN> = <BoN> None <EoN> , <BoN> method <EoN> = <BoN> None <EoN> , <BoN> limit <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> api <EoN> . <BoN> types <EoN> <BoN> import <EoN> <BoN> is array like <EoN> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> util <EoN> . <BoN> validators <EoN> <BoN> import <EoN> <BoN> validate fillna kwargs <EoN> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> missing <EoN> <BoN> import <EoN> <BoN> pad 1 d <EoN> , <BoN> backfill 1 d <EoN> <NEWLINE> <NEWLINE> <BoN> value <EoN> , <BoN> method <EoN> = <BoN> validate fillna kwargs <EoN> ( <BoN> value <EoN> , <BoN> method <EoN> ) <NEWLINE> <NEWLINE> <BoN> mask <EoN> = <BoN> self <EoN> . <BoN> isna <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> is array like <EoN> ( <BoN> value <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> value <EoN> ) != <BoN> len <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <BoN> len <EoN> ( <BoN> value <EoN> ) , <BoN> len <EoN> ( <BoN> self <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> value <EoN> = <BoN> value <EoN> [ <BoN> mask <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> mask <EoN> . <BoN> any <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> method <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> func <EoN> = <BoN> pad 1 d <EoN> <BoN> if <EoN> <BoN> method <EoN> == <STRING> <BoN> else <EoN> <BoN> backfill 1 d <EoN> <NEWLINE> <BoN> new values <EoN> = <BoN> func <EoN> ( <BoN> self <EoN> . <BoN> astype <EoN> ( <BoN> object <EoN> ) , <BoN> limit <EoN> = <BoN> limit <EoN> , <NEWLINE> <BoN> mask <EoN> = <BoN> mask <EoN> ) <NEWLINE> <BoN> new values <EoN> = <BoN> self <EoN> . <BoN> from sequence <EoN> ( <BoN> new values <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> self <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <BoN> new values <EoN> [ <BoN> mask <EoN> ] = <BoN> value <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new values <EoN> = <BoN> self <EoN> . <BoN> copy <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> new values <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> segment prod eager fallback <EoN> ( <BoN> data <EoN> , <BoN> segment ids <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> data <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> data <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> attr Tindices <EoN> , ( <BoN> segment ids <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> segment ids <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> data <EoN> , <BoN> segment ids <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> , <STRING> , <BoN> attr Tindices <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <NEWLINE> <BoN> attrs <EoN> = <BoN> attrs <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> create intersect all <EoN> ( <BoN> cls <EoN> , * <BoN> selects <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Compound Select <EoN> ( <NEWLINE> <BoN> Compound Select <EoN> . <BoN> INTERSECT ALL <EoN> , * <BoN> selects <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nonlinear 2 eq order 1 type 4 <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> t <EoN> , <BoN> eq <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> C 1 <EoN> , <BoN> C 2 <EoN> = <BoN> get numbered constants <EoN> ( <BoN> eq <EoN> , <BoN> num <EoN> = <NUMBER> ) <NEWLINE> <BoN> u <EoN> , <BoN> v <EoN> = <BoN> symbols <EoN> ( <STRING> ) <NEWLINE> <BoN> U <EoN> , <BoN> V <EoN> = <BoN> symbols <EoN> ( <STRING> , <BoN> cls <EoN> = <BoN> Function <EoN> ) <NEWLINE> <BoN> f <EoN> = <BoN> Wild <EoN> ( <STRING> ) <NEWLINE> <BoN> g <EoN> = <BoN> Wild <EoN> ( <STRING> ) <NEWLINE> <BoN> f 1 <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> v <EoN> , <BoN> t <EoN> ] ) <NEWLINE> <BoN> f 2 <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> v <EoN> , <BoN> t <EoN> ] ) <NEWLINE> <BoN> g 1 <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> u <EoN> , <BoN> t <EoN> ] ) <NEWLINE> <BoN> g 2 <EoN> = <BoN> Wild <EoN> ( <STRING> , <BoN> exclude <EoN> = [ <BoN> u <EoN> , <BoN> t <EoN> ] ) <NEWLINE> <BoN> r 1 <EoN> = <BoN> eq <EoN> [ <NUMBER> ] . <BoN> match <EoN> ( <BoN> diff <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> t <EoN> ) - <BoN> f <EoN> ) <NEWLINE> <BoN> r 2 <EoN> = <BoN> eq <EoN> [ <NUMBER> ] . <BoN> match <EoN> ( <BoN> diff <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> t <EoN> ) - <BoN> g <EoN> ) <NEWLINE> <BoN> num <EoN> , <BoN> den <EoN> = ( <NEWLINE> ( <BoN> r 1 <EoN> [ <BoN> f <EoN> ] . <BoN> subs <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> u <EoN> ) . <BoN> subs <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> v <EoN> ) ) / <NEWLINE> ( <BoN> r 2 <EoN> [ <BoN> g <EoN> ] . <BoN> subs <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> u <EoN> ) . <BoN> subs <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> v <EoN> ) ) ) . <BoN> as numer denom <EoN> ( ) <NEWLINE> <BoN> R 1 <EoN> = <BoN> num <EoN> . <BoN> match <EoN> ( <BoN> f 1 <EoN> * <BoN> g 1 <EoN> ) <NEWLINE> <BoN> R 2 <EoN> = <BoN> den <EoN> . <BoN> match <EoN> ( <BoN> f 2 <EoN> * <BoN> g 2 <EoN> ) <NEWLINE> <BoN> phi <EoN> = ( <BoN> r 1 <EoN> [ <BoN> f <EoN> ] . <BoN> subs <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> u <EoN> ) . <BoN> subs <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> v <EoN> ) ) / <BoN> num <EoN> <NEWLINE> <BoN> F 1 <EoN> = <BoN> R 1 <EoN> [ <BoN> f 1 <EoN> ] ; <BoN> F 2 <EoN> = <BoN> R 2 <EoN> [ <BoN> f 2 <EoN> ] <NEWLINE> <BoN> G 1 <EoN> = <BoN> R 1 <EoN> [ <BoN> g 1 <EoN> ] ; <BoN> G 2 <EoN> = <BoN> R 2 <EoN> [ <BoN> g 2 <EoN> ] <NEWLINE> <BoN> sol 1 r <EoN> = <BoN> solve <EoN> ( <BoN> Integral <EoN> ( <BoN> F 2 <EoN> / <BoN> F 1 <EoN> , <BoN> u <EoN> ) . <BoN> doit <EoN> ( ) - <BoN> Integral <EoN> ( <BoN> G 1 <EoN> / <BoN> G 2 <EoN> , <BoN> v <EoN> ) . <BoN> doit <EoN> ( ) - <BoN> C 1 <EoN> , <BoN> u <EoN> ) <NEWLINE> <BoN> sol 2 r <EoN> = <BoN> solve <EoN> ( <BoN> Integral <EoN> ( <BoN> F 2 <EoN> / <BoN> F 1 <EoN> , <BoN> u <EoN> ) . <BoN> doit <EoN> ( ) - <BoN> Integral <EoN> ( <BoN> G 1 <EoN> / <BoN> G 2 <EoN> , <BoN> v <EoN> ) . <BoN> doit <EoN> ( ) - <BoN> C 1 <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> sol <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> sols <EoN> <BoN> in <EoN> <BoN> sol 1 r <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> . <BoN> append <EoN> ( <BoN> Eq <EoN> ( <BoN> y <EoN> ( <BoN> t <EoN> ) , <BoN> dsolve <EoN> ( <BoN> diff <EoN> ( <BoN> V <EoN> ( <BoN> t <EoN> ) , <BoN> t <EoN> ) - <BoN> F 2 <EoN> . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> sols <EoN> ) . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> V <EoN> ( <BoN> t <EoN> ) ) * <BoN> G 2 <EoN> . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> V <EoN> ( <BoN> t <EoN> ) ) * <BoN> phi <EoN> . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> sols <EoN> ) . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> V <EoN> ( <BoN> t <EoN> ) ) ) . <BoN> rhs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> sols <EoN> <BoN> in <EoN> <BoN> sol 2 r <EoN> : <NEWLINE> <TAB> <BoN> sol <EoN> . <BoN> append <EoN> ( <BoN> Eq <EoN> ( <BoN> x <EoN> ( <BoN> t <EoN> ) , <BoN> dsolve <EoN> ( <BoN> diff <EoN> ( <BoN> U <EoN> ( <BoN> t <EoN> ) , <BoN> t <EoN> ) - <BoN> F 1 <EoN> . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> U <EoN> ( <BoN> t <EoN> ) ) * <BoN> G 1 <EoN> . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> sols <EoN> ) . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> U <EoN> ( <BoN> t <EoN> ) ) * <BoN> phi <EoN> . <BoN> subs <EoN> ( <BoN> v <EoN> , <BoN> sols <EoN> ) . <BoN> subs <EoN> ( <BoN> u <EoN> , <BoN> U <EoN> ( <BoN> t <EoN> ) ) ) . <BoN> rhs <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> set <EoN> ( <BoN> sol <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> savefig <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> . <BoN> setdefault <EoN> ( <STRING> , <STRING> ) <NEWLINE> <BoN> self <EoN> . <BoN> fig <EoN> . <BoN> savefig <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dict from expr <EoN> ( <BoN> expr <EoN> , <BoN> opt <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> expr <EoN> . <BoN> is commutative <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polynomial Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> is expandable pow <EoN> ( <BoN> expr <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> ( <BoN> expr <EoN> . <BoN> is Pow <EoN> <BoN> and <EoN> <BoN> expr <EoN> . <BoN> exp <EoN> . <BoN> is positive <EoN> <BoN> and <EoN> <BoN> expr <EoN> . <BoN> exp <EoN> . <BoN> is Integer <EoN> <NEWLINE> <BoN> and <EoN> <BoN> expr <EoN> . <BoN> base <EoN> . <BoN> is Add <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> opt <EoN> . <BoN> expand <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> expr <EoN> , <BoN> Expr <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polynomial Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> expr <EoN> = <BoN> expr <EoN> . <BoN> expand <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> while <EoN> <BoN> any <EoN> ( <BoN> is expandable pow <EoN> ( <BoN> i <EoN> ) <BoN> or <EoN> <BoN> i <EoN> . <BoN> is Mul <EoN> <BoN> and <EoN> <NEWLINE> <BoN> any <EoN> ( <BoN> is expandable pow <EoN> ( <BoN> j <EoN> ) <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> i <EoN> . <BoN> args <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <NEWLINE> <BoN> Add <EoN> . <BoN> make args <EoN> ( <BoN> expr <EoN> ) ) : <NEWLINE> <NEWLINE> <TAB> <BoN> expr <EoN> = <BoN> expand multinomial <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> any <EoN> ( <BoN> i <EoN> . <BoN> is Mul <EoN> <BoN> and <EoN> <BoN> any <EoN> ( <BoN> j <EoN> . <BoN> is Add <EoN> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> i <EoN> . <BoN> args <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> Add <EoN> . <BoN> make args <EoN> ( <BoN> expr <EoN> ) ) : <NEWLINE> <TAB> <BoN> expr <EoN> = <BoN> expand mul <EoN> ( <BoN> expr <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> opt <EoN> . <BoN> gens <EoN> : <NEWLINE> <TAB> <BoN> rep <EoN> , <BoN> gens <EoN> = <BoN> dict from expr if gens <EoN> ( <BoN> expr <EoN> , <BoN> opt <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> rep <EoN> , <BoN> gens <EoN> = <BoN> dict from expr no gens <EoN> ( <BoN> expr <EoN> , <BoN> opt <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> rep <EoN> , <BoN> opt <EoN> . <BoN> clone <EoN> ( { <STRING> : <BoN> gens <EoN> } ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> load embedding <EoN> ( <BoN> self <EoN> , <BoN> pretrained file path <EoN> , <BoN> elem delim <EoN> , <BoN> init unknown vec <EoN> , <BoN> encoding <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> pretrained file path <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> expanduser <EoN> ( <BoN> pretrained file path <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> os <EoN> . <BoN> path <EoN> . <BoN> isfile <EoN> ( <BoN> pretrained file path <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> pretrained file path <EoN> ) <NEWLINE> <BoN> vec len <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> all elems <EoN> = [ ] <NEWLINE> <BoN> tokens <EoN> = <BoN> set <EoN> ( ) <NEWLINE> <BoN> loaded unknown vec <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> line num <EoN> = <NUMBER> <NEWLINE> <BoN> with <EoN> <BoN> io <EoN> . <BoN> open <EoN> ( <BoN> pretrained file path <EoN> , <STRING> , <BoN> encoding <EoN> = <BoN> encoding <EoN> ) <BoN> as <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> line <EoN> <BoN> in <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> line num <EoN> += <NUMBER> <NEWLINE> <BoN> elems <EoN> = <BoN> line <EoN> . <BoN> rstrip <EoN> ( ) . <BoN> split <EoN> ( <BoN> elem delim <EoN> ) <NEWLINE> <NEWLINE> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> elems <EoN> ) > <NUMBER> , <STRING> <STRING> <STRING> % ( <BoN> line num <EoN> , <BoN> pretrained file path <EoN> ) <NEWLINE> <NEWLINE> <BoN> token <EoN> , <BoN> elems <EoN> = <BoN> elems <EoN> [ <NUMBER> ] , [ <BoN> float <EoN> ( <BoN> i <EoN> ) <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> elems <EoN> [ <NUMBER> : ] ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> token <EoN> == <BoN> self <EoN> . <BoN> unknown token <EoN> <BoN> and <EoN> <BoN> loaded unknown vec <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> loaded unknown vec <EoN> = <BoN> elems <EoN> <NEWLINE> <BoN> tokens <EoN> . <BoN> add <EoN> ( <BoN> self <EoN> . <BoN> unknown token <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> token <EoN> <BoN> in <EoN> <BoN> tokens <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % <NEWLINE> ( <BoN> line num <EoN> , <BoN> token <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> len <EoN> ( <BoN> elems <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> % ( <BoN> line num <EoN> , <BoN> token <EoN> , <BoN> elems <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> vec len <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> vec len <EoN> = <BoN> len <EoN> ( <BoN> elems <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> all elems <EoN> . <BoN> extend <EoN> ( [ <NUMBER> ] * <BoN> vec len <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> len <EoN> ( <BoN> elems <EoN> ) == <BoN> vec len <EoN> , <STRING> <STRING> <STRING> % ( <BoN> line num <EoN> , <BoN> token <EoN> , <BoN> len <EoN> ( <BoN> elems <EoN> ) , <BoN> vec len <EoN> ) <NEWLINE> <UNTAB> <BoN> all elems <EoN> . <BoN> extend <EoN> ( <BoN> elems <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> idx to token <EoN> . <BoN> append <EoN> ( <BoN> token <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> token to idx <EoN> [ <BoN> token <EoN> ] = <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> idx to token <EoN> ) - <NUMBER> <NEWLINE> <BoN> tokens <EoN> . <BoN> add <EoN> ( <BoN> token <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> vec len <EoN> = <BoN> vec len <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> idx to vec <EoN> = <BoN> nd <EoN> . <BoN> array <EoN> ( <BoN> all elems <EoN> ) . <BoN> reshape <EoN> ( ( - <NUMBER> , <BoN> self <EoN> . <BoN> vec len <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> loaded unknown vec <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> idx to vec <EoN> [ <BoN> C <EoN> . <BoN> UNKNOWN IDX <EoN> ] = <BoN> init unknown vec <EoN> ( <BoN> shape <EoN> = <BoN> self <EoN> . <BoN> vec len <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> idx to vec <EoN> [ <BoN> C <EoN> . <BoN> UNKNOWN IDX <EoN> ] = <BoN> nd <EoN> . <BoN> array <EoN> ( <BoN> loaded unknown vec <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> save inst <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> cls <EoN> = <BoN> obj <EoN> . <BoN> class <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> f <EoN> = <BoN> self <EoN> . <BoN> dispatch <EoN> . <BoN> get <EoN> ( <BoN> cls <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> ( <BoN> self <EoN> , <BoN> obj <EoN> ) <NEWLINE> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> memo <EoN> = <BoN> self <EoN> . <BoN> memo <EoN> <NEWLINE> <BoN> write <EoN> = <BoN> self <EoN> . <BoN> write <EoN> <NEWLINE> <BoN> save <EoN> = <BoN> self <EoN> . <BoN> save <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> obj <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> args <EoN> = <BoN> obj <EoN> . <BoN> getinitargs <EoN> ( ) <NEWLINE> <BoN> len <EoN> ( <BoN> args <EoN> ) <NEWLINE> <BoN> pickle <EoN> . <BoN> keep alive <EoN> ( <BoN> args <EoN> , <BoN> memo <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> args <EoN> = ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> write <EoN> ( <BoN> pickle <EoN> . <BoN> MAR K <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> bin <EoN> : <NEWLINE> <TAB> <BoN> save <EoN> ( <BoN> cls <EoN> ) <NEWLINE> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> save <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <UNTAB> <BoN> write <EoN> ( <BoN> pickle <EoN> . <BoN> OB J <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> save <EoN> ( <BoN> arg <EoN> ) <NEWLINE> <UNTAB> <BoN> write <EoN> ( <BoN> pickle <EoN> . <BoN> INS T <EoN> + <BoN> cls <EoN> . <BoN> module <EoN> + <STRING> + <BoN> cls <EoN> . <BoN> name <EoN> + <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> memoize <EoN> ( <BoN> obj <EoN> ) <NEWLINE> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> getstate <EoN> = <BoN> obj <EoN> . <BoN> getstate <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> stuff <EoN> = <BoN> obj <EoN> . <BoN> dict <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> stuff <EoN> = <BoN> getstate <EoN> ( ) <NEWLINE> <BoN> pickle <EoN> . <BoN> keep alive <EoN> ( <BoN> stuff <EoN> , <BoN> memo <EoN> ) <NEWLINE> <UNTAB> <BoN> save <EoN> ( <BoN> stuff <EoN> ) <NEWLINE> <BoN> write <EoN> ( <BoN> pickle <EoN> . <BoN> BUIL D <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> nseries <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> = <BoN> None <EoN> , <BoN> x 0 <EoN> = <NUMBER> , <BoN> n <EoN> = <NUMBER> , <BoN> dir <EoN> = <STRING> , <BoN> logx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> x <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> x <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> x 0 <EoN> <BoN> or <EoN> <BoN> dir <EoN> != <STRING> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> series <EoN> ( <BoN> x <EoN> , <BoN> x 0 <EoN> , <BoN> n <EoN> , <BoN> dir <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval nseries <EoN> ( <BoN> x <EoN> , <BoN> n <EoN> = <BoN> n <EoN> , <BoN> logx <EoN> = <BoN> logx <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> with shape <EoN> ( <BoN> expected shape <EoN> , <BoN> tensor <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> tensor <EoN> , <BoN> sparse tensor <EoN> . <BoN> Sparse Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> tensor util <EoN> . <BoN> is tensor <EoN> ( <BoN> expected shape <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expected shape <EoN> . <BoN> dtype <EoN> . <BoN> base dtype <EoN> != <BoN> dtypes <EoN> . <BoN> int 32 <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> expected shape <EoN> . <BoN> dtype <EoN> , <BoN> expected shape <EoN> , <BoN> tensor <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> expected shape <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> expected shape <EoN> : <NEWLINE> <TAB> <BoN> expected shape <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( [ ] , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> np expected shape <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> expected shape <EoN> ) <NEWLINE> <BoN> expected shape <EoN> = ( <NEWLINE> <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> expected shape <EoN> , <BoN> dtype <EoN> = <BoN> np <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> np expected shape <EoN> . <BoN> dtype <EoN> == <BoN> np <EoN> . <BoN> int 64 <EoN> <BoN> else <EoN> <BoN> np expected shape <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> expected shape <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> expected shape <EoN> . <BoN> ndim <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> expected shape <EoN> . <BoN> ndim <EoN> , <BoN> expected shape <EoN> , <BoN> tensor <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> expected shape <EoN> . <BoN> dtype <EoN> != <BoN> np <EoN> . <BoN> int 32 <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> % ( <NEWLINE> <BoN> expected shape <EoN> . <BoN> dtype <EoN> , <BoN> expected shape <EoN> , <BoN> tensor <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> actual shape <EoN> = <BoN> tensor <EoN> . <BoN> get shape <EoN> ( ) <NEWLINE> <NEWLINE> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> actual shape <EoN> . <BoN> is fully defined <EoN> ( ) <NEWLINE> <BoN> or <EoN> <BoN> tensor util <EoN> . <BoN> is tensor <EoN> ( <BoN> expected shape <EoN> ) ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> % <BoN> tensor <EoN> . <BoN> op <EoN> . <BoN> name <EoN> , <BoN> values <EoN> = [ <BoN> tensor <EoN> ] ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> tensor util <EoN> . <BoN> is tensor <EoN> ( <BoN> expected shape <EoN> ) <NEWLINE> <BoN> and <EoN> ( <BoN> len <EoN> ( <BoN> expected shape <EoN> ) < <NUMBER> ) ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> tensor <EoN> , [ ] ) <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> assert shape op <EoN> ( <BoN> expected shape <EoN> , <BoN> tensor <EoN> ) ] ) : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> array ops <EoN> . <BoN> identity <EoN> ( <BoN> tensor <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> tensor util <EoN> . <BoN> is tensor <EoN> ( <BoN> expected shape <EoN> ) : <NEWLINE> <TAB> <BoN> result <EoN> . <BoN> set shape <EoN> ( <BoN> expected shape <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> tensor util <EoN> . <BoN> is tensor <EoN> ( <BoN> expected shape <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> not <EoN> <BoN> actual shape <EoN> . <BoN> is compatible with <EoN> ( <BoN> expected shape <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> len <EoN> ( <BoN> expected shape <EoN> ) < <NUMBER> ) <BoN> and <EoN> <BoN> actual shape <EoN> . <BoN> is compatible with <EoN> ( [ <NUMBER> ] ) : <NEWLINE> <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <STRING> % <BoN> tensor <EoN> . <BoN> op <EoN> . <BoN> name <EoN> , <BoN> values <EoN> = [ <BoN> tensor <EoN> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> tensor <EoN> , [ ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % ( <NEWLINE> <BoN> tensor <EoN> . <BoN> name <EoN> , <BoN> expected shape <EoN> , <BoN> actual shape <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> tensor <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> remote exception <EoN> ( <BoN> exc <EoN> , <BoN> tb <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> type <EoN> ( <BoN> exc <EoN> ) <BoN> in <EoN> <BoN> exceptions <EoN> : <NEWLINE> <TAB> <BoN> typ <EoN> = <BoN> exceptions <EoN> [ <BoN> type <EoN> ( <BoN> exc <EoN> ) ] <NEWLINE> <BoN> return <EoN> <BoN> typ <EoN> ( <BoN> exc <EoN> , <BoN> tb <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> typ <EoN> = <BoN> type <EoN> ( <BoN> exc <EoN> . <BoN> class <EoN> . <BoN> name <EoN> , <NEWLINE> ( <BoN> Remote Exception <EoN> , <BoN> type <EoN> ( <BoN> exc <EoN> ) ) , <NEWLINE> { <STRING> : <BoN> type <EoN> ( <BoN> exc <EoN> ) } ) <NEWLINE> <BoN> exceptions <EoN> [ <BoN> type <EoN> ( <BoN> exc <EoN> ) ] = <BoN> typ <EoN> <NEWLINE> <BoN> return <EoN> <BoN> typ <EoN> ( <BoN> exc <EoN> , <BoN> tb <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Type Error <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> exc <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> randdm <EoN> ( <BoN> pnts <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> pnts <EoN> >= <NUMBER> : <NEWLINE> <TAB> <BoN> D <EoN> = <BoN> np <EoN> . <BoN> random <EoN> . <BoN> rand <EoN> ( <BoN> pnts <EoN> * ( <BoN> pnts <EoN> - <NUMBER> ) / <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> D <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> self <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> = <STRING> % <BoN> self <EoN> . <BoN> name <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> fn <EoN> = <BoN> lambda <EoN> : <BoN> gen data flow ops <EoN> . <BoN> unstage <EoN> ( <BoN> dtypes <EoN> = <BoN> self <EoN> . <BoN> dtypes <EoN> , <NEWLINE> <BoN> shared name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <NEWLINE> <BoN> capacity <EoN> = <BoN> self <EoN> . <BoN> capacity <EoN> , <NEWLINE> <BoN> memory limit <EoN> = <BoN> self <EoN> . <BoN> memory limit <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> internal get <EoN> ( <BoN> fn <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> new <EoN> ( <BoN> cls <EoN> , <BoN> stylename <EoN> , ** <BoN> kw <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> list <EoN> = <BoN> stylename <EoN> . <BoN> replace <EoN> ( <STRING> , <STRING> ) . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <BoN> name <EoN> = <BoN> list <EoN> [ <NUMBER> ] . <BoN> lower <EoN> ( ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> cls <EoN> = <BoN> cls <EoN> . <BoN> style list <EoN> [ <BoN> name <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> stylename <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> args pair <EoN> = [ <BoN> cs <EoN> . <BoN> split <EoN> ( <STRING> ) <BoN> for <EoN> <BoN> cs <EoN> <BoN> in <EoN> <BoN> list <EoN> [ <NUMBER> : ] ] <NEWLINE> <BoN> args <EoN> = { <BoN> k <EoN> : <BoN> float <EoN> ( <BoN> v <EoN> ) <BoN> for <EoN> <BoN> k <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> args pair <EoN> } <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> stylename <EoN> ) <NEWLINE> <UNTAB> <BoN> args <EoN> . <BoN> update <EoN> ( <BoN> kw <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> cls <EoN> ( ** <BoN> args <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get dpi <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> dpi <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> svd factorization projections <EoN> ( <BoN> A <EoN> , <BoN> m <EoN> , <BoN> n <EoN> , <BoN> orth tol <EoN> , <BoN> max refin <EoN> , <BoN> tol <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> U <EoN> , <BoN> s <EoN> , <BoN> Vt <EoN> = <BoN> scipy <EoN> . <BoN> linalg <EoN> . <BoN> svd <EoN> ( <BoN> A <EoN> , <BoN> full matrices <EoN> = <BoN> False <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> U <EoN> = <BoN> U <EoN> [ : , <BoN> s <EoN> > <BoN> tol <EoN> ] <NEWLINE> <BoN> Vt <EoN> = <BoN> Vt <EoN> [ <BoN> s <EoN> > <BoN> tol <EoN> , : ] <NEWLINE> <BoN> s <EoN> = <BoN> s <EoN> [ <BoN> s <EoN> > <BoN> tol <EoN> ] <NEWLINE> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> null space <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> aux 1 <EoN> = <BoN> Vt <EoN> . <BoN> dot <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> aux 2 <EoN> = <NUMBER> / <BoN> s <EoN> * <BoN> aux 1 <EoN> <NEWLINE> <BoN> v <EoN> = <BoN> U <EoN> . <BoN> dot <EoN> ( <BoN> aux 2 <EoN> ) <NEWLINE> <BoN> z <EoN> = <BoN> x <EoN> - <BoN> A <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> v <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> k <EoN> = <NUMBER> <NEWLINE> <BoN> while <EoN> <BoN> orthogonality <EoN> ( <BoN> A <EoN> , <BoN> z <EoN> ) > <BoN> orth tol <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> k <EoN> >= <BoN> max refin <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> aux 1 <EoN> = <BoN> Vt <EoN> . <BoN> dot <EoN> ( <BoN> z <EoN> ) <NEWLINE> <BoN> aux 2 <EoN> = <NUMBER> / <BoN> s <EoN> * <BoN> aux 1 <EoN> <NEWLINE> <BoN> v <EoN> = <BoN> U <EoN> . <BoN> dot <EoN> ( <BoN> aux 2 <EoN> ) <NEWLINE> <NEWLINE> <BoN> z <EoN> = <BoN> z <EoN> - <BoN> A <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> v <EoN> ) <NEWLINE> <BoN> k <EoN> += <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> z <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> least squares <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> aux 1 <EoN> = <BoN> Vt <EoN> . <BoN> dot <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> aux 2 <EoN> = <NUMBER> / <BoN> s <EoN> * <BoN> aux 1 <EoN> <NEWLINE> <BoN> z <EoN> = <BoN> U <EoN> . <BoN> dot <EoN> ( <BoN> aux 2 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> z <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> row space <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> aux 1 <EoN> = <BoN> U <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> aux 2 <EoN> = <NUMBER> / <BoN> s <EoN> * <BoN> aux 1 <EoN> <NEWLINE> <BoN> z <EoN> = <BoN> Vt <EoN> . <BoN> T <EoN> . <BoN> dot <EoN> ( <BoN> aux 2 <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> z <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> null space <EoN> , <BoN> least squares <EoN> , <BoN> row space <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bind method <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> func <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> P Y 3 <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> types <EoN> . <BoN> Method Type <EoN> ( <BoN> func <EoN> , <BoN> None <EoN> , <BoN> cls <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> setattr <EoN> ( <BoN> cls <EoN> , <BoN> name <EoN> , <BoN> func <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> num tasks <EoN> ( <BoN> self <EoN> , <BoN> job name <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> job <EoN> = <BoN> self <EoN> . <BoN> cluster spec <EoN> [ <BoN> job name <EoN> ] <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Key Error <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> job name <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> len <EoN> ( <BoN> job <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trace <EoN> ( <BoN> a <EoN> , <BoN> offset <EoN> = <NUMBER> , <BoN> axis 1 <EoN> = <NUMBER> , <BoN> axis 2 <EoN> = <NUMBER> , <BoN> dtype <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> a <EoN> , <BoN> np <EoN> . <BoN> matrix <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> asarray <EoN> ( <BoN> a <EoN> ) . <BoN> trace <EoN> ( <BoN> offset <EoN> = <BoN> offset <EoN> , <BoN> axis 1 <EoN> = <BoN> axis 1 <EoN> , <BoN> axis 2 <EoN> = <BoN> axis 2 <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> out <EoN> = <BoN> out <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> asanyarray <EoN> ( <BoN> a <EoN> ) . <BoN> trace <EoN> ( <BoN> offset <EoN> = <BoN> offset <EoN> , <BoN> axis 1 <EoN> = <BoN> axis 1 <EoN> , <BoN> axis 2 <EoN> = <BoN> axis 2 <EoN> , <BoN> dtype <EoN> = <BoN> dtype <EoN> , <BoN> out <EoN> = <BoN> out <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> assign from values fn <EoN> ( <BoN> var names to values <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> assign op <EoN> , <BoN> feed dict <EoN> = <BoN> assign from values <EoN> ( <BoN> var names to values <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> callback <EoN> ( <BoN> session <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> session <EoN> . <BoN> run <EoN> ( <BoN> assign op <EoN> , <BoN> feed dict <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> callback <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dot <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> strict <EoN> = <BoN> False <EoN> , <BoN> out <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> strict <EoN> <BoN> and <EoN> ( <BoN> a <EoN> . <BoN> ndim <EoN> == <NUMBER> ) <BoN> and <EoN> ( <BoN> b <EoN> . <BoN> ndim <EoN> == <NUMBER> ) : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> mask rowcols <EoN> ( <BoN> a <EoN> , <NUMBER> ) <NEWLINE> <BoN> b <EoN> = <BoN> mask rowcols <EoN> ( <BoN> b <EoN> , <NUMBER> ) <NEWLINE> <UNTAB> <BoN> am <EoN> = ~ <BoN> getmaskarray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> bm <EoN> = ~ <BoN> getmaskarray <EoN> ( <BoN> b <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> filled <EoN> ( <BoN> a <EoN> , <NUMBER> ) , <BoN> filled <EoN> ( <BoN> b <EoN> , <NUMBER> ) ) <NEWLINE> <BoN> m <EoN> = ~ <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> am <EoN> , <BoN> bm <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> d <EoN> . <BoN> ndim <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> np <EoN> . <BoN> asarray <EoN> ( <BoN> d <EoN> ) <NEWLINE> <UNTAB> <BoN> r <EoN> = <BoN> d <EoN> . <BoN> view <EoN> ( <BoN> get masked subclass <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) ) <NEWLINE> <BoN> r <EoN> . <BoN> setmask <EoN> ( <BoN> m <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> r <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> d <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> filled <EoN> ( <BoN> a <EoN> , <NUMBER> ) , <BoN> filled <EoN> ( <BoN> b <EoN> , <NUMBER> ) , <BoN> out <EoN> . <BoN> data <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> out <EoN> . <BoN> mask <EoN> . <BoN> shape <EoN> != <BoN> d <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> out <EoN> . <BoN> mask <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> d <EoN> . <BoN> shape <EoN> , <BoN> Mask Type <EoN> ) <NEWLINE> <UNTAB> <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> am <EoN> , <BoN> bm <EoN> , <BoN> out <EoN> . <BoN> mask <EoN> ) <NEWLINE> <BoN> np <EoN> . <BoN> logical not <EoN> ( <BoN> out <EoN> . <BoN> mask <EoN> , <BoN> out <EoN> . <BoN> mask <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> out <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> from FF gmpy <EoN> ( <BoN> K 1 <EoN> , <BoN> a <EoN> , <BoN> K 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> nthroot mod <EoN> ( <BoN> a <EoN> , <BoN> n <EoN> , <BoN> p <EoN> , <BoN> all roots <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> numbers <EoN> <BoN> import <EoN> <BoN> igcdex <EoN> <NEWLINE> <BoN> a <EoN> , <BoN> n <EoN> , <BoN> p <EoN> = <BoN> as int <EoN> ( <BoN> a <EoN> ) , <BoN> as int <EoN> ( <BoN> n <EoN> ) , <BoN> as int <EoN> ( <BoN> p <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sqrt mod <EoN> ( <BoN> a <EoN> , <BoN> p <EoN> , <BoN> all roots <EoN> ) <NEWLINE> <UNTAB> <BoN> f <EoN> = <BoN> totient <EoN> ( <BoN> p <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> is nthpow residue <EoN> ( <BoN> a <EoN> , <BoN> n <EoN> , <BoN> p <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> primitive root <EoN> ( <BoN> p <EoN> ) == <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> p <EoN> - <NUMBER> ) % <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> nthroot mod 1 <EoN> ( <BoN> a <EoN> , <BoN> n <EoN> , <BoN> p <EoN> , <BoN> all roots <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> pa <EoN> = <BoN> n <EoN> <NEWLINE> <BoN> pb <EoN> = <BoN> p <EoN> - <NUMBER> <NEWLINE> <BoN> b <EoN> = <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> pa <EoN> < <BoN> pb <EoN> : <NEWLINE> <TAB> <BoN> a <EoN> , <BoN> pa <EoN> , <BoN> b <EoN> , <BoN> pb <EoN> = <BoN> b <EoN> , <BoN> pb <EoN> , <BoN> a <EoN> , <BoN> pa <EoN> <NEWLINE> <UNTAB> <BoN> while <EoN> <BoN> pb <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> q <EoN> , <BoN> r <EoN> = <BoN> divmod <EoN> ( <BoN> pa <EoN> , <BoN> pb <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> pow <EoN> ( <BoN> b <EoN> , <BoN> q <EoN> , <BoN> p <EoN> ) <NEWLINE> <BoN> c <EoN> = <BoN> igcdex <EoN> ( <BoN> c <EoN> , <BoN> p <EoN> ) [ <NUMBER> ] <NEWLINE> <BoN> c <EoN> = ( <BoN> c <EoN> * <BoN> a <EoN> ) % <BoN> p <EoN> <NEWLINE> <BoN> pa <EoN> , <BoN> pb <EoN> = <BoN> pb <EoN> , <BoN> r <EoN> <NEWLINE> <BoN> a <EoN> , <BoN> b <EoN> = <BoN> b <EoN> , <BoN> c <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> pa <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> all roots <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = [ <BoN> a <EoN> ] <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> a <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> pa <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> sqrt mod <EoN> ( <BoN> a <EoN> , <BoN> p <EoN> , <BoN> all roots <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> nthroot mod 1 <EoN> ( <BoN> a <EoN> , <BoN> pa <EoN> , <BoN> p <EoN> , <BoN> all roots <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> period break <EoN> ( <BoN> dates <EoN> , <BoN> period <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> current <EoN> = <BoN> getattr <EoN> ( <BoN> dates <EoN> , <BoN> period <EoN> ) <NEWLINE> <BoN> previous <EoN> = <BoN> getattr <EoN> ( <BoN> dates <EoN> - <NUMBER> , <BoN> period <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> np <EoN> . <BoN> nonzero <EoN> ( <BoN> current <EoN> - <BoN> previous <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> collins crt <EoN> ( <BoN> r <EoN> , <BoN> R <EoN> , <BoN> P <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> gf int <EoN> ( <BoN> gf crt <EoN> ( [ <BoN> r <EoN> , <BoN> R <EoN> ] , [ <BoN> P <EoN> , <BoN> p <EoN> ] , <BoN> K <EoN> ) , <BoN> P <EoN> * <BoN> p <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> updated ctor param <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> dct <EoN> = <BoN> super <EoN> ( <BoN> rv histogram <EoN> , <BoN> self <EoN> ) . <BoN> updated ctor param <EoN> ( ) <NEWLINE> <BoN> dct <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> histogram <EoN> <NEWLINE> <BoN> return <EoN> <BoN> dct <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is type <EoN> ( <BoN> t <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> lambda <EoN> <BoN> x <EoN> : <BoN> isinstance <EoN> ( <BoN> x <EoN> . <BoN> value <EoN> , <BoN> t <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> trace <EoN> ( * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> def <EoN> <BoN> wrapper <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <TAB> <BoN> executor options <EoN> = { <STRING> : <BoN> True <EoN> } <NEWLINE> <BoN> for <EoN> <BoN> name <EoN> <BoN> in <EoN> <BoN> executor options <EoN> : <NEWLINE> <TAB> <BoN> executor options <EoN> [ <BoN> name <EoN> ] = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <BoN> name <EoN> , <BoN> executor options <EoN> [ <BoN> name <EoN> ] ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> kwargs <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> . <BoN> format <EoN> ( <STRING> . <BoN> join <EoN> ( <BoN> kwargs <EoN> . <BoN> keys <EoN> ( ) ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> func <EoN> , <BoN> torch <EoN> . <BoN> nn <EoN> . <BoN> Module <EoN> ) : <NEWLINE> <TAB> <BoN> orig <EoN> = <BoN> func <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> orig <EoN> = <BoN> Module <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> module <EoN> = <BoN> Top Level Traced Module <EoN> ( <BoN> orig <EoN> , ** <BoN> executor options <EoN> ) <NEWLINE> <BoN> module <EoN> . <BoN> create method from trace <EoN> ( <STRING> , <BoN> func <EoN> , <BoN> args <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> module <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> wrapper <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> parameter value <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> u <EoN> , <BoN> v <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> geometry <EoN> . <BoN> point <EoN> <BoN> import <EoN> <BoN> Point <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> symbol <EoN> <BoN> import <EoN> <BoN> Dummy <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> solvers <EoN> . <BoN> solvers <EoN> <BoN> import <EoN> <BoN> solve <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Geometry Entity <EoN> ) : <NEWLINE> <TAB> <BoN> other <EoN> = <BoN> Point <EoN> ( <BoN> other <EoN> , <BoN> dim <EoN> = <BoN> self <EoN> . <BoN> ambient dimension <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Point <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> other <EoN> == <BoN> self <EoN> . <BoN> p 1 <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> other <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> u <EoN> , <BoN> Symbol <EoN> ) <BoN> and <EoN> <BoN> v <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> delta <EoN> = <BoN> self <EoN> . <BoN> arbitrary point <EoN> ( <BoN> u <EoN> ) - <BoN> self <EoN> . <BoN> p 1 <EoN> <NEWLINE> <BoN> eq <EoN> = <BoN> delta <EoN> - ( <BoN> other <EoN> - <BoN> self <EoN> . <BoN> p 1 <EoN> ) . <BoN> unit <EoN> <NEWLINE> <BoN> sol <EoN> = <BoN> solve <EoN> ( <BoN> eq <EoN> , <BoN> u <EoN> , <BoN> dict <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> u <EoN> , <BoN> Symbol <EoN> ) <BoN> and <EoN> <BoN> isinstance <EoN> ( <BoN> v <EoN> , <BoN> Symbol <EoN> ) : <NEWLINE> <TAB> <BoN> pt <EoN> = <BoN> self <EoN> . <BoN> arbitrary point <EoN> ( <BoN> u <EoN> , <BoN> v <EoN> ) <NEWLINE> <BoN> sol <EoN> = <BoN> solve <EoN> ( <BoN> pt <EoN> - <BoN> other <EoN> , ( <BoN> u <EoN> , <BoN> v <EoN> ) , <BoN> dict <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> sol <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> func name <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sol <EoN> [ <NUMBER> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> interpgrid <EoN> ( <BoN> a <EoN> , <BoN> xi <EoN> , <BoN> yi <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> Ny <EoN> , <BoN> Nx <EoN> = <BoN> np <EoN> . <BoN> shape <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> xi <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> xi <EoN> . <BoN> astype <EoN> ( <BoN> int <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> yi <EoN> . <BoN> astype <EoN> ( <BoN> int <EoN> ) <NEWLINE> <NEWLINE> <BoN> xn <EoN> = <BoN> np <EoN> . <BoN> clip <EoN> ( <BoN> x <EoN> + <NUMBER> , <NUMBER> , <BoN> Nx <EoN> - <NUMBER> ) <NEWLINE> <BoN> yn <EoN> = <BoN> np <EoN> . <BoN> clip <EoN> ( <BoN> y <EoN> + <NUMBER> , <NUMBER> , <BoN> Ny <EoN> - <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> int <EoN> ( <BoN> xi <EoN> ) <NEWLINE> <BoN> y <EoN> = <BoN> int <EoN> ( <BoN> yi <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> == ( <BoN> Nx <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> xn <EoN> = <BoN> x <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xn <EoN> = <BoN> x <EoN> + <NUMBER> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> y <EoN> == ( <BoN> Ny <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> yn <EoN> = <BoN> y <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> yn <EoN> = <BoN> y <EoN> + <NUMBER> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> a 00 <EoN> = <BoN> a <EoN> [ <BoN> y <EoN> , <BoN> x <EoN> ] <NEWLINE> <BoN> a 01 <EoN> = <BoN> a <EoN> [ <BoN> y <EoN> , <BoN> xn <EoN> ] <NEWLINE> <BoN> a 10 <EoN> = <BoN> a <EoN> [ <BoN> yn <EoN> , <BoN> x <EoN> ] <NEWLINE> <BoN> a 11 <EoN> = <BoN> a <EoN> [ <BoN> yn <EoN> , <BoN> xn <EoN> ] <NEWLINE> <BoN> xt <EoN> = <BoN> xi <EoN> - <BoN> x <EoN> <NEWLINE> <BoN> yt <EoN> = <BoN> yi <EoN> - <BoN> y <EoN> <NEWLINE> <BoN> a 0 <EoN> = <BoN> a 00 <EoN> * ( <NUMBER> - <BoN> xt <EoN> ) + <BoN> a 01 <EoN> * <BoN> xt <EoN> <NEWLINE> <BoN> a 1 <EoN> = <BoN> a 10 <EoN> * ( <NUMBER> - <BoN> xt <EoN> ) + <BoN> a 11 <EoN> * <BoN> xt <EoN> <NEWLINE> <BoN> ai <EoN> = <BoN> a 0 <EoN> * ( <NUMBER> - <BoN> yt <EoN> ) + <BoN> a 1 <EoN> * <BoN> yt <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> xi <EoN> , <BoN> np <EoN> . <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> ma <EoN> . <BoN> is masked <EoN> ( <BoN> ai <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Terminate Trajectory <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> ai <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> reset <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> num inst <EoN> = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> sum metric <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> rotate <EoN> ( <BoN> self <EoN> , <BoN> angle <EoN> = <NUMBER> , <BoN> pt <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> hradius <EoN> == <BoN> self <EoN> . <BoN> vradius <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> self <EoN> . <BoN> center <EoN> . <BoN> rotate <EoN> ( <BoN> angle <EoN> , <BoN> pt <EoN> ) , <BoN> self <EoN> . <BoN> hradius <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> angle <EoN> / <BoN> S <EoN> . <BoN> Pi <EoN> ) . <BoN> is integer <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> super <EoN> ( <BoN> Ellipse <EoN> , <BoN> self <EoN> ) . <BoN> rotate <EoN> ( <BoN> angle <EoN> , <BoN> pt <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> ( <NUMBER> * <BoN> angle <EoN> / <BoN> S <EoN> . <BoN> Pi <EoN> ) . <BoN> is integer <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> self <EoN> . <BoN> center <EoN> . <BoN> rotate <EoN> ( <BoN> angle <EoN> , <BoN> pt <EoN> ) , <BoN> self <EoN> . <BoN> vradius <EoN> , <BoN> self <EoN> . <BoN> hradius <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> quantized bias add <EoN> ( <BoN> input <EoN> , <BoN> bias <EoN> , <BoN> min input <EoN> , <BoN> max input <EoN> , <BoN> min bias <EoN> , <BoN> max bias <EoN> , <BoN> out type <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> context <EoN> . <BoN> context <EoN> <NEWLINE> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> and <EoN> <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> is eager <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> pywrap tensorflow <EoN> . <BoN> TFE Py FastPathExecute <EoN> ( <NEWLINE> <BoN> ctx <EoN> . <BoN> context handle <EoN> , <BoN> ctx <EoN> . <BoN> eager context <EoN> . <BoN> device name <EoN> , <NEWLINE> <STRING> , <BoN> name <EoN> , <BoN> ctx <EoN> . <BoN> post execution callbacks <EoN> , <BoN> input <EoN> , <BoN> bias <EoN> , <NEWLINE> <BoN> min input <EoN> , <BoN> max input <EoN> , <BoN> min bias <EoN> , <BoN> max bias <EoN> , <STRING> , <BoN> out type <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedBiasAddOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> FallbackException <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> quantized bias add eager fallback <EoN> ( <NEWLINE> <BoN> input <EoN> , <BoN> bias <EoN> , <BoN> min input <EoN> , <BoN> max input <EoN> , <BoN> min bias <EoN> , <BoN> max bias <EoN> , <NEWLINE> <BoN> out type <EoN> = <BoN> out type <EoN> , <BoN> name <EoN> = <BoN> name <EoN> , <BoN> ctx <EoN> = <BoN> ctx <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> SymbolicException <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> core <EoN> . <BoN> NotOkStatusException <EoN> <BoN> as <EoN> <BoN> e <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> name <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> + <STRING> + <BoN> name <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> message <EoN> = <BoN> e <EoN> . <BoN> message <EoN> <NEWLINE> <UNTAB> <BoN> six <EoN> . <BoN> raise from <EoN> ( <BoN> core <EoN> . <BoN> status to exception <EoN> ( <BoN> e <EoN> . <BoN> code <EoN> , <BoN> message <EoN> ) , <BoN> None <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> out type <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> out type <EoN> , <STRING> ) <NEWLINE> <BoN> <EoN> , <BoN> <EoN> , <BoN> op <EoN> = <BoN> op def lib <EoN> . <BoN> apply op helper <EoN> ( <NEWLINE> <STRING> , <BoN> input <EoN> = <BoN> input <EoN> , <BoN> bias <EoN> = <BoN> bias <EoN> , <BoN> min input <EoN> = <BoN> min input <EoN> , <NEWLINE> <BoN> max input <EoN> = <BoN> max input <EoN> , <BoN> min bias <EoN> = <BoN> min bias <EoN> , <NEWLINE> <BoN> max bias <EoN> = <BoN> max bias <EoN> , <BoN> out type <EoN> = <BoN> out type <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> op <EoN> . <BoN> outputs <EoN> [ : ] <NEWLINE> <BoN> inputs flat <EoN> = <BoN> op <EoN> . <BoN> inputs <EoN> <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) , <STRING> , <NEWLINE> <BoN> op <EoN> . <BoN> get attr <EoN> ( <STRING> ) ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> QuantizedBiasAddOutput <EoN> . <BoN> make <EoN> ( <BoN> result <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get enum <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> const to enum <EoN> [ <BoN> key <EoN> ] [ <BoN> key <EoN> ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get config <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> = { <STRING> : <BoN> self <EoN> . <BoN> name <EoN> , <NEWLINE> <STRING> : <BoN> self <EoN> . <BoN> trainable <EoN> } <NEWLINE> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> config <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> batch input shape <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> , <STRING> ) : <NEWLINE> <TAB> <BoN> config <EoN> [ <STRING> ] = <BoN> self <EoN> . <BoN> dtype <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> config <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is platform little endian <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sys <EoN> . <BoN> byteorder <EoN> == <STRING> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> sympifyit <EoN> ( <STRING> , <BoN> Not Implemented Error <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> doit numerically <EoN> ( <BoN> self <EoN> , <BoN> z 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> import <EoN> <BoN> mpmath <EoN> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> core <EoN> . <BoN> expr <EoN> <BoN> import <EoN> <BoN> Expr <EoN> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> free symbols <EoN> ) != <NUMBER> <BoN> or <EoN> <BoN> len <EoN> ( <BoN> self <EoN> . <BoN> variables <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> z <EoN> = <BoN> list <EoN> ( <BoN> self <EoN> . <BoN> free symbols <EoN> ) [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> eval <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> f 0 <EoN> = <BoN> self <EoN> . <BoN> expr <EoN> . <BoN> subs <EoN> ( <BoN> z <EoN> , <BoN> Expr <EoN> . <BoN> from mpmath <EoN> ( <BoN> x <EoN> , <BoN> prec <EoN> = <BoN> mpmath <EoN> . <BoN> mp <EoN> . <BoN> prec <EoN> ) ) <NEWLINE> <BoN> f 0 <EoN> = <BoN> f 0 <EoN> . <BoN> evalf <EoN> ( <BoN> mlib <EoN> . <BoN> libmpf <EoN> . <BoN> prec to dps <EoN> ( <BoN> mpmath <EoN> . <BoN> mp <EoN> . <BoN> prec <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> f 0 <EoN> . <BoN> to mpmath <EoN> ( <BoN> mpmath <EoN> . <BoN> mp <EoN> . <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Expr <EoN> . <BoN> from mpmath <EoN> ( <BoN> mpmath <EoN> . <BoN> diff <EoN> ( <BoN> eval <EoN> , <NEWLINE> <BoN> z 0 <EoN> . <BoN> to mpmath <EoN> ( <BoN> mpmath <EoN> . <BoN> mp <EoN> . <BoN> prec <EoN> ) ) , <NEWLINE> <BoN> mpmath <EoN> . <BoN> mp <EoN> . <BoN> prec <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , <BoN> src <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> alpha <EoN> = <NUMBER> + <BoN> random <EoN> . <BoN> uniform <EoN> ( - <BoN> self <EoN> . <BoN> brightness <EoN> , <BoN> self <EoN> . <BoN> brightness <EoN> ) <NEWLINE> <BoN> src <EoN> *= <BoN> alpha <EoN> <NEWLINE> <BoN> return <EoN> <BoN> src <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> harden mask <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> hardmask <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> decode <EoN> ( <BoN> self <EoN> , <BoN> serialized example <EoN> , <BoN> items <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> example <EoN> = <BoN> parsing ops <EoN> . <BoN> parse single example <EoN> ( <BoN> serialized example <EoN> , <NEWLINE> <BoN> self <EoN> . <BoN> keys to features <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> k <EoN> <BoN> in <EoN> <BoN> sorted <EoN> ( <BoN> self <EoN> . <BoN> keys to features <EoN> ) : <NEWLINE> <TAB> <BoN> v <EoN> = <BoN> self <EoN> . <BoN> keys to features <EoN> [ <BoN> k <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> v <EoN> , <BoN> parsing ops <EoN> . <BoN> Fixed Len Feature <EoN> ) : <NEWLINE> <TAB> <BoN> example <EoN> [ <BoN> k <EoN> ] = <BoN> array ops <EoN> . <BoN> reshape <EoN> ( <BoN> example <EoN> [ <BoN> k <EoN> ] , <BoN> v <EoN> . <BoN> shape <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> items <EoN> : <NEWLINE> <TAB> <BoN> items <EoN> = <BoN> self <EoN> . <BoN> items to handlers <EoN> . <BoN> keys <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> outputs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> item <EoN> <BoN> in <EoN> <BoN> items <EoN> : <NEWLINE> <TAB> <BoN> handler <EoN> = <BoN> self <EoN> . <BoN> items to handlers <EoN> [ <BoN> item <EoN> ] <NEWLINE> <BoN> keys to tensors <EoN> = { <BoN> key <EoN> : <BoN> example <EoN> [ <BoN> key <EoN> ] <BoN> for <EoN> <BoN> key <EoN> <BoN> in <EoN> <BoN> handler <EoN> . <BoN> keys <EoN> } <NEWLINE> <BoN> outputs <EoN> . <BoN> append <EoN> ( <BoN> handler <EoN> . <BoN> tensors to item <EoN> ( <BoN> keys to tensors <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> outputs <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert All Less Equal <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> comparison target <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> = <BoN> self <EoN> . <BoN> GetNdArray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> assert Less Equal <EoN> ( <BoN> np <EoN> . <BoN> max <EoN> ( <BoN> a <EoN> ) , <BoN> comparison target <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> read pickle <EoN> ( <BoN> path <EoN> , <BoN> compression <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> path <EoN> = <BoN> stringify path <EoN> ( <BoN> path <EoN> ) <NEWLINE> <BoN> inferred compression <EoN> = <BoN> infer compression <EoN> ( <BoN> path <EoN> , <BoN> compression <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> read wrapper <EoN> ( <BoN> func <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> f <EoN> , <BoN> fh <EoN> = <BoN> get handle <EoN> ( <BoN> path <EoN> , <STRING> , <NEWLINE> <BoN> compression <EoN> = <BoN> inferred compression <EoN> , <NEWLINE> <BoN> is text <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> func <EoN> ( <BoN> f <EoN> ) <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> f <EoN> <BoN> in <EoN> <BoN> fh <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> def <EoN> <BoN> try read <EoN> ( <BoN> path <EoN> , <BoN> encoding <EoN> = <BoN> None <EoN> ) : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> warnings <EoN> . <BoN> catch warnings <EoN> ( <BoN> record <EoN> = <BoN> True <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <BoN> read wrapper <EoN> ( <BoN> lambda <EoN> <BoN> f <EoN> : <BoN> pkl <EoN> . <BoN> load <EoN> ( <BoN> f <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> read wrapper <EoN> ( <NEWLINE> <BoN> lambda <EoN> <BoN> f <EoN> : <BoN> pc <EoN> . <BoN> load <EoN> ( <BoN> f <EoN> , <BoN> encoding <EoN> = <BoN> encoding <EoN> , <BoN> compat <EoN> = <BoN> False <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> read wrapper <EoN> ( <NEWLINE> <BoN> lambda <EoN> <BoN> f <EoN> : <BoN> pc <EoN> . <BoN> load <EoN> ( <BoN> f <EoN> , <BoN> encoding <EoN> = <BoN> encoding <EoN> , <BoN> compat <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> try read <EoN> ( <BoN> path <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> P Y 3 <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> try read <EoN> ( <BoN> path <EoN> , <BoN> encoding <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> raise <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> checked Thread <EoN> ( <BoN> self <EoN> , <BoN> target <EoN> , <BoN> args <EoN> = <BoN> None <EoN> , <BoN> kwargs <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ret <EoN> = <BoN> Tensor Flow Test Case <EoN> . <BoN> CheckedThread <EoN> ( <BoN> self <EoN> , <BoN> target <EoN> , <BoN> args <EoN> , <BoN> kwargs <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> threads <EoN> . <BoN> append <EoN> ( <BoN> ret <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> ret <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get feed dict fn <EoN> ( <BoN> self <EoN> , <BoN> input placeholder <EoN> , <BoN> output placeholder <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> feed dict fn <EoN> ( ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> sample <EoN> = <BoN> self <EoN> . <BoN> df <EoN> . <BoN> random split <EoN> ( <NEWLINE> [ <BoN> self <EoN> . <BoN> sample fraction <EoN> , <NUMBER> - <BoN> self <EoN> . <BoN> sample fraction <EoN> ] , <NEWLINE> <BoN> random state <EoN> = <BoN> self <EoN> . <BoN> random state <EoN> ) <NEWLINE> <BoN> inp <EoN> = <BoN> extract pandas matrix <EoN> ( <BoN> sample <EoN> [ <NUMBER> ] [ <BoN> self <EoN> . <BoN> x columns <EoN> ] . <BoN> compute <EoN> ( ) ) . <BoN> tolist <EoN> ( ) <NEWLINE> <BoN> out <EoN> = <BoN> extract pandas matrix <EoN> ( <BoN> sample <EoN> [ <NUMBER> ] [ <BoN> self <EoN> . <BoN> y columns <EoN> ] . <BoN> compute <EoN> ( ) ) <NEWLINE> <NEWLINE> <BoN> inp <EoN> = <BoN> np <EoN> . <BoN> array <EoN> ( <BoN> inp <EoN> , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> input dtype <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> HAS PANDAS <EoN> : <NEWLINE> <TAB> <BoN> import <EoN> <BoN> pandas <EoN> <BoN> as <EoN> <BoN> pd <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> out <EoN> , <BoN> pd <EoN> . <BoN> Series <EoN> ) : <NEWLINE> <TAB> <BoN> out <EoN> = <BoN> out <EoN> . <BoN> flatten <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> out max <EoN> = <BoN> self <EoN> . <BoN> y <EoN> . <BoN> max <EoN> ( ) . <BoN> compute <EoN> ( ) . <BoN> values <EoN> [ <NUMBER> ] <NEWLINE> <BoN> encoded out <EoN> = <BoN> np <EoN> . <BoN> zeros <EoN> ( ( <BoN> out <EoN> . <BoN> size <EoN> , <BoN> out max <EoN> + <NUMBER> ) , <BoN> dtype <EoN> = <BoN> self <EoN> . <BoN> output dtype <EoN> ) <NEWLINE> <BoN> encoded out <EoN> [ <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> out <EoN> . <BoN> size <EoN> ) , <BoN> out <EoN> ] = <NUMBER> <NEWLINE> <BoN> return <EoN> { <BoN> input placeholder <EoN> . <BoN> name <EoN> : <BoN> inp <EoN> , <BoN> output placeholder <EoN> . <BoN> name <EoN> : <BoN> encoded out <EoN> } <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> feed dict fn <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> check imgnum <EoN> ( <BoN> self <EoN> , <BoN> n <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> num <EoN> = <BoN> self <EoN> . <BoN> numframes <EoN> <NEWLINE> <BoN> if <EoN> - <BoN> num <EoN> <= <BoN> n <EoN> < <BoN> num <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> n <EoN> % <BoN> num <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Index Error <EoN> ( <STRING> <NEWLINE> % <BoN> num <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> relu <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> y <EoN> , = <BoN> Re L U <EoN> ( ) . <BoN> apply <EoN> ( ( <BoN> x <EoN> , ) ) <NEWLINE> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> clip <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> a min <EoN> = <BoN> Null <EoN> , <BoN> a max <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> connect <EoN> ( <BoN> self <EoN> , <BoN> dbapi connection <EoN> , <BoN> connection record <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write expansion fields <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> write <EoN> ( <BoN> pad bytes <EoN> ( <STRING> , <NUMBER> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fgraph updated vars <EoN> ( <BoN> fgraph <EoN> , <BoN> expanded inputs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> updated vars <EoN> = { } <NEWLINE> <BoN> potential values <EoN> = <BoN> list <EoN> ( <BoN> fgraph <EoN> . <BoN> outputs <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> expanded inputs <EoN> ) != <BoN> len <EoN> ( <BoN> fgraph <EoN> . <BoN> inputs <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> e input <EoN> , <BoN> ivar <EoN> <BoN> in <EoN> <BoN> reversed <EoN> ( <BoN> list <EoN> ( <BoN> zip <EoN> ( <BoN> expanded inputs <EoN> , <BoN> fgraph <EoN> . <BoN> inputs <EoN> ) ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> e input <EoN> . <BoN> update <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> updated vars <EoN> [ <BoN> ivar <EoN> ] = <BoN> potential values <EoN> . <BoN> pop <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> updated vars <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> first connect <EoN> ( <BoN> self <EoN> , <BoN> dbapi con <EoN> , <BoN> con record <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> syntactic feasibility <EoN> ( <BoN> self <EoN> , <BoN> G 1 node <EoN> , <BoN> G 2 node <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> . <BoN> number of edges <EoN> ( <BoN> G 1 node <EoN> , <BoN> G 1 node <EoN> ) != <BoN> self <EoN> . <BoN> G 2 <EoN> . <BoN> number of edges <EoN> ( <BoN> G 2 node <EoN> , <BoN> G 2 node <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> [ <BoN> G 1 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> core 1 <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> self <EoN> . <BoN> core 1 <EoN> [ <BoN> neighbor <EoN> ] <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 2 <EoN> [ <BoN> G 2 node <EoN> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> . <BoN> number of edges <EoN> ( <BoN> neighbor <EoN> , <BoN> G 1 node <EoN> ) != <BoN> self <EoN> . <BoN> G 2 <EoN> . <BoN> number of edges <EoN> ( <BoN> self <EoN> . <BoN> core 1 <EoN> [ <BoN> neighbor <EoN> ] , <BoN> G 2 node <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 2 <EoN> [ <BoN> G 2 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> core 2 <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> self <EoN> . <BoN> core 2 <EoN> [ <BoN> neighbor <EoN> ] <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> [ <BoN> G 1 node <EoN> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> . <BoN> number of edges <EoN> ( <BoN> self <EoN> . <BoN> core 2 <EoN> [ <BoN> neighbor <EoN> ] , <BoN> G 1 node <EoN> ) != <BoN> self <EoN> . <BoN> G 2 <EoN> . <BoN> number of edges <EoN> ( <BoN> neighbor <EoN> , <BoN> G 2 node <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> num 1 <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> [ <BoN> G 1 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inout 1 <EoN> ) <BoN> and <EoN> ( <BoN> neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> core 1 <EoN> ) : <NEWLINE> <TAB> <BoN> num 1 <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> num 2 <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 2 <EoN> [ <BoN> G 2 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inout 2 <EoN> ) <BoN> and <EoN> ( <BoN> neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> core 2 <EoN> ) : <NEWLINE> <TAB> <BoN> num 2 <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> test <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> num 1 <EoN> == <BoN> num 2 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> num 1 <EoN> >= <BoN> num 2 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> num 1 <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 1 <EoN> [ <BoN> G 1 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inout 1 <EoN> : <NEWLINE> <TAB> <BoN> num 1 <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> num 2 <EoN> = <NUMBER> <NEWLINE> <BoN> for <EoN> <BoN> neighbor <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> G 2 <EoN> [ <BoN> G 2 node <EoN> ] : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> neighbor <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> inout 2 <EoN> : <NEWLINE> <TAB> <BoN> num 2 <EoN> += <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> test <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> num 1 <EoN> == <BoN> num 2 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> num 1 <EoN> >= <BoN> num 2 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> copy <EoN> ( <BoN> self <EoN> , <BoN> deep <EoN> = <BoN> True <EoN> , <BoN> mgr <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> values <EoN> = <BoN> self <EoN> . <BoN> values <EoN> <NEWLINE> <BoN> if <EoN> <BoN> deep <EoN> : <NEWLINE> <TAB> <BoN> values <EoN> = <BoN> values <EoN> . <BoN> copy <EoN> ( <BoN> deep <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> make block same class <EoN> ( <BoN> values <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> equivalence classes <EoN> ( <BoN> iterable <EoN> , <BoN> relation <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> blocks <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> y <EoN> <BoN> in <EoN> <BoN> iterable <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> for <EoN> <BoN> block <EoN> <BoN> in <EoN> <BoN> blocks <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> arbitrary element <EoN> ( <BoN> block <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> relation <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> ) : <NEWLINE> <TAB> <BoN> block <EoN> . <BoN> append <EoN> ( <BoN> y <EoN> ) <NEWLINE> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> blocks <EoN> . <BoN> append <EoN> ( [ <BoN> y <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> { <BoN> frozenset <EoN> ( <BoN> block <EoN> ) <BoN> for <EoN> <BoN> block <EoN> <BoN> in <EoN> <BoN> blocks <EoN> } <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> assert False <EoN> ( <BoN> self <EoN> , <BoN> expr <EoN> , <BoN> msg <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> expr <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <BoN> self <EoN> . <BoN> formatMessage <EoN> ( <BoN> msg <EoN> , <STRING> % <BoN> safe repr <EoN> ( <BoN> expr <EoN> ) ) <NEWLINE> <BoN> raise <EoN> <BoN> self <EoN> . <BoN> failure Exception <EoN> ( <BoN> msg <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> hash from ndarray <EoN> ( <BoN> data <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> data <EoN> . <BoN> flags <EoN> [ <STRING> ] : <NEWLINE> <NEWLINE> <TAB> <BoN> data <EoN> = <BoN> np <EoN> . <BoN> ascontiguousarray <EoN> ( <BoN> data <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> hash from code <EoN> ( <BoN> hash from code <EoN> ( <BoN> data <EoN> ) + <NEWLINE> <BoN> hash from code <EoN> ( <BoN> str <EoN> ( <BoN> data <EoN> . <BoN> shape <EoN> ) ) + <NEWLINE> <BoN> hash from code <EoN> ( <BoN> str <EoN> ( <BoN> data <EoN> . <BoN> strides <EoN> ) ) + <NEWLINE> <BoN> hash from code <EoN> ( <BoN> str <EoN> ( <BoN> data <EoN> . <BoN> dtype <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> solve <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> a <EoN> , <BoN> <EoN> = <BoN> makearray <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> assertRankAtLeast 2 <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> assertNdSquareness <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> b <EoN> , <BoN> wrap <EoN> = <BoN> makearray <EoN> ( <BoN> b <EoN> ) <NEWLINE> <BoN> t <EoN> , <BoN> result t <EoN> = <BoN> commonType <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> b <EoN> . <BoN> ndim <EoN> == <BoN> a <EoN> . <BoN> ndim <EoN> - <NUMBER> : <NEWLINE> <TAB> <BoN> gufunc <EoN> = <BoN> umath linalg <EoN> . <BoN> solve 1 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> gufunc <EoN> = <BoN> umath linalg <EoN> . <BoN> solve <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> signature <EoN> = <STRING> <BoN> if <EoN> <BoN> is Complex Type <EoN> ( <BoN> t <EoN> ) <BoN> else <EoN> <STRING> <NEWLINE> <BoN> extobj <EoN> = <BoN> get linalg error extobj <EoN> ( <BoN> raise linalgerror singular <EoN> ) <NEWLINE> <BoN> r <EoN> = <BoN> gufunc <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> signature <EoN> = <BoN> signature <EoN> , <BoN> extobj <EoN> = <BoN> extobj <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> wrap <EoN> ( <BoN> r <EoN> . <BoN> astype <EoN> ( <BoN> result t <EoN> , <BoN> copy <EoN> = <BoN> False <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set url <EoN> ( <BoN> self <EoN> , <BoN> url <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> url <EoN> = <BoN> url <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> homogeneous order <EoN> ( <BoN> f <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> . <BoN> is zero <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> - <BoN> oo <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> monoms <EoN> = <BoN> f <EoN> . <BoN> monoms <EoN> ( ) <NEWLINE> <BoN> tdeg <EoN> = <BoN> sum <EoN> ( <BoN> monoms <EoN> [ <NUMBER> ] ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> monom <EoN> <BoN> in <EoN> <BoN> monoms <EoN> : <NEWLINE> <TAB> <BoN> tdeg <EoN> = <BoN> sum <EoN> ( <BoN> monom <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> tdeg <EoN> != <BoN> tdeg <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> tdeg <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set capstyle <EoN> ( <BoN> self <EoN> , <BoN> cs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> cs <EoN> <BoN> in <EoN> ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> capstyle <EoN> = <BoN> cs <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <BoN> cs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> shuffle <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> canonical weight shape <EoN> ( <BoN> self <EoN> , <BoN> layer <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> layer <EoN> < <NUMBER> <BoN> or <EoN> <BoN> layer <EoN> >= <BoN> self <EoN> . <BoN> num layers <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> % <NEWLINE> ( <BoN> layer <EoN> , <NUMBER> , <BoN> self <EoN> . <BoN> num layers <EoN> - <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> input size <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <NEWLINE> <STRING> % <NEWLINE> <BoN> type <EoN> ( <BoN> self <EoN> ) . <BoN> name <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> input size <EoN> = <BoN> self <EoN> . <BoN> input size <EoN> <NEWLINE> <BoN> num units <EoN> = <BoN> self <EoN> . <BoN> num units <EoN> <NEWLINE> <BoN> num gates <EoN> = <BoN> self <EoN> . <BoN> num params per layer <EoN> // <NUMBER> <NEWLINE> <BoN> is bidi <EoN> = <BoN> self <EoN> . <BoN> direction <EoN> == <BoN> CUDNN RNN BIDIRECTION <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> layer <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> wts applied on inputs <EoN> = [ ( <BoN> num units <EoN> , <BoN> input size <EoN> ) ] * <BoN> num gates <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> is bidi <EoN> : <NEWLINE> <TAB> <BoN> wts applied on inputs <EoN> = [ ( <BoN> num units <EoN> , <NUMBER> * <BoN> num units <EoN> ) ] * <BoN> num gates <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> wts applied on inputs <EoN> = [ ( <BoN> num units <EoN> , <BoN> num units <EoN> ) ] * <BoN> num gates <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> wts applied on hidden states <EoN> = [ ( <BoN> num units <EoN> , <BoN> num units <EoN> ) ] * <BoN> num gates <EoN> <NEWLINE> <BoN> tf wts <EoN> = <BoN> wts applied on inputs <EoN> + <BoN> wts applied on hidden states <EoN> <NEWLINE> <BoN> return <EoN> <BoN> tf wts <EoN> <BoN> if <EoN> <BoN> not <EoN> <BoN> is bidi <EoN> <BoN> else <EoN> <BoN> tf wts <EoN> * <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> verify <EoN> ( <BoN> model <EoN> , <BoN> args <EoN> , <BoN> loss fn <EoN> = <BoN> torch <EoN> . <BoN> sum <EoN> , <BoN> devices <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> model <EoN> , <BoN> torch <EoN> . <BoN> C <EoN> . <BoN> Compiled Function <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> is module <EoN> = <BoN> isinstance <EoN> ( <BoN> model <EoN> , <BoN> Module <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> args <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> args <EoN> = ( <BoN> args <EoN> , ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> saved args <EoN> = <BoN> clone inputs <EoN> ( <BoN> args <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> is module <EoN> : <NEWLINE> <TAB> <BoN> saved state <EoN> = <BoN> copy <EoN> . <BoN> deepcopy <EoN> ( <BoN> model <EoN> . <BoN> state dict <EoN> ( ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> run fwd bwd <EoN> ( <BoN> args <EoN> , <BoN> force trace <EoN> = <BoN> False <EoN> , <BoN> assert compiled <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <BoN> params <EoN> = <BoN> list <EoN> ( <BoN> model <EoN> . <BoN> parameters <EoN> ( ) ) <BoN> if <EoN> <BoN> is module <EoN> <BoN> else <EoN> [ ] <NEWLINE> <BoN> in vars <EoN> , <BoN> <EoN> = <BoN> flatten <EoN> ( ( <BoN> args <EoN> , <BoN> params <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> compiled fn <EoN> = <BoN> model <EoN> <NEWLINE> <BoN> if <EoN> <BoN> force trace <EoN> : <NEWLINE> <TAB> <BoN> compiled fn <EoN> . <BoN> clear cache <EoN> ( ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> assert compiled <EoN> : <NEWLINE> <TAB> <BoN> hits <EoN> = <BoN> compiled fn <EoN> . <BoN> hits <EoN> <NEWLINE> <UNTAB> <BoN> out <EoN> = <BoN> model <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> assert compiled <EoN> <BoN> and <EoN> <BoN> compiled fn <EoN> . <BoN> hits <EoN> == <BoN> hits <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Runtime Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> out <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> out <EoN> = ( <BoN> out <EoN> , ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> loss fn <EoN> == <BoN> torch <EoN> . <BoN> sum <EoN> <BoN> and <EoN> <BoN> len <EoN> ( <BoN> out <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( ( <STRING> <NEWLINE> <STRING> ) . <BoN> format <EoN> ( <BoN> len <EoN> ( <BoN> out <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> out vars <EoN> , <BoN> <EoN> = <BoN> flatten <EoN> ( <BoN> out <EoN> ) <NEWLINE> <BoN> saved outs <EoN> = [ <BoN> v <EoN> . <BoN> data <EoN> . <BoN> clone <EoN> ( ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> out vars <EoN> ] <NEWLINE> <BoN> loss <EoN> = <BoN> loss fn <EoN> ( * <BoN> out <EoN> ) <NEWLINE> <BoN> grads <EoN> = <BoN> torch <EoN> . <BoN> autograd <EoN> . <BoN> grad <EoN> ( [ <BoN> loss <EoN> ] , <BoN> in vars <EoN> ) <NEWLINE> <NEWLINE> <BoN> saved grads <EoN> = [ <BoN> v <EoN> . <BoN> data <EoN> . <BoN> clone <EoN> ( ) <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> grads <EoN> ] <NEWLINE> <BoN> return <EoN> ( <BoN> saved outs <EoN> , <BoN> saved grads <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> torch <EoN> . <BoN> random <EoN> . <BoN> fork rng <EoN> ( <BoN> devices <EoN> , <BoN> caller <EoN> = <STRING> ) : <NEWLINE> <TAB> <BoN> uncompiled outs <EoN> , <BoN> uncompiled grads <EoN> = <BoN> run fwd bwd <EoN> ( <BoN> args <EoN> , <BoN> force trace <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> assert <EoN> <BoN> model <EoN> . <BoN> has trace for <EoN> ( * <BoN> args <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> is module <EoN> : <NEWLINE> <TAB> <BoN> model <EoN> . <BoN> load state dict <EoN> ( <BoN> saved state <EoN> ) <NEWLINE> <UNTAB> <BoN> compiled outs <EoN> , <BoN> compiled grads <EoN> = <BoN> run fwd bwd <EoN> ( <BoN> args <EoN> , <BoN> assert compiled <EoN> = <BoN> True <EoN> ) <NEWLINE> <NEWLINE> <BoN> verify equal <EoN> ( <BoN> uncompiled outs <EoN> , <BoN> compiled outs <EoN> ) <NEWLINE> <BoN> verify equal <EoN> ( <BoN> uncompiled grads <EoN> , <BoN> compiled grads <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> get roots <EoN> ( <BoN> cls <EoN> , <BoN> method <EoN> , <BoN> poly <EoN> , <BoN> radicals <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> poly <EoN> . <BoN> is univariate <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Polynomial Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> coeff <EoN> , <BoN> poly <EoN> = <BoN> cls <EoN> . <BoN> preprocess roots <EoN> ( <BoN> poly <EoN> ) <NEWLINE> <BoN> roots <EoN> = [ ] <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> root <EoN> <BoN> in <EoN> <BoN> getattr <EoN> ( <BoN> cls <EoN> , <BoN> method <EoN> ) ( <BoN> poly <EoN> ) : <NEWLINE> <TAB> <BoN> roots <EoN> . <BoN> append <EoN> ( <BoN> coeff <EoN> * <BoN> cls <EoN> . <BoN> postprocess root <EoN> ( <BoN> root <EoN> , <BoN> radicals <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> roots <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is lexsorted <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> lexsort depth <EoN> == <BoN> self <EoN> . <BoN> nlevels <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> seekable <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> readable <EoN> ( ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> fp <EoN> . <BoN> seekable <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> is square <EoN> ( <BoN> n <EoN> , <BoN> prep <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> prep <EoN> : <NEWLINE> <TAB> <BoN> n <EoN> = <BoN> as int <EoN> ( <BoN> n <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> <BoN> in <EoN> [ <NUMBER> , <NUMBER> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> m <EoN> = <BoN> n <EoN> & <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( ( <BoN> m <EoN> * <NUMBER> ) & ( <BoN> m <EoN> * <NUMBER> ) & <NUMBER> ) : <NEWLINE> <TAB> <BoN> m <EoN> = <BoN> n <EoN> % <NUMBER> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( ( <BoN> m <EoN> * <NUMBER> ) & ( <BoN> m <EoN> * <NUMBER> ) & <NUMBER> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> ntheory <EoN> <BoN> import <EoN> <BoN> perfect power <EoN> <NEWLINE> <BoN> if <EoN> <BoN> perfect power <EoN> ( <BoN> n <EoN> , [ <NUMBER> ] ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> execute <EoN> ( <BoN> self <EoN> , <BoN> statement <EoN> , * <BoN> multiparams <EoN> , ** <BoN> params <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> connection <EoN> = <BoN> self <EoN> . <BoN> contextual connect <EoN> ( <BoN> close with result <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> connection <EoN> . <BoN> execute <EoN> ( <BoN> statement <EoN> , * <BoN> multiparams <EoN> , ** <BoN> params <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> len <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> inputs <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> Add <EoN> ( ** <BoN> kwargs <EoN> ) ( <BoN> inputs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> convert <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> kwargs <EoN> [ <STRING> ] = <BoN> False <EoN> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> apply <EoN> ( <STRING> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> encode data <EoN> ( <BoN> self <EoN> , <BoN> data <EoN> , <BoN> attributes <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> current row <EoN> = <NUMBER> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> inst <EoN> <BoN> in <EoN> <BoN> data <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> inst <EoN> ) != <BoN> len <EoN> ( <BoN> attributes <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Bad Object <EoN> ( <NEWLINE> <STRING> % <NEWLINE> ( <BoN> current row <EoN> , <BoN> len <EoN> ( <BoN> inst <EoN> ) , <BoN> len <EoN> ( <BoN> attributes <EoN> ) ) <NEWLINE> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> new data <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> value <EoN> <BoN> in <EoN> <BoN> inst <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> value <EoN> <BoN> is <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> value <EoN> == <STRING> <BoN> or <EoN> <BoN> value <EoN> != <BoN> value <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <STRING> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> encode string <EoN> ( <BoN> unicode <EoN> ( <BoN> value <EoN> ) ) <NEWLINE> <UNTAB> <BoN> new data <EoN> . <BoN> append <EoN> ( <BoN> s <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> current row <EoN> += <NUMBER> <NEWLINE> <BoN> yield <EoN> <STRING> . <BoN> join <EoN> ( <BoN> new data <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> jacobi normalized <EoN> ( <BoN> n <EoN> , <BoN> a <EoN> , <BoN> b <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> nfactor <EoN> = ( <BoN> S <EoN> ( <NUMBER> ) ** ( <BoN> a <EoN> + <BoN> b <EoN> + <NUMBER> ) * ( <BoN> gamma <EoN> ( <BoN> n <EoN> + <BoN> a <EoN> + <NUMBER> ) * <BoN> gamma <EoN> ( <BoN> n <EoN> + <BoN> b <EoN> + <NUMBER> ) ) <NEWLINE> / ( <NUMBER> * <BoN> n <EoN> + <BoN> a <EoN> + <BoN> b <EoN> + <NUMBER> ) / ( <BoN> factorial <EoN> ( <BoN> n <EoN> ) * <BoN> gamma <EoN> ( <BoN> n <EoN> + <BoN> a <EoN> + <BoN> b <EoN> + <NUMBER> ) ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> jacobi <EoN> ( <BoN> n <EoN> , <BoN> a <EoN> , <BoN> b <EoN> , <BoN> x <EoN> ) / <BoN> sqrt <EoN> ( <BoN> nfactor <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> mul <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> lev <EoN> , <BoN> dom <EoN> , <BoN> per <EoN> , <BoN> F <EoN> , <BoN> G <EoN> = <BoN> f <EoN> . <BoN> unify <EoN> ( <BoN> g <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> per <EoN> ( <BoN> dmp mul <EoN> ( <BoN> F <EoN> , <BoN> G <EoN> , <BoN> lev <EoN> , <BoN> dom <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> signm <EoN> ( <BoN> A <EoN> , <BoN> disp <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> A <EoN> = <BoN> asarray square <EoN> ( <BoN> A <EoN> ) <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> rounded sign <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> rx <EoN> = <BoN> np <EoN> . <BoN> real <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> rx <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> c <EoN> = <NUMBER> * <BoN> feps <EoN> * <BoN> amax <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> c <EoN> = <NUMBER> * <BoN> eps <EoN> * <BoN> amax <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> sign <EoN> ( ( <BoN> absolute <EoN> ( <BoN> rx <EoN> ) > <BoN> c <EoN> ) * <BoN> rx <EoN> ) <NEWLINE> <UNTAB> <BoN> result <EoN> , <BoN> errest <EoN> = <BoN> funm <EoN> ( <BoN> A <EoN> , <BoN> rounded sign <EoN> , <BoN> disp <EoN> = <NUMBER> ) <NEWLINE> <BoN> errtol <EoN> = { <NUMBER> : <NUMBER> * <BoN> feps <EoN> , <NUMBER> : <NUMBER> * <BoN> eps <EoN> } [ <BoN> array precision <EoN> [ <BoN> result <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> ] ] <NEWLINE> <BoN> if <EoN> <BoN> errest <EoN> < <BoN> errtol <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> vals <EoN> = <BoN> svd <EoN> ( <BoN> A <EoN> , <BoN> compute uv <EoN> = <NUMBER> ) <NEWLINE> <BoN> max sv <EoN> = <BoN> np <EoN> . <BoN> amax <EoN> ( <BoN> vals <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> c <EoN> = <NUMBER> / <BoN> max sv <EoN> <NEWLINE> <BoN> S 0 <EoN> = <BoN> A <EoN> + <BoN> c <EoN> * <BoN> np <EoN> . <BoN> identity <EoN> ( <BoN> A <EoN> . <BoN> shape <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> prev errest <EoN> = <BoN> errest <EoN> <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> ) : <NEWLINE> <TAB> <BoN> i S 0 <EoN> = <BoN> inv <EoN> ( <BoN> S 0 <EoN> ) <NEWLINE> <BoN> S 0 <EoN> = <NUMBER> * ( <BoN> S 0 <EoN> + <BoN> i S 0 <EoN> ) <NEWLINE> <BoN> Pp <EoN> = <NUMBER> * ( <BoN> dot <EoN> ( <BoN> S 0 <EoN> , <BoN> S 0 <EoN> ) + <BoN> S 0 <EoN> ) <NEWLINE> <BoN> errest <EoN> = <BoN> norm <EoN> ( <BoN> dot <EoN> ( <BoN> Pp <EoN> , <BoN> Pp <EoN> ) - <BoN> Pp <EoN> , <NUMBER> ) <NEWLINE> <BoN> if <EoN> <BoN> errest <EoN> < <BoN> errtol <EoN> <BoN> or <EoN> <BoN> prev errest <EoN> == <BoN> errest <EoN> : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <BoN> prev errest <EoN> = <BoN> errest <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> disp <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isfinite <EoN> ( <BoN> errest <EoN> ) <BoN> or <EoN> <BoN> errest <EoN> >= <BoN> errtol <EoN> : <NEWLINE> <TAB> <BoN> print <EoN> ( <STRING> , <BoN> errest <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> S 0 <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S 0 <EoN> , <BoN> errest <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set navigate <EoN> ( <BoN> self <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> navigate <EoN> = <BoN> b <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arcsinh <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> instancecheck <EoN> ( <BoN> cls <EoN> , <BoN> instance <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> subclass <EoN> = <BoN> instance <EoN> . <BoN> class <EoN> <NEWLINE> <BoN> if <EoN> <BoN> subclass <EoN> <BoN> in <EoN> <BoN> cls <EoN> . <BoN> abc cache <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> subtype <EoN> = <BoN> type <EoN> ( <BoN> instance <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> subtype <EoN> <BoN> is <EoN> <BoN> subclass <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> ( <BoN> cls <EoN> . <BoN> abc negative cache version <EoN> == <NEWLINE> <BoN> ABC Meta <EoN> . <BoN> abc invalidation counter <EoN> <BoN> and <EoN> <NEWLINE> <BoN> subclass <EoN> <BoN> in <EoN> <BoN> cls <EoN> . <BoN> abc negative cache <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> cls <EoN> . <BoN> subclasscheck <EoN> ( <BoN> subclass <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> any <EoN> ( <BoN> cls <EoN> . <BoN> subclasscheck <EoN> ( <BoN> c <EoN> ) <BoN> for <EoN> <BoN> c <EoN> <BoN> in <EoN> { <BoN> subclass <EoN> , <BoN> subtype <EoN> } ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> coshm <EoN> ( <BoN> A <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> A <EoN> = <BoN> asarray square <EoN> ( <BoN> A <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> maybe real <EoN> ( <BoN> A <EoN> , <NUMBER> * ( <BoN> expm <EoN> ( <BoN> A <EoN> ) + <BoN> expm <EoN> ( - <BoN> A <EoN> ) ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> trace <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> rows <EoN> == <BoN> self <EoN> . <BoN> cols <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Non Square Matrix Error <EoN> ( ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> eval trace <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> shuffle <EoN> ( <BoN> data <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> internal <EoN> . <BoN> shuffle <EoN> ( <BoN> data <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sin <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> math to image <EoN> ( <BoN> s <EoN> , <BoN> filename or obj <EoN> , <BoN> prop <EoN> = <BoN> None <EoN> , <BoN> dpi <EoN> = <BoN> None <EoN> , <BoN> format <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> matplotlib <EoN> <BoN> import <EoN> <BoN> figure <EoN> <NEWLINE> <NEWLINE> <BoN> from <EoN> <BoN> matplotlib <EoN> . <BoN> backends <EoN> <BoN> import <EoN> <BoN> backend agg <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> prop <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> prop <EoN> = <BoN> Font Properties <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> parser <EoN> = <BoN> Math Text Parser <EoN> ( <STRING> ) <NEWLINE> <BoN> width <EoN> , <BoN> height <EoN> , <BoN> depth <EoN> , <BoN> <EoN> , <BoN> <EoN> = <BoN> parser <EoN> . <BoN> parse <EoN> ( <BoN> s <EoN> , <BoN> dpi <EoN> = <NUMBER> , <BoN> prop <EoN> = <BoN> prop <EoN> ) <NEWLINE> <NEWLINE> <BoN> fig <EoN> = <BoN> figure <EoN> . <BoN> Figure <EoN> ( <BoN> figsize <EoN> = ( <BoN> width <EoN> / <NUMBER> , <BoN> height <EoN> / <NUMBER> ) ) <NEWLINE> <BoN> fig <EoN> . <BoN> text <EoN> ( <NUMBER> , <BoN> depth <EoN> / <BoN> height <EoN> , <BoN> s <EoN> , <BoN> fontproperties <EoN> = <BoN> prop <EoN> ) <NEWLINE> <BoN> backend agg <EoN> . <BoN> Figure Canvas Agg <EoN> ( <BoN> fig <EoN> ) <NEWLINE> <BoN> fig <EoN> . <BoN> savefig <EoN> ( <BoN> filename or obj <EoN> , <BoN> dpi <EoN> = <BoN> dpi <EoN> , <BoN> format <EoN> = <BoN> format <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> depth <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> staticmethod <EoN> <NEWLINE> @ <BoN> cacheit <EoN> <NEWLINE> <BoN> def <EoN> <BoN> taylor term <EoN> ( <BoN> n <EoN> , <BoN> x <EoN> , * <BoN> previous terms <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> < <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> S <EoN> . <BoN> One <EoN> <NEWLINE> <UNTAB> <BoN> x <EoN> = <BoN> sympify <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> previous terms <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> = <BoN> previous terms <EoN> [ - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> p <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> p <EoN> * <BoN> x <EoN> / <BoN> n <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> ** <BoN> n <EoN> / <BoN> factorial <EoN> ( <BoN> n <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> local conv 2 d <EoN> ( <BoN> inputs <EoN> , <BoN> kernel <EoN> , <BoN> kernel size <EoN> , <BoN> strides <EoN> , <BoN> output shape <EoN> , <BoN> data format <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> data format <EoN> = <BoN> normalize data format <EoN> ( <BoN> data format <EoN> ) <NEWLINE> <NEWLINE> <BoN> stride row <EoN> , <BoN> stride col <EoN> = <BoN> strides <EoN> <NEWLINE> <BoN> output row <EoN> , <BoN> output col <EoN> = <BoN> output shape <EoN> <NEWLINE> <BoN> kernel shape <EoN> = <BoN> int shape <EoN> ( <BoN> kernel <EoN> ) <NEWLINE> <BoN> <EoN> , <BoN> feature dim <EoN> , <BoN> filters <EoN> = <BoN> kernel shape <EoN> <NEWLINE> <NEWLINE> <BoN> xs <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> output row <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> output col <EoN> ) : <NEWLINE> <TAB> <BoN> slice row <EoN> = <BoN> py slice <EoN> ( <BoN> i <EoN> * <BoN> stride row <EoN> , <NEWLINE> <BoN> i <EoN> * <BoN> stride row <EoN> + <BoN> kernel size <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> slice col <EoN> = <BoN> py slice <EoN> ( <BoN> j <EoN> * <BoN> stride col <EoN> , <NEWLINE> <BoN> j <EoN> * <BoN> stride col <EoN> + <BoN> kernel size <EoN> [ <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> data format <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> xs <EoN> . <BoN> append <EoN> ( <BoN> reshape <EoN> ( <BoN> inputs <EoN> [ : , : , <BoN> slice row <EoN> , <BoN> slice col <EoN> ] , <NEWLINE> ( <NUMBER> , - <NUMBER> , <BoN> feature dim <EoN> ) ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> xs <EoN> . <BoN> append <EoN> ( <BoN> reshape <EoN> ( <BoN> inputs <EoN> [ : , <BoN> slice row <EoN> , <BoN> slice col <EoN> , : ] , <NEWLINE> ( <NUMBER> , - <NUMBER> , <BoN> feature dim <EoN> ) ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> x aggregate <EoN> = <BoN> concatenate <EoN> ( <BoN> xs <EoN> , <BoN> axis <EoN> = <NUMBER> ) <NEWLINE> <BoN> output <EoN> = <BoN> batch dot <EoN> ( <BoN> x aggregate <EoN> , <BoN> kernel <EoN> ) <NEWLINE> <BoN> output <EoN> = <BoN> reshape <EoN> ( <BoN> output <EoN> , <NEWLINE> ( <BoN> output row <EoN> , <BoN> output col <EoN> , - <NUMBER> , <BoN> filters <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> data format <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> output <EoN> = <BoN> permute dimensions <EoN> ( <BoN> output <EoN> , ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> output <EoN> = <BoN> permute dimensions <EoN> ( <BoN> output <EoN> , ( <NUMBER> , <NUMBER> , <NUMBER> , <NUMBER> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> output <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gf multi eval <EoN> ( <BoN> f <EoN> , <BoN> A <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ <BoN> gf eval <EoN> ( <BoN> f <EoN> , <BoN> a <EoN> , <BoN> p <EoN> , <BoN> K <EoN> ) <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> A <EoN> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> number connected components <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sum <EoN> ( <NUMBER> <BoN> for <EoN> <BoN> cc <EoN> <BoN> in <EoN> <BoN> connected components <EoN> ( <BoN> G <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> predict cluster index <EoN> ( <BoN> self <EoN> , <BoN> input fn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> index <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> predict one key <EoN> ( <BoN> input fn <EoN> , <NEWLINE> <BoN> K Means Clustering <EoN> . <BoN> CLUSTER INDEX <EoN> ) : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> index <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> @ <BoN> not implemented for <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> score sequence <EoN> ( <BoN> G <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> sorted <EoN> ( <BoN> d <EoN> <BoN> for <EoN> <BoN> v <EoN> , <BoN> d <EoN> <BoN> in <EoN> <BoN> G <EoN> . <BoN> out degree <EoN> ( ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> load model <EoN> ( <BoN> filepath <EoN> , <BoN> custom objects <EoN> = <BoN> None <EoN> , <BoN> compile <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> h 5 py <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Import Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> model <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> opened new file <EoN> = <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> filepath <EoN> , <BoN> h 5 py <EoN> . <BoN> Group <EoN> ) <NEWLINE> <BoN> f <EoN> = <BoN> h 5 dict <EoN> ( <BoN> filepath <EoN> , <STRING> ) <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> model <EoN> = <BoN> deserialize model <EoN> ( <BoN> f <EoN> , <BoN> custom objects <EoN> , <BoN> compile <EoN> ) <NEWLINE> <UNTAB> <BoN> finally <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> opened new file <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> . <BoN> close <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> model <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> unique <EoN> ( <BoN> ar 1 <EoN> , <BoN> return index <EoN> = <BoN> False <EoN> , <BoN> return inverse <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> output <EoN> = <BoN> np <EoN> . <BoN> unique <EoN> ( <BoN> ar 1 <EoN> , <NEWLINE> <BoN> return index <EoN> = <BoN> return index <EoN> , <NEWLINE> <BoN> return inverse <EoN> = <BoN> return inverse <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> output <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> output <EoN> = <BoN> list <EoN> ( <BoN> output <EoN> ) <NEWLINE> <BoN> output <EoN> [ <NUMBER> ] = <BoN> output <EoN> [ <NUMBER> ] . <BoN> view <EoN> ( <BoN> Masked Array <EoN> ) <NEWLINE> <BoN> output <EoN> = <BoN> tuple <EoN> ( <BoN> output <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> output <EoN> = <BoN> output <EoN> . <BoN> view <EoN> ( <BoN> Masked Array <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> output <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as immutable <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> Immutable Properties <EoN> ( <BoN> self <EoN> . <BoN> data <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> arg min eager fallback <EoN> ( <BoN> input <EoN> , <BoN> dimension <EoN> , <BoN> output type <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> ctx <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> <BoN> if <EoN> <BoN> ctx <EoN> <BoN> else <EoN> <BoN> context <EoN> . <BoN> context <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> output type <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> output type <EoN> = <BoN> dtypes <EoN> . <BoN> int 64 <EoN> <NEWLINE> <UNTAB> <BoN> output type <EoN> = <BoN> execute <EoN> . <BoN> make type <EoN> ( <BoN> output type <EoN> , <STRING> ) <NEWLINE> <BoN> attr T <EoN> , ( <BoN> input <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> input <EoN> ] , <BoN> ctx <EoN> ) <NEWLINE> <BoN> attr Tidx <EoN> , ( <BoN> dimension <EoN> , ) = <BoN> execute <EoN> . <BoN> args to matching eager <EoN> ( [ <BoN> dimension <EoN> ] , <BoN> ctx <EoN> , <BoN> dtypes <EoN> . <BoN> int 32 <EoN> ) <NEWLINE> <BoN> inputs flat <EoN> = [ <BoN> input <EoN> , <BoN> dimension <EoN> ] <NEWLINE> <BoN> attrs <EoN> = ( <STRING> , <BoN> attr T <EoN> , <STRING> , <BoN> attr Tidx <EoN> , <STRING> , <BoN> output type <EoN> ) <NEWLINE> <BoN> result <EoN> = <BoN> execute <EoN> . <BoN> execute <EoN> ( <STRING> , <NUMBER> , <BoN> inputs <EoN> = <BoN> inputs flat <EoN> , <BoN> attrs <EoN> = <BoN> attrs <EoN> , <NEWLINE> <BoN> ctx <EoN> = <BoN> ctx <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <BoN> execute <EoN> . <BoN> record gradient <EoN> ( <NEWLINE> <STRING> , <BoN> inputs flat <EoN> , <BoN> attrs <EoN> , <BoN> result <EoN> , <BoN> name <EoN> ) <NEWLINE> <BoN> result <EoN> , = <BoN> result <EoN> <NEWLINE> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> convolution subset <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> a <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> b <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> iterable <EoN> ( <BoN> a <EoN> ) <BoN> or <EoN> <BoN> not <EoN> <BoN> iterable <EoN> ( <BoN> b <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> = [ <BoN> sympify <EoN> ( <BoN> arg <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> a <EoN> ] <NEWLINE> <BoN> b <EoN> = [ <BoN> sympify <EoN> ( <BoN> arg <EoN> ) <BoN> for <EoN> <BoN> arg <EoN> <BoN> in <EoN> <BoN> b <EoN> ] <NEWLINE> <BoN> n <EoN> = <BoN> max <EoN> ( <BoN> len <EoN> ( <BoN> a <EoN> ) , <BoN> len <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> n <EoN> & ( <BoN> n <EoN> - <NUMBER> ) : <NEWLINE> <TAB> <BoN> n <EoN> = <NUMBER> ** <BoN> n <EoN> . <BoN> bit length <EoN> ( ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> += [ <BoN> S <EoN> . <BoN> Zero <EoN> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <BoN> b <EoN> += [ <BoN> S <EoN> . <BoN> Zero <EoN> ] * ( <BoN> n <EoN> - <BoN> len <EoN> ( <BoN> b <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> c <EoN> = [ <BoN> S <EoN> . <BoN> Zero <EoN> ] * <BoN> n <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> mask <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> n <EoN> ) : <NEWLINE> <TAB> <BoN> smask <EoN> = <BoN> mask <EoN> <NEWLINE> <BoN> while <EoN> <BoN> smask <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> c <EoN> [ <BoN> mask <EoN> ] += <BoN> expand mul <EoN> ( <BoN> a <EoN> [ <BoN> smask <EoN> ] * <BoN> b <EoN> [ <BoN> mask <EoN> ^ <BoN> smask <EoN> ] ) <NEWLINE> <BoN> smask <EoN> = ( <BoN> smask <EoN> - <NUMBER> ) & <BoN> mask <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> c <EoN> [ <BoN> mask <EoN> ] += <BoN> expand mul <EoN> ( <BoN> a <EoN> [ <BoN> smask <EoN> ] * <BoN> b <EoN> [ <BoN> mask <EoN> ^ <BoN> smask <EoN> ] ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> c <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> initialized value <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> minpoly compose <EoN> ( <BoN> ex <EoN> , <BoN> x <EoN> , <BoN> dom <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> ex <EoN> . <BoN> is Rational <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ex <EoN> . <BoN> q <EoN> * <BoN> x <EoN> - <BoN> ex <EoN> . <BoN> p <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> ex <EoN> <BoN> is <EoN> <BoN> I <EoN> : <NEWLINE> <TAB> <BoN> <EoN> , <BoN> factors <EoN> = <BoN> factor list <EoN> ( <BoN> x <EoN> ** <NUMBER> + <NUMBER> , <BoN> x <EoN> , <BoN> domain <EoN> = <BoN> dom <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> ** <NUMBER> + <NUMBER> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> factors <EoN> ) == <NUMBER> <BoN> else <EoN> <BoN> x <EoN> - <BoN> I <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> hasattr <EoN> ( <BoN> dom <EoN> , <STRING> ) <BoN> and <EoN> <BoN> ex <EoN> <BoN> in <EoN> <BoN> dom <EoN> . <BoN> symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> x <EoN> - <BoN> ex <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> dom <EoN> . <BoN> is QQ <EoN> <BoN> and <EoN> <BoN> is sum surds <EoN> ( <BoN> ex <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> ex <EoN> -= <BoN> x <EoN> <NEWLINE> <BoN> while <EoN> <NUMBER> : <NEWLINE> <TAB> <BoN> ex 1 <EoN> = <BoN> separate sq <EoN> ( <BoN> ex <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ex 1 <EoN> <BoN> is <EoN> <BoN> ex <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ex <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> ex <EoN> = <BoN> ex 1 <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> ex <EoN> . <BoN> is Add <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly add <EoN> ( <BoN> x <EoN> , <BoN> dom <EoN> , * <BoN> ex <EoN> . <BoN> args <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> is Mul <EoN> : <NEWLINE> <TAB> <BoN> f <EoN> = <BoN> Factors <EoN> ( <BoN> ex <EoN> ) . <BoN> factors <EoN> <NEWLINE> <BoN> r <EoN> = <BoN> sift <EoN> ( <BoN> f <EoN> . <BoN> items <EoN> ( ) , <BoN> lambda <EoN> <BoN> itx <EoN> : <BoN> itx <EoN> [ <NUMBER> ] . <BoN> is Rational <EoN> <BoN> and <EoN> <BoN> itx <EoN> [ <NUMBER> ] . <BoN> is Rational <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> r <EoN> [ <BoN> True <EoN> ] <BoN> and <EoN> <BoN> dom <EoN> == <BoN> Q Q <EoN> : <NEWLINE> <TAB> <BoN> ex 1 <EoN> = <BoN> Mul <EoN> ( * [ <BoN> bx <EoN> ** <BoN> ex <EoN> <BoN> for <EoN> <BoN> bx <EoN> , <BoN> ex <EoN> <BoN> in <EoN> <BoN> r <EoN> [ <BoN> False <EoN> ] + <BoN> r <EoN> [ <BoN> None <EoN> ] ] ) <NEWLINE> <BoN> r 1 <EoN> = <BoN> r <EoN> [ <BoN> True <EoN> ] <NEWLINE> <BoN> dens <EoN> = [ <BoN> y <EoN> . <BoN> q <EoN> <BoN> for <EoN> <BoN> <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> r 1 <EoN> ] <NEWLINE> <BoN> lcmdens <EoN> = <BoN> reduce <EoN> ( <BoN> lcm <EoN> , <BoN> dens <EoN> , <NUMBER> ) <NEWLINE> <BoN> nums <EoN> = [ <BoN> base <EoN> ** ( <BoN> y <EoN> . <BoN> p <EoN> * <BoN> lcmdens <EoN> // <BoN> y <EoN> . <BoN> q <EoN> ) <BoN> for <EoN> <BoN> base <EoN> , <BoN> y <EoN> <BoN> in <EoN> <BoN> r 1 <EoN> ] <NEWLINE> <BoN> ex 2 <EoN> = <BoN> Mul <EoN> ( * <BoN> nums <EoN> ) <NEWLINE> <BoN> mp 1 <EoN> = <BoN> minimal polynomial <EoN> ( <BoN> ex 1 <EoN> , <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> mp 2 <EoN> = <BoN> ex 2 <EoN> . <BoN> q <EoN> * <BoN> x <EoN> ** <BoN> lcmdens <EoN> - <BoN> ex 2 <EoN> . <BoN> p <EoN> <NEWLINE> <BoN> ex 2 <EoN> = <BoN> ex 2 <EoN> ** <BoN> Rational <EoN> ( <NUMBER> , <BoN> lcmdens <EoN> ) <NEWLINE> <BoN> res <EoN> = <BoN> minpoly op algebraic element <EoN> ( <BoN> Mul <EoN> , <BoN> ex 1 <EoN> , <BoN> ex 2 <EoN> , <BoN> x <EoN> , <BoN> dom <EoN> , <BoN> mp 1 <EoN> = <BoN> mp 1 <EoN> , <BoN> mp 2 <EoN> = <BoN> mp 2 <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly mul <EoN> ( <BoN> x <EoN> , <BoN> dom <EoN> , * <BoN> ex <EoN> . <BoN> args <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> is Pow <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly pow <EoN> ( <BoN> ex <EoN> . <BoN> base <EoN> , <BoN> ex <EoN> . <BoN> exp <EoN> , <BoN> x <EoN> , <BoN> dom <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> class <EoN> <BoN> is <EoN> <BoN> sin <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly sin <EoN> ( <BoN> ex <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> class <EoN> <BoN> is <EoN> <BoN> cos <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly cos <EoN> ( <BoN> ex <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> class <EoN> <BoN> is <EoN> <BoN> exp <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly exp <EoN> ( <BoN> ex <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> ex <EoN> . <BoN> class <EoN> <BoN> is <EoN> <BoN> C Root Of <EoN> : <NEWLINE> <TAB> <BoN> res <EoN> = <BoN> minpoly rootof <EoN> ( <BoN> ex <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Not Algebraic <EoN> ( <STRING> % <BoN> ex <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> res <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> subclass <EoN> , <BoN> shape <EoN> , <BoN> order <EoN> , <BoN> dtype <EoN> , <BoN> allow mmap <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> subclass <EoN> = <BoN> subclass <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> shape <EoN> = <BoN> shape <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> order <EoN> = <BoN> order <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dtype <EoN> = <BoN> dtype <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> allow mmap <EoN> = <BoN> allow mmap <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> resize <EoN> ( <BoN> a <EoN> , <BoN> new shape <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> new shape <EoN> , ( <BoN> int <EoN> , <BoN> nt <EoN> . <BoN> integer <EoN> ) ) : <NEWLINE> <TAB> <BoN> new shape <EoN> = ( <BoN> new shape <EoN> , ) <NEWLINE> <UNTAB> <BoN> a <EoN> = <BoN> ravel <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> Na <EoN> = <BoN> len <EoN> ( <BoN> a <EoN> ) <NEWLINE> <BoN> total size <EoN> = <BoN> um <EoN> . <BoN> multiply <EoN> . <BoN> reduce <EoN> ( <BoN> new shape <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> Na <EoN> == <NUMBER> <BoN> or <EoN> <BoN> total size <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> mu <EoN> . <BoN> zeros <EoN> ( <BoN> new shape <EoN> , <BoN> a <EoN> . <BoN> dtype <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> n copies <EoN> = <BoN> int <EoN> ( <BoN> total size <EoN> / <BoN> Na <EoN> ) <NEWLINE> <BoN> extra <EoN> = <BoN> total size <EoN> % <BoN> Na <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> extra <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> n copies <EoN> = <BoN> n copies <EoN> + <NUMBER> <NEWLINE> <BoN> extra <EoN> = <BoN> Na <EoN> - <BoN> extra <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> = <BoN> concatenate <EoN> ( ( <BoN> a <EoN> , ) * <BoN> n copies <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> extra <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> a <EoN> = <BoN> a <EoN> [ : - <BoN> extra <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> reshape <EoN> ( <BoN> a <EoN> , <BoN> new shape <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> add <EoN> ( <BoN> self <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> + <BoN> b <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> to cpu <EoN> ( <BoN> array <EoN> , <BoN> stream <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> array <EoN> , ( <BoN> list <EoN> , <BoN> tuple <EoN> ) ) : <NEWLINE> <TAB> <BoN> d <EoN> = { } <NEWLINE> <BoN> ret <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> arr <EoN> <BoN> in <EoN> <BoN> array <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> arr <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> ret <EoN> . <BoN> append <EoN> ( <BoN> None <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> arr 2 <EoN> = <BoN> d <EoN> . <BoN> get <EoN> ( <BoN> id <EoN> ( <BoN> arr <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> arr 2 <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> arr 2 <EoN> = <BoN> array to cpu <EoN> ( <BoN> arr <EoN> , <BoN> stream <EoN> ) <NEWLINE> <BoN> d <EoN> [ <BoN> id <EoN> ( <BoN> arr <EoN> ) ] = <BoN> arr 2 <EoN> <NEWLINE> <UNTAB> <BoN> ret <EoN> . <BoN> append <EoN> ( <BoN> arr 2 <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> type <EoN> ( <BoN> array <EoN> ) ( <BoN> ret <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> array to cpu <EoN> ( <BoN> array <EoN> , <BoN> stream <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> chebweight <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> w <EoN> = <NUMBER> / ( <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> + <BoN> x <EoN> ) * <BoN> np <EoN> . <BoN> sqrt <EoN> ( <NUMBER> - <BoN> x <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> w <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> replace by <EoN> ( <BoN> module function <EoN> , <BoN> package <EoN> = <BoN> package <EoN> , <BoN> warn <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> importlib <EoN> <BoN> import <EoN> <BoN> import module <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Import Error <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> lambda <EoN> <BoN> func <EoN> : <BoN> func <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> decorate <EoN> ( <BoN> func <EoN> , <BoN> module function <EoN> = <BoN> module function <EoN> , <BoN> warn <EoN> = <BoN> warn <EoN> ) : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> , <BoN> function <EoN> = <BoN> module function <EoN> . <BoN> split <EoN> ( <STRING> ) <NEWLINE> <BoN> if <EoN> <BoN> package <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> = <BoN> import module <EoN> ( <STRING> + <BoN> module <EoN> , <BoN> package <EoN> = <BoN> package <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> module <EoN> = <BoN> import module <EoN> ( <BoN> module <EoN> ) <NEWLINE> <UNTAB> <BoN> func <EoN> , <BoN> oldfunc <EoN> = <BoN> getattr <EoN> ( <BoN> module <EoN> , <BoN> function <EoN> ) , <BoN> func <EoN> <NEWLINE> <BoN> globals <EoN> ( ) [ <STRING> + <BoN> func <EoN> . <BoN> name <EoN> ] = <BoN> oldfunc <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> warn <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> % <BoN> module function <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> func <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> decorate <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> leading term <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> p <EoN> = <BoN> self <EoN> . <BoN> ring <EoN> . <BoN> zero <EoN> <NEWLINE> <BoN> expv <EoN> = <BoN> self <EoN> . <BoN> leading expv <EoN> ( ) <NEWLINE> <BoN> if <EoN> <BoN> expv <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> p <EoN> [ <BoN> expv <EoN> ] = <BoN> self <EoN> [ <BoN> expv <EoN> ] <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> p <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> write image description <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> ( <BoN> not <EoN> <BoN> self <EoN> . <BoN> data shape <EoN> <BoN> or <EoN> <BoN> self <EoN> . <BoN> data shape <EoN> [ <NUMBER> ] == <NUMBER> <BoN> or <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> description offset <EoN> <= <NUMBER> ) : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> colormapped <EoN> = <BoN> self <EoN> . <BoN> colormap <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> imagej <EoN> : <NEWLINE> <TAB> <BoN> isrgb <EoN> = <BoN> self <EoN> . <BoN> shape <EoN> [ - <NUMBER> ] <BoN> in <EoN> ( <NUMBER> , <NUMBER> ) <NEWLINE> <BoN> description <EoN> = <BoN> imagej description <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> data shape <EoN> , <BoN> isrgb <EoN> , <BoN> colormapped <EoN> , ** <BoN> self <EoN> . <BoN> metadata <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> description <EoN> = <BoN> image description <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> data shape <EoN> , <BoN> colormapped <EoN> , ** <BoN> self <EoN> . <BoN> metadata <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> description <EoN> = <BoN> description <EoN> [ : <BoN> self <EoN> . <BoN> description len <EoN> - <NUMBER> ] <NEWLINE> <BoN> pos <EoN> = <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> description offset <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> write <EoN> ( <BoN> description <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> description len offset <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> write <EoN> ( <BoN> struct <EoN> . <BoN> pack <EoN> ( <BoN> self <EoN> . <BoN> byteorder <EoN> + <BoN> self <EoN> . <BoN> offset format <EoN> , <NEWLINE> <BoN> len <EoN> ( <BoN> description <EoN> ) + <NUMBER> ) ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> pos <EoN> ) <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> description offset <EoN> = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> description len offset <EoN> = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> description len <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> lagline <EoN> ( <BoN> off <EoN> , <BoN> scl <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> scl <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> off <EoN> + <BoN> scl <EoN> , - <BoN> scl <EoN> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> np <EoN> . <BoN> array <EoN> ( [ <BoN> off <EoN> ] ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> array wrap <EoN> ( <BoN> self <EoN> , <BoN> result <EoN> , <BoN> context <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> context <EoN> , <BoN> tuple <EoN> ) <BoN> and <EoN> <BoN> len <EoN> ( <BoN> context <EoN> ) > <NUMBER> : <NEWLINE> <TAB> <BoN> func <EoN> = <BoN> context <EoN> [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> ( <BoN> func <EoN> <BoN> is <EoN> <BoN> np <EoN> . <BoN> add <EoN> ) : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> ( <BoN> func <EoN> <BoN> is <EoN> <BoN> np <EoN> . <BoN> subtract <EoN> ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> <NEWLINE> <BoN> left <EoN> = <BoN> context <EoN> [ <NUMBER> ] [ <NUMBER> ] <NEWLINE> <BoN> right <EoN> = <BoN> context <EoN> [ <NUMBER> ] [ <NUMBER> ] <NEWLINE> <BoN> if <EoN> ( <BoN> isinstance <EoN> ( <BoN> left <EoN> , <BoN> Period Index <EoN> ) <BoN> and <EoN> <NEWLINE> <BoN> isinstance <EoN> ( <BoN> right <EoN> , <BoN> Period Index <EoN> ) ) : <NEWLINE> <TAB> <BoN> name <EoN> = <BoN> left <EoN> . <BoN> name <EoN> <BoN> if <EoN> <BoN> left <EoN> . <BoN> name <EoN> == <BoN> right <EoN> . <BoN> name <EoN> <BoN> else <EoN> <BoN> None <EoN> <NEWLINE> <BoN> return <EoN> <BoN> Index <EoN> ( <BoN> result <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> left <EoN> , <BoN> Period <EoN> ) <BoN> or <EoN> <BoN> isinstance <EoN> ( <BoN> right <EoN> , <BoN> Period <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Index <EoN> ( <BoN> result <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> func <EoN> , <BoN> np <EoN> . <BoN> ufunc <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <STRING> <BoN> not <EoN> <BoN> in <EoN> <BoN> func <EoN> . <BoN> types <EoN> : <NEWLINE> <TAB> <BoN> msg <EoN> = <STRING> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <BoN> msg <EoN> . <BoN> format <EoN> ( <BoN> func <EoN> . <BoN> name <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> is bool dtype <EoN> ( <BoN> result <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> shallow copy <EoN> ( <BoN> result <EoN> , <BoN> freq <EoN> = <BoN> self <EoN> . <BoN> freq <EoN> , <BoN> name <EoN> = <BoN> self <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get children <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> [ ] <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> floordiv <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> math <EoN> . <BoN> floor <EoN> ( <BoN> a <EoN> / <BoN> b <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> button press event <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> button <EoN> , <BoN> dblclick <EoN> = <BoN> False <EoN> , <BoN> gui Event <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> button <EoN> = <BoN> button <EoN> <NEWLINE> <BoN> s <EoN> = <STRING> <NEWLINE> <BoN> mouseevent <EoN> = <BoN> Mouse Event <EoN> ( <BoN> s <EoN> , <BoN> self <EoN> , <BoN> x <EoN> , <BoN> y <EoN> , <BoN> button <EoN> , <BoN> self <EoN> . <BoN> key <EoN> , <NEWLINE> <BoN> dblclick <EoN> = <BoN> dblclick <EoN> , <BoN> gui Event <EoN> = <BoN> gui Event <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> callbacks <EoN> . <BoN> process <EoN> ( <BoN> s <EoN> , <BoN> mouseevent <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> call <EoN> ( <BoN> self <EoN> , * <BoN> args <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> out <EoN> = <BoN> kwargs <EoN> . <BoN> pop <EoN> ( <STRING> , <BoN> None <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> out <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> original output <EoN> = <BoN> out <EoN> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> out <EoN> , <BoN> ND Array Base <EoN> ) : <NEWLINE> <TAB> <BoN> out <EoN> = ( <BoN> out <EoN> , ) <NEWLINE> <UNTAB> <BoN> num output <EoN> = <BoN> ctypes <EoN> . <BoN> c int <EoN> ( <BoN> len <EoN> ( <BoN> out <EoN> ) ) <NEWLINE> <BoN> output vars <EoN> = <BoN> c handle array <EoN> ( <BoN> out <EoN> ) <NEWLINE> <BoN> output vars <EoN> = <BoN> ctypes <EoN> . <BoN> cast <EoN> ( <BoN> output vars <EoN> , <BoN> ctypes <EoN> . <BoN> POINTE R <EoN> ( <BoN> ND Array Handle <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> original output <EoN> = <BoN> None <EoN> <NEWLINE> <BoN> output vars <EoN> = <BoN> ctypes <EoN> . <BoN> POINTE R <EoN> ( <BoN> ND Array Handle <EoN> ) ( ) <NEWLINE> <BoN> num output <EoN> = <BoN> ctypes <EoN> . <BoN> c int <EoN> ( <NUMBER> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> kwargs <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Type Error <EoN> ( <NEWLINE> <STRING> + <STRING> . <BoN> join <EoN> ( <BoN> kwargs <EoN> . <BoN> keys <EoN> ( ) ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> out stypes <EoN> = <BoN> ctypes <EoN> . <BoN> POINTE R <EoN> ( <BoN> ctypes <EoN> . <BoN> c int <EoN> ) ( ) <NEWLINE> <NEWLINE> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MX Invoke Cached Op Ex <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> handle <EoN> , <NEWLINE> <BoN> ctypes <EoN> . <BoN> c int <EoN> ( <BoN> len <EoN> ( <BoN> args <EoN> ) ) , <NEWLINE> <BoN> c handle array <EoN> ( <BoN> args <EoN> ) , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> num output <EoN> ) , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> output vars <EoN> ) , <NEWLINE> <BoN> ctypes <EoN> . <BoN> byref <EoN> ( <BoN> out stypes <EoN> ) ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> original output <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> original output <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> num output <EoN> . <BoN> value <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> ndarray cls <EoN> ( <BoN> ctypes <EoN> . <BoN> cast <EoN> ( <BoN> output vars <EoN> [ <NUMBER> ] , <BoN> ND Array Handle <EoN> ) , <NEWLINE> <BoN> stype <EoN> = <BoN> out stypes <EoN> [ <NUMBER> ] ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ <BoN> ndarray cls <EoN> ( <BoN> ctypes <EoN> . <BoN> cast <EoN> ( <BoN> output vars <EoN> [ <BoN> i <EoN> ] , <BoN> ND Array Handle <EoN> ) , <NEWLINE> <BoN> stype <EoN> = <BoN> out stypes <EoN> [ <BoN> i <EoN> ] ) <NEWLINE> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> num output <EoN> . <BoN> value <EoN> ) ] <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dmp exclude <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> u <EoN> <BoN> or <EoN> <BoN> dmp ground p <EoN> ( <BoN> f <EoN> , <BoN> None <EoN> , <BoN> u <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> [ ] , <BoN> f <EoN> , <BoN> u <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> J <EoN> , <BoN> F <EoN> = [ ] , <BoN> dmp to dict <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <NUMBER> , <BoN> u <EoN> + <NUMBER> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> monom <EoN> <BoN> in <EoN> <BoN> F <EoN> . <BoN> keys <EoN> ( ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> monom <EoN> [ <BoN> j <EoN> ] : <NEWLINE> <TAB> <BoN> break <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> J <EoN> . <BoN> append <EoN> ( <BoN> j <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> J <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> [ ] , <BoN> f <EoN> , <BoN> u <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> = { } <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> monom <EoN> , <BoN> coeff <EoN> <BoN> in <EoN> <BoN> F <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> monom <EoN> = <BoN> list <EoN> ( <BoN> monom <EoN> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> j <EoN> <BoN> in <EoN> <BoN> reversed <EoN> ( <BoN> J <EoN> ) : <NEWLINE> <TAB> <BoN> del <EoN> <BoN> monom <EoN> [ <BoN> j <EoN> ] <NEWLINE> <NEWLINE> <UNTAB> <BoN> f <EoN> [ <BoN> tuple <EoN> ( <BoN> monom <EoN> ) ] = <BoN> coeff <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> u <EoN> -= <BoN> len <EoN> ( <BoN> J <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> J <EoN> , <BoN> dmp from dict <EoN> ( <BoN> f <EoN> , <BoN> u <EoN> , <BoN> K <EoN> ) , <BoN> u <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> cubehelix <EoN> ( <BoN> gamma <EoN> = <NUMBER> , <BoN> s <EoN> = <NUMBER> , <BoN> r <EoN> = - <NUMBER> , <BoN> h <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> def <EoN> <BoN> get color function <EoN> ( <BoN> p 0 <EoN> , <BoN> p 1 <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> def <EoN> <BoN> color <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> xg <EoN> = <BoN> x <EoN> ** <BoN> gamma <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> a <EoN> = <BoN> h <EoN> * <BoN> xg <EoN> * ( <NUMBER> - <BoN> xg <EoN> ) / <NUMBER> <NEWLINE> <NEWLINE> <BoN> phi <EoN> = <NUMBER> * <BoN> np <EoN> . <BoN> pi <EoN> * ( <BoN> s <EoN> / <NUMBER> + <BoN> r <EoN> * <BoN> x <EoN> ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> xg <EoN> + <BoN> a <EoN> * ( <BoN> p 0 <EoN> * <BoN> np <EoN> . <BoN> cos <EoN> ( <BoN> phi <EoN> ) + <BoN> p 1 <EoN> * <BoN> np <EoN> . <BoN> sin <EoN> ( <BoN> phi <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> color <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> { <NEWLINE> <STRING> : <BoN> get color function <EoN> ( - <NUMBER> , <NUMBER> ) , <NEWLINE> <STRING> : <BoN> get color function <EoN> ( - <NUMBER> , - <NUMBER> ) , <NEWLINE> <STRING> : <BoN> get color function <EoN> ( <NUMBER> , <NUMBER> ) , <NEWLINE> } <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set aspect <EoN> ( <BoN> self <EoN> , <BoN> aspect <EoN> , <BoN> adjustable <EoN> = <BoN> None <EoN> , <BoN> anchor <EoN> = <BoN> None <EoN> , <BoN> share <EoN> = <BoN> False <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> ( <BoN> isinstance <EoN> ( <BoN> aspect <EoN> , <BoN> str <EoN> ) <BoN> and <EoN> <BoN> aspect <EoN> <BoN> in <EoN> ( <STRING> , <STRING> ) ) : <NEWLINE> <TAB> <BoN> aspect <EoN> = <BoN> float <EoN> ( <BoN> aspect <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> share <EoN> : <NEWLINE> <TAB> <BoN> axes <EoN> = <BoN> set <EoN> ( <BoN> self <EoN> . <BoN> shared x axes <EoN> . <BoN> get siblings <EoN> ( <BoN> self <EoN> ) <NEWLINE> + <BoN> self <EoN> . <BoN> shared y axes <EoN> . <BoN> get siblings <EoN> ( <BoN> self <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> axes <EoN> = [ <BoN> self <EoN> ] <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> ax <EoN> <BoN> in <EoN> <BoN> axes <EoN> : <NEWLINE> <TAB> <BoN> ax <EoN> . <BoN> aspect <EoN> = <BoN> aspect <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> adjustable <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> adjustable <EoN> = <BoN> self <EoN> . <BoN> adjustable <EoN> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> set adjustable <EoN> ( <BoN> adjustable <EoN> , <BoN> share <EoN> = <BoN> share <EoN> ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> anchor <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> set anchor <EoN> ( <BoN> anchor <EoN> , <BoN> share <EoN> = <BoN> share <EoN> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> ifft <EoN> ( <BoN> data <EoN> = <BoN> None <EoN> , <BoN> compute size <EoN> = <BoN> Null <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> recv <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> buf <EoN> = <BoN> self <EoN> . <BoN> recv bytes <EoN> ( ) <NEWLINE> <BoN> return <EoN> <BoN> pickle <EoN> . <BoN> loads <EoN> ( <BoN> buf <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> detach <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> self <EoN> . <BoN> connection <EoN> . <BoN> detach <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> is coplanar <EoN> ( <BoN> self <EoN> , <BoN> o <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> o <EoN> , <BoN> Plane <EoN> ) : <NEWLINE> <TAB> <BoN> x <EoN> , <BoN> y <EoN> , <BoN> z <EoN> = <BoN> map <EoN> ( <BoN> Dummy <EoN> , <STRING> ) <NEWLINE> <BoN> return <EoN> <BoN> not <EoN> <BoN> cancel <EoN> ( <BoN> self <EoN> . <BoN> equation <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> z <EoN> ) / <BoN> o <EoN> . <BoN> equation <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> z <EoN> ) ) . <BoN> has <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> z <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> o <EoN> , <BoN> Point 3 D <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> o <EoN> <BoN> in <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> o <EoN> , <BoN> Linear Entity 3 D <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> all <EoN> ( <BoN> i <EoN> <BoN> in <EoN> <BoN> self <EoN> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> self <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> o <EoN> , <BoN> Geometry Entity <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> all <EoN> ( <BoN> i <EoN> == <NUMBER> <BoN> for <EoN> <BoN> i <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> normal vector <EoN> [ : <NUMBER> ] ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> pchanged <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> for <EoN> <BoN> oid <EoN> , <BoN> func <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> propobservers <EoN> . <BoN> items <EoN> ( ) : <NEWLINE> <TAB> <BoN> func <EoN> ( <BoN> self <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> evaluate <EoN> ( <BoN> self <EoN> , <BoN> delay secs <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> delay secs <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> delay secs <EoN> = <BoN> self <EoN> . <BoN> eval delay secs <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> delay secs <EoN> : <NEWLINE> <TAB> <BoN> logging <EoN> . <BoN> info <EoN> ( <STRING> , <BoN> delay secs <EoN> ) <NEWLINE> <BoN> time <EoN> . <BoN> sleep <EoN> ( <BoN> delay secs <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> self <EoN> . <BoN> call evaluate <EoN> ( <NEWLINE> <BoN> input fn <EoN> = <BoN> self <EoN> . <BoN> eval input fn <EoN> , <NEWLINE> <BoN> steps <EoN> = <BoN> self <EoN> . <BoN> eval steps <EoN> , <NEWLINE> <BoN> metrics <EoN> = <BoN> self <EoN> . <BoN> eval metrics <EoN> , <NEWLINE> <BoN> name <EoN> = ( <BoN> name <EoN> <BoN> or <EoN> <STRING> ) , <NEWLINE> <BoN> hooks <EoN> = <BoN> self <EoN> . <BoN> eval hooks <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> create empty copy <EoN> ( <BoN> G <EoN> , <BoN> with data <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> H <EoN> = <BoN> G <EoN> . <BoN> fresh copy <EoN> ( ) <NEWLINE> <BoN> H <EoN> . <BoN> add nodes from <EoN> ( <BoN> G <EoN> . <BoN> nodes <EoN> ( <BoN> data <EoN> = <BoN> with data <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> with data <EoN> : <NEWLINE> <TAB> <BoN> H <EoN> . <BoN> graph <EoN> . <BoN> update <EoN> ( <BoN> G <EoN> . <BoN> graph <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> H <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> get arrowstyle <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> arrow transmuter <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> enter <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> classmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> unit regular polygon <EoN> ( <BoN> cls <EoN> , <BoN> num Vertices <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> num Vertices <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> path <EoN> = <BoN> cls <EoN> . <BoN> unit regular polygons <EoN> . <BoN> get <EoN> ( <BoN> num Vertices <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> path <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> path <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> theta <EoN> = ( ( <NUMBER> * <BoN> np <EoN> . <BoN> pi <EoN> / <BoN> num Vertices <EoN> ) * <BoN> np <EoN> . <BoN> arange <EoN> ( <BoN> num Vertices <EoN> + <NUMBER> ) <NEWLINE> <NEWLINE> <NEWLINE> + <BoN> np <EoN> . <BoN> pi <EoN> / <NUMBER> ) <NEWLINE> <BoN> verts <EoN> = <BoN> np <EoN> . <BoN> column stack <EoN> ( ( <BoN> np <EoN> . <BoN> cos <EoN> ( <BoN> theta <EoN> ) , <BoN> np <EoN> . <BoN> sin <EoN> ( <BoN> theta <EoN> ) ) ) <NEWLINE> <BoN> codes <EoN> = <BoN> np <EoN> . <BoN> empty <EoN> ( <BoN> num Vertices <EoN> + <NUMBER> ) <NEWLINE> <BoN> codes <EoN> [ <NUMBER> ] = <BoN> cls <EoN> . <BoN> MOVET O <EoN> <NEWLINE> <BoN> codes <EoN> [ <NUMBER> : - <NUMBER> ] = <BoN> cls <EoN> . <BoN> LINET O <EoN> <NEWLINE> <BoN> codes <EoN> [ - <NUMBER> ] = <BoN> cls <EoN> . <BoN> CLOSEPOL Y <EoN> <NEWLINE> <BoN> path <EoN> = <BoN> cls <EoN> ( <BoN> verts <EoN> , <BoN> codes <EoN> , <BoN> readonly <EoN> = <BoN> True <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> num Vertices <EoN> <= <NUMBER> : <NEWLINE> <TAB> <BoN> cls <EoN> . <BoN> unit regular polygons <EoN> [ <BoN> num Vertices <EoN> ] = <BoN> path <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> path <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> set debug <EoN> ( <BoN> debug <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> config <EoN> . <BoN> debug <EoN> = <BoN> debug <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> broadcast hypot <EoN> ( <BoN> lhs <EoN> = <BoN> None <EoN> , <BoN> rhs <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , <BoN> attr <EoN> = <BoN> None <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> log <EoN> ( <BoN> self <EoN> , <BoN> a <EoN> , <BoN> b <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> set center <EoN> ( <BoN> self <EoN> , <BoN> xy <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> self <EoN> . <BoN> center <EoN> = <BoN> xy <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> stale <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> gaussian random matrix <EoN> ( <BoN> n components <EoN> , <BoN> n features <EoN> , <BoN> random state <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> check input size <EoN> ( <BoN> n components <EoN> , <BoN> n features <EoN> ) <NEWLINE> <BoN> rng <EoN> = <BoN> check random state <EoN> ( <BoN> random state <EoN> ) <NEWLINE> <BoN> components <EoN> = <BoN> rng <EoN> . <BoN> normal <EoN> ( <BoN> loc <EoN> = <NUMBER> , <NEWLINE> <BoN> scale <EoN> = <NUMBER> / <BoN> np <EoN> . <BoN> sqrt <EoN> ( <BoN> n components <EoN> ) , <NEWLINE> <BoN> size <EoN> = ( <BoN> n components <EoN> , <BoN> n features <EoN> ) ) <NEWLINE> <BoN> return <EoN> <BoN> components <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> sample poisson <EoN> ( <BoN> lam <EoN> = <BoN> None <EoN> , <BoN> shape <EoN> = <BoN> Null <EoN> , <BoN> dtype <EoN> = <BoN> Null <EoN> , <BoN> out <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> ( <NUMBER> , ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> savez compressed <EoN> ( <BoN> file <EoN> , * <BoN> args <EoN> , ** <BoN> kwds <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> savez <EoN> ( <BoN> file <EoN> , <BoN> args <EoN> , <BoN> kwds <EoN> , <BoN> True <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> radsimp <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> sympy <EoN> . <BoN> simplify <EoN> <BoN> import <EoN> <BoN> radsimp <EoN> <NEWLINE> <BoN> return <EoN> <BoN> radsimp <EoN> ( <BoN> self <EoN> , ** <BoN> kwargs <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> from FractionField <EoN> ( <BoN> K 1 <EoN> , <BoN> a <EoN> , <BoN> K 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> K 1 <EoN> ( <BoN> K 0 <EoN> . <BoN> to sympy <EoN> ( <BoN> a <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> fourier series <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> f <EoN> = <BoN> sympify <EoN> ( <BoN> f <EoN> ) <NEWLINE> <NEWLINE> <BoN> limits <EoN> = <BoN> process limits <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> limits <EoN> [ <NUMBER> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> f <EoN> . <BoN> free symbols <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> f <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> n <EoN> = <BoN> Dummy <EoN> ( <STRING> ) <NEWLINE> <BoN> neg f <EoN> = <BoN> f <EoN> . <BoN> subs <EoN> ( <BoN> x <EoN> , - <BoN> x <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> f <EoN> == <BoN> neg f <EoN> : <NEWLINE> <TAB> <BoN> a 0 <EoN> , <BoN> an <EoN> = <BoN> fourier cos seq <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> bn <EoN> = <BoN> Seq Formula <EoN> ( <NUMBER> , ( <NUMBER> , <BoN> oo <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> f <EoN> == - <BoN> neg f <EoN> : <NEWLINE> <TAB> <BoN> a 0 <EoN> = <BoN> S <EoN> . <BoN> Zero <EoN> <NEWLINE> <BoN> an <EoN> = <BoN> Seq Formula <EoN> ( <NUMBER> , ( <NUMBER> , <BoN> oo <EoN> ) ) <NEWLINE> <BoN> bn <EoN> = <BoN> fourier sin seq <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> , <BoN> n <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> a 0 <EoN> , <BoN> an <EoN> = <BoN> fourier cos seq <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> , <BoN> n <EoN> ) <NEWLINE> <BoN> bn <EoN> = <BoN> fourier sin seq <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> , <BoN> n <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Fourier Series <EoN> ( <BoN> f <EoN> , <BoN> limits <EoN> , ( <BoN> a 0 <EoN> , <BoN> an <EoN> , <BoN> bn <EoN> ) ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> permute rows <EoN> ( <BoN> self <EoN> , <BoN> swaps <EoN> , <BoN> direction <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> permute <EoN> ( <BoN> swaps <EoN> , <BoN> orientation <EoN> = <STRING> , <BoN> direction <EoN> = <BoN> direction <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> join <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> , <BoN> how <EoN> = <STRING> , <BoN> lsuffix <EoN> = <STRING> , <BoN> rsuffix <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> from <EoN> <BoN> pandas <EoN> . <BoN> core <EoN> . <BoN> reshape <EoN> . <BoN> concat <EoN> <BoN> import <EoN> <BoN> concat <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> other <EoN> , <BoN> Panel <EoN> ) : <NEWLINE> <TAB> <BoN> join major <EoN> , <BoN> join minor <EoN> = <BoN> self <EoN> . <BoN> get join index <EoN> ( <BoN> other <EoN> , <BoN> how <EoN> ) <NEWLINE> <BoN> this <EoN> = <BoN> self <EoN> . <BoN> reindex <EoN> ( <BoN> major <EoN> = <BoN> join major <EoN> , <BoN> minor <EoN> = <BoN> join minor <EoN> ) <NEWLINE> <BoN> other <EoN> = <BoN> other <EoN> . <BoN> reindex <EoN> ( <BoN> major <EoN> = <BoN> join major <EoN> , <BoN> minor <EoN> = <BoN> join minor <EoN> ) <NEWLINE> <BoN> merged data <EoN> = <BoN> this <EoN> . <BoN> data <EoN> . <BoN> merge <EoN> ( <BoN> other <EoN> . <BoN> data <EoN> , <BoN> lsuffix <EoN> , <BoN> rsuffix <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> self <EoN> . <BoN> constructor <EoN> ( <BoN> merged data <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> lsuffix <EoN> <BoN> or <EoN> <BoN> rsuffix <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> how <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> how <EoN> = <STRING> <NEWLINE> <BoN> join axes <EoN> = [ <BoN> self <EoN> . <BoN> major axis <EoN> , <BoN> self <EoN> . <BoN> minor axis <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> how <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> join axes <EoN> = <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> concat <EoN> ( [ <BoN> self <EoN> ] + <BoN> list <EoN> ( <BoN> other <EoN> ) , <BoN> axis <EoN> = <NUMBER> , <BoN> join <EoN> = <BoN> how <EoN> , <NEWLINE> <BoN> join axes <EoN> = <BoN> join axes <EoN> , <BoN> verify integrity <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> pow <EoN> ( <BoN> self <EoN> , <BoN> exponent <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Not Implemented Error <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> tanh <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> K <EoN> . <BoN> tanh <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> sub <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> delegate binop <EoN> ( <BoN> other <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Not Implemented <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> subtract <EoN> ( <BoN> self <EoN> , <BoN> other <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> as content primitive <EoN> ( <BoN> self <EoN> , <BoN> radical <EoN> = <BoN> False <EoN> , <BoN> clear <EoN> = <BoN> True <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> S <EoN> . <BoN> One <EoN> , <BoN> self <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> run <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> ctrl proto <EoN> = <BoN> ctypes <EoN> . <BoN> CFUNCTYP E <EoN> ( <BoN> None <EoN> , <BoN> ctypes <EoN> . <BoN> c int <EoN> , <BoN> ctypes <EoN> . <BoN> c char p <EoN> , <BoN> ctypes <EoN> . <BoN> c void p <EoN> ) <NEWLINE> <BoN> check call <EoN> ( <BoN> LIB <EoN> . <BoN> MXKV Store Run Server <EoN> ( <BoN> self <EoN> . <BoN> handle <EoN> , <BoN> ctrl proto <EoN> ( <BoN> self <EoN> . <BoN> controller <EoN> ( ) ) , <BoN> None <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> open <EoN> ( <BoN> self <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> fh <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> , <BoN> basestring <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> file <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> realpath <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> dir <EoN> , <BoN> self <EoN> . <BoN> name <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> split <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> = <BoN> open <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> , <BoN> self <EoN> . <BoN> mode <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> close <EoN> = <BoN> True <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> offset <EoN> = <NUMBER> <NEWLINE> <UNTAB> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> , <BoN> File Handle <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fh <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> fh <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> offset <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> offset <EoN> += <BoN> self <EoN> . <BoN> file <EoN> . <BoN> offset <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> close <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> : <NEWLINE> <TAB> <BoN> name <EoN> , <BoN> ext <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> splitext <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> . <BoN> name <EoN> ) <NEWLINE> <BoN> self <EoN> . <BoN> name <EoN> = <STRING> % ( <BoN> name <EoN> , <BoN> self <EoN> . <BoN> offset <EoN> , <BoN> ext <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> name <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> name <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> mode <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> mode <EoN> != <BoN> self <EoN> . <BoN> file <EoN> . <BoN> mode <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> mode <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> mode <EoN> <NEWLINE> <BoN> self <EoN> . <BoN> dir <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> dir <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> hasattr <EoN> ( <BoN> self <EoN> . <BoN> file <EoN> , <STRING> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> file <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> fh <EoN> = <BoN> self <EoN> . <BoN> file <EoN> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> offset <EoN> = <BoN> self <EoN> . <BoN> file <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> close <EoN> = <BoN> False <EoN> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> self <EoN> . <BoN> name <EoN> : <NEWLINE> <TAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> dir <EoN> , <BoN> self <EoN> . <BoN> name <EoN> = <BoN> os <EoN> . <BoN> path <EoN> . <BoN> split <EoN> ( <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> name <EoN> = <STRING> <NEWLINE> <UNTAB> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> mode <EoN> = <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> mode <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Attribute Error <EoN> : <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> offset <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> offset <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> size <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> pos <EoN> = <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> self <EoN> . <BoN> offset <EoN> , <NUMBER> ) <NEWLINE> <BoN> self <EoN> . <BoN> size <EoN> = <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> tell <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> seek <EoN> ( <BoN> pos <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> fh <EoN> . <BoN> fileno <EoN> ( ) <NEWLINE> <BoN> self <EoN> . <BoN> is file <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Exception <EoN> : <NEWLINE> <TAB> <BoN> self <EoN> . <BoN> is file <EoN> = <BoN> False <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> apply gradients <EoN> ( <BoN> self <EoN> , <BoN> grads and vars <EoN> , <BoN> global step <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> grads and vars <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> global step <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> apply updates <EoN> = <BoN> self <EoN> . <BoN> opt <EoN> . <BoN> apply gradients <EoN> ( <BoN> grads and vars <EoN> ) <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> apply updates <EoN> ] ) : <NEWLINE> <TAB> <BoN> local update <EoN> = <BoN> state ops <EoN> . <BoN> assign add <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> local step <EoN> , <NUMBER> , <BoN> name <EoN> = <STRING> ) . <BoN> op <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> def <EoN> <BoN> update global variables <EoN> ( ) : <NEWLINE> <TAB> <BoN> local vars <EoN> = [ <BoN> v <EoN> <BoN> for <EoN> <BoN> g <EoN> , <BoN> v <EoN> <BoN> in <EoN> <BoN> grads and vars <EoN> <BoN> if <EoN> <BoN> g <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> ] <NEWLINE> <BoN> global vars <EoN> = [ <BoN> self <EoN> . <BoN> local 2 global <EoN> [ <BoN> v <EoN> ] <BoN> for <EoN> <BoN> v <EoN> <BoN> in <EoN> <BoN> local vars <EoN> ] <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> colocate with <EoN> ( <BoN> global step <EoN> ) : <NEWLINE> <TAB> <BoN> sync queue <EoN> = <BoN> data flow ops <EoN> . <BoN> FIFO Queue <EoN> ( <NEWLINE> - <NUMBER> , [ <BoN> dtypes <EoN> . <BoN> bool <EoN> ] , <BoN> shapes <EoN> = [ [ ] ] , <BoN> shared name <EoN> = <STRING> ) <NEWLINE> <UNTAB> <BoN> train ops <EoN> = [ ] <NEWLINE> <BoN> aggregated vars <EoN> = [ ] <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> name scope <EoN> ( <BoN> None <EoN> , <BoN> self <EoN> . <BoN> name <EoN> + <STRING> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> var <EoN> , <BoN> gvar <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> local vars <EoN> , <BoN> global vars <EoN> ) : <NEWLINE> <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> device <EoN> ( <BoN> gvar <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> var <EoN> . <BoN> ref <EoN> ( ) , <BoN> ops <EoN> . <BoN> Tensor <EoN> ) : <NEWLINE> <TAB> <BoN> var accum <EoN> = <BoN> data flow ops <EoN> . <BoN> Conditional Accumulator <EoN> ( <NEWLINE> <BoN> var <EoN> . <BoN> dtype <EoN> , <NEWLINE> <BoN> shape <EoN> = <BoN> var <EoN> . <BoN> get shape <EoN> ( ) , <NEWLINE> <BoN> shared name <EoN> = <BoN> gvar <EoN> . <BoN> name <EoN> + <STRING> ) <NEWLINE> <BoN> train ops <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> var accum <EoN> . <BoN> apply grad <EoN> ( <BoN> var <EoN> . <BoN> ref <EoN> ( ) , <BoN> local step <EoN> = <BoN> global step <EoN> ) ) <NEWLINE> <BoN> aggregated vars <EoN> . <BoN> append <EoN> ( <BoN> var accum <EoN> . <BoN> take grad <EoN> ( <BoN> self <EoN> . <BoN> num worker <EoN> ) ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> accumulator list <EoN> . <BoN> append <EoN> ( ( <BoN> var accum <EoN> , <BoN> gvar <EoN> . <BoN> device <EoN> ) ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> is chief <EoN> : <NEWLINE> <TAB> <BoN> update ops <EoN> = [ ] <NEWLINE> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> train ops <EoN> ) : <NEWLINE> <TAB> <BoN> for <EoN> <BoN> avg var <EoN> , <BoN> gvar <EoN> <BoN> in <EoN> <BoN> zip <EoN> ( <BoN> aggregated vars <EoN> , <BoN> global vars <EoN> ) : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> device <EoN> ( <BoN> gvar <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign <EoN> ( <BoN> gvar <EoN> , <BoN> avg var <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> device <EoN> ( <BoN> global step <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> update ops <EoN> . <BoN> append <EoN> ( <BoN> state ops <EoN> . <BoN> assign add <EoN> ( <BoN> global step <EoN> , <NUMBER> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> update ops <EoN> ) , <BoN> ops <EoN> . <BoN> device <EoN> ( <NEWLINE> <BoN> global step <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> tokens <EoN> = <BoN> array ops <EoN> . <BoN> fill <EoN> ( [ <BoN> self <EoN> . <BoN> num worker <EoN> - <NUMBER> ] , <NEWLINE> <BoN> constant op <EoN> . <BoN> constant <EoN> ( <BoN> False <EoN> ) ) <NEWLINE> <BoN> sync op <EoN> = <BoN> sync queue <EoN> . <BoN> enqueue many <EoN> ( <BoN> tokens <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( <BoN> train ops <EoN> ) , <BoN> ops <EoN> . <BoN> device <EoN> ( <NEWLINE> <BoN> global step <EoN> . <BoN> device <EoN> ) : <NEWLINE> <TAB> <BoN> sync op <EoN> = <BoN> sync queue <EoN> . <BoN> dequeue <EoN> ( ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> sync op <EoN> ] ) : <NEWLINE> <TAB> <BoN> local update op <EoN> = <BoN> self <EoN> . <BoN> local vars update <EoN> ( <BoN> local vars <EoN> ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> local update op <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> control dependencies <EoN> ( [ <BoN> local update <EoN> ] ) : <NEWLINE> <TAB> <BoN> condition <EoN> = <BoN> math ops <EoN> . <BoN> equal <EoN> ( <NEWLINE> <BoN> math ops <EoN> . <BoN> mod <EoN> ( <BoN> self <EoN> . <BoN> local step <EoN> , <BoN> self <EoN> . <BoN> interval steps <EoN> ) , <NUMBER> ) <NEWLINE> <BoN> conditional update <EoN> = <BoN> control flow ops <EoN> . <BoN> cond <EoN> ( <NEWLINE> <BoN> condition <EoN> , <BoN> update global variables <EoN> , <BoN> control flow ops <EoN> . <BoN> no op <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> chief init ops <EoN> = [ ] <NEWLINE> <BoN> for <EoN> <BoN> accum <EoN> , <BoN> dev <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> accumulator list <EoN> : <NEWLINE> <TAB> <BoN> with <EoN> <BoN> ops <EoN> . <BoN> device <EoN> ( <BoN> dev <EoN> ) : <NEWLINE> <TAB> <BoN> chief init ops <EoN> . <BoN> append <EoN> ( <NEWLINE> <BoN> accum <EoN> . <BoN> set global step <EoN> ( <BoN> global step <EoN> , <BoN> name <EoN> = <STRING> ) ) <NEWLINE> <UNTAB> <UNTAB> <BoN> self <EoN> . <BoN> chief init op <EoN> = <BoN> control flow ops <EoN> . <BoN> group <EoN> ( * ( <BoN> chief init ops <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> return <EoN> <BoN> conditional update <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> eval subs <EoN> ( <BoN> self <EoN> , <BoN> old <EoN> , <BoN> new <EoN> ) : <NEWLINE> <TAB> <BoN> from <EoN> <BoN> sympy <EoN> <BoN> import <EoN> <BoN> exp <EoN> , <BoN> log <EoN> , <BoN> Symbol <EoN> <NEWLINE> <BoN> def <EoN> <BoN> check <EoN> ( <BoN> ct 1 <EoN> , <BoN> ct 2 <EoN> , <BoN> old <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> coeff 1 <EoN> , <BoN> terms 1 <EoN> = <BoN> ct 1 <EoN> <NEWLINE> <BoN> coeff 2 <EoN> , <BoN> terms 2 <EoN> = <BoN> ct 2 <EoN> <NEWLINE> <BoN> if <EoN> <BoN> terms 1 <EoN> == <BoN> terms 2 <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> old <EoN> . <BoN> is commutative <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pow <EoN> = <BoN> coeff 1 <EoN> / <BoN> coeff 2 <EoN> <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> pow <EoN> = <BoN> as int <EoN> ( <BoN> pow <EoN> ) <NEWLINE> <BoN> combines <EoN> = <BoN> True <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <TAB> <BoN> combines <EoN> = <BoN> Pow <EoN> . <BoN> eval power <EoN> ( <NEWLINE> <BoN> Pow <EoN> ( * <BoN> old <EoN> . <BoN> as base exp <EoN> ( ) , <BoN> evaluate <EoN> = <BoN> False <EoN> ) , <NEWLINE> <BoN> pow <EoN> ) <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> combines <EoN> , <BoN> pow <EoN> , <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> isinstance <EoN> ( <BoN> terms 1 <EoN> , <BoN> tuple <EoN> ) : <NEWLINE> <TAB> <BoN> terms 1 <EoN> = ( <BoN> terms 1 <EoN> , ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> all <EoN> ( <BoN> term <EoN> . <BoN> is integer <EoN> <BoN> for <EoN> <BoN> term <EoN> <BoN> in <EoN> <BoN> terms 1 <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> , <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> try <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pow <EoN> , <BoN> remainder <EoN> = <BoN> divmod <EoN> ( <BoN> as int <EoN> ( <BoN> coeff 1 <EoN> ) , <BoN> as int <EoN> ( <BoN> coeff 2 <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> pow <EoN> < <NUMBER> <BoN> and <EoN> <BoN> remainder <EoN> != <NUMBER> : <NEWLINE> <TAB> <BoN> pow <EoN> += <NUMBER> <NEWLINE> <BoN> remainder <EoN> -= <BoN> as int <EoN> ( <BoN> coeff 2 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> remainder <EoN> == <NUMBER> : <NEWLINE> <TAB> <BoN> remainder pow <EoN> = <BoN> None <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> remainder pow <EoN> = <BoN> Mul <EoN> ( <BoN> remainder <EoN> , * <BoN> terms 1 <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> , <BoN> pow <EoN> , <BoN> remainder pow <EoN> <NEWLINE> <UNTAB> <BoN> except <EoN> <BoN> Value Error <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> pass <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> False <EoN> , <BoN> None <EoN> , <BoN> None <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> old <EoN> == <BoN> self <EoN> . <BoN> base <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> new <EoN> ** <BoN> self <EoN> . <BoN> exp <EoN> . <BoN> subs <EoN> ( <BoN> old <EoN> , <BoN> new <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> old <EoN> , <BoN> self <EoN> . <BoN> func <EoN> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> exp <EoN> == <BoN> old <EoN> . <BoN> exp <EoN> : <NEWLINE> <TAB> <BoN> l <EoN> = <BoN> log <EoN> ( <BoN> self <EoN> . <BoN> base <EoN> , <BoN> old <EoN> . <BoN> base <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> l <EoN> . <BoN> is Number <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> Pow <EoN> ( <BoN> new <EoN> , <BoN> l <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> old <EoN> , <BoN> self <EoN> . <BoN> func <EoN> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> base <EoN> == <BoN> old <EoN> . <BoN> base <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> exp <EoN> . <BoN> is Add <EoN> <BoN> is <EoN> <BoN> False <EoN> : <NEWLINE> <TAB> <BoN> ct 1 <EoN> = <BoN> self <EoN> . <BoN> exp <EoN> . <BoN> as independent <EoN> ( <BoN> Symbol <EoN> , <BoN> as Add <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> ct 2 <EoN> = <BoN> old <EoN> . <BoN> exp <EoN> . <BoN> as independent <EoN> ( <BoN> Symbol <EoN> , <BoN> as Add <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> ok <EoN> , <BoN> pow <EoN> , <BoN> remainder pow <EoN> = <BoN> check <EoN> ( <BoN> ct 1 <EoN> , <BoN> ct 2 <EoN> , <BoN> old <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ok <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> new <EoN> , <BoN> pow <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> remainder pow <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> Mul <EoN> ( <BoN> result <EoN> , <BoN> Pow <EoN> ( <BoN> old <EoN> . <BoN> base <EoN> , <BoN> remainder pow <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> else <EoN> : <NEWLINE> <NEWLINE> <TAB> <BoN> oarg <EoN> = <BoN> old <EoN> . <BoN> exp <EoN> <NEWLINE> <BoN> new l <EoN> = [ ] <NEWLINE> <BoN> o al <EoN> = [ ] <NEWLINE> <BoN> ct 2 <EoN> = <BoN> oarg <EoN> . <BoN> as coeff mul <EoN> ( ) <NEWLINE> <BoN> for <EoN> <BoN> a <EoN> <BoN> in <EoN> <BoN> self <EoN> . <BoN> exp <EoN> . <BoN> args <EoN> : <NEWLINE> <TAB> <BoN> newa <EoN> = <BoN> a <EoN> . <BoN> subs <EoN> ( <BoN> old <EoN> , <BoN> new <EoN> ) <NEWLINE> <BoN> ct 1 <EoN> = <BoN> newa <EoN> . <BoN> as coeff mul <EoN> ( ) <NEWLINE> <BoN> ok <EoN> , <BoN> pow <EoN> , <BoN> remainder pow <EoN> = <BoN> check <EoN> ( <BoN> ct 1 <EoN> , <BoN> ct 2 <EoN> , <BoN> old <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ok <EoN> : <NEWLINE> <TAB> <BoN> new l <EoN> . <BoN> append <EoN> ( <BoN> new <EoN> ** <BoN> pow <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> remainder pow <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> o al <EoN> . <BoN> append <EoN> ( <BoN> remainder pow <EoN> ) <NEWLINE> <UNTAB> <BoN> continue <EoN> <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> not <EoN> <BoN> old <EoN> . <BoN> is commutative <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> newa <EoN> . <BoN> is integer <EoN> : <NEWLINE> <NEWLINE> <NEWLINE> <TAB> <BoN> return <EoN> <NEWLINE> <UNTAB> <BoN> o al <EoN> . <BoN> append <EoN> ( <BoN> newa <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> new l <EoN> : <NEWLINE> <TAB> <BoN> expo <EoN> = <BoN> Add <EoN> ( * <BoN> o al <EoN> ) <NEWLINE> <BoN> new l <EoN> . <BoN> append <EoN> ( <BoN> Pow <EoN> ( <BoN> self <EoN> . <BoN> base <EoN> , <BoN> expo <EoN> , <BoN> evaluate <EoN> = <BoN> False <EoN> ) <BoN> if <EoN> <BoN> expo <EoN> != <NUMBER> <BoN> else <EoN> <BoN> self <EoN> . <BoN> base <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> Mul <EoN> ( * <BoN> new l <EoN> ) <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> old <EoN> , <BoN> exp <EoN> ) <BoN> and <EoN> <BoN> self <EoN> . <BoN> exp <EoN> . <BoN> is real <EoN> <BoN> and <EoN> <BoN> self <EoN> . <BoN> base <EoN> . <BoN> is positive <EoN> : <NEWLINE> <TAB> <BoN> ct 1 <EoN> = <BoN> old <EoN> . <BoN> args <EoN> [ <NUMBER> ] . <BoN> as independent <EoN> ( <BoN> Symbol <EoN> , <BoN> as Add <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> ct 2 <EoN> = ( <BoN> self <EoN> . <BoN> exp <EoN> * <BoN> log <EoN> ( <BoN> self <EoN> . <BoN> base <EoN> ) ) . <BoN> as independent <EoN> ( <NEWLINE> <BoN> Symbol <EoN> , <BoN> as Add <EoN> = <BoN> False <EoN> ) <NEWLINE> <BoN> ok <EoN> , <BoN> pow <EoN> , <BoN> remainder pow <EoN> = <BoN> check <EoN> ( <BoN> ct 1 <EoN> , <BoN> ct 2 <EoN> , <BoN> old <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> ok <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> self <EoN> . <BoN> func <EoN> ( <BoN> new <EoN> , <BoN> pow <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> remainder pow <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> result <EoN> = <BoN> Mul <EoN> ( <BoN> result <EoN> , <BoN> Pow <EoN> ( <BoN> old <EoN> . <BoN> base <EoN> , <BoN> remainder pow <EoN> ) ) <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> result <EoN> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> reduce sum <EoN> ( <BoN> attrs <EoN> , <BoN> inputs <EoN> , <BoN> proto obj <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> new attrs <EoN> = <BoN> translation utils <EoN> . <BoN> fix attribute names <EoN> ( <BoN> attrs <EoN> , { <STRING> : <STRING> } ) <NEWLINE> <BoN> return <EoN> <STRING> , <BoN> new attrs <EoN> , <BoN> inputs <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> argtopk <EoN> ( <BoN> x <EoN> , <BoN> kth <EoN> , <BoN> axis <EoN> = - <NUMBER> , <BoN> sorted <EoN> = <BoN> True <EoN> , <BoN> idx dtype <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> axis <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> theano <EoN> . <BoN> tensor <EoN> . <BoN> flatten <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> axis <EoN> = <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> Top K Op <EoN> ( <NEWLINE> <BoN> axis <EoN> = <BoN> axis <EoN> , <NEWLINE> <BoN> sorted <EoN> = <BoN> sorted <EoN> , <NEWLINE> <BoN> idx dtype <EoN> = <BoN> idx dtype <EoN> ) ( <BoN> x <EoN> , <BoN> kth <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <BoN> v 1 <EoN> = [ <STRING> , <STRING> ] ) <NEWLINE> @ <BoN> deprecation <EoN> . <BoN> deprecated endpoints <EoN> ( <STRING> ) <NEWLINE> <BoN> def <EoN> <BoN> random poisson <EoN> ( <BoN> lam <EoN> , <BoN> shape <EoN> , <BoN> dtype <EoN> = <BoN> dtypes <EoN> . <BoN> float 32 <EoN> , <BoN> seed <EoN> = <BoN> None <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> random poisson v 2 <EoN> ( <BoN> shape <EoN> , <BoN> lam <EoN> , <BoN> dtype <EoN> , <BoN> seed <EoN> , <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> @ <BoN> tf export <EoN> ( <STRING> , <BoN> v 1 <EoN> = [ ] ) <NEWLINE> <BoN> def <EoN> <BoN> import event <EoN> ( <BoN> tensor <EoN> , <BoN> name <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> gen summary ops <EoN> . <BoN> import event <EoN> ( <NEWLINE> <BoN> context <EoN> . <BoN> context <EoN> ( ) . <BoN> summary writer resource <EoN> , <BoN> tensor <EoN> , <BoN> name <EoN> = <BoN> name <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> prod <EoN> ( <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> x <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <NUMBER> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> functools <EoN> . <BoN> reduce <EoN> ( <BoN> operator <EoN> . <BoN> mul <EoN> , <BoN> x <EoN> ) <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> validate key <EoN> ( <BoN> self <EoN> , <BoN> key <EoN> , <BoN> axis <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> raise <EoN> <BoN> Abstract Method Error <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> are validate args <EoN> ( <BoN> a <EoN> , <BoN> b <EoN> , <BoN> q <EoN> , <BoN> r <EoN> , <BoN> e <EoN> , <BoN> s <EoN> , <BoN> eq type <EoN> = <STRING> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> eq type <EoN> . <BoN> lower <EoN> ( ) <BoN> in <EoN> ( <STRING> , <STRING> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> a <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> a <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> b <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> b <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> q <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> q <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> r <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> r <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> r or c <EoN> = <BoN> complex <EoN> <BoN> if <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> b <EoN> ) <BoN> else <EoN> <BoN> float <EoN> <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> ind <EoN> , <BoN> mat <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( ( <BoN> a <EoN> , <BoN> q <EoN> , <BoN> r <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> mat <EoN> ) : <NEWLINE> <TAB> <BoN> r or c <EoN> = <BoN> complex <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> equal <EoN> ( * <BoN> mat <EoN> . <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> . <BoN> format <EoN> ( <STRING> [ <BoN> ind <EoN> ] ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> m <EoN> , <BoN> n <EoN> = <BoN> b <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> m <EoN> != <BoN> a <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> m <EoN> != <BoN> q <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> n <EoN> != <BoN> r <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> for <EoN> <BoN> ind <EoN> , <BoN> mat <EoN> <BoN> in <EoN> <BoN> enumerate <EoN> ( ( <BoN> q <EoN> , <BoN> r <EoN> ) ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> norm <EoN> ( <BoN> mat <EoN> - <BoN> mat <EoN> . <BoN> conj <EoN> ( ) . <BoN> T <EoN> , <NUMBER> ) > <BoN> np <EoN> . <BoN> spacing <EoN> ( <BoN> norm <EoN> ( <BoN> mat <EoN> , <NUMBER> ) ) * <NUMBER> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> <NEWLINE> <STRING> . <BoN> format <EoN> ( <STRING> [ <BoN> ind <EoN> ] ) ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> eq type <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> min sv <EoN> = <BoN> svd <EoN> ( <BoN> r <EoN> , <BoN> compute uv <EoN> = <BoN> False <EoN> ) [ - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> min sv <EoN> == <NUMBER> <BoN> or <EoN> <BoN> min sv <EoN> < <BoN> np <EoN> . <BoN> spacing <EoN> ( <NUMBER> ) * <BoN> norm <EoN> ( <BoN> r <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> generalized case <EoN> = <BoN> e <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <BoN> or <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> generalized case <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> e <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> e <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> e <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> np <EoN> . <BoN> equal <EoN> ( * <BoN> e <EoN> . <BoN> shape <EoN> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> m <EoN> != <BoN> e <EoN> . <BoN> shape <EoN> [ <NUMBER> ] : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> min sv <EoN> = <BoN> svd <EoN> ( <BoN> e <EoN> , <BoN> compute uv <EoN> = <BoN> False <EoN> ) [ - <NUMBER> ] <NEWLINE> <BoN> if <EoN> <BoN> min sv <EoN> == <NUMBER> <BoN> or <EoN> <BoN> min sv <EoN> < <BoN> np <EoN> . <BoN> spacing <EoN> ( <NUMBER> ) * <BoN> norm <EoN> ( <BoN> e <EoN> , <NUMBER> ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> e <EoN> ) : <NEWLINE> <TAB> <BoN> r or c <EoN> = <BoN> complex <EoN> <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> s <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> s <EoN> = <BoN> np <EoN> . <BoN> atleast 2 d <EoN> ( <BoN> asarray validated <EoN> ( <BoN> s <EoN> , <BoN> check finite <EoN> = <BoN> True <EoN> ) ) <NEWLINE> <BoN> if <EoN> <BoN> s <EoN> . <BoN> shape <EoN> != <BoN> b <EoN> . <BoN> shape <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> np <EoN> . <BoN> iscomplexobj <EoN> ( <BoN> s <EoN> ) : <NEWLINE> <TAB> <BoN> r or c <EoN> = <BoN> complex <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> a <EoN> , <BoN> b <EoN> , <BoN> q <EoN> , <BoN> r <EoN> , <BoN> e <EoN> , <BoN> s <EoN> , <BoN> m <EoN> , <BoN> n <EoN> , <BoN> r or c <EoN> , <BoN> generalized case <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> init <EoN> ( <BoN> self <EoN> , <BoN> graph <EoN> = <BoN> None <EoN> , <BoN> op log <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> graph <EoN> <BoN> and <EoN> <BoN> not <EoN> <BoN> context <EoN> . <BoN> executing eagerly <EoN> ( ) : <NEWLINE> <TAB> <BoN> graph <EoN> = <BoN> ops <EoN> . <BoN> get default graph <EoN> ( ) <NEWLINE> <UNTAB> <BoN> self <EoN> . <BoN> coverage <EoN> = <NUMBER> <NEWLINE> <BoN> self <EoN> . <BoN> graph <EoN> = <BoN> graph <EoN> <NEWLINE> <NEWLINE> <BoN> op log <EoN> = <BoN> tfprof logger <EoN> . <BoN> merge default with oplog <EoN> ( <NEWLINE> <BoN> self <EoN> . <BoN> graph <EoN> , <BoN> op log <EoN> = <BoN> op log <EoN> ) <NEWLINE> <NEWLINE> <BoN> print mdl <EoN> . <BoN> New Profiler <EoN> ( <NEWLINE> <BoN> graph string <EoN> ( <BoN> self <EoN> . <BoN> graph <EoN> ) , <BoN> op log <EoN> . <BoN> Serialize To String <EoN> ( ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> forward <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> unroll loop <EoN> : <NEWLINE> <TAB> <BoN> event size <EoN> = <BoN> tensor shape <EoN> . <BoN> dimension value <EoN> ( <NEWLINE> <BoN> x <EoN> . <BoN> shape <EoN> . <BoN> with rank at least <EoN> ( <NUMBER> ) [ - <NUMBER> ] ) <NEWLINE> <BoN> if <EoN> <BoN> event size <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <NEWLINE> <STRING> <NEWLINE> <STRING> % <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> for <EoN> <BoN> <EoN> <BoN> in <EoN> <BoN> range <EoN> ( <BoN> event size <EoN> ) : <NEWLINE> <TAB> <BoN> shift <EoN> , <BoN> log scale <EoN> = <BoN> self <EoN> . <BoN> shift and log scale fn <EoN> ( <BoN> y <EoN> ) <NEWLINE> <NEWLINE> <BoN> next y <EoN> = <BoN> x <EoN> <NEWLINE> <BoN> if <EoN> <BoN> log scale <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> next y <EoN> *= <BoN> math ops <EoN> . <BoN> exp <EoN> ( <BoN> log scale <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> shift <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> next y <EoN> += <BoN> shift <EoN> <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> next y <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> event size <EoN> = <BoN> array ops <EoN> . <BoN> shape <EoN> ( <BoN> x <EoN> ) [ - <NUMBER> ] <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> static event size <EoN> = <BoN> tensor shape <EoN> . <BoN> dimension value <EoN> ( <NEWLINE> <BoN> x <EoN> . <BoN> shape <EoN> . <BoN> with rank at least <EoN> ( <NUMBER> ) [ - <NUMBER> ] ) <NEWLINE> <BoN> y 0 <EoN> = <BoN> array ops <EoN> . <BoN> zeros like <EoN> ( <BoN> x <EoN> , <BoN> name <EoN> = <STRING> ) <NEWLINE> <NEWLINE> <BoN> <EoN> = <BoN> self <EoN> . <BoN> shift and log scale fn <EoN> ( <BoN> y 0 <EoN> ) <NEWLINE> <BoN> def <EoN> <BoN> loop body <EoN> ( <BoN> index <EoN> , <BoN> y 0 <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> with <EoN> <BoN> variable scope lib <EoN> . <BoN> variable scope <EoN> ( <NEWLINE> <BoN> variable scope lib <EoN> . <BoN> get variable scope <EoN> ( ) ) <BoN> as <EoN> <BoN> vs <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> vs <EoN> . <BoN> caching device <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> vs <EoN> . <BoN> set caching device <EoN> ( <BoN> lambda <EoN> <BoN> op <EoN> : <BoN> op <EoN> . <BoN> device <EoN> ) <NEWLINE> <UNTAB> <BoN> shift <EoN> , <BoN> log scale <EoN> = <BoN> self <EoN> . <BoN> shift and log scale fn <EoN> ( <BoN> y 0 <EoN> ) <NEWLINE> <UNTAB> <BoN> y <EoN> = <BoN> x <EoN> <NEWLINE> <BoN> if <EoN> <BoN> log scale <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> y <EoN> *= <BoN> math ops <EoN> . <BoN> exp <EoN> ( <BoN> log scale <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> shift <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> y <EoN> += <BoN> shift <EoN> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> index <EoN> + <NUMBER> , <BoN> y <EoN> <NEWLINE> <UNTAB> <BoN> <EoN> , <BoN> y <EoN> = <BoN> control flow ops <EoN> . <BoN> while loop <EoN> ( <NEWLINE> <BoN> cond <EoN> = <BoN> lambda <EoN> <BoN> index <EoN> , <BoN> <EoN> : <BoN> index <EoN> < <BoN> event size <EoN> , <NEWLINE> <BoN> body <EoN> = <BoN> loop body <EoN> , <NEWLINE> <BoN> loop vars <EoN> = ( <NUMBER> , <BoN> y 0 <EoN> ) , <NEWLINE> <BoN> maximum iterations <EoN> = <BoN> static event size <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> dup subresultants <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> return <EoN> <BoN> dup inner subresultants <EoN> ( <BoN> f <EoN> , <BoN> g <EoN> , <BoN> K <EoN> ) [ <NUMBER> ] <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> generic bfs edges <EoN> ( <BoN> G <EoN> , <BoN> source <EoN> , <BoN> neighbors <EoN> = <BoN> None <EoN> , <BoN> depth limit <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> visited <EoN> = { <BoN> source <EoN> } <NEWLINE> <BoN> if <EoN> <BoN> depth limit <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> depth limit <EoN> = <BoN> len <EoN> ( <BoN> G <EoN> ) <NEWLINE> <UNTAB> <BoN> queue <EoN> = <BoN> deque <EoN> ( [ ( <BoN> source <EoN> , <BoN> depth limit <EoN> , <BoN> neighbors <EoN> ( <BoN> source <EoN> ) ) ] ) <NEWLINE> <BoN> while <EoN> <BoN> queue <EoN> : <NEWLINE> <TAB> <BoN> parent <EoN> , <BoN> depth now <EoN> , <BoN> children <EoN> = <BoN> queue <EoN> [ <NUMBER> ] <NEWLINE> <BoN> try <EoN> : <NEWLINE> <TAB> <BoN> child <EoN> = <BoN> next <EoN> ( <BoN> children <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> child <EoN> <BoN> not <EoN> <BoN> in <EoN> <BoN> visited <EoN> : <NEWLINE> <TAB> <BoN> yield <EoN> <BoN> parent <EoN> , <BoN> child <EoN> <NEWLINE> <BoN> visited <EoN> . <BoN> add <EoN> ( <BoN> child <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> depth now <EoN> > <NUMBER> : <NEWLINE> <TAB> <BoN> queue <EoN> . <BoN> append <EoN> ( ( <BoN> child <EoN> , <BoN> depth now <EoN> - <NUMBER> , <BoN> neighbors <EoN> ( <BoN> child <EoN> ) ) ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <BoN> except <EoN> <BoN> Stop Iteration <EoN> : <NEWLINE> <TAB> <BoN> queue <EoN> . <BoN> popleft <EoN> ( ) <NEWLINE> <UNTAB> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> spawn <EoN> ( <BoN> cmd <EoN> , <BoN> search path <EoN> = <NUMBER> , <BoN> verbose <EoN> = <NUMBER> , <BoN> dry run <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> cmd <EoN> = <BoN> list <EoN> ( <BoN> cmd <EoN> ) <NEWLINE> <BoN> if <EoN> <BoN> os <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> spawn posix <EoN> ( <BoN> cmd <EoN> , <BoN> search path <EoN> , <BoN> dry run <EoN> = <BoN> dry run <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> os <EoN> . <BoN> name <EoN> == <STRING> : <NEWLINE> <TAB> <BoN> spawn nt <EoN> ( <BoN> cmd <EoN> , <BoN> search path <EoN> , <BoN> dry run <EoN> = <BoN> dry run <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Distutils Platform Error <EoN> ( <NEWLINE> <STRING> % <BoN> os <EoN> . <BoN> name <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> get <EoN> ( <BoN> identifier <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> K <EoN> . <BoN> backend <EoN> ( ) == <STRING> : <NEWLINE> <NEWLINE> <TAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> tf <EoN> . <BoN> train <EoN> . <BoN> Optimizer <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> TF Optimizer <EoN> ( <BoN> identifier <EoN> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> dict <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> deserialize <EoN> ( <BoN> identifier <EoN> ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> six <EoN> . <BoN> string types <EoN> ) : <NEWLINE> <TAB> <BoN> config <EoN> = { <STRING> : <BoN> str <EoN> ( <BoN> identifier <EoN> ) , <STRING> : { } } <NEWLINE> <BoN> return <EoN> <BoN> deserialize <EoN> ( <BoN> config <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> isinstance <EoN> ( <BoN> identifier <EoN> , <BoN> Optimizer <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> identifier <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> + <NEWLINE> <BoN> str <EoN> ( <BoN> identifier <EoN> ) ) <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> resample <EoN> ( <BoN> x <EoN> , <BoN> num <EoN> , <BoN> t <EoN> = <BoN> None <EoN> , <BoN> axis <EoN> = <NUMBER> , <BoN> window <EoN> = <BoN> None <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x <EoN> = <BoN> asarray <EoN> ( <BoN> x <EoN> ) <NEWLINE> <BoN> X <EoN> = <BoN> fftpack <EoN> . <BoN> fft <EoN> ( <BoN> x <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) <NEWLINE> <BoN> Nx <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> [ <BoN> axis <EoN> ] <NEWLINE> <BoN> if <EoN> <BoN> window <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> callable <EoN> ( <BoN> window <EoN> ) : <NEWLINE> <TAB> <BoN> W <EoN> = <BoN> window <EoN> ( <BoN> fftpack <EoN> . <BoN> fftfreq <EoN> ( <BoN> Nx <EoN> ) ) <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> isinstance <EoN> ( <BoN> window <EoN> , <BoN> ndarray <EoN> ) : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> window <EoN> . <BoN> shape <EoN> != ( <BoN> Nx <EoN> , ) : <NEWLINE> <TAB> <BoN> raise <EoN> <BoN> Value Error <EoN> ( <STRING> ) <NEWLINE> <UNTAB> <BoN> W <EoN> = <BoN> window <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> W <EoN> = <BoN> fftpack <EoN> . <BoN> ifftshift <EoN> ( <BoN> get window <EoN> ( <BoN> window <EoN> , <BoN> Nx <EoN> ) ) <NEWLINE> <UNTAB> <BoN> newshape <EoN> = [ <NUMBER> ] * <BoN> x <EoN> . <BoN> ndim <EoN> <NEWLINE> <BoN> newshape <EoN> [ <BoN> axis <EoN> ] = <BoN> len <EoN> ( <BoN> W <EoN> ) <NEWLINE> <BoN> W <EoN> . <BoN> shape <EoN> = <BoN> newshape <EoN> <NEWLINE> <BoN> X <EoN> = <BoN> X <EoN> * <BoN> W <EoN> <NEWLINE> <BoN> W <EoN> . <BoN> shape <EoN> = ( <BoN> Nx <EoN> , ) <NEWLINE> <UNTAB> <BoN> sl <EoN> = [ <BoN> slice <EoN> ( <BoN> None <EoN> ) ] * <BoN> x <EoN> . <BoN> ndim <EoN> <NEWLINE> <BoN> newshape <EoN> = <BoN> list <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> <BoN> newshape <EoN> [ <BoN> axis <EoN> ] = <BoN> num <EoN> <NEWLINE> <BoN> N <EoN> = <BoN> int <EoN> ( <BoN> np <EoN> . <BoN> minimum <EoN> ( <BoN> num <EoN> , <BoN> Nx <EoN> ) ) <NEWLINE> <BoN> Y <EoN> = <BoN> zeros <EoN> ( <BoN> newshape <EoN> , <STRING> ) <NEWLINE> <BoN> sl <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <NUMBER> , ( <BoN> N <EoN> + <NUMBER> ) // <NUMBER> ) <NEWLINE> <BoN> Y <EoN> [ <BoN> sl <EoN> ] = <BoN> X <EoN> [ <BoN> sl <EoN> ] <NEWLINE> <BoN> sl <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( - ( <BoN> N <EoN> - <NUMBER> ) // <NUMBER> , <BoN> None <EoN> ) <NEWLINE> <BoN> Y <EoN> [ <BoN> sl <EoN> ] = <BoN> X <EoN> [ <BoN> sl <EoN> ] <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> N <EoN> % <NUMBER> == <NUMBER> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> N <EoN> < <BoN> Nx <EoN> : <NEWLINE> <TAB> <BoN> sl <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <BoN> N <EoN> // <NUMBER> , <BoN> N <EoN> // <NUMBER> + <NUMBER> , <BoN> None <EoN> ) <NEWLINE> <BoN> Y <EoN> [ <BoN> sl <EoN> ] += <BoN> X <EoN> [ <BoN> sl <EoN> ] <NEWLINE> <UNTAB> <BoN> elif <EoN> <BoN> N <EoN> < <BoN> num <EoN> : <NEWLINE> <TAB> <BoN> sl <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <BoN> num <EoN> - <BoN> N <EoN> // <NUMBER> , <BoN> num <EoN> - <BoN> N <EoN> // <NUMBER> + <NUMBER> , <BoN> None <EoN> ) <NEWLINE> <BoN> Y <EoN> [ <BoN> sl <EoN> ] /= <NUMBER> <NEWLINE> <BoN> temp <EoN> = <BoN> Y <EoN> [ <BoN> sl <EoN> ] <NEWLINE> <BoN> sl <EoN> [ <BoN> axis <EoN> ] = <BoN> slice <EoN> ( <BoN> N <EoN> // <NUMBER> , <BoN> N <EoN> // <NUMBER> + <NUMBER> , <BoN> None <EoN> ) <NEWLINE> <BoN> Y <EoN> [ <BoN> sl <EoN> ] = <BoN> temp <EoN> <NEWLINE> <NEWLINE> <UNTAB> <UNTAB> <BoN> y <EoN> = <BoN> fftpack <EoN> . <BoN> ifft <EoN> ( <BoN> Y <EoN> , <BoN> axis <EoN> = <BoN> axis <EoN> ) * ( <BoN> float <EoN> ( <BoN> num <EoN> ) / <BoN> float <EoN> ( <BoN> Nx <EoN> ) ) <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> x <EoN> . <BoN> dtype <EoN> . <BoN> char <EoN> <BoN> not <EoN> <BoN> in <EoN> [ <STRING> , <STRING> ] : <NEWLINE> <TAB> <BoN> y <EoN> = <BoN> y <EoN> . <BoN> real <EoN> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> t <EoN> <BoN> is <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> y <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> new t <EoN> = <BoN> arange <EoN> ( <NUMBER> , <BoN> num <EoN> ) * ( <BoN> t <EoN> [ <NUMBER> ] - <BoN> t <EoN> [ <NUMBER> ] ) * <BoN> Nx <EoN> / <BoN> float <EoN> ( <BoN> num <EoN> ) + <BoN> t <EoN> [ <NUMBER> ] <NEWLINE> <BoN> return <EoN> <BoN> y <EoN> , <BoN> new t <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> @ <BoN> abstractmethod <EoN> <NEWLINE> <BoN> def <EoN> <BoN> clear location <EoN> ( <BoN> self <EoN> , <BoN> location <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> standardize <EoN> ( <BoN> self <EoN> , <BoN> x <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> if <EoN> <BoN> self <EoN> . <BoN> preprocessing function <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> = <BoN> self <EoN> . <BoN> preprocessing function <EoN> ( <BoN> x <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> rescale <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> *= <BoN> self <EoN> . <BoN> rescale <EoN> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> samplewise center <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> -= <BoN> np <EoN> . <BoN> mean <EoN> ( <BoN> x <EoN> , <BoN> keepdims <EoN> = <BoN> True <EoN> ) <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> samplewise std normalization <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> /= ( <BoN> np <EoN> . <BoN> std <EoN> ( <BoN> x <EoN> , <BoN> keepdims <EoN> = <BoN> True <EoN> ) + <NUMBER> ) <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> featurewise center <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> mean <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> -= <BoN> self <EoN> . <BoN> mean <EoN> <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> featurewise std normalization <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> std <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> x <EoN> /= ( <BoN> self <EoN> . <BoN> std <EoN> + <NUMBER> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> zca whitening <EoN> : <NEWLINE> <TAB> <BoN> if <EoN> <BoN> self <EoN> . <BoN> principal components <EoN> <BoN> is <EoN> <BoN> not <EoN> <BoN> None <EoN> : <NEWLINE> <TAB> <BoN> flatx <EoN> = <BoN> np <EoN> . <BoN> reshape <EoN> ( <BoN> x <EoN> , ( - <NUMBER> , <BoN> np <EoN> . <BoN> prod <EoN> ( <BoN> x <EoN> . <BoN> shape <EoN> [ - <NUMBER> : ] ) ) ) <NEWLINE> <BoN> whitex <EoN> = <BoN> np <EoN> . <BoN> dot <EoN> ( <BoN> flatx <EoN> , <BoN> self <EoN> . <BoN> principal components <EoN> ) <NEWLINE> <BoN> x <EoN> = <BoN> np <EoN> . <BoN> reshape <EoN> ( <BoN> whitex <EoN> , <BoN> x <EoN> . <BoN> shape <EoN> ) <NEWLINE> <UNTAB> <BoN> else <EoN> : <NEWLINE> <TAB> <BoN> warnings <EoN> . <BoN> warn <EoN> ( <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> ) <NEWLINE> <UNTAB> <UNTAB> <BoN> return <EoN> <BoN> x <EoN> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> can dot <EoN> ( <BoN> inputs <EoN> , <BoN> result <EoN> , <BoN> idx removed <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> idx removed <EoN> ) == <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> inputs <EoN> ) != <NUMBER> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> input left <EoN> , <BoN> input right <EoN> = <BoN> inputs <EoN> <NEWLINE> <BoN> set left <EoN> = <BoN> set <EoN> ( <BoN> input left <EoN> ) <NEWLINE> <BoN> set right <EoN> = <BoN> set <EoN> ( <BoN> input right <EoN> ) <NEWLINE> <BoN> keep left <EoN> = <BoN> set left <EoN> - <BoN> idx removed <EoN> <NEWLINE> <BoN> keep right <EoN> = <BoN> set right <EoN> - <BoN> idx removed <EoN> <NEWLINE> <BoN> rs <EoN> = <BoN> len <EoN> ( <BoN> idx removed <EoN> ) <NEWLINE> <NEWLINE> <NEWLINE> <BoN> if <EoN> <BoN> not <EoN> <BoN> len <EoN> ( <BoN> set left <EoN> & <BoN> set right <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> ( <BoN> len <EoN> ( <BoN> set left <EoN> ) != <BoN> len <EoN> ( <BoN> input left <EoN> ) ) <BoN> or <EoN> ( <BoN> len <EoN> ( <BoN> set right <EoN> ) != <BoN> len <EoN> ( <BoN> input right <EoN> ) ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> len <EoN> ( <BoN> keep left <EoN> & <BoN> keep right <EoN> ) : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> input left <EoN> == <BoN> input right <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> set left <EoN> == <BoN> set right <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> input left <EoN> [ - <BoN> rs <EoN> : ] == <BoN> input right <EoN> [ : <BoN> rs <EoN> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> input left <EoN> [ : <BoN> rs <EoN> ] == <BoN> input right <EoN> [ - <BoN> rs <EoN> : ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> input left <EoN> [ - <BoN> rs <EoN> : ] == <BoN> input right <EoN> [ - <BoN> rs <EoN> : ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> input left <EoN> [ : <BoN> rs <EoN> ] == <BoN> input right <EoN> [ : <BoN> rs <EoN> ] : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> if <EoN> <BoN> not <EoN> <BoN> keep left <EoN> <BoN> or <EoN> <BoN> not <EoN> <BoN> keep right <EoN> : <NEWLINE> <TAB> <BoN> return <EoN> <BoN> False <EoN> <NEWLINE> <NEWLINE> <NEWLINE> <UNTAB> <BoN> return <EoN> <BoN> True <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <BoN> def <EoN> <BoN> bias <EoN> ( <BoN> x <EoN> , <BoN> y <EoN> , <BoN> axis <EoN> = <NUMBER> ) : <NEWLINE> <TAB> <NEWLINE> <BoN> x shape <EoN> = <BoN> x <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> y shape <EoN> = <BoN> y <EoN> . <BoN> shape <EoN> <NEWLINE> <BoN> if <EoN> <BoN> chainer <EoN> . <BoN> is debug <EoN> ( ) : <NEWLINE> <TAB> <BoN> assert <EoN> <BoN> x shape <EoN> [ <BoN> axis <EoN> : <BoN> axis <EoN> + <BoN> len <EoN> ( <BoN> y shape <EoN> ) ] == <BoN> y shape <EoN> <NEWLINE> <UNTAB> <BoN> y 1 shape <EoN> = <BoN> tuple <EoN> ( [ <NUMBER> ] * <BoN> axis <EoN> + <BoN> list <EoN> ( <BoN> y shape <EoN> ) + <NEWLINE> [ <NUMBER> ] * ( <BoN> len <EoN> ( <BoN> x shape <EoN> ) - <BoN> axis <EoN> - <BoN> len <EoN> ( <BoN> y shape <EoN> ) ) ) <NEWLINE> <BoN> y 1 <EoN> = <BoN> reshape <EoN> . <BoN> reshape <EoN> ( <BoN> y <EoN> , <BoN> y 1 shape <EoN> ) <NEWLINE> <BoN> y 2 <EoN> = <BoN> broadcast <EoN> . <BoN> broadcast to <EoN> ( <BoN> y 1 <EoN> , <BoN> x shape <EoN> ) <NEWLINE> <BoN> return <EoN> <BoN> x <EoN> + <BoN> y 2 <EoN> <NEWLINE> <UNTAB> <END> <EoC>
<BoC> <TAB> <BoN> def <EoN> <BoN> begin <EoN> ( <BoN> self <EoN> , <BoN> conn <EoN> ) : <NEWLINE> <TAB> <NEWLINE> <UNTAB> <UNTAB> <END> <EoC>
